--- channels/rdpdr/server/rdpdr_main.c ---
@@ -1615,6 +1615,10 @@ static UINT rdpdr_server_receive_device_io_request(RdpdrServerContext* context,
 		case IRP_MJ_LOCK_CONTROL:
 			return rdpdr_server_receive_io_lock_control_request(context, s, DeviceId, FileId,
 			                                                    CompletionId);
+		case IRP_MJ_SET_VOLUME_INFORMATION:
+			return rdpdr_server_receive_io_set_volume_information_request(context, s, DeviceId,
+			                                                              FileId, CompletionId);
+
 		default:
 			WLog_Print(
 			    context->priv->log, WLOG_WARN,

--- channels/rdpgfx/client/rdpgfx_main.c ---
@@ -628,87 +628,6 @@ static UINT rdpgfx_recv_evict_cache_entry_pdu(GENERIC_CHANNEL_CALLBACK* callback
 	return error;
 }
 
-/**
- * Load cache import offer from file (offline replay)
- *
- * @return 0 on success, otherwise a Win32 error code
- */
-static UINT rdpgfx_load_cache_import_offer(RDPGFX_PLUGIN* gfx, RDPGFX_CACHE_IMPORT_OFFER_PDU* offer)
-{
-	int count = 0;
-	UINT error = CHANNEL_RC_OK;
-	PERSISTENT_CACHE_ENTRY entry;
-	rdpPersistentCache* persistent = NULL;
-	WINPR_ASSERT(gfx);
-	WINPR_ASSERT(gfx->rdpcontext);
-	rdpSettings* settings = gfx->rdpcontext->settings;
-
-	WINPR_ASSERT(offer);
-	WINPR_ASSERT(settings);
-
-	offer->cacheEntriesCount = 0;
-
-	if (!freerdp_settings_get_bool(settings, FreeRDP_BitmapCachePersistEnabled))
-		return CHANNEL_RC_OK;
-
-	const char* BitmapCachePersistFile =
-	    freerdp_settings_get_string(settings, FreeRDP_BitmapCachePersistFile);
-	if (!BitmapCachePersistFile)
-		return CHANNEL_RC_OK;
-
-	persistent = persistent_cache_new();
-
-	if (!persistent)
-		return CHANNEL_RC_NO_MEMORY;
-
-	if (persistent_cache_open(persistent, BitmapCachePersistFile, FALSE, 3) < 1)
-	{
-		error = CHANNEL_RC_INITIALIZATION_ERROR;
-		goto fail;
-	}
-
-	if (persistent_cache_get_version(persistent) != 3)
-	{
-		error = ERROR_INVALID_DATA;
-		goto fail;
-	}
-
-	count = persistent_cache_get_count(persistent);
-
-	if (count < 1)
-	{
-		error = ERROR_INVALID_DATA;
-		goto fail;
-	}
-
-	if (count >= RDPGFX_CACHE_ENTRY_MAX_COUNT)
-		count = RDPGFX_CACHE_ENTRY_MAX_COUNT - 1;
-
-	if (count > gfx->MaxCacheSlots)
-		count = gfx->MaxCacheSlots;
-
-	offer->cacheEntriesCount = (UINT16)count;
-
-	for (int idx = 0; idx < count; idx++)
-	{
-		if (persistent_cache_read_entry(persistent, &entry) < 1)
-		{
-			error = ERROR_INVALID_DATA;
-			goto fail;
-		}
-
-		offer->cacheEntries[idx].cacheKey = entry.key64;
-		offer->cacheEntries[idx].bitmapLength = entry.size;
-	}
-
-	persistent_cache_free(persistent);
-
-	return error;
-fail:
-	persistent_cache_free(persistent);
-	return error;
-}
-
 /**
  * Function description
  *

--- client/SDL/SDL3/sdl_clip.cpp ---
@@ -108,10 +108,7 @@ static bool operator<(const CLIPRDR_FORMAT& lhs, const CLIPRDR_FORMAT& rhs)
 {
 	return (lhs.formatId < rhs.formatId);
 }
-static bool operator>(const CLIPRDR_FORMAT& lhs, const CLIPRDR_FORMAT& rhs)
-{
-	return (lhs.formatId > rhs.formatId);
-}
+
 static bool operator==(const CLIPRDR_FORMAT& lhs, const CLIPRDR_FORMAT& rhs)
 {
 	return (lhs.formatId == rhs.formatId);

--- client/Wayland/wlf_disp.c ---
@@ -129,15 +129,15 @@ static BOOL wlf_disp_sendResize(wlfDispContext* wlfDisp)
 	if (!wlf_disp_settings_changed(wlfDisp))
 		return TRUE;
 
-	/* TODO: Multimonitor support for wayland
-	if (wlc->fullscreen && (freerdp_settings_get_uint32(settings, FreeRDP_MonitorCount > 0))
+	if (wlc->fullscreen && (freerdp_settings_get_uint32(settings, FreeRDP_MonitorCount) > 0))
 	{
-	    if (wlf_disp_sendLayout(wlfDisp->disp, setings->MonitorDefArray,
-	                           freerdp_settings_get_uint32(settings, FreeRDP_MonitorCount) !=
-	CHANNEL_RC_OK) return FALSE;
+		const rdpMonitor* monitors =
+		    freerdp_settings_get_pointer(settings, FreeRDP_MonitorDefArray);
+		const size_t nmonitors = freerdp_settings_get_uint32(settings, FreeRDP_MonitorCount);
+		if (wlf_disp_sendLayout(wlfDisp->disp, monitors, nmonitors) != CHANNEL_RC_OK)
+			return FALSE;
 	}
 	else
-	*/
 	{
 		wlfDisp->waitingResize = TRUE;
 		layout.Flags = DISPLAY_CONTROL_MONITOR_PRIMARY;

--- libfreerdp/cache/nine_grid.c ---
@@ -23,16 +23,13 @@
 
 #include <winpr/crt.h>
 
-#include <freerdp/log.h>
 #include <freerdp/update.h>
 #include <freerdp/freerdp.h>
 #include <winpr/stream.h>
 
 #include "nine_grid.h"
 #include "cache.h"
 
-#define TAG FREERDP_TAG("cache.nine_grid")
-
 typedef struct
 {
 	void* entry;
@@ -52,9 +49,6 @@ struct rdp_nine_grid_cache
 	rdpContext* context;
 };
 
-static void* nine_grid_cache_get(rdpNineGridCache* nine_grid, UINT32 index);
-static void nine_grid_cache_put(rdpNineGridCache* nine_grid, UINT32 index, void* entry);
-
 static BOOL update_gdi_draw_nine_grid(rdpContext* context,
                                       const DRAW_NINE_GRID_ORDER* draw_nine_grid)
 {
@@ -80,39 +74,6 @@ void nine_grid_cache_register_callbacks(rdpUpdate* update)
 	update->primary->MultiDrawNineGrid = update_gdi_multi_draw_nine_grid;
 }
 
-void* nine_grid_cache_get(rdpNineGridCache* nine_grid, UINT32 index)
-{
-	void* entry = NULL;
-
-	if (index >= nine_grid->maxEntries)
-	{
-		WLog_ERR(TAG, "invalid NineGrid index: 0x%08" PRIX32 "", index);
-		return NULL;
-	}
-
-	entry = nine_grid->entries[index].entry;
-
-	if (entry == NULL)
-	{
-		WLog_ERR(TAG, "invalid NineGrid at index: 0x%08" PRIX32 "", index);
-		return NULL;
-	}
-
-	return entry;
-}
-
-void nine_grid_cache_put(rdpNineGridCache* nine_grid, UINT32 index, void* entry)
-{
-	if (index >= nine_grid->maxEntries)
-	{
-		WLog_ERR(TAG, "invalid NineGrid index: 0x%08" PRIX32 "", index);
-		return;
-	}
-
-	free(nine_grid->entries[index].entry);
-	nine_grid->entries[index].entry = entry;
-}
-
 rdpNineGridCache* nine_grid_cache_new(rdpContext* context)
 {
 	rdpNineGridCache* nine_grid = NULL;

--- libfreerdp/cache/palette.c ---
@@ -30,8 +30,6 @@
 
 #define TAG FREERDP_TAG("cache.palette")
 
-static void* palette_cache_get(rdpPaletteCache* palette, UINT32 index);
-
 static void palette_cache_put(rdpPaletteCache* palette, UINT32 index, void* entry);
 
 static BOOL update_gdi_cache_color_table(rdpContext* context,
@@ -49,27 +47,6 @@ static BOOL update_gdi_cache_color_table(rdpContext* context,
 	return TRUE;
 }
 
-void* palette_cache_get(rdpPaletteCache* paletteCache, UINT32 index)
-{
-	void* entry = NULL;
-
-	if (index >= paletteCache->maxEntries)
-	{
-		WLog_ERR(TAG, "invalid color table index: 0x%08" PRIX32 "", index);
-		return NULL;
-	}
-
-	entry = paletteCache->entries[index].entry;
-
-	if (!entry)
-	{
-		WLog_ERR(TAG, "invalid color table at index: 0x%08" PRIX32 "", index);
-		return NULL;
-	}
-
-	return entry;
-}
-
 void palette_cache_put(rdpPaletteCache* paletteCache, UINT32 index, void* entry)
 {
 	if (index >= paletteCache->maxEntries)
@@ -85,6 +62,8 @@ void palette_cache_put(rdpPaletteCache* paletteCache, UINT32 index, void* entry)
 
 void palette_cache_register_callbacks(rdpUpdate* update)
 {
+	WINPR_ASSERT(update);
+	WINPR_ASSERT(update->secondary);
 	update->secondary->CacheColorTable = update_gdi_cache_color_table;
 }
 

--- libfreerdp/codec/interleaved.c ---
@@ -98,6 +98,7 @@ static const BYTE g_MaskSpecialFgBg2 = 0x05;
 static const BYTE g_MaskRegularRunLength = 0x1F;
 static const BYTE g_MaskLiteRunLength = 0x0F;
 
+#if defined(WITH_DEBUG_CODECS)
 static const char* rle_code_str(UINT32 code)
 {
 	switch (code)
@@ -146,13 +147,7 @@ static const char* rle_code_str(UINT32 code)
 			return "UNKNOWN";
 	}
 }
-
-static const char* rle_code_str_buffer(UINT32 code, char* buffer, size_t size)
-{
-	const char* str = rle_code_str(code);
-	(void)_snprintf(buffer, size, "%s [0x%08" PRIx32 "]", str, code);
-	return buffer;
-}
+#endif
 
 #define buffer_within_range(pbSrc, size, pbEnd) \
 	buffer_within_range_((pbSrc), (size), (pbEnd), __func__, __FILE__, __LINE__)
@@ -327,6 +322,10 @@ static INLINE UINT32 ExtractRunLength(UINT32 code, const BYTE* pbOrderHdr, const
 	WINPR_ASSERT(pbEnd);
 	WINPR_ASSERT(advance);
 
+#if defined(WITH_DEBUG_CODECS)
+	WLog_VRB(TAG, "extracting %s", rle_code_str(code));
+#endif
+
 	*advance = 0;
 	if (!buffer_within_range(pbOrderHdr, 0, pbEnd))
 		return 0;

--- libfreerdp/codec/nsc_encode.c ---
@@ -416,34 +416,6 @@ static void nsc_rle_compress_data(NSC_CONTEXT* WINPR_RESTRICT context)
 	}
 }
 
-static UINT32 nsc_compute_byte_count(NSC_CONTEXT* WINPR_RESTRICT context,
-                                     UINT32* WINPR_RESTRICT ByteCount, UINT32 width, UINT32 height)
-{
-	UINT32 tempWidth = 0;
-	UINT32 tempHeight = 0;
-	UINT32 maxPlaneSize = 0;
-	tempWidth = ROUND_UP_TO(width, 8);
-	tempHeight = ROUND_UP_TO(height, 2);
-	maxPlaneSize = tempWidth * tempHeight + 16;
-
-	if (context->ChromaSubsamplingLevel)
-	{
-		ByteCount[0] = tempWidth * height;
-		ByteCount[1] = tempWidth * tempHeight / 4;
-		ByteCount[2] = tempWidth * tempHeight / 4;
-		ByteCount[3] = width * height;
-	}
-	else
-	{
-		ByteCount[0] = width * height;
-		ByteCount[1] = width * height;
-		ByteCount[2] = width * height;
-		ByteCount[3] = width * height;
-	}
-
-	return maxPlaneSize;
-}
-
 BOOL nsc_write_message(WINPR_ATTR_UNUSED NSC_CONTEXT* WINPR_RESTRICT context,
                        wStream* WINPR_RESTRICT s, const NSC_MESSAGE* WINPR_RESTRICT message)
 {

--- libfreerdp/codec/progressive.c ---
@@ -78,20 +78,6 @@ progressive_component_codec_quant_read(wStream* WINPR_RESTRICT s,
 	quantVal->HH1 = b >> 4;
 }
 
-static INLINE void progressive_rfx_quant_ladd(RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q, int val)
-{
-	q->HL1 += val; /* HL1 */
-	q->LH1 += val; /* LH1 */
-	q->HH1 += val; /* HH1 */
-	q->HL2 += val; /* HL2 */
-	q->LH2 += val; /* LH2 */
-	q->HH2 += val; /* HH2 */
-	q->HL3 += val; /* HL3 */
-	q->LH3 += val; /* LH3 */
-	q->HH3 += val; /* HH3 */
-	q->LL3 += val; /* LL3 */
-}
-
 static INLINE void progressive_rfx_quant_add(const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q1,
                                              const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q2,
                                              RFX_COMPONENT_CODEC_QUANT* dst)
@@ -174,43 +160,6 @@ progressive_rfx_quant_lcmp_less_equal(const RFX_COMPONENT_CODEC_QUANT* WINPR_RES
 	return TRUE;
 }
 
-static INLINE BOOL
-progressive_rfx_quant_cmp_less_equal(const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q1,
-                                     const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q2)
-{
-	if (q1->HL1 > q2->HL1)
-		return FALSE; /* HL1 */
-
-	if (q1->LH1 > q2->LH1)
-		return FALSE; /* LH1 */
-
-	if (q1->HH1 > q2->HH1)
-		return FALSE; /* HH1 */
-
-	if (q1->HL2 > q2->HL2)
-		return FALSE; /* HL2 */
-
-	if (q1->LH2 > q2->LH2)
-		return FALSE; /* LH2 */
-
-	if (q1->HH2 > q2->HH2)
-		return FALSE; /* HH2 */
-
-	if (q1->HL3 > q2->HL3)
-		return FALSE; /* HL3 */
-
-	if (q1->LH3 > q2->LH3)
-		return FALSE; /* LH3 */
-
-	if (q1->HH3 > q2->HH3)
-		return FALSE; /* HH3 */
-
-	if (q1->LL3 > q2->LL3)
-		return FALSE; /* LL3 */
-
-	return TRUE;
-}
-
 static INLINE BOOL
 progressive_rfx_quant_lcmp_greater_equal(const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q, int val)
 {
@@ -247,43 +196,6 @@ progressive_rfx_quant_lcmp_greater_equal(const RFX_COMPONENT_CODEC_QUANT* WINPR_
 	return TRUE;
 }
 
-static INLINE BOOL
-progressive_rfx_quant_cmp_greater_equal(const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q1,
-                                        const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q2)
-{
-	if (q1->HL1 < q2->HL1)
-		return FALSE; /* HL1 */
-
-	if (q1->LH1 < q2->LH1)
-		return FALSE; /* LH1 */
-
-	if (q1->HH1 < q2->HH1)
-		return FALSE; /* HH1 */
-
-	if (q1->HL2 < q2->HL2)
-		return FALSE; /* HL2 */
-
-	if (q1->LH2 < q2->LH2)
-		return FALSE; /* LH2 */
-
-	if (q1->HH2 < q2->HH2)
-		return FALSE; /* HH2 */
-
-	if (q1->HL3 < q2->HL3)
-		return FALSE; /* HL3 */
-
-	if (q1->LH3 < q2->LH3)
-		return FALSE; /* LH3 */
-
-	if (q1->HH3 < q2->HH3)
-		return FALSE; /* HH3 */
-
-	if (q1->LL3 < q2->LL3)
-		return FALSE; /* LL3 */
-
-	return TRUE;
-}
-
 static INLINE BOOL
 progressive_rfx_quant_cmp_equal(const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q1,
                                 const RFX_COMPONENT_CODEC_QUANT* WINPR_RESTRICT q2)

--- libfreerdp/codec/zgfx.c ---
@@ -379,17 +379,6 @@ static INLINE BOOL zgfx_decompress_segment(ZGFX_CONTEXT* WINPR_RESTRICT zgfx,
 	return TRUE;
 }
 
-/* Allocate the buffers a bit larger.
- *
- * Due to optimizations some h264 decoders will read data beyond
- * the actual available data, so ensure that it will never be a
- * out of bounds read.
- */
-static INLINE BYTE* aligned_zgfx_malloc(size_t size)
-{
-	return malloc(size + 64);
-}
-
 static INLINE BOOL zgfx_append(ZGFX_CONTEXT* WINPR_RESTRICT zgfx,
                                BYTE** WINPR_RESTRICT ppConcatenated, size_t uncompressedSize,
                                size_t* WINPR_RESTRICT pUsed)

--- libfreerdp/core/capabilities.c ---
@@ -2312,33 +2312,6 @@ static BOOL rdp_write_draw_nine_grid_cache_capability_set(wStream* s, const rdpS
 	return rdp_capability_set_finish(s, header, CAPSET_TYPE_DRAW_NINE_GRID_CACHE);
 }
 
-static void rdp_write_gdiplus_cache_entries(wStream* s, UINT16 gce, UINT16 bce, UINT16 pce,
-                                            UINT16 ice, UINT16 ace)
-{
-	Stream_Write_UINT16(s, gce); /* gdipGraphicsCacheEntries (2 bytes) */
-	Stream_Write_UINT16(s, bce); /* gdipBrushCacheEntries (2 bytes) */
-	Stream_Write_UINT16(s, pce); /* gdipPenCacheEntries (2 bytes) */
-	Stream_Write_UINT16(s, ice); /* gdipImageCacheEntries (2 bytes) */
-	Stream_Write_UINT16(s, ace); /* gdipImageAttributesCacheEntries (2 bytes) */
-}
-
-static void rdp_write_gdiplus_cache_chunk_size(wStream* s, UINT16 gccs, UINT16 obccs, UINT16 opccs,
-                                               UINT16 oiaccs)
-{
-	Stream_Write_UINT16(s, gccs);   /* gdipGraphicsCacheChunkSize (2 bytes) */
-	Stream_Write_UINT16(s, obccs);  /* gdipObjectBrushCacheChunkSize (2 bytes) */
-	Stream_Write_UINT16(s, opccs);  /* gdipObjectPenCacheChunkSize (2 bytes) */
-	Stream_Write_UINT16(s, oiaccs); /* gdipObjectImageAttributesCacheChunkSize (2 bytes) */
-}
-
-static void rdp_write_gdiplus_image_cache_properties(wStream* s, UINT16 oiccs, UINT16 oicts,
-                                                     UINT16 oicms)
-{
-	Stream_Write_UINT16(s, oiccs); /* gdipObjectImageCacheChunkSize (2 bytes) */
-	Stream_Write_UINT16(s, oicts); /* gdipObjectImageCacheTotalSize (2 bytes) */
-	Stream_Write_UINT16(s, oicms); /* gdipObjectImageCacheMaxSize (2 bytes) */
-}
-
 #ifdef WITH_DEBUG_CAPABILITIES
 static BOOL rdp_print_draw_nine_grid_cache_capability_set(wStream* s)
 {
@@ -2402,33 +2375,6 @@ static BOOL rdp_read_draw_gdiplus_cache_capability_set(wStream* s, rdpSettings*
 	return TRUE;
 }
 
-/*
- * Write GDI+ cache capability set.
- * msdn{cc241566}
- */
-
-static BOOL rdp_write_draw_gdiplus_cache_capability_set(wStream* s, const rdpSettings* settings)
-{
-	WINPR_ASSERT(settings);
-	if (!Stream_EnsureRemainingCapacity(s, 64))
-		return FALSE;
-
-	const size_t header = rdp_capability_set_start(s);
-	const UINT32 drawGDIPlusSupportLevel =
-	    (settings->DrawGdiPlusEnabled) ? DRAW_GDIPLUS_SUPPORTED : DRAW_GDIPLUS_DEFAULT;
-	const UINT32 drawGdiplusCacheLevel = (settings->DrawGdiPlusEnabled)
-	                                         ? DRAW_GDIPLUS_CACHE_LEVEL_ONE
-	                                         : DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;
-	Stream_Write_UINT32(s, drawGDIPlusSupportLevel);     /* drawGDIPlusSupportLevel (4 bytes) */
-	Stream_Write_UINT32(s, 0);                           /* GdipVersion (4 bytes) */
-	Stream_Write_UINT32(s, drawGdiplusCacheLevel);       /* drawGdiplusCacheLevel (4 bytes) */
-	rdp_write_gdiplus_cache_entries(s, 10, 5, 5, 10, 2); /* GdipCacheEntries (10 bytes) */
-	rdp_write_gdiplus_cache_chunk_size(s, 512, 2048, 1024, 64); /* GdipCacheChunkSize (8 bytes) */
-	rdp_write_gdiplus_image_cache_properties(s, 4096, 256,
-	                                         128); /* GdipImageCacheProperties (6 bytes) */
-	return rdp_capability_set_finish(s, header, CAPSET_TYPE_DRAW_GDI_PLUS);
-}
-
 #ifdef WITH_DEBUG_CAPABILITIES
 static BOOL rdp_print_draw_gdiplus_cache_capability_set(wStream* s)
 {
@@ -3567,6 +3513,7 @@ static BOOL rdp_write_rfx_server_capability_container(wStream* s, const rdpSetti
 	return TRUE;
 }
 
+#if defined(WITH_JPEG)
 static BOOL rdp_write_jpeg_server_capability_container(wStream* s, const rdpSettings* settings)
 {
 	WINPR_UNUSED(settings);
@@ -3579,6 +3526,7 @@ static BOOL rdp_write_jpeg_server_capability_container(wStream* s, const rdpSett
 	Stream_Write_UINT8(s, 75);
 	return TRUE;
 }
+#endif
 
 /*
  * Write NSCODEC Server Capability Container.

--- libfreerdp/core/license.c ---
@@ -50,6 +50,8 @@
 #define LICENSE_NULL_PREMASTER_SECRET 1
 #endif
 
+// #define WITH_LICENSE_DECRYPT_CHALLENGE_RESPONSE
+
 #define PLATFORM_CHALLENGE_RESPONSE_VERSION 0x0100
 
 /** @brief Licensing Packet Types */
@@ -203,6 +205,7 @@ struct rdp_license
 	LICENSE_BLOB* ClientUserName;
 	LICENSE_BLOB* ClientMachineName;
 	LICENSE_BLOB* PlatformChallenge;
+	LICENSE_BLOB* PlatformChallengeResponse;
 	LICENSE_BLOB* EncryptedPremasterSecret;
 	LICENSE_BLOB* EncryptedPlatformChallenge;
 	LICENSE_BLOB* EncryptedPlatformChallengeResponse;
@@ -331,12 +334,11 @@ static BOOL license_read_new_license_request_packet(rdpLicense* license, wStream
 static BOOL license_answer_license_request(rdpLicense* license);
 
 static BOOL license_send_platform_challenge_response(rdpLicense* license);
-static BOOL license_read_platform_challenge_response(rdpLicense* license, wStream* s);
+static BOOL license_read_platform_challenge_response(rdpLicense* license);
 
 static BOOL license_read_client_platform_challenge_response(rdpLicense* license, wStream* s);
 static BOOL license_write_client_platform_challenge_response(rdpLicense* license, wStream* s);
 
-static BOOL license_read_server_upgrade_license(rdpLicense* license, wStream* s);
 static BOOL license_write_server_upgrade_license(const rdpLicense* license, wStream* s);
 
 static BOOL license_send_license_info(rdpLicense* license, const LICENSE_BLOB* calBlob,
@@ -802,19 +804,6 @@ static BOOL license_send(rdpLicense* license, wStream* s, BYTE type)
 	return ret;
 }
 
-BOOL license_read_server_upgrade_license(rdpLicense* license, wStream* s)
-{
-	WINPR_ASSERT(license);
-
-	if (!license_read_binary_blob(s, license->EncryptedLicenseInfo))
-		return FALSE;
-	if (!license_check_stream_length(s, sizeof(license->MACData),
-	                                 "SERVER_UPGRADE_LICENSE::MACData"))
-		return FALSE;
-	Stream_Read(s, license->MACData, sizeof(license->MACData));
-	return TRUE;
-}
-
 BOOL license_write_server_upgrade_license(const rdpLicense* license, wStream* s)
 {
 	WINPR_ASSERT(license);
@@ -2566,12 +2555,8 @@ BOOL license_send_platform_challenge_response(rdpLicense* license)
 	return FALSE;
 }
 
-BOOL license_read_platform_challenge_response(rdpLicense* license, wStream* s)
+BOOL license_read_platform_challenge_response(rdpLicense* license)
 {
-	UINT16 wVersion = 0;
-	UINT16 cbChallenge = 0;
-	const BYTE* pbChallenge = NULL;
-
 	WINPR_ASSERT(license);
 	WINPR_ASSERT(license->PlatformChallenge);
 	WINPR_ASSERT(license->MacSaltKey);
@@ -2580,31 +2565,56 @@ BOOL license_read_platform_challenge_response(rdpLicense* license, wStream* s)
 
 	DEBUG_LICENSE("Receiving Platform Challenge Response Packet");
 
-	if (!license_check_stream_length(s, 8, "PLATFORM_CHALLENGE_RESPONSE_DATA"))
+#if defined(WITH_LICENSE_DECRYPT_CHALLENGE_RESPONSE)
+	BOOL rc = FALSE;
+	LICENSE_BLOB* dblob = license_new_binary_blob(BB_ANY_BLOB);
+	if (!dblob)
 		return FALSE;
 
+	wStream sbuffer = { 0 };
+	UINT16 wVersion = 0;
+	UINT16 cbChallenge = 0;
+	const BYTE* pbChallenge = NULL;
+	LICENSE_BLOB* blob = license->EncryptedPlatformChallengeResponse;
+
+	if (!license_rc4_with_licenseKey(license, blob->data, blob->length, dblob))
+		goto fail;
+
+	wStream* s = Stream_StaticConstInit(&sbuffer, dblob->data, dblob->length);
+	if (!license_check_stream_length(s, 8, "PLATFORM_CHALLENGE_RESPONSE_DATA"))
+		goto fail;
+
 	Stream_Read_UINT16(s, wVersion);
 	if (wVersion != PLATFORM_CHALLENGE_RESPONSE_VERSION)
 	{
 		WLog_WARN(TAG,
 		          "Invalid PLATFORM_CHALLENGE_RESPONSE_DATA::wVersion 0x%04" PRIx16
 		          ", expected 0x04" PRIx16,
 		          wVersion, PLATFORM_CHALLENGE_RESPONSE_VERSION);
-		return FALSE;
+		goto fail;
 	}
 	Stream_Read_UINT16(s, license->ClientType);
 	Stream_Read_UINT16(s, license->LicenseDetailLevel);
 	Stream_Read_UINT16(s, cbChallenge);
 
 	if (!license_check_stream_length(s, cbChallenge,
 	                                 "PLATFORM_CHALLENGE_RESPONSE_DATA::pbChallenge"))
-		return FALSE;
+		goto fail;
 
 	pbChallenge = Stream_Pointer(s);
-	if (!license_read_binary_blob_data(license->EncryptedPlatformChallengeResponse, BB_DATA_BLOB,
+	if (!license_read_binary_blob_data(license->PlatformChallengeResponse, BB_DATA_BLOB,
 	                                   pbChallenge, cbChallenge))
-		return FALSE;
-	return Stream_SafeSeek(s, cbChallenge);
+		goto fail;
+	if (!Stream_SafeSeek(s, cbChallenge))
+		goto fail;
+
+	rc = TRUE;
+fail:
+	license_free_binary_blob(dblob);
+	return rc;
+#else
+	return TRUE;
+#endif
 }
 
 BOOL license_write_client_platform_challenge_response(rdpLicense* license, wStream* s)
@@ -2634,7 +2644,7 @@ BOOL license_read_client_platform_challenge_response(rdpLicense* license, wStrea
 	                                 "CLIENT_PLATFORM_CHALLENGE_RESPONSE::MACData"))
 		return FALSE;
 	Stream_Read(s, license->MACData, sizeof(license->MACData));
-	return TRUE;
+	return license_read_platform_challenge_response(license);
 }
 
 /**
@@ -2698,6 +2708,8 @@ rdpLicense* license_new(rdpRdp* rdp)
 		goto out_error;
 	if (!(license->PlatformChallenge = license_new_binary_blob(BB_ANY_BLOB)))
 		goto out_error;
+	if (!(license->PlatformChallengeResponse = license_new_binary_blob(BB_ANY_BLOB)))
+		goto out_error;
 	if (!(license->EncryptedPlatformChallenge = license_new_binary_blob(BB_ANY_BLOB)))
 		goto out_error;
 	if (!(license->EncryptedPlatformChallengeResponse =
@@ -2742,6 +2754,7 @@ void license_free(rdpLicense* license)
 		license_free_binary_blob(license->ClientUserName);
 		license_free_binary_blob(license->ClientMachineName);
 		license_free_binary_blob(license->PlatformChallenge);
+		license_free_binary_blob(license->PlatformChallengeResponse);
 		license_free_binary_blob(license->EncryptedPlatformChallenge);
 		license_free_binary_blob(license->EncryptedPlatformChallengeResponse);
 		license_free_binary_blob(license->EncryptedPremasterSecret);

--- libfreerdp/core/tcp.c ---
@@ -103,14 +103,6 @@ typedef struct
 static int transport_bio_simple_init(BIO* bio, SOCKET socket, int shutdown);
 static int transport_bio_simple_uninit(BIO* bio);
 
-static long transport_bio_simple_callback(WINPR_ATTR_UNUSED BIO* bio, WINPR_ATTR_UNUSED int mode,
-                                          WINPR_ATTR_UNUSED const char* argp,
-                                          WINPR_ATTR_UNUSED int argi, WINPR_ATTR_UNUSED long argl,
-                                          WINPR_ATTR_UNUSED long ret)
-{
-	return 1;
-}
-
 static int transport_bio_simple_write(BIO* bio, const char* buf, int size)
 {
 	int error = 0;
@@ -464,14 +456,6 @@ typedef struct
 	RingBuffer xmitBuffer;
 } WINPR_BIO_BUFFERED_SOCKET;
 
-static long transport_bio_buffered_callback(WINPR_ATTR_UNUSED BIO* bio, WINPR_ATTR_UNUSED int mode,
-                                            WINPR_ATTR_UNUSED const char* argp,
-                                            WINPR_ATTR_UNUSED int argi, WINPR_ATTR_UNUSED long argl,
-                                            WINPR_ATTR_UNUSED long ret)
-{
-	return 1;
-}
-
 static int transport_bio_buffered_write(BIO* bio, const char* buf, int num)
 {
 	int ret = num;

--- libfreerdp/crypto/certificate.c ---
@@ -1049,30 +1049,6 @@ static BOOL certificate_read_server_x509_certificate_chain(rdpCertificate* cert,
 	return update_x509_from_info(cert);
 }
 
-static BOOL certificate_write_server_x509_certificate_chain(const rdpCertificate* certificate,
-                                                            wStream* s)
-{
-	UINT32 numCertBlobs = 0;
-
-	WINPR_ASSERT(certificate);
-	WINPR_ASSERT(s);
-
-	numCertBlobs = certificate->x509_cert_chain.count;
-
-	if (!Stream_EnsureRemainingCapacity(s, 4))
-		return FALSE;
-	Stream_Write_UINT32(s, numCertBlobs); /* numCertBlobs */
-
-	for (UINT32 i = 0; i < numCertBlobs; i++)
-	{
-		const rdpCertBlob* cert = &certificate->x509_cert_chain.array[i];
-		if (!cert_blob_write(cert, s))
-			return FALSE;
-	}
-
-	return TRUE;
-}
-
 /**
  * Read a Server Certificate.
  * @param certificate certificate module

--- libfreerdp/crypto/per.c ---
@@ -469,19 +469,6 @@ BOOL per_write_object_identifier(wStream* s, const BYTE oid[6])
 	return TRUE;
 }
 
-/**
- * Write PER string.
- * @param s stream
- * @param str string
- * @param length string length
- */
-
-static void per_write_string(wStream* s, BYTE* str, int length)
-{
-	for (int i = 0; i < length; i++)
-		Stream_Write_UINT8(s, str[i]);
-}
-
 /**
  * Read PER OCTET_STRING.
  *

--- libfreerdp/gdi/region.c ---
@@ -398,8 +398,8 @@ BOOL gdi_RgnToCRect(const HGDI_RGN rgn, INT32* left, INT32* top, INT32* right, I
  * @param bottom y2
  */
 
-INLINE BOOL gdi_CRgnToCRect(INT32 x, INT32 y, INT32 w, INT32 h, INT32* left, INT32* top,
-                            INT32* right, INT32* bottom)
+BOOL gdi_CRgnToCRect(INT32 x, INT32 y, INT32 w, INT32 h, INT32* left, INT32* top, INT32* right,
+                     INT32* bottom)
 {
 	BOOL rc = TRUE;
 	*left = x;

--- libfreerdp/locale/keyboard.c ---
@@ -263,6 +263,7 @@ static int freerdp_detect_keyboard(DWORD* keyboardLayoutId)
 	return 0;
 }
 
+#if defined(__APPLE__)
 static int freerdp_keyboard_init_apple(WINPR_ATTR_UNUSED const DWORD* keyboardLayoutId,
                                        DWORD* x11_keycode_to_rdp_scancode, size_t count)
 {
@@ -280,6 +281,7 @@ static int freerdp_keyboard_init_apple(WINPR_ATTR_UNUSED const DWORD* keyboardLa
 	maptype = WINPR_KEYCODE_TYPE_APPLE;
 	return 0;
 }
+#endif
 
 static int freerdp_keyboard_init_x11_evdev(WINPR_ATTR_UNUSED const DWORD* keyboardLayoutId,
                                            DWORD* x11_keycode_to_rdp_scancode, size_t count)

--- libfreerdp/primitives/sse/prim_YUV_sse4.1.c ---
@@ -229,22 +229,6 @@ static inline void BGRX_fillRGB(size_t offset, BYTE* WINPR_RESTRICT pRGB[2],
 	}
 }
 
-static inline void unpack_mul_add(__m128i toadd[2], __m128i narrow, short iMul, __m128i sub)
-{
-	const __m128i usub = _mm_sub_epi16(narrow, sub);
-	const __m128i mul = _mm_set1_epi32(iMul);
-	const __m128i umulhi = _mm_mulhi_epi16(usub, mul);
-	const __m128i umullo = _mm_mullo_epi16(usub, mul);
-	{
-		const __m128i umul = _mm_unpackhi_epi16(umullo, umulhi);
-		toadd[0] = _mm_add_epi32(toadd[0], umul);
-	}
-	{
-		const __m128i umul = _mm_unpacklo_epi16(umullo, umulhi);
-		toadd[1] = _mm_add_epi32(toadd[1], umul);
-	}
-}
-
 /* input are uint16_t vectors */
 static inline __m128i sse41_yuv2x_single(const __m128i Y, __m128i U, __m128i V, const short iMulU,
                                          const short iMulV)

--- server/proxy/modules/bitmap-filter/bitmap-filter.cpp ---
@@ -38,6 +38,8 @@
 
 #define TAG MODULE_TAG("persist-bitmap-filter")
 
+// #define REPLY_WITH_EMPTY_OFFER
+
 static constexpr char plugin_name[] = "bitmap-filter";
 static constexpr char plugin_desc[] =
     "this plugin deactivates and filters persistent bitmap cache.";
@@ -267,6 +269,7 @@ static BOOL filter_set_plugin_data(proxyPlugin* plugin, proxyData* pdata, DynCha
 	return mgr->SetPluginData(mgr, plugin_name, pdata, data);
 }
 
+#if defined(REPLY_WITH_EMPTY_OFFER)
 static UINT8 drdynvc_value_to_cblen(UINT32 value)
 {
 	if (value <= 0xFF)
@@ -328,6 +331,7 @@ static BOOL filter_forward_empty_offer(const char* sessionID, proxyDynChannelInt
 	data->rewritten = TRUE;
 	return TRUE;
 }
+#endif
 
 static BOOL filter_dyn_channel_intercept(proxyPlugin* plugin, proxyData* pdata, void* arg)
 {
@@ -396,7 +400,8 @@ static BOOL filter_dyn_channel_intercept(proxyPlugin* plugin, proxyData* pdata,
 				          inputDataLength, state->remaining());
 				data->result = PF_CHANNEL_RESULT_DROP;
 
-#if 0 // TODO: Sending this does screw up some windows RDP server versions :/
+#if defined(REPLY_WITH_EMPTY_OFFER) // TODO: Sending this does screw up some windows RDP server
+                                    // versions :/
 				if (state->remaining() == 0)
 				{
 					if (!filter_forward_empty_offer(pdata->session_id, data, pos,

--- server/proxy/pf_client.c ---
@@ -193,36 +193,6 @@ static BOOL pf_client_use_proxy_smartcard_auth(const rdpSettings* settings)
 	return TRUE;
 }
 
-static BOOL freerdp_client_load_static_channel_addin(rdpChannels* channels, rdpSettings* settings,
-                                                     const char* name, void* data)
-{
-	PVIRTUALCHANNELENTRY entry = NULL;
-	PVIRTUALCHANNELENTRY lentry = freerdp_load_channel_addin_entry(
-	    name, NULL, NULL, FREERDP_ADDIN_CHANNEL_STATIC | FREERDP_ADDIN_CHANNEL_ENTRYEX);
-	PVIRTUALCHANNELENTRYEX entryEx = WINPR_FUNC_PTR_CAST(lentry, PVIRTUALCHANNELENTRYEX);
-	if (!entryEx)
-		entry = freerdp_load_channel_addin_entry(name, NULL, NULL, FREERDP_ADDIN_CHANNEL_STATIC);
-
-	if (entryEx)
-	{
-		if (freerdp_channels_client_load_ex(channels, settings, entryEx, data) == 0)
-		{
-			WLog_INFO(TAG, "loading channelEx %s", name);
-			return TRUE;
-		}
-	}
-	else if (entry)
-	{
-		if (freerdp_channels_client_load(channels, settings, entry, data) == 0)
-		{
-			WLog_INFO(TAG, "loading channel %s", name);
-			return TRUE;
-		}
-	}
-
-	return FALSE;
-}
-
 static BOOL pf_client_pre_connect(freerdp* instance)
 {
 	pClientContext* pc = NULL;

--- server/shadow/X11/x11_shadow.c ---
@@ -48,6 +48,8 @@
 
 #define TAG SERVER_TAG("shadow.x11")
 
+// #define USE_SHADOW_BLEND_CURSOR
+
 static UINT32 x11_shadow_enum_monitors(MONITOR_DEF* monitors, UINT32 maxMonitors);
 
 #ifdef WITH_PAM
@@ -589,54 +591,19 @@ static int x11_shadow_handle_xevent(x11ShadowSubsystem* subsystem, XEvent* xeven
 	return 1;
 }
 
-static void x11_shadow_validate_region(x11ShadowSubsystem* subsystem, int x, int y, int width,
-                                       int height)
-{
-	XRectangle region;
-
-	if (!subsystem->use_xfixes || !subsystem->use_xdamage)
-		return;
-
-	region.x = WINPR_ASSERTING_INT_CAST(INT16, x);
-	region.y = WINPR_ASSERTING_INT_CAST(INT16, y);
-	region.width = WINPR_ASSERTING_INT_CAST(UINT16, width);
-	region.height = WINPR_ASSERTING_INT_CAST(UINT16, height);
-#if defined(WITH_XFIXES) && defined(WITH_XDAMAGE)
-	XLockDisplay(subsystem->display);
-	XFixesSetRegion(subsystem->display, subsystem->xdamage_region, &region, 1);
-	XDamageSubtract(subsystem->display, subsystem->xdamage, subsystem->xdamage_region, None);
-	XUnlockDisplay(subsystem->display);
-#endif
-}
-
+#if defined(USE_SHADOW_BLEND_CURSOR)
 static int x11_shadow_blend_cursor(x11ShadowSubsystem* subsystem)
 {
-	UINT32 nXSrc = 0;
-	UINT32 nYSrc = 0;
-	INT64 nXDst = 0;
-	INT64 nYDst = 0;
-	UINT32 nWidth = 0;
-	UINT32 nHeight = 0;
-	UINT32 nSrcStep = 0;
-	UINT32 nDstStep = 0;
-	BYTE* pSrcData = NULL;
-	BYTE* pDstData = NULL;
-	BYTE A = 0;
-	BYTE R = 0;
-	BYTE G = 0;
-	BYTE B = 0;
-	rdpShadowSurface* surface = NULL;
-
 	if (!subsystem)
 		return -1;
 
-	surface = subsystem->common.server->surface;
-	nXSrc = 0;
-	nYSrc = 0;
-	nWidth = subsystem->cursorWidth;
-	nHeight = subsystem->cursorHeight;
-	nXDst = subsystem->common.pointerX - subsystem->cursorHotX;
-	nYDst = subsystem->common.pointerY - subsystem->cursorHotY;
+	rdpShadowSurface* surface = subsystem->common.server->surface;
+	UINT32 nXSrc = 0;
+	UINT32 nYSrc = 0;
+	UINT32 nWidth = subsystem->cursorWidth;
+	UINT32 nHeight = subsystem->cursorHeight;
+	INT64 nXDst = subsystem->common.pointerX - subsystem->cursorHotX;
+	INT64 nYDst = subsystem->common.pointerY - subsystem->cursorHotY;
 
 	if (nXDst >= surface->width)
 		return 1;
@@ -674,10 +641,10 @@ static int x11_shadow_blend_cursor(x11ShadowSubsystem* subsystem)
 	if ((nYDst + nHeight) > surface->height)
 		nHeight = (nYDst > surface->height) ? 0 : (UINT32)(surface->height - nYDst);
 
-	pSrcData = subsystem->cursorPixels;
-	nSrcStep = subsystem->cursorWidth * 4;
-	pDstData = surface->data;
-	nDstStep = surface->scanline;
+	const BYTE* pSrcData = subsystem->cursorPixels;
+	const UINT32 nSrcStep = subsystem->cursorWidth * 4;
+	BYTE* pDstData = surface->data;
+	const UINT32 nDstStep = surface->scanline;
 
 	for (size_t y = 0; y < nHeight; y++)
 	{
@@ -687,10 +654,10 @@ static int x11_shadow_blend_cursor(x11ShadowSubsystem* subsystem)
 
 		for (size_t x = 0; x < nWidth; x++)
 		{
-			B = *pSrcPixel++;
-			G = *pSrcPixel++;
-			R = *pSrcPixel++;
-			A = *pSrcPixel++;
+			const BYTE B = *pSrcPixel++;
+			const BYTE G = *pSrcPixel++;
+			const BYTE R = *pSrcPixel++;
+			const BYTE A = *pSrcPixel++;
 
 			if (A == 0xFF)
 			{
@@ -712,6 +679,7 @@ static int x11_shadow_blend_cursor(x11ShadowSubsystem* subsystem)
 
 	return 1;
 }
+#endif
 
 static BOOL x11_shadow_check_resize(x11ShadowSubsystem* subsystem)
 {
@@ -876,7 +844,10 @@ static int x11_shadow_screen_grab(x11ShadowSubsystem* subsystem)
 			if (!success)
 				goto fail_capture;
 
-			// x11_shadow_blend_cursor(subsystem);
+#if defined(USE_SHADOW_BLEND_CURSOR)
+			if (x11_shadow_blend_cursor(subsystem) < 0)
+				goto fail_capture;
+#endif
 			count = ArrayList_Count(server->clients);
 			shadow_subsystem_frame_update(&subsystem->common);
 

--- winpr/libwinpr/clipboard/synthetic_file.c ---
@@ -615,22 +615,6 @@ static BOOL process_mate_copied_files(wClipboard* clipboard, const char* data, U
 	return process_files(clipboard, data, pSize, "copy\n");
 }
 
-static BOOL process_nautilus_clipboard(wClipboard* clipboard, const char* data, UINT32 pSize)
-{
-	return process_files(clipboard, data, pSize, "x-special/nautilus-clipboard\ncopy\n");
-}
-
-static void* convert_nautilus_clipboard_to_filedescriptors(wClipboard* clipboard, UINT32 formatId,
-                                                           const void* data, UINT32* pSize)
-{
-	const UINT32 expected = ClipboardGetFormatId(clipboard, mime_gnome_copied_files);
-	if (formatId != expected)
-		return NULL;
-	if (!process_nautilus_clipboard(clipboard, (const char*)data, *pSize))
-		return NULL;
-	return convert_any_uri_list_to_filedescriptors(clipboard, formatId, pSize);
-}
-
 static void* convert_gnome_copied_files_to_filedescriptors(wClipboard* clipboard, UINT32 formatId,
                                                            const void* data, UINT32* pSize)
 {
@@ -888,30 +872,6 @@ static void* convert_filedescriptors_to_gnome_copied_files(wClipboard* clipboard
 	                                            "file://", "\n", TRUE);
 }
 
-/* Prepend header of nautilus based filemanager's format to file list*/
-static void* convert_filedescriptors_to_nautilus_clipboard(wClipboard* clipboard, UINT32 formatId,
-                                                           const void* data, UINT32* pSize)
-{
-	/* Here Nemo (and Caja) have different behavior. They encounter error with the last \n . but
-	   nautilus needs it. So user have to skip Nemo's error dialog to continue. Caja has different
-	   TARGET , so it's easy to fix. see convert_filedescriptors_to_mate_copied_files
-
-	   The text based "x-special/nautilus-clipboard" type was introduced with GNOME 3.30 and
-	   was necessary for the desktop icons extension, as gnome-shell at that time only
-	   supported text based mime types for gnome extensions. With GNOME 3.38, gnome-shell got
-	   support for non-text based mime types for gnome extensions. With GNOME 40, nautilus reverted
-	   the mime type change to "x-special/gnome-copied-files" and removed support for the text based
-	   mime type. So, in the near future, change this behaviour in favor for Nemo and Caja.
-	*/
-	/*	see nautilus/src/nautilus-clipboard.c:convert_selection_data_to_str_list
-	    see nemo/libnemo-private/nemo-clipboard.c:nemo_clipboard_get_uri_list_from_selection_data
-	*/
-
-	return convert_filedescriptors_to_file_list(clipboard, formatId, data, pSize,
-	                                            "x-special/nautilus-clipboard\ncopy\n", "file://",
-	                                            "\n", FALSE);
-}
-
 static void* convert_filedescriptors_to_mate_copied_files(wClipboard* clipboard, UINT32 formatId,
                                                           const void* data, UINT32* pSize)
 {

--- winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c ---
@@ -51,6 +51,7 @@ static BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair
 	return cbAvPair >= offset;
 }
 
+#ifdef WITH_DEBUG_NTLM
 static const char* get_av_pair_string(UINT16 pair)
 {
 	switch (pair)
@@ -81,6 +82,7 @@ static const char* get_av_pair_string(UINT16 pair)
 			return "UNKNOWN";
 	}
 }
+#endif
 
 static BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair);
 static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPairList, size_t* pcbAvPairList);

