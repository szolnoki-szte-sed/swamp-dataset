--- src/main/java/de/tum/in/test/api/security/ArtemisSecurityManager.java ---
@@ -511,19 +511,20 @@ private boolean isNotPrivileged(StackFrame stackFrame) {
 		return !AccessController.class.getName().equals(stackFrame.getClassName());
 	}
 
-	private boolean isCallNotWhitelisted(String call) {
+	private boolean isCallNotWhitelisted(String className, String methodName) {
+		String call = className + "." + methodName; //$NON-NLS-1$
 		return SecurityConstants.STACK_BLACKLIST.stream().anyMatch(call::startsWith)
 				|| (SecurityConstants.STACK_WHITELIST.stream().noneMatch(call::startsWith)
-						&& (configuration == null || !(configuration.whitelistedClassNames().contains(call)
-								|| configuration.trustedPackages().stream().anyMatch(pm -> pm.matches(call)))));
+						&& (configuration == null || !(configuration.whitelistedClassNames().contains(className)
+								|| configuration.trustedPackages().stream().anyMatch(pm -> pm.matches(className)))));
 	}
 
 	private boolean isStackFrameNotWhitelisted(StackFrame sf) {
-		return isCallNotWhitelisted(sf.getClassName());
+		return isCallNotWhitelisted(sf.getClassName(), sf.getMethodName());
 	}
 
 	private boolean isStackFrameNotWhitelisted(StackTraceElement ste) {
-		return isCallNotWhitelisted(ste.getClassName());
+		return isCallNotWhitelisted(ste.getClassName(), ste.getMethodName());
 	}
 
 	public static Optional<StackTraceElement> firstNonWhitelisted(StackTraceElement... elements) {

--- src/main/java/de/tum/in/test/api/security/SecurityConstants.java ---
@@ -15,7 +15,8 @@ public final class SecurityConstants {
 	static final Set<String> STACK_WHITELIST = Set.of("java.", "org.junit.", "jdk.", "org.eclipse.", "com.intellij", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
 			"org.assertj", "org.opentest4j.", "com.sun.", "sun.", "org.apache.", "de.tum.in.test.", "net.jqwik", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$
 			"ch.qos.logback", "org.jacoco", "javax.", "org.json", SECURITY_PACKAGE_NAME); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
-	static final Set<String> STACK_BLACKLIST = Set.of(BlacklistedInvoker.class.getName());
+	static final Set<String> STACK_BLACKLIST = Set.of(BlacklistedInvoker.class.getName(),
+			"org.junit.platform.commons.util.ReflectionUtils.getUnderlyingCause"); //$NON-NLS-1$
 
 	static final Set<String> PACKAGE_USE_BLACKLIST = Set.of(SECURITY_PACKAGE_NAME, "de.tum.in.test.api.internal", //$NON-NLS-1$
 			"jdk.internal", "sun."); //$NON-NLS-1$ //$NON-NLS-2$

--- src/test/java/de/tum/in/test/api/SecurityTest.java ---
@@ -26,6 +26,7 @@ class SecurityTest {
 	private final String testExecuteGit = "testExecuteGit";
 	private final String testMaliciousExceptionA = "testMaliciousExceptionA";
 	private final String testMaliciousExceptionB = "testMaliciousExceptionB";
+	private final String testMaliciousInvocationTargetException = "testMaliciousInvocationTargetException";
 	private final String testNewClassLoader = "testNewClassLoader";
 	private final String testNewSecurityManager = "testNewSecurityManager";
 	private final String tryManageProcess = "tryManageProcess";
@@ -80,6 +81,12 @@ void test_testMaliciousExceptionB() {
 		tests.assertThatEvents().haveExactly(1, testFailedWith(testMaliciousExceptionB, SecurityException.class));
 	}
 
+	@TestTest
+	void test_testMaliciousInvocationTargetException() {
+		tests.assertThatEvents().haveExactly(1,
+				testFailedWith(testMaliciousInvocationTargetException, SecurityException.class));
+	}
+
 	@TestTest
 	void test_testNewClassLoader() {
 		tests.assertThatEvents().haveExactly(1, testFailedWith(testNewClassLoader, SecurityException.class));

--- src/test/java/de/tum/in/testuser/SecurityUser.java ---
@@ -77,6 +77,11 @@ void testMaliciousExceptionB() {
 		assertFalse(SecurityPenguin.maliciousExceptionB());
 	}
 
+	@Test
+	void testMaliciousInvocationTargetException() throws Exception {
+		SecurityPenguin.maliciousInvocationTargetException();
+	}
+
 	@Test
 	void testNewClassLoader() throws IOException {
 		SecurityPenguin.newClassLoader();

--- src/test/java/de/tum/in/testuser/subject/SecurityPenguin.java ---
@@ -19,6 +19,7 @@
 import org.apache.xyz.Circumvention;
 import org.apache.xyz.FakeTrustedClass;
 import org.apache.xyz.MaliciousExceptionB;
+import org.apache.xyz.MaliciousInvocationTargetException;
 
 import de.tum.in.test.api.io.IOTester;
 
@@ -49,6 +50,10 @@ public static boolean maliciousExceptionB() {
 		return ab.get();
 	}
 
+	public static void maliciousInvocationTargetException() throws Exception {
+		throw new MaliciousInvocationTargetException();
+	}
+
 	@SuppressWarnings("resource")
 	public static void newClassLoader() throws IOException {
 		new URLClassLoader(new URL[0]).close();

--- src/test/java/org/apache/xyz/MaliciousInvocationTargetException.java ---
@@ -0,0 +1,22 @@
+package org.apache.xyz;
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+public class MaliciousInvocationTargetException extends InvocationTargetException {
+
+	private static final long serialVersionUID = 1L;
+
+	@Override
+	public Throwable getTargetException() {
+		try {
+			Files.readString(Path.of("pom.xml"));
+		} catch (IOException e) {
+			throw new UncheckedIOException(e);
+		}
+		return new Error("succeeded");
+	}
+}

