--- APTRS/lib/htmldocx.py ---
@@ -21,7 +21,8 @@
 import urllib.request
 from urllib.parse import urlparse
 from html.parser import HTMLParser
-
+import requests
+from requests.packages.urllib3.exceptions import InsecureRequestWarning
 import docx, docx.table
 from docx import Document
 from docx.shared import RGBColor, Pt, Inches
@@ -52,20 +53,25 @@ def is_url(url):
     care if it's a url or a file path, and they're pretty distinguishable
     """
     parts = urlparse(url)
+    print(all([parts.scheme, parts.netloc, parts.path]))
     return all([parts.scheme, parts.netloc, parts.path])
 
-def fetch_image(url):
+def fetch_image(url, headers, base_url):
     """
     Attempts to fetch an image from a url. 
     If successful returns a bytes object, else returns None
 
     :return:
     """
-    try:
-        with urllib.request.urlopen(url) as response:
-            # security flaw?
-            return io.BytesIO(response.read())
-    except urllib.error.URLError:
+    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
+    full_url = base_url + url
+    headers = {
+        "Authorization": f"Bearer {headers}"
+    }
+    response = requests.get(full_url, headers=headers,verify=False)
+    if response.status_code == 200:
+        return io.BytesIO(response.content)
+    else:
         return None
 
 def remove_last_occurence(ls, x):
@@ -183,7 +189,7 @@ def __init__(self):
         self.table_style = DEFAULT_TABLE_STYLE
         self.paragraph_style = DEFAULT_PARAGRAPH_STYLE
 
-    def set_initial_attrs(self, document=None):
+    def set_initial_attrs(self, document=None, headers=None, base_url=None):
         self.tags = {
             'span': [],
             'list': [],
@@ -192,6 +198,8 @@ def set_initial_attrs(self, document=None):
             self.doc = document
         else:
             self.doc = Document()
+        self.headers = headers
+        self.base_url = base_url
         self.bs = self.options['fix-html'] # whether or not to clean with BeautifulSoup
         self.document = self.doc
         self.include_tables = True #TODO add this option back in?
@@ -307,10 +315,10 @@ def handle_img(self, current_attrs):
             return
         src = current_attrs['src']
         # fetch image
-        src_is_url = is_url(src)
+        src_is_url = True #is_url(self.base_url + src) APTRS does not support local images
         if src_is_url:
             try:
-                image = fetch_image(src)
+                image = fetch_image(src,self.headers, self.base_url)
             except urllib.error.URLError:
                 image = None
         else:
@@ -319,7 +327,7 @@ def handle_img(self, current_attrs):
         if image:
             try:
                 if isinstance(self.doc, docx.document.Document):
-                    self.doc.add_picture(image)
+                    self.doc.add_picture(image,width=Inches(6.69291), height=Inches(4.2244094))
                 else:
                     self.add_image_to_cell(self.doc, image)
             except FileNotFoundError:
@@ -629,12 +637,12 @@ def run_process(self, html):
             self.get_tables()
         self.feed(html)
 
-    def add_html_to_document(self, html, document):
+    def add_html_to_document(self, html, document,headers, base_url):
         if not isinstance(html, str):
             raise ValueError('First argument needs to be a %s' % str)
         elif not isinstance(document, docx.document.Document) and not isinstance(document, docx.table._Cell):
             raise ValueError('Second argument needs to be a %s' % docx.document.Document)
-        self.set_initial_attrs(document)
+        self.set_initial_attrs(document,headers, base_url)
         self.run_process(html)
 
     def add_html_to_cell(self, html, cell):

--- APTRS/project/report.py ---
@@ -18,7 +18,7 @@
 from docxtpl import DocxTemplate,RichText
 from django.shortcuts import get_object_or_404
 from datetime import datetime
-import jinja2
+from jinja2.sandbox import SandboxedEnvironment
 import html
 import traceback
 
@@ -36,18 +36,14 @@
 token = None
 
 
-def CheckReport(Report_format,Report_type,pk,url,standard,request):
+def CheckReport(Report_format,Report_type,pk,url,standard,request,access_token):
     global base_url
     base_url = url
     if Report_format == "excel":
         response =  CreateExcel(pk)
 
     global token
-    auth_header = request.headers.get('Authorization')
-    if auth_header:
-        token = auth_header.split(' ')[1] if auth_header.startswith('Bearer ') else None
-    else:
-        token = request.cookies.get('access_token')
+    token = access_token
     if Report_format == "docx":
         response = generate_vulnerability_document(pk,Report_type,standard)
     if Report_format == "pdf":
@@ -107,7 +103,7 @@ def generate_vulnerability_document(pk,Report_type,standard):
                 'standard':standard,'totalvulnerability':totalvulnerability,'totalretest':totalretest,'projectscope':projectscope,
                 'page_break': RichText('\f'),'new_line': RichText('\n')
                 }
-        jinja_env = jinja2.Environment()
+        jinja_env = SandboxedEnvironment(autoescape=True)
         jinja_env.trim_blocks = True
         jinja_env.lstrip_blocks = True
         doc.render(context,jinja_env)

--- APTRS/project/views/project.py ---
@@ -5,7 +5,7 @@
 from django.core.cache import cache
 from django.utils.decorators import method_decorator
 from django.views.decorators.cache import cache_page
-
+from rest_framework_simplejwt.tokens import RefreshToken
 from rest_framework import status, views
 from rest_framework.decorators import (api_view, permission_classes)
 from rest_framework.permissions import IsAuthenticated,IsAdminUser
@@ -266,6 +266,8 @@ def project_report(request, pk):
     except ValueError as e:
         logging.error(f"Error: {e}")
         return Response({"Status": "Failed", "Message": "Report Standards are not provided"})
-        
-    output = CheckReport(report_format,report_type,pk,url,standard,request)
+    
+    refresh = RefreshToken.for_user(request.user) # generate new token for user to access auth protected images for report, user token in request might be close to expiry, so refreshing it to have new 30 mins token
+    access_token = refresh.access_token
+    output = CheckReport(report_format,report_type,pk,url,standard,request,access_token)
     return output

--- APTRS/utils/doc_style.py ---
@@ -3,8 +3,9 @@
 from docx import Document
 import io
 from lib.htmldocx import HtmlToDocx
-from utils.image_parsing import find_images
+import logging
 
+logger = logging.getLogger(__name__)
 
 def apply_font_style(element, font_name, font_size):
     if hasattr(element, 'font'):
@@ -27,22 +28,8 @@ def get_subdoc(doc,raw_html, headers, base_url):
     temp_parser = HtmlToDocx()
 
     if raw_html is not None:
-
-        images = find_images(raw_html, headers, base_url)
-        '''
-        CKEDITOR HTML allow images like POC images, html imc tag will have src=/api/project/getimage/?filename=img-uuid.jpg
-        The use of API allow to handle both case in case images stored on cloud bucket or locally
-        with that images are mostly POC and contain senstive info, its easy to prevent direct access to image as /api/* need auth token.
-        This also fix, ckeditor html direclty stored in db, if s3 url used in case of s3 allowed, having signed url in src would fail to load images if signed url expired 
-
-        Adding fix for docxtpl , instead of url for src replacing it with image byte 
-        '''
-        # Convert image src paths - doctpl does not support loading img over url, adding image full path
-        for i, img in enumerate(images):
-            raw_html = raw_html.replace(img['html_tag'], f"{{{{img{i}}}}}")
-
         # Convert HTML to temporary DOCX
-        temp_parser.add_html_to_document(raw_html, temp_doc)
+        temp_parser.add_html_to_document(raw_html, temp_doc,headers, base_url)
 
         # Resize images in the temporary DOCX
         ## https://stackoverflow.com/questions/76571366/resizing-all-images-in-a-word-document-using-python
@@ -83,18 +70,8 @@ def get_subdoc(doc,raw_html, headers, base_url):
         sub_docxtpl = DocxTemplate(subdoc_tmp)
         context = {}
 
-        # handle image bytes and place image byte as inline imaage in doc
-        for i, img in enumerate(images):
-            img_obj = InlineImage(sub_docxtpl, img['bytes'],width=Inches(6.69291), height=Inches(4.2244094))
-            context[f"img{i}"] = img_obj
-
-        sub_docxtpl.render(context)
         sub_docxtpl.save(subdoc_tmp)
         subdoc_tmp.seek(0)
-
-
-
-
         # Create docxtpl subdoc object
         subdoc = doc.new_subdoc(subdoc_tmp)
         return subdoc

--- APTRS/utils/image_parsing.py ---
@@ -1,43 +0,0 @@
-import requests
-from io import BytesIO
-import re
-from requests.packages.urllib3.exceptions import InsecureRequestWarning
-
-def fetch_image_bytes(image_url_or_path, headers, base_url):
-    """Fetch image bytes from a URL (S3) or from the local file system."""
-
-    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
-
-    image_url = base_url + image_url_or_path
-    token_headers = {
-                "Authorization": f"Bearer {headers}"
-            }
-    response = requests.get(image_url, headers=token_headers, verify=False)
-    if response.status_code == 200:
-        return BytesIO(response.content)
-    else:
-        raise Exception(f"Failed to retrieve image from {image_url}, status code {response.status_code}")
-
-def find_images(raw_html, headers, base_url):
-    """Find all <img> tags in raw HTML and replace with jinja2 placeholders."""
-    regex = r'<img.*?>'
-    images = []
-
-    for cnt, match in enumerate(re.finditer(regex, raw_html)):
-        image_metadata = {
-            'id': cnt,
-            'html_tag': match.group()
-        }
-
-        # Extract image URL or path from the src attribute
-        src_match = re.search(r'src="([^"]+)"', image_metadata['html_tag'])
-        if src_match:
-            image_url_or_path = src_match.group(1)
-            image_metadata['image_url_or_path'] = image_url_or_path
-
-            # Fetch image bytes from the URL or local file system
-            image_metadata['bytes'] = fetch_image_bytes(image_url_or_path, headers,base_url)
-
-        images.append(image_metadata)
-
-    return images

--- APTRS/utils/validators.py ---
@@ -4,6 +4,8 @@
 from django.conf import settings
 from django.core.exceptions import ValidationError
 from django.utils.translation import gettext as _
+from jinja2.sandbox import SandboxedEnvironment
+from docxtpl import InlineImage
 
 ALLOWED_TAGS = settings.ALLOWED_TAGS
 
@@ -121,4 +123,4 @@ def get_base_url(request=None):
             base_url = f"{request.scheme}://{request.get_host()}"
         else:
             raise Exception("Request is required when not using Docker.")
-    return base_url
\ No newline at end of file
+    return base_url

--- README.md ---
@@ -25,19 +25,10 @@ APTRS (Automated Penetration Testing Reporting System) is a Python and Django-ba
 ![GitHub contributors from allcontributors.org](https://img.shields.io/github/all-contributors/aptrs/aptrs)
 
 
-**Support APTRS**
-
-
-<a href="https://github.com/sponsors/APTRS"><img src="https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=%23fe8e86" alt="Sponsor APTRS" width="230" height="50"></a>
-<br/><br/>
-
-If you've found APTRS helpful and valuable, your support through donations is greatly appreciated.
-
-
 ## Documentation
 
-> [!WARNING]  
-> Please ensure to review the Deployment Guide for configuration and security instructions from the documentation.
+> [!Note]  
+> Please ensure to review the Installation and Deployment Guide from the documentation.
 
 
 
@@ -50,7 +41,18 @@ If you've found APTRS helpful and valuable, your support through donations is gr
 > [!NOTE]  
 > Default creds are sourav.kalal@aptrs.com & I-am-Weak-Password-Please-Change-Me
 
+Quick Installation
+
+> [!Warning]  
+> Please ensure to review the documentation for Security Configuration for ENV and other Installation methods.
 
+```bash
+git clone https://github.com/APTRS/APTRS
+cd APTRS
+cp env.docker .env
+nano .env
+docker-compose up 
+```
 
 
 
@@ -68,6 +70,19 @@ If you've found APTRS helpful and valuable, your support through donations is gr
 - Manage Project Status, Schedules and Retest
 
 
+## Support APTRS
+
+If you've found APTRS helpful and valuable, please consider supporting the project. Your donations are crucial in helping maintain and improve APTRS, which is primarily maintained by a single dedicated developer. Your support will ensure the continued development of new features, timely updates, and the overall sustainability of the project. Every contribution, no matter how small, makes a significant difference and is greatly appreciated. Thank you for your generosity and support!
+<div style="display: flex; flex-direction: column; align-items: center; border: 1px solid #000; padding: 10px; width: 350px;"><b>Bitcoin</b>
+  <img src="https://raw.githubusercontent.com/APTRS/APTRS-Changelog/refs/heads/main/images/BTC.png" alt="BTC Wallet QR Code" width="200" height="200">
+  <p style="margin-top: 10px; text-align: center;">bc1qusxngf2w5gl2g8hw82ggct59227k4963f9fwhm</p>
+</div>
+<br/><br/>
+<a href="https://github.com/sponsors/APTRS"><img src="https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=%23fe8e86" alt="Sponsor APTRS" width="230" height="50"></a>
+<br/><br/>
+
+
+
 ## Sponsor
 
 <p>This project is supported by:</p>

