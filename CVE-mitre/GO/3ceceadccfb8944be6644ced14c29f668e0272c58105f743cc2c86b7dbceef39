--- packages/ubuntu_init/lib/src/init_model.dart ---
@@ -14,7 +14,6 @@ final initModelProvider = Provider(
     args: tryGetService<ArgResults>(),
     identityService: tryGetService<IdentityService>(),
     gdmService: tryGetService<GdmService>(),
-    chownService: tryGetService<ChownService>(),
   ),
 );
 
@@ -24,23 +23,19 @@ class InitModel {
     ArgResults? args,
     IdentityService? identityService,
     GdmService? gdmService,
-    ChownService? chownService,
   })  : _gdmService = gdmService,
         _identityService = identityService,
-        _pageConfig = pageConfig,
-        _chownService = chownService;
+        _pageConfig = pageConfig;
 
   final PageConfigService? _pageConfig;
   final IdentityService? _identityService;
   final GdmService? _gdmService;
-  final ChownService? _chownService;
 
   Future<void> launchDesktopSession() async {
     final identity = await _identityService?.getIdentity();
     if (identity == null) return;
 
     try {
-      await _chownService?.chownSettings(identity.username);
       await _gdmService?.launchSession(
         identity.username,
         identity.password,

--- packages/ubuntu_init/lib/src/init_services.dart ---
@@ -3,7 +3,6 @@ import 'package:gsettings/gsettings.dart';
 import 'package:timezone_map/timezone_map.dart';
 import 'package:ubuntu_init/src/init_step.dart';
 import 'package:ubuntu_init/src/services/provd_accessibility_service.dart';
-import 'package:ubuntu_init/src/services/provd_chown_service.dart';
 import 'package:ubuntu_init/src/services/provd_gdm_service.dart';
 import 'package:ubuntu_init/src/services/provd_identity_service.dart';
 import 'package:ubuntu_init/src/services/provd_keyboard_service.dart';
@@ -22,7 +21,6 @@ export 'package:args/args.dart' show ArgResults;
 export 'package:timezone_map/timezone_map.dart' show GeoService;
 
 export 'services/provd_accessibility_service.dart';
-export 'services/provd_chown_service.dart';
 export 'services/provd_gdm_service.dart';
 export 'services/provd_identity_service.dart';
 export 'services/provd_keyboard_service.dart';
@@ -51,7 +49,6 @@ Future<void> registerInitServices(List<String> args) async {
 
   tryRegisterService<ActiveDirectoryService>(RealmdActiveDirectoryService.new);
   tryRegisterService<AccessibilityService>(ProvdAccessibilityService.new);
-  tryRegisterService<ChownService>(ProvdChownService.new);
   tryRegisterService<ConfigService>(ConfigService.new);
   tryRegisterService<GdmService>(ProvdGdmService.new);
   tryRegisterServiceFactory<GSettings, String>(GSettings.new);

--- packages/ubuntu_init/lib/src/services/provd_chown_service.dart ---
@@ -1,23 +0,0 @@
-import 'package:flutter/foundation.dart';
-import 'package:meta/meta.dart';
-import 'package:provd_client/provd_client.dart' as provd;
-import 'package:ubuntu_init/src/services/provd_address.dart';
-
-abstract class ChownService {
-  Future<bool> chownSettings(String username);
-}
-
-class ProvdChownService with ProvdAddress implements ChownService {
-  ProvdChownService({@visibleForTesting provd.ProvdChownClient? client})
-      : _client = client ??
-            provd.ProvdChownClient(
-              ProvdAddress.socketAddress,
-              ProvdAddress.port,
-            );
-
-  final provd.ProvdChownClient _client;
-
-  @override
-  Future<bool> chownSettings(String username) =>
-      _client.chownSettings(username);
-}

--- provd/debian/changelog ---
@@ -1,3 +1,9 @@
+provd (0.1.5~ppa1) noble; urgency=medium
+
+  * Remove Ubuntu Pro and Chmod services
+
+ -- Matthew Gary Hagemann <matt.hagemann@canonical.com>  Mon, 1 Jul 2024 14:23:46 +0200
+
 provd (0.1.4) noble; urgency=medium
 
   * Gnome-keyring now unlocked for wifi password prompt to appear during setup.

--- provd/debian/provd.install ---
@@ -1,3 +1,2 @@
 usr/bin/provd usr/libexec/
-usr/bin/sprovd usr/libexec/
 debian/launch-desktop-provision-init usr/libexec/

--- provd/debian/provd.postinst ---
@@ -13,9 +13,7 @@ case "$1" in
         chmod 750 /usr/libexec/launch-desktop-provision-init
 
         # Set ownership and permissions for bin's
-        chown root:provd /usr/libexec/sprovd
         chown root:provd /usr/libexec/provd
-        chmod u+s /usr/libexec/sprovd
         ;;
 esac
 

--- provd/internal/services/chown/chowm_test.go ---
@@ -1,108 +0,0 @@
-package chown_test
-
-import (
-	"context"
-	"errors"
-	"flag"
-	"net"
-	"os"
-	"path/filepath"
-	"strings"
-	"testing"
-
-	chown "github.com/canonical/ubuntu-desktop-provision/provd/internal/services/chown"
-	"github.com/canonical/ubuntu-desktop-provision/provd/internal/testutils"
-	pb "github.com/canonical/ubuntu-desktop-provision/provd/protos"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/credentials/insecure"
-)
-
-func TestChownSettings(t *testing.T) {
-	t.Parallel()
-
-	tests := map[string]struct {
-		wantError bool
-	}{
-		"Successfully chown settings to a new user": {},
-
-		"Error when chown settings fails": {wantError: true},
-	}
-
-	for name, tc := range tests {
-		t.Run(name, func(t *testing.T) {
-			tc := tc
-			t.Parallel()
-
-			// Prepare mocks
-			opts := []chown.Option{
-				chown.WithChownExecutable(&mockChownExecutable{}),
-			}
-			username := "foo"
-			if tc.wantError {
-				username = "error"
-			}
-			client := newChownClient(t, opts...)
-			resp, err := client.ChownSettings(context.Background(), &pb.ChownRequest{Username: username})
-			require.NoError(t, err, "ChownSettings should not return an error")
-
-			got := resp.String()
-			want := testutils.LoadWithUpdateFromGolden(t, got)
-			require.Equal(t, want, got, "response from ChownSettings should match expected")
-		})
-	}
-}
-
-// newChownClient creates a new chown client for testing, with a temp unix socket.
-func newChownClient(t *testing.T, opts ...chown.Option) pb.ChownServiceClient {
-	t.Helper()
-
-	// socket path is limited in length.
-	tmpDir, err := os.MkdirTemp("", "hello-socket-dir")
-	require.NoError(t, err, "Setup: could not setup temporary socket dir path")
-	t.Cleanup(func() { _ = os.RemoveAll(tmpDir) })
-	socketPath := filepath.Join(tmpDir, "provd.sock")
-
-	lis, err := net.Listen("unix", socketPath)
-	require.NoError(t, err, "Setup: could not create unix socket")
-
-	service, err := chown.New(opts...)
-
-	if err != nil {
-		t.Fatalf("Setup: could not create user service: %v", err)
-	}
-
-	grpcServer := grpc.NewServer()
-	pb.RegisterChownServiceServer(grpcServer, service)
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		_ = grpcServer.Serve(lis)
-	}()
-	t.Cleanup(func() {
-		grpcServer.Stop()
-		<-done
-	})
-
-	conn, err := grpc.Dial("unix://"+socketPath, grpc.WithTransportCredentials(insecure.NewCredentials()))
-	require.NoError(t, err, "Setup: Could not connect to GRPC server")
-	t.Cleanup(func() { _ = conn.Close() })
-
-	return pb.NewChownServiceClient(conn)
-}
-
-func TestMain(m *testing.M) {
-	testutils.InstallUpdateFlag()
-	flag.Parse()
-
-	m.Run()
-}
-
-type mockChownExecutable struct{}
-
-func (c *mockChownExecutable) Chown(ctx context.Context, username string) error {
-	if strings.Contains(username, "error") {
-		return errors.New("mock requsted failure")
-	}
-	return nil
-}

--- provd/internal/services/chown/chown.go ---
@@ -1,70 +0,0 @@
-// Package chown implements the chown gRPC service.
-package chown
-
-import (
-	"context"
-	"fmt"
-	"log/slog"
-	"os/exec"
-
-	pb "github.com/canonical/ubuntu-desktop-provision/provd/protos"
-)
-
-type iChownExecutable interface {
-	Chown(ctx context.Context, username string) error
-}
-
-type chownExecutable struct{}
-
-// Option is a functional option to set the executable in tests.
-type Option func(*Service) error
-
-// Service is the implementation of the Pro service.
-type Service struct {
-	pb.UnimplementedChownServiceServer
-	chownExecutable iChownExecutable
-}
-
-// New returns a new instance of the Chown service.
-func New(opts ...Option) (*Service, error) {
-	s := &Service{}
-
-	c := &chownExecutable{}
-	s.chownExecutable = c
-
-	// Applying options
-	for _, opt := range opts {
-		if err := opt(s); err != nil {
-			return nil, err
-		}
-	}
-
-	return s, nil
-}
-
-func (c *chownExecutable) Chown(ctx context.Context, username string) error {
-	// Construct the full path to the priveledged executable
-	path := "/usr/libexec/sprovd"
-
-	// Run the pro attach command with the contract token
-	out, err := exec.CommandContext(ctx, path, "-chown", username).CombinedOutput()
-	if err != nil {
-		slog.Error(fmt.Sprintf("failed to run chown /run/gnome-initial-setup for user %s: %v\nOutput: %s", username, err, string(out)))
-		return fmt.Errorf("failed to run pro attach: %v\nOutput: %s", err, string(out))
-	}
-
-	return nil
-}
-
-// ChownSettings attempts to recursively chown the /run/gnome-initial-setup directory for a given user.
-func (s *Service) ChownSettings(ctx context.Context, req *pb.ChownRequest) (*pb.ChownResponse, error) {
-	err := s.chownExecutable.Chown(ctx, req.Username)
-
-	// This is only a temporary workaround, and somthing we don't want to be fatal, nor surface to the user if it fails.
-	if err != nil {
-		slog.Error(fmt.Sprintf("failed to change ownership of /run/gnome-initial-setup, not all settings will be correctly moved to new user: %v", err))
-		return &pb.ChownResponse{Code: pb.ChownResponse_UNKNOWN_ERROR}, nil
-	}
-
-	return &pb.ChownResponse{Code: pb.ChownResponse_SUCCESS}, nil
-}

--- provd/internal/services/chown/export_test.go ---
@@ -1,11 +0,0 @@
-package chown
-
-type IChownExecutable = iChownExecutable
-
-// Option is a functional option to set the chown executable for testing.
-func WithChownExecutable(c IChownExecutable) Option {
-	return func(s *Service) error {
-		s.chownExecutable = c
-		return nil
-	}
-}

--- provd/internal/services/chown/testdata/TestChownSettings/golden/error_when_chown_settings_fails ---
@@ -1 +0,0 @@
-code:UNKNOWN_ERROR
\ No newline at end of file

--- provd/internal/services/manager.go ---
@@ -8,12 +8,10 @@ import (
 	"log/slog"
 
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/accessibility"
-	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/chown"
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/gdm"
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/keyboard"
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/locale"
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/privacy"
-	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/pro"
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/telemetry"
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/timezone"
 	"github.com/canonical/ubuntu-desktop-provision/provd/internal/services/user"
@@ -33,8 +31,6 @@ type Manager struct {
 	privacyService       privacy.Service
 	timezoneService      timezone.Service
 	accessibilityService accessibility.Service
-	proService           pro.Service
-	chownService         chown.Service
 	telemetryService     telemetry.Service
 	gdmService           *gdm.Service
 	bus                  *dbus.Conn
@@ -93,16 +89,6 @@ func NewManager(ctx context.Context) (m *Manager, e error) {
 		return nil, status.Errorf(codes.Internal, "%s", errs)
 	}
 
-	proService, err := pro.New()
-	if err != nil {
-		return nil, status.Errorf(codes.Internal, "failed to create pro service: %s", err)
-	}
-
-	chownService, err := chown.New()
-	if err != nil {
-		return nil, status.Errorf(codes.Internal, "failed to create chown service: %s", err)
-	}
-
 	telemetryService, err := telemetry.New()
 	if err != nil {
 		return nil, status.Errorf(codes.Internal, "failed to create telemetry service: %s", err)
@@ -115,8 +101,6 @@ func NewManager(ctx context.Context) (m *Manager, e error) {
 		privacyService:       *privacyService,
 		timezoneService:      *timezoneService,
 		accessibilityService: *accessibilityService,
-		proService:           *proService,
-		chownService:         *chownService,
 		telemetryService:     *telemetryService,
 		gdmService:           gdmService,
 		bus:                  bus,
@@ -135,8 +119,6 @@ func (m Manager) RegisterGRPCServices(ctx context.Context) *grpc.Server {
 	pb.RegisterPrivacyServiceServer(grpcServer, &m.privacyService)
 	pb.RegisterTimezoneServiceServer(grpcServer, &m.timezoneService)
 	pb.RegisterAccessibilityServiceServer(grpcServer, &m.accessibilityService)
-	pb.RegisterProServiceServer(grpcServer, &m.proService)
-	pb.RegisterChownServiceServer(grpcServer, &m.chownService)
 	pb.RegisterTelemetryServiceServer(grpcServer, &m.telemetryService)
 
 	if m.gdmService != nil {

--- provd/internal/services/pro/export_test.go ---
@@ -1,14 +0,0 @@
-package pro
-
-type IProExecutable = iProExecutable
-type ProAPIResponse = proAPIResponse
-type ProAPIErrors = proAPIErrors
-type ProAPIError = proAPIError
-
-// Option is a functional option to set the pro executable for testing.
-func WithProExecutable(p IProExecutable) Option {
-	return func(s *Service) error {
-		s.proExecutable = p
-		return nil
-	}
-}

--- provd/internal/services/pro/pro.go ---
@@ -1,270 +0,0 @@
-// Package pro implements the Pro gRPC service.
-package pro
-
-import (
-	"context"
-	"encoding/json"
-	"fmt"
-	"log/slog"
-	"os/exec"
-	"strings"
-
-	pb "github.com/canonical/ubuntu-desktop-provision/provd/protos"
-	"google.golang.org/grpc/codes"
-	"google.golang.org/grpc/status"
-	"google.golang.org/protobuf/types/known/emptypb"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-)
-
-type iProExecutable interface {
-	Initiate(ctx context.Context) (*proAPIResponse, error)
-	Wait(ctx context.Context, token string) (*proAPIResponse, error)
-	Attach(ctx context.Context, token string) error
-	Status(ctx context.Context) (*bool, error)
-}
-
-type proExecutable struct{}
-
-// Option is a functional option to set the DBus objects in tests.
-type Option func(*Service) error
-
-// Service is the implementation of the Pro service.
-type Service struct {
-	pb.UnimplementedProServiceServer
-	proExecutable iProExecutable
-}
-
-// New returns a new instance of the Pro service.
-func New(opts ...Option) (*Service, error) {
-	s := &Service{}
-
-	p := &proExecutable{}
-	s.proExecutable = p
-
-	// Applying options, checking for errors in obtaining DBus objects
-	for _, opt := range opts {
-		if err := opt(s); err != nil {
-			return nil, err
-		}
-	}
-
-	return s, nil
-}
-
-type proAPIResponse struct {
-	Result string `json:"result"`
-	Data   struct {
-		Attributes struct {
-			Expires       string  `json:"expires,omitempty"`
-			ExpiresIn     int     `json:"expires_in,omitempty"`
-			Token         string  `json:"token,omitempty"`
-			UserCode      string  `json:"user_code,omitempty"`
-			ContractID    *string `json:"contract_id,omitempty"`
-			ContractToken *string `json:"contract_token,omitempty"`
-		} `json:"attributes"`
-	} `json:"data"`
-	Errors   proAPIErrors  `json:"errors"`
-	Version  string        `json:"version"`
-	Warnings []interface{} `json:"warnings"`
-}
-
-type proAPIError struct {
-	Code string `json:"code"`
-}
-
-type proAPIErrors []proAPIError
-
-func (e proAPIErrors) ContainsCode(code string) bool {
-	for _, err := range e {
-		if err.Code == code {
-			return true
-		}
-	}
-	return false
-}
-
-// ProMagicAttach streams a user code and waits on a contract token from the pro server to preform a magic attach.
-func (s *Service) ProMagicAttach(req *emptypb.Empty, stream pb.ProService_ProMagicAttachServer) error {
-	// Initiate magic attach process
-	response, err := s.proExecutable.Initiate(stream.Context())
-	if err != nil {
-		return status.Errorf(codes.Internal, fmt.Sprintf("failed to initiate magic attach: %v", err))
-	}
-	if response.Result != "success" {
-		if response.Errors.ContainsCode("connectivity-error") {
-			return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_NETWORK_ERROR, nil)
-		}
-		return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_UNKNOWN_ERROR, nil)
-	}
-
-	// Send the user code
-	err = s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_USER_CODE, &response.Data.Attributes.UserCode)
-	if err != nil {
-		return err
-	}
-
-	// Wait for user to enter User Code on ubuntu.com/pro/attach
-	var contractToken *string
-	magicToken := &response.Data.Attributes.Token
-	for {
-		// Wait for magic attach process to complete
-		response, err := s.proExecutable.Wait(stream.Context(), *magicToken)
-		if err != nil {
-			return status.Errorf(codes.Internal, fmt.Sprintf("failed to wait on magic attach: %v", err))
-		}
-
-		// Successfully got the Contract Token
-		if response.Result == "success" {
-			contractToken = response.Data.Attributes.ContractToken
-			break
-		}
-
-		// Failed to get Contract Token
-		if response.Errors.ContainsCode("magic-attach-token-error") {
-			// Code exparation reached, generate a new user code
-			response, err := s.proExecutable.Initiate(stream.Context())
-			if err != nil {
-				return status.Errorf(codes.Internal, fmt.Sprintf("failed to initiate magic attach: %v", err))
-			}
-			if response.Result != "success" {
-				if response.Errors.ContainsCode("connectivity-error") {
-					return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_NETWORK_ERROR, nil)
-				}
-				return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_UNKNOWN_ERROR, nil)
-			}
-			// Send the newly generated user code
-			err = s.sendSteamResponse(stream, *pb.ProMagicAttachResponseType_REFRESHED_USER_CODE.Enum(), &response.Data.Attributes.UserCode)
-			if err != nil {
-				return err
-			}
-			magicToken = &response.Data.Attributes.Token
-			continue
-		}
-
-		// Handle other error cases
-		if response.Errors.ContainsCode("connectivity-error") {
-			return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_NETWORK_ERROR, nil)
-		}
-		return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_UNKNOWN_ERROR, nil)
-	}
-
-	// Pro attach the returned Contract Token
-	if contractToken == nil {
-		return status.Errorf(codes.Internal, "contract token not found in response")
-	}
-	if err := s.proExecutable.Attach(stream.Context(), *contractToken); err != nil {
-		if strings.Contains(err.Error(), "failed to run pro attach") {
-			return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_ALREADY_ATTACHED, nil)
-		}
-		return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_UNKNOWN_ERROR, nil)
-	}
-
-	// Send the final success response
-	return s.sendSteamResponse(stream, pb.ProMagicAttachResponseType_SUCCESS, nil)
-}
-
-func (p *proExecutable) Initiate(ctx context.Context) (*proAPIResponse, error) {
-	out, err := exec.CommandContext(ctx, "pro", "api", "u.pro.attach.magic.initiate.v1").Output()
-
-	if out == nil && err != nil {
-		slog.Error(fmt.Sprintf("failed to initiate magic attach: %v\nOutput: %s", err, string(out)))
-		return nil, fmt.Errorf("failed to initiate magic attach: %v\nOutput: %s", err, string(out))
-	}
-
-	// Parse the response
-	var response proAPIResponse
-	if err := json.Unmarshal(out, &response); err != nil {
-		slog.Error(fmt.Sprintf("failed to parse response: %v", err))
-		return nil, fmt.Errorf("failed to parse response: %v", err)
-	}
-
-	return &response, nil
-}
-
-func (p *proExecutable) Status(ctx context.Context) (*bool, error) {
-	// Execute the pro status command
-	out, err := exec.CommandContext(ctx, "pro", "status", "--format=json").Output()
-	if err != nil {
-		slog.Error(fmt.Sprintf("failed to execute pro status: %v\nOutput: %s", err, string(out)))
-		return nil, fmt.Errorf("failed to execute pro status: %v\nOutput: %s", err, string(out))
-	}
-
-	var attachedStatus struct {
-		Attached bool
-	}
-	if err = json.Unmarshal(out, &attachedStatus); err != nil {
-		return nil, fmt.Errorf("could not parse output: %v. Output: %s", err, string(out))
-	}
-
-	return &attachedStatus.Attached, nil
-}
-
-func (p *proExecutable) Wait(ctx context.Context, token string) (*proAPIResponse, error) {
-	// Initiate magic attach process
-	// #nosec:G204 // We are in control of the token formatting and this is only the argument.
-	out, err := exec.CommandContext(ctx, "pro", "api", "u.pro.attach.magic.wait.v1", "--args", fmt.Sprintf("magic_token=%s", token)).Output()
-
-	if out == nil && err != nil {
-		slog.Error(fmt.Sprintf("failed to wait on attach response: %v\nOutput: %s", err, string(out)))
-		return nil, fmt.Errorf("failed to wait on attach response: %v\nOutput: %s", err, string(out))
-	}
-
-	// Parse the response
-	var response proAPIResponse
-	if err := json.Unmarshal(out, &response); err != nil {
-		slog.Error(fmt.Sprintf("failed to parse response: %v", err))
-		return nil, fmt.Errorf("failed to parse response: %v", err)
-	}
-
-	return &response, nil
-}
-
-func (p *proExecutable) Attach(ctx context.Context, token string) error {
-	// Construct the full path to the pro-attach executable
-	proAttachPath := "/usr/libexec/sprovd"
-
-	// Run the pro attach command with the contract token
-	out, err := exec.CommandContext(ctx, proAttachPath, "-attach", token).CombinedOutput()
-	if err != nil {
-		slog.Error(fmt.Sprintf("failed to run pro attach: %v\nOutput: %s", err, string(out)))
-		return fmt.Errorf("failed to run pro attach: %v\nOutput: %s", err, string(out))
-	}
-
-	return nil
-}
-
-// Helper function to send an initiate response and handle errors.
-func (s *Service) sendSteamResponse(stream pb.ProService_ProMagicAttachServer, respType pb.ProMagicAttachResponseType, userCode *string) error {
-	resp := &pb.ProMagicAttachResponse{
-		Type: respType,
-	}
-	if userCode != nil {
-		resp.UserCode = userCode
-	}
-	if err := stream.Send(resp); err != nil {
-		return status.Errorf(codes.Internal, "failed to send response: %v", err)
-	}
-	return nil
-}
-
-// ProAttach attaches a contract token to the system.
-func (s *Service) ProAttach(ctx context.Context, req *pb.ProAttachRequest) (*pb.ProAttachResponse, error) {
-	if err := s.proExecutable.Attach(ctx, req.Token); err != nil {
-		if strings.Contains(err.Error(), "failed to run pro attach") {
-			return &pb.ProAttachResponse{Type: pb.ProAttachResponse_ALREADY_ATTACHED}, nil
-		}
-		return &pb.ProAttachResponse{Type: pb.ProAttachResponse_UNKNOWN_ERROR}, nil
-	}
-
-	return &pb.ProAttachResponse{Type: pb.ProAttachResponse_SUCCESS}, nil
-}
-
-// ProStatus returns if the machine is currently pro attached.
-func (s *Service) ProStatus(ctx context.Context, _ *emptypb.Empty) (*wrapperspb.BoolValue, error) {
-	attached, err := s.proExecutable.Status(ctx)
-
-	if err != nil {
-		return nil, status.Errorf(codes.Internal, fmt.Sprintf("failed to pro attach: %v", err))
-	}
-	return &wrapperspb.BoolValue{Value: *attached}, nil
-}

--- provd/internal/services/pro/pro_test.go ---
@@ -1,339 +0,0 @@
-package pro_test
-
-import (
-	"context"
-	"encoding/json"
-	"errors"
-	"flag"
-	"io"
-	"net"
-	"os"
-	"path/filepath"
-	"testing"
-
-	pro "github.com/canonical/ubuntu-desktop-provision/provd/internal/services/pro"
-	"github.com/canonical/ubuntu-desktop-provision/provd/internal/testutils"
-	pb "github.com/canonical/ubuntu-desktop-provision/provd/protos"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/credentials/insecure"
-	"google.golang.org/protobuf/types/known/emptypb"
-)
-
-func TestProMagicAttach(t *testing.T) {
-	t.Parallel()
-
-	tests := map[string]struct {
-
-		// Special cases
-		userCodeRefresh bool
-
-		// Failure flags
-		failInitiate    bool
-		failWait        bool
-		failAttach      bool
-		alreadyAttached bool
-
-		// Network error flags
-		networkErrorInitiate bool
-		networkErrorWait     bool
-	}{
-		// Success cases
-		"Successfully attach machine to pro subscription":             {},
-		"Successfully attach machine after, single user code refresh": {userCodeRefresh: true},
-
-		// Error cases
-		"Error when fail to call initiate": {failInitiate: true},
-		"Error when fail to call wait":     {failWait: true},
-
-		// Special return cases
-		"UnknownError code returned when fail to call attach":                  {failAttach: true},
-		"NetworkError code returned when network fails while waiting:":         {networkErrorWait: true},
-		"NetworkError code returned when network fails when calling initiate:": {networkErrorInitiate: true},
-		"AlreadyAttachedError code returned when already attached":             {alreadyAttached: true},
-	}
-
-	for name, tc := range tests {
-		t.Run(name, func(t *testing.T) {
-			tc := tc
-			t.Parallel()
-
-			// Prepare mocks
-			opts := []pro.Option{
-				pro.WithProExecutable(&mockProExecutable{failInitiate: tc.failInitiate, failWait: tc.failWait, failAttach: tc.failAttach, userCodeRefresh: tc.userCodeRefresh, networkErrorWait: tc.networkErrorWait, networkErrorInitiate: tc.networkErrorInitiate, alreadyAttached: tc.alreadyAttached}),
-			}
-
-			// Setup test
-			client := newProClient(t, opts...)
-			stream, err := client.ProMagicAttach(context.Background(), &emptypb.Empty{})
-			require.NoError(t, err, "calling ProMagicAttach should not fail")
-
-			// Collect all responses from the stream
-			var responses []string
-			for {
-				resp, err := stream.Recv()
-				if err != nil {
-					if !errors.Is(err, io.EOF) {
-						responses = append(responses, err.Error())
-					}
-					break
-				}
-				respBytes, err := json.Marshal(resp)
-				require.NoError(t, err, "marshaling response to JSON should not fail")
-				responses = append(responses, string(respBytes))
-			}
-			gotBytes, err := json.Marshal(responses)
-			require.NoError(t, err, "marshaling responses to JSON should not fail")
-
-			got := string(gotBytes)
-			want := testutils.LoadWithUpdateFromGolden(t, got)
-			require.Equal(t, want, got, "response from ProMagicAttach should match expected")
-		})
-	}
-}
-
-func TestProStatus(t *testing.T) {
-	t.Parallel()
-
-	tests := map[string]struct {
-		// Failure flags
-		failStatus bool
-
-		alreadyAttached bool
-	}{
-		"False returned when the system is not attached":   {},
-		"True returned when the system is aleady attached": {alreadyAttached: true},
-
-		"Error when fails to get a response from status call": {failStatus: true},
-	}
-
-	for name, tc := range tests {
-		t.Run(name, func(t *testing.T) {
-			tc := tc
-			t.Parallel()
-
-			// Prepare mocks
-			opts := []pro.Option{
-				pro.WithProExecutable(&mockProExecutable{failStatus: tc.failStatus, alreadyAttached: tc.alreadyAttached}),
-			}
-
-			// Setup test
-			client := newProClient(t, opts...)
-			resp, err := client.ProStatus(context.Background(), &emptypb.Empty{})
-
-			// Error cases
-			if tc.failStatus {
-				require.Error(t, err, "ProStatus should return an error")
-				return
-			}
-			require.NoError(t, err, "ProStatus should not return an error")
-
-			// Success cases
-			require.Equal(t, tc.alreadyAttached, resp.Value, "ProStatus returned an unexpected response")
-		})
-	}
-}
-
-func TestProAttach(t *testing.T) {
-	t.Parallel()
-
-	tests := map[string]struct {
-		// Failure flags
-		failAttach      bool
-		alreadyAttached bool
-	}{
-		// Success cases
-		"Successfully attach machine to pro subscription": {},
-
-		// Special return case
-		"AlreadyAttachedError returned when already attached": {alreadyAttached: true},
-		"UnknownError code returned when fail to call attach": {failAttach: true},
-	}
-
-	for name, tc := range tests {
-		t.Run(name, func(t *testing.T) {
-			tc := tc
-			t.Parallel()
-
-			// Prepare mocks
-			opts := []pro.Option{
-				pro.WithProExecutable(&mockProExecutable{failAttach: tc.failAttach, alreadyAttached: tc.alreadyAttached}),
-			}
-			client := newProClient(t, opts...)
-			resp, err := client.ProAttach(context.Background(), &pb.ProAttachRequest{Token: "mock_token"})
-			require.NoError(t, err, "ProAttach should not return an error")
-
-			got := resp.String()
-			want := testutils.LoadWithUpdateFromGolden(t, got)
-			require.Equal(t, want, got, "response from ProAttach should match expected")
-		})
-	}
-}
-
-// newProClient creates a new keyboard client for testing, with a temp unix socket.
-func newProClient(t *testing.T, opts ...pro.Option) pb.ProServiceClient {
-	t.Helper()
-
-	// socket path is limited in length.
-	tmpDir, err := os.MkdirTemp("", "hello-socket-dir")
-	require.NoError(t, err, "Setup: could not setup temporary socket dir path")
-	t.Cleanup(func() { _ = os.RemoveAll(tmpDir) })
-	socketPath := filepath.Join(tmpDir, "provd.sock")
-
-	lis, err := net.Listen("unix", socketPath)
-	require.NoError(t, err, "Setup: could not create unix socket")
-
-	service, err := pro.New(opts...)
-
-	if err != nil {
-		t.Fatalf("Setup: could not create user service: %v", err)
-	}
-
-	grpcServer := grpc.NewServer()
-	pb.RegisterProServiceServer(grpcServer, service)
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		_ = grpcServer.Serve(lis)
-	}()
-	t.Cleanup(func() {
-		grpcServer.Stop()
-		<-done
-	})
-
-	conn, err := grpc.Dial("unix://"+socketPath, grpc.WithTransportCredentials(insecure.NewCredentials()))
-	require.NoError(t, err, "Setup: Could not connect to GRPC server")
-	t.Cleanup(func() { _ = conn.Close() })
-
-	return pb.NewProServiceClient(conn)
-}
-
-func TestMain(m *testing.M) {
-	testutils.InstallUpdateFlag()
-	flag.Parse()
-
-	m.Run()
-}
-
-type mockProExecutable struct {
-	userCodeRefresh bool
-
-	failInitiate bool
-	failWait     bool
-	failAttach   bool
-	failStatus   bool
-
-	alreadyAttached bool
-
-	networkErrorWait     bool
-	networkErrorInitiate bool
-}
-
-func (m *mockProExecutable) Initiate(ctx context.Context) (*pro.ProAPIResponse, error) {
-	if m.failInitiate {
-		return nil, errors.New("mock initiate failed")
-	}
-	if m.networkErrorInitiate {
-		return &pro.ProAPIResponse{
-			Result: "failure",
-			Errors: pro.ProAPIErrors{
-				{
-					Code: "connectivity-error",
-				},
-			},
-		}, nil
-	}
-	return &pro.ProAPIResponse{
-		Result: "success",
-		Data: struct {
-			Attributes struct {
-				Expires       string  `json:"expires,omitempty"`
-				ExpiresIn     int     `json:"expires_in,omitempty"`
-				Token         string  `json:"token,omitempty"`
-				UserCode      string  `json:"user_code,omitempty"`
-				ContractID    *string `json:"contract_id,omitempty"`
-				ContractToken *string `json:"contract_token,omitempty"`
-			} `json:"attributes"`
-		}{
-			Attributes: struct {
-				Expires       string  `json:"expires,omitempty"`
-				ExpiresIn     int     `json:"expires_in,omitempty"`
-				Token         string  `json:"token,omitempty"`
-				UserCode      string  `json:"user_code,omitempty"`
-				ContractID    *string `json:"contract_id,omitempty"`
-				ContractToken *string `json:"contract_token,omitempty"`
-			}{
-				Token:    "mock_token",
-				UserCode: "mock_user_code",
-			},
-		},
-	}, nil
-}
-
-func (m *mockProExecutable) Wait(ctx context.Context, token string) (*pro.ProAPIResponse, error) {
-	if m.failWait {
-		return nil, errors.New("wait failed")
-	}
-	if m.userCodeRefresh {
-		m.userCodeRefresh = false
-		return &pro.ProAPIResponse{
-			Result: "failure",
-			Errors: pro.ProAPIErrors{
-				{
-					Code: "magic-attach-token-error",
-				},
-			},
-		}, nil
-	}
-	if m.networkErrorWait {
-		return &pro.ProAPIResponse{
-			Result: "failure",
-			Errors: pro.ProAPIErrors{
-				{
-					Code: "connectivity-error",
-				},
-			},
-		}, nil
-	}
-	return &pro.ProAPIResponse{
-		Result: "success",
-		Data: struct {
-			Attributes struct {
-				Expires       string  `json:"expires,omitempty"`
-				ExpiresIn     int     `json:"expires_in,omitempty"`
-				Token         string  `json:"token,omitempty"`
-				UserCode      string  `json:"user_code,omitempty"`
-				ContractID    *string `json:"contract_id,omitempty"`
-				ContractToken *string `json:"contract_token,omitempty"`
-			} `json:"attributes"`
-		}{
-			Attributes: struct {
-				Expires       string  `json:"expires,omitempty"`
-				ExpiresIn     int     `json:"expires_in,omitempty"`
-				Token         string  `json:"token,omitempty"`
-				UserCode      string  `json:"user_code,omitempty"`
-				ContractID    *string `json:"contract_id,omitempty"`
-				ContractToken *string `json:"contract_token,omitempty"`
-			}{
-				ContractToken: new(string),
-			},
-		},
-	}, nil
-}
-
-func (m *mockProExecutable) Attach(ctx context.Context, token string) error {
-	if m.failAttach {
-		return errors.New("attach failed")
-	}
-	if m.alreadyAttached {
-		return errors.New("failed to run pro attach")
-	}
-	return nil
-}
-
-func (m *mockProExecutable) Status(ctx context.Context) (*bool, error) {
-	if m.failStatus {
-		return nil, errors.New("failed status")
-	}
-	return &m.alreadyAttached, nil
-}

--- provd/internal/services/pro/testdata/TestProAttach/golden/alreadyattachederror_returned_when_already_attached ---
@@ -1 +0,0 @@
-type:ALREADY_ATTACHED
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProAttach/golden/unknownerror_code_returned_when_fail_to_call_attach ---
@@ -1 +0,0 @@
-type:UNKNOWN_ERROR
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/alreadyattachederror_code_returned_when_already_attached ---
@@ -1 +0,0 @@
-["{\"userCode\":\"mock_user_code\"}","{\"type\":6}"]
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/error_when_fail_to_call_initiate ---
@@ -1 +0,0 @@
-["rpc error: code = Internal desc = failed to initiate magic attach: mock initiate failed"]
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/error_when_fail_to_call_wait ---
@@ -1 +0,0 @@
-["{\"userCode\":\"mock_user_code\"}","rpc error: code = Internal desc = failed to wait on magic attach: wait failed"]
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/networkerror_code_returned_when_network_fails_when_calling_initiate ---
@@ -1 +0,0 @@
-["{\"type\":3}"]
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/networkerror_code_returned_when_network_fails_while_waiting ---
@@ -1 +0,0 @@
-["{\"userCode\":\"mock_user_code\"}","{\"type\":3}"]
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/successfully_attach_machine_after,_single_user_code_refresh ---
@@ -1 +0,0 @@
-["{\"userCode\":\"mock_user_code\"}","{\"type\":1,\"userCode\":\"mock_user_code\"}","{\"type\":2}"]
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/successfully_attach_machine_to_pro_subscription ---
@@ -1 +0,0 @@
-["{\"userCode\":\"mock_user_code\"}","{\"type\":2}"]
\ No newline at end of file

--- provd/internal/services/pro/testdata/TestProMagicAttach/golden/unknownerror_code_returned_when_fail_to_call_attach ---
@@ -1 +0,0 @@
-["{\"userCode\":\"mock_user_code\"}","{\"type\":5}"]
\ No newline at end of file

--- provd/internal/services/testdata/TestRegisterGRPCServices/golden ---
@@ -91,12 +91,6 @@ accessibility.AccessibilityService:
           isclientstream: false
           isserverstream: false
     metadata: protos/accessibility.proto
-chown.ChownService:
-    methods:
-        - name: ChownSettings
-          isclientstream: false
-          isserverstream: false
-    metadata: protos/chown.proto
 gdm.GdmService:
     methods:
         - name: LaunchDesktopSession
@@ -136,18 +130,6 @@ privacy.PrivacyService:
           isclientstream: false
           isserverstream: false
     metadata: protos/privacy.proto
-pro.ProService:
-    methods:
-        - name: ProAttach
-          isclientstream: false
-          isserverstream: false
-        - name: ProMagicAttach
-          isclientstream: false
-          isserverstream: true
-        - name: ProStatus
-          isclientstream: false
-          isserverstream: false
-    metadata: protos/pro.proto
 telemetry.TelemetryService:
     methods:
         - name: Collect

--- provd/internal/services/user/actions ---
@@ -1,4 +0,0 @@
-Accounts.FindUserByName(name: mock-user)
-Accounts.FindUserByName(name: mock-user)
-Accounts.FindUserByName(name: mock-user)
-Accounts.FindUserByName(name: mock-user)

--- provd/sprovd/sprovd.go ---
@@ -1,115 +0,0 @@
-// package main of sprovd wraps sudo pro attach for use by the gis user exclusively.
-package main
-
-import (
-	"context"
-	"flag"
-	"fmt"
-	"os"
-	"os/exec"
-	"os/user"
-	"regexp"
-	"syscall"
-)
-
-func main() {
-	// Parse flags
-	attachFlag := flag.Bool("attach", false, "Attach use case")
-	chownFlag := flag.Bool("chown", false, "Chown use case")
-	flag.Parse()
-
-	// Validate flags and arg length
-	if (*attachFlag && *chownFlag) || (!*attachFlag && !*chownFlag) {
-		fmt.Fprintln(os.Stderr, "Error: Either -attach or -chown must be specified, but not both")
-		os.Exit(2)
-	}
-	if len(flag.Args()) != 1 {
-		fmt.Fprintln(os.Stderr, "Usage: program -attach <token> | -chown <username>")
-		os.Exit(2)
-	}
-	arg := flag.Arg(0)
-
-	// Pro attach
-	if *attachFlag {
-		if !isValidToken(arg) {
-			fmt.Fprintln(os.Stderr, "Invalid token format")
-			os.Exit(1)
-		}
-
-		err := attach(arg)
-		if err != nil {
-			fmt.Fprintf(os.Stderr, "Error: %s\n", err)
-			os.Exit(1)
-		}
-		return
-	}
-
-	// chown /run/gnome-initial-setup
-	err := chown(arg)
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "Error: %s\n", err)
-		os.Exit(1)
-	}
-}
-
-func isValidToken(token string) bool {
-	pattern := `^[A-Za-z0-9]{29,32}$`
-	re := regexp.MustCompile(pattern)
-	return re.MatchString(token)
-}
-
-func attach(token string) error {
-	err := syscall.Setuid(os.Geteuid())
-	if err != nil {
-		return fmt.Errorf("setting uid: %w", err)
-	}
-
-	cmd := exec.CommandContext(context.Background(), "pro", "attach", token)
-	_, err = cmd.CombinedOutput()
-	if err != nil {
-		return fmt.Errorf("executing command: %w", err)
-	}
-	return nil
-}
-
-func isValidUsername(username string) bool {
-	pattern := `^[a-z_][a-z0-9_-]*$`
-	re := regexp.MustCompile(pattern)
-	return re.MatchString(username)
-}
-
-func chown(username string) error {
-	if !isValidUsername(username) {
-		return fmt.Errorf("invalid username")
-	}
-
-	_, err := user.Lookup(username)
-	if err != nil {
-		return fmt.Errorf("looking up user: %w", err)
-	}
-
-	// #nosec:G204 // We are in control of the username and validate we can find it on the system before executing.
-	cmd := exec.Command("chown", fmt.Sprintf("%s:provd", username), "/run/gnome-initial-setup")
-	_, err = cmd.CombinedOutput()
-	if err != nil {
-		return fmt.Errorf("executing chown command: %w", err)
-	}
-
-	cmd = exec.Command("chmod", "770", "/run/gnome-initial-setup")
-	_, err = cmd.CombinedOutput()
-	if err != nil {
-		return fmt.Errorf("executing chmod command: %w", err)
-	}
-	// Change ownership of specific subdirectories and files
-	subdirs := []string{".config", ".local"}
-	for _, subdir := range subdirs {
-		// #nosec:G204 // We are in control of the username and validate we can find it on the system before executing.
-		cmd = exec.Command("chown", "-R", fmt.Sprintf("%s:nogroup", username), fmt.Sprintf("/run/gnome-initial-setup/%s", subdir))
-		_, err = cmd.CombinedOutput()
-		if err != nil {
-			return fmt.Errorf("executing chown command for %s: %w", subdir, err)
-		}
-	}
-
-	return nil
-}

