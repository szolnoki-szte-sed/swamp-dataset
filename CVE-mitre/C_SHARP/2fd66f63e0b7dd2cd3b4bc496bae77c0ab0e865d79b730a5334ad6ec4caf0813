--- access-token-management/src/AccessTokenManagement/ClientCredentialsTokenManagementService.cs ---
@@ -2,37 +2,19 @@
 // Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
 
 using Microsoft.Extensions.Logging;
+using System.Threading;
 
 namespace Duende.AccessTokenManagement;
 
 /// <summary>
 /// Implements token management logic
 /// </summary>
-public class ClientCredentialsTokenManagementService : IClientCredentialsTokenManagementService
+public class ClientCredentialsTokenManagementService(
+    IClientCredentialsTokenEndpointService clientCredentialsTokenEndpointService,
+    IClientCredentialsTokenCache tokenCache,
+    ILogger<ClientCredentialsTokenManagementService> logger
+) : IClientCredentialsTokenManagementService
 {
-    private readonly ITokenRequestSynchronization _sync;
-    private readonly IClientCredentialsTokenEndpointService _clientCredentialsTokenEndpointService;
-    private readonly IClientCredentialsTokenCache _tokenCache;
-    private readonly ILogger<ClientCredentialsTokenManagementService> _logger;
-
-    /// <summary>
-    /// ctor
-    /// </summary>
-    /// <param name="sync"></param>
-    /// <param name="clientCredentialsTokenEndpointService"></param>
-    /// <param name="tokenCache"></param>
-    /// <param name="logger"></param>
-    public ClientCredentialsTokenManagementService(
-        ITokenRequestSynchronization sync,
-        IClientCredentialsTokenEndpointService clientCredentialsTokenEndpointService,
-        IClientCredentialsTokenCache tokenCache,
-        ILogger<ClientCredentialsTokenManagementService> logger)
-    {
-        _sync = sync;
-        _clientCredentialsTokenEndpointService = clientCredentialsTokenEndpointService;
-        _tokenCache = tokenCache;
-        _logger = logger;
-    }
 
     /// <inheritdoc/>
     public async Task<ClientCredentialsToken> GetAccessTokenAsync(
@@ -46,47 +28,34 @@ public async Task<ClientCredentialsToken> GetAccessTokenAsync(
         {
             try
             {
-                var item = await _tokenCache.GetAsync(clientName, parameters, cancellationToken).ConfigureAwait(false);
+                var item = await tokenCache.GetAsync(
+                    clientName: clientName, 
+                    requestParameters: parameters, 
+                    cancellationToken: cancellationToken).ConfigureAwait(false);
                 if (item != null)
                 {
                     return item;
                 }
             }
             catch (Exception e)
             {
-                _logger.LogError(e,
+                logger.LogError(e,
                     "Error trying to obtain token from cache for client {clientName}. Error = {error}. Will obtain new token.", 
                     clientName, e.Message);
             }
         }
 
-        return await _sync.SynchronizeAsync(clientName, async () =>
-        {
-            var token = await _clientCredentialsTokenEndpointService.RequestToken(clientName, parameters, cancellationToken).ConfigureAwait(false);
-            if (token.IsError)
-            {
-                _logger.LogError(
-                    "Error requesting access token for client {clientName}. Error = {error}.",
-                    clientName, token.Error);
-
-                return token;
-            }
-
-            try
-            {
-                await _tokenCache.SetAsync(clientName, token, parameters, cancellationToken).ConfigureAwait(false);
-            }
-            catch (Exception e)
-            {
-                _logger.LogError(e,
-                    "Error trying to set token in cache for client {clientName}. Error = {error}", 
-                    clientName, e.Message);
-            }
-
-            return token;
-        }).ConfigureAwait(false);
+        return await tokenCache.GetOrCreateAsync(
+            clientName: clientName, 
+            requestParameters: parameters, 
+            factory: InvokeGetAccessToken, 
+            cancellationToken: cancellationToken).ConfigureAwait(false);
     }
 
+    private async Task<ClientCredentialsToken> InvokeGetAccessToken(string clientName, TokenRequestParameters parameters, CancellationToken cancellationToken)
+    {
+        return await clientCredentialsTokenEndpointService.RequestToken(clientName, parameters, cancellationToken).ConfigureAwait(false);
+    }
 
     /// <inheritdoc/>
     public Task DeleteAccessTokenAsync(
@@ -95,6 +64,6 @@ public Task DeleteAccessTokenAsync(
         CancellationToken cancellationToken = default)
     {
         parameters ??= new TokenRequestParameters();
-        return _tokenCache.DeleteAsync(clientName, parameters, cancellationToken);
+        return tokenCache.DeleteAsync(clientName, parameters, cancellationToken);
     }
 }
\ No newline at end of file

--- access-token-management/src/AccessTokenManagement/DistributedClientCredentialsTokenCache.cs ---
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Duende Software. All rights reserved.
 // Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
 
+using System.Collections.Concurrent;
 using System.Text.Json;
 using Microsoft.Extensions.Caching.Distributed;
 using Microsoft.Extensions.Logging;
@@ -11,27 +12,19 @@ namespace Duende.AccessTokenManagement;
 /// <summary>
 /// Client access token cache using IDistributedCache
 /// </summary>
-public class DistributedClientCredentialsTokenCache : IClientCredentialsTokenCache
+public class DistributedClientCredentialsTokenCache(
+    IDistributedCache cache,
+    ITokenRequestSynchronization synchronization,
+    IOptions<ClientCredentialsTokenManagementOptions> options,
+    ILogger<DistributedClientCredentialsTokenCache> logger
+    )
+    : IClientCredentialsTokenCache
 {
-    private readonly IDistributedCache _cache;
-    private readonly ILogger<DistributedClientCredentialsTokenCache> _logger;
-    private readonly ClientCredentialsTokenManagementOptions _options;
+    private readonly IDistributedCache _cache = cache;
+    private readonly ITokenRequestSynchronization _synchronization = synchronization;
+    private readonly ILogger<DistributedClientCredentialsTokenCache> _logger = logger;
+    private readonly ClientCredentialsTokenManagementOptions _options = options.Value;
 
-    /// <summary>
-    /// ctor
-    /// </summary>
-    /// <param name="cache"></param>
-    /// <param name="options"></param>
-    /// <param name="logger"></param>
-    public DistributedClientCredentialsTokenCache(
-        IDistributedCache cache, 
-        IOptions<ClientCredentialsTokenManagementOptions> options, 
-        ILogger<DistributedClientCredentialsTokenCache> logger)
-    {
-        _cache = cache;
-        _logger = logger;
-        _options = options.Value;
-    }
         
     /// <inheritdoc/>
     public async Task SetAsync(
@@ -56,6 +49,43 @@ public async Task SetAsync(
         await _cache.SetStringAsync(cacheKey, data, entryOptions, token: cancellationToken).ConfigureAwait(false);
     }
 
+    public async Task<ClientCredentialsToken> GetOrCreateAsync(
+        string clientName, TokenRequestParameters requestParameters,
+        Func<string, TokenRequestParameters, CancellationToken, Task<ClientCredentialsToken>> factory,
+        CancellationToken cancellationToken = default)
+    {
+        ArgumentNullException.ThrowIfNull(clientName);
+
+        var cacheKey = GenerateCacheKey(_options, clientName, requestParameters);
+
+
+        return await _synchronization.SynchronizeAsync(cacheKey, async () =>
+        {
+            var token = await factory(clientName, requestParameters, cancellationToken).ConfigureAwait(false);
+            if (token.IsError)
+            {
+                _logger.LogError(
+                    "Error requesting access token for client {clientName}. Error = {error}.",
+                    clientName, token.Error);
+
+                return token;
+            }
+
+            try
+            {
+                await SetAsync(clientName, token, requestParameters, cancellationToken).ConfigureAwait(false);
+            }
+            catch (Exception e)
+            {
+                _logger.LogError(e,
+                    "Error trying to set token in cache for client {clientName}. Error = {error}",
+                    clientName, e.Message);
+            }
+
+            return token;
+        }).ConfigureAwait(false);
+    }
+
     /// <inheritdoc/>
     public async Task<ClientCredentialsToken?> GetAsync(
         string clientName, 

--- access-token-management/src/AccessTokenManagement/Interfaces/IClientCredentialsTokenCache.cs ---
@@ -22,6 +22,12 @@ Task SetAsync(
         TokenRequestParameters requestParameters,
         CancellationToken cancellationToken = default);
 
+    Task<ClientCredentialsToken> GetOrCreateAsync(
+        string clientName,
+        TokenRequestParameters requestParameters,
+        Func<string, TokenRequestParameters, CancellationToken, Task<ClientCredentialsToken>> factory,
+        CancellationToken cancellationToken = default);
+
     /// <summary>
     /// Retrieves a client access token from the cache
     /// </summary>

--- access-token-management/test/AccessTokenManagement.Tests/BackChannelClientTests.cs ---
@@ -2,6 +2,8 @@
 // Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
 
 using System.Net;
+using System.Net.Http.Json;
+using Duende.IdentityModel.Client;
 using Microsoft.Extensions.DependencyInjection;
 using RichardSzalay.MockHttp;
 
@@ -21,11 +23,11 @@ public async Task Get_access_token_uses_default_backchannel_client_from_factory(
                 client.TokenEndpoint = "https://as";
                 client.ClientId = "id";
             });
-        
+
         var mockHttp = new MockHttpMessageHandler();
         var request = mockHttp.When("https://as/*")
             .Respond(HttpStatusCode.NotFound);
-        
+
         services.AddHttpClient(ClientCredentialsTokenManagementDefaults.BackChannelHttpClientName)
             .ConfigurePrimaryHttpMessageHandler(() => mockHttp);
 
@@ -39,7 +41,7 @@ public async Task Get_access_token_uses_default_backchannel_client_from_factory(
         token.Error.ShouldBe("Not Found");
         mockHttp.GetMatchCount(request).ShouldBe(1);
     }
-    
+
     [Fact]
     public async Task Get_access_token_uses_custom_backchannel_client_from_factory()
     {
@@ -51,36 +53,228 @@ public async Task Get_access_token_uses_custom_backchannel_client_from_factory()
             {
                 client.TokenEndpoint = "https://as";
                 client.ClientId = "id";
-                
+
                 client.HttpClientName = "custom";
             });
-        
+
         var mockHttp = new MockHttpMessageHandler();
         var request = mockHttp.When("https://as/*")
             .Respond(HttpStatusCode.NotFound);
-        
+
         services.AddHttpClient("custom")
             .ConfigurePrimaryHttpMessageHandler(() => mockHttp);
 
         var provider = services.BuildServiceProvider();
         var sut = provider.GetRequiredService<IClientCredentialsTokenManagementService>();
 
         var token = await sut.GetAccessTokenAsync("test");
-        
+
         token.AccessToken.ShouldBeNull();
         token.AccessTokenType.ShouldBeNull();
         token.Error.ShouldBe("Not Found");
         mockHttp.GetMatchCount(request).ShouldBe(1);
     }
-    
+    [Fact]
+    public async Task Getting_a_token_with_different_scope_twice_sequentially_will_result_in_two_calls()
+    {
+        var services = new ServiceCollection();
+
+        services.AddDistributedMemoryCache();
+        services.AddClientCredentialsTokenManagement()
+            .AddClient("test", client =>
+            {
+                client.TokenEndpoint = "https://as";
+                client.ClientId = "id";
+
+                client.HttpClientName = "custom";
+            });
+
+        var mockHttp = new MockHttpMessageHandler();
+        var request = mockHttp.When("https://as/*")
+            .Respond(HttpStatusCode.OK, JsonContent.Create(new TokenResponse()
+            {
+
+            }));
+
+        services.AddHttpClient("custom")
+            .ConfigurePrimaryHttpMessageHandler(() => mockHttp);
+
+        var provider = services.BuildServiceProvider();
+        var sut = provider.GetRequiredService<IClientCredentialsTokenManagementService>();
+
+        ClientCredentialsToken token1 = null!;
+        token1 = await sut.GetAccessTokenAsync("test", new TokenRequestParameters()
+        {
+            ForceRenewal = false,
+            Scope = "scope1",
+
+        });
+
+
+        ClientCredentialsToken token2 = null!;
+
+        token2 = await sut.GetAccessTokenAsync("test", new TokenRequestParameters()
+        {
+            ForceRenewal = false,
+            Scope = "scope2",
+
+        });
+
+        mockHttp.GetMatchCount(request).ShouldBe(2);
+
+    }
+
+    [Fact]
+    public async Task Getting_a_token_with_different_scope_twice_concurrently_will_result_two_calls()
+    {
+        var services = new ServiceCollection();
+
+        services.AddDistributedMemoryCache();
+        services.AddClientCredentialsTokenManagement()
+            .AddClient("test", client =>
+            {
+                client.TokenEndpoint = "https://as";
+                client.ClientId = "id";
+
+                client.HttpClientName = "custom";
+            });
+
+        var mockHttp = new MockHttpMessageHandler();
+        var request = mockHttp.When("https://as/*")
+            .Respond(HttpStatusCode.OK, JsonContent.Create(new TokenResponse()
+            {
+
+            }));
+
+        services.AddHttpClient("custom")
+            .ConfigurePrimaryHttpMessageHandler(() => mockHttp);
+
+        mockHttp.AutoFlush = false;
+
+        var provider = services.BuildServiceProvider();
+        var sut = provider.GetRequiredService<IClientCredentialsTokenManagementService>();
+
+        ClientCredentialsToken token1 = null!;
+        var t1 = Task.Run(async () =>
+        {
+            token1 = await sut.GetAccessTokenAsync("test", new TokenRequestParameters()
+            {
+                ForceRenewal = false,
+                Scope = "scope1",
+
+            });
+        });
+        await Task.Delay(10);
+
+
+        ClientCredentialsToken token2 = null!;
+        var t2 = Task.Run(async () =>
+        {
+
+            token2 = await sut.GetAccessTokenAsync("test", new TokenRequestParameters()
+            {
+                ForceRenewal = false,
+                Scope = "scope2",
+
+            });
+        });
+
+
+        Console.WriteLine("before delay");
+
+        await Task.Delay(10);
+
+        mockHttp.Flush();
+        Console.WriteLine("flushed");
+        await t1;
+        await t2;
+
+        mockHttp.GetMatchCount(request).ShouldBe(2);
+
+    }
+
+    [Fact]
+    public async Task Getting_a_token_with_different_parameters_twice_concurrently_will_result_two_calls()
+    {
+        var services = new ServiceCollection();
+
+        services.AddDistributedMemoryCache();
+        services.AddClientCredentialsTokenManagement()
+            .AddClient("test", client =>
+            {
+                client.TokenEndpoint = "https://as";
+                client.ClientId = "id";
+
+                client.HttpClientName = "custom";
+            });
+
+        var mockHttp = new MockHttpMessageHandler();
+        var request = mockHttp.When("https://as/*")
+            .Respond(HttpStatusCode.OK, JsonContent.Create(new TokenResponse()
+            {
+
+            }));
+
+        services.AddHttpClient("custom")
+            .ConfigurePrimaryHttpMessageHandler(() => mockHttp);
+
+        mockHttp.AutoFlush = true;
+
+        var provider = services.BuildServiceProvider();
+        var sut = provider.GetRequiredService<IClientCredentialsTokenManagementService>();
+
+        ClientCredentialsToken token1 = null!;
+        var t1 = Task.Run(async () =>
+        {
+            token1 = await sut.GetAccessTokenAsync("test", new TokenRequestParameters()
+            {
+                ForceRenewal = false,
+                Parameters = new Parameters()
+                {
+                    {"tenant", "1"}
+                }
+
+            });
+        });
+        await Task.Delay(100);
+
+
+        ClientCredentialsToken token2 = null!;
+        var t2 = Task.Run(async () =>
+        {
+
+            token2 = await sut.GetAccessTokenAsync("test", new TokenRequestParameters()
+            {
+                ForceRenewal = false,
+                Parameters = new Parameters()
+                {
+                    {"tenant", "2"}
+                }
+
+            });
+        });
+
+
+        Console.WriteLine("before delay");
+
+        await Task.Delay(100);
+
+        mockHttp.Flush();
+        Console.WriteLine("flushed");
+        await t1;
+        await t2;
+
+        mockHttp.GetMatchCount(request).ShouldBe(1);
+
+    }
     [Fact]
     public async Task Get_access_token_uses_specific_http_client_instance()
     {
         var mockHttp = new MockHttpMessageHandler();
         var request = mockHttp.When("https://as/*")
             .Respond(HttpStatusCode.NotFound);
         var mockClient = mockHttp.ToHttpClient();
-        
+
         var services = new ServiceCollection();
 
         services.AddDistributedMemoryCache();
@@ -89,15 +283,15 @@ public async Task Get_access_token_uses_specific_http_client_instance()
             {
                 client.TokenEndpoint = "https://as";
                 client.ClientId = "id";
-                
+
                 client.HttpClient = mockClient;
             });
-     
+
         var provider = services.BuildServiceProvider();
         var sut = provider.GetRequiredService<IClientCredentialsTokenManagementService>();
 
         var token = await sut.GetAccessTokenAsync("test");
-        
+
         token.AccessToken.ShouldBeNull();
         token.AccessTokenType.ShouldBeNull();
         token.Error.ShouldBe("Not Found");

