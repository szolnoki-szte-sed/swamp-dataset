--- .github/workflows/build-push-deploy.yml ---
@@ -12,7 +12,7 @@ jobs:
     runs-on: ubuntu-latest
     strategy:
       matrix:
-        service: [backend, radar, ml]
+        service: [backend, realtime-evaluators, ml]
     steps:
       - name: Check out the private Ops repo
         uses: actions/checkout@v4

--- ops ---
@@ -1 +1 @@
-Subproject commit 0d1f1379e582bcc73eac7017b413471a069136eb
+Subproject commit eb7857ed8163e45c576cb5a2b3f6bc822ff82177

--- package-lock.json ---
@@ -5081,6 +5081,11 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/highlight-words-core": {
+      "version": "1.2.2",
+      "resolved": "https://registry.npmjs.org/highlight-words-core/-/highlight-words-core-1.2.2.tgz",
+      "integrity": "sha512-BXUKIkUuh6cmmxzi5OIbUJxrG8OAk2MqoL1DtO3Wo9D2faJg2ph5ntyuQeLqaHJmzER6H5tllCDA9ZnNe9BVGg=="
+    },
     "node_modules/http-assert": {
       "version": "1.5.0",
       "resolved": "https://registry.npmjs.org/http-assert/-/http-assert-1.5.0.tgz",
@@ -5874,6 +5879,11 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/memoize-one": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/memoize-one/-/memoize-one-4.0.3.tgz",
+      "integrity": "sha512-QmpUu4KqDmX0plH4u+tf0riMc1KHE1+lw95cMrLlXQAFOx/xnBtwhZ52XJxd9X2O6kwKBqX32kmhbhlobD0cuw=="
+    },
     "node_modules/merge-stream": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
@@ -7263,6 +7273,19 @@
         "react": "^18.3.1"
       }
     },
+    "node_modules/react-highlight-words": {
+      "version": "0.20.0",
+      "resolved": "https://registry.npmjs.org/react-highlight-words/-/react-highlight-words-0.20.0.tgz",
+      "integrity": "sha512-asCxy+jCehDVhusNmCBoxDf2mm1AJ//D+EzDx1m5K7EqsMBIHdZ5G4LdwbSEXqZq1Ros0G0UySWmAtntSph7XA==",
+      "dependencies": {
+        "highlight-words-core": "^1.2.0",
+        "memoize-one": "^4.0.0",
+        "prop-types": "^15.5.8"
+      },
+      "peerDependencies": {
+        "react": "^0.14.0 || ^15.0.0 || ^16.0.0-0 || ^17.0.0-0 || ^18.0.0-0"
+      }
+    },
     "node_modules/react-is": {
       "version": "16.13.1",
       "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
@@ -9423,6 +9446,7 @@
         "react": "^18.3.1",
         "react-confetti": "^6.1.0",
         "react-dom": "^18.3.1",
+        "react-highlight-words": "^0.20.0",
         "react-json-view-lite": "^1.2.1",
         "recharts": "^2.12.7",
         "shared": "*",

--- packages/backend/package.json ---
@@ -4,6 +4,7 @@
   "scripts": {
     "start": "npm run migrate:db && tsx src/index.ts",
     "start:radar": "tsx src/radar.ts",
+    "start:realtime-evaluators": "tsx src/realtime-evaluators.ts",
     "dev:realtime-evaluators": "tsx --env-file=.env --watch src/realtime-evaluators.ts",
     "migrate:db": "tsx src/migrate.ts",
     "build": "tsup src/index.ts --format esm",

--- packages/backend/src/api/v1/evaluator.ts ---
@@ -44,7 +44,6 @@ evaluators.get("/:id", async (ctx: Context) => {
 })
 
 evaluators.post("/", async (ctx: Context) => {
-  console.log(ctx.request.body)
   const requestBody = z.object({
     ownerId: z.string().optional(),
     name: z.string(),
@@ -53,7 +52,7 @@ evaluators.post("/", async (ctx: Context) => {
     type: z.string(),
     mode: z.string(),
     params: z.record(z.any()),
-    filters: z.string(),
+    filters: z.array(z.any()),
   })
 
   const { projectId } = ctx.state
@@ -63,7 +62,6 @@ evaluators.post("/", async (ctx: Context) => {
   const [insertedEvaluator] = await sql`
     insert into evaluator ${sql({
       ...evaluator,
-      filters: deserializeLogic(evaluator.filters),
       projectId,
     })} 
     returning *
@@ -79,7 +77,7 @@ evaluators.patch("/:id", async (ctx: Context) => {
     type: z.string(),
     mode: z.string(),
     params: z.record(z.any()),
-    filters: z.record(z.any()),
+    filters: z.array(z.any()),
   })
 
   const { projectId } = ctx.state

--- packages/backend/src/api/v1/projects/index.ts ---
@@ -164,40 +164,93 @@ projects.patch(
   async (ctx: Context) => {
     const bodySchema = z.object({
       name: z.string().optional(),
-      filters: z.array(z.any()).optional(),
-    });
-    const { name, filters } = bodySchema.parse(ctx.request.body);
-    const { projectId } = ctx.params;
-    const { userId } = ctx.state;
+    })
+    const { name } = bodySchema.parse(ctx.request.body)
+    const { projectId } = ctx.params
+    const { userId } = ctx.state
 
     // TODO: this should be in a middleware
-    const hasProjectAccess = await checkProjectAccess(projectId, userId);
+    const hasProjectAccess = await checkProjectAccess(projectId, userId)
     if (!hasProjectAccess) {
-      ctx.throw(401, "Unauthorized");
+      ctx.throw(401, "Unauthorized")
     }
 
-
     if (name) {
       await sql`
-        update project
-        set name = ${name}
-        where id = ${projectId}
-      `;
+        update project set name = ${name} where id = ${projectId}
+      `
     }
 
-    if (filters) {
-      await sql`
-        insert into ingestion_rule (project_id, type, filters)
-        values (${projectId}, 'filtering', ${filters})
-        on conflict (project_id, type)
-        do update set filters = excluded.filters
-      `;
+    ctx.status = 200
+    ctx.body = {}
+  },
+)
+
+projects.get(
+  "/:projectId/rules",
+  checkAccess("projects", "update"),
+  async (ctx: Context) => {
+    const { projectId } = ctx.params
+    const { userId } = ctx.state
+
+    const hasProjectAccess = await checkProjectAccess(projectId, userId)
+    if (!hasProjectAccess) {
+      ctx.throw(401, "Unauthorized")
     }
 
-    ctx.status = 200;
-    ctx.body = {};
-  }
-);
+    const rules =
+      await sql`select * from ingestion_rule where project_id = ${projectId}`
+
+    ctx.body = rules
+  },
+)
+
+projects.post(
+  "/:projectId/rules",
+  checkAccess("projects", "update"),
+  async (ctx: Context) => {
+    const bodySchema = z.object({
+      type: z.enum(["filtering", "masking"]).default("filtering"),
+      filters: z.array(z.any()).optional(),
+    })
+    const { type, filters } = bodySchema.parse(ctx.request.body)
+    const { projectId } = ctx.params
+    const { userId } = ctx.state
+
+    const hasProjectAccess = await checkProjectAccess(projectId, userId)
+    if (!hasProjectAccess) {
+      ctx.throw(401, "Unauthorized")
+    }
 
+    await sql`
+      insert into ingestion_rule (project_id, type, filters)
+      values (${projectId}, ${type}, ${filters})
+      on conflict (project_id, type)
+      do update set filters = excluded.filters
+    `
+
+    ctx.status = 200
+    ctx.body = {}
+  },
+)
+
+projects.delete(
+  "/:projectId/rules",
+  checkAccess("projects", "update"),
+  async (ctx: Context) => {
+    const { projectId } = ctx.params
+    const { userId } = ctx.state
+
+    const hasProjectAccess = await checkProjectAccess(projectId, userId)
+    if (!hasProjectAccess) {
+      ctx.throw(401, "Unauthorized")
+    }
+
+    await sql`delete from ingestion_rule where project_id = ${projectId}`
+
+    ctx.status = 200
+    ctx.body = {}
+  },
+)
 
 export default projects

--- packages/backend/src/api/v1/runs/index.ts ---
@@ -99,7 +99,6 @@ function formatRun(run: any) {
     status: run.status,
     siblingRunId: run.siblingRunId,
     params: processParams(run.params),
-
     metadata: run.metadata,
     user: run.externalUserId && {
       id: run.externalUserId,
@@ -110,81 +109,95 @@ function formatRun(run: any) {
     },
   }
 
-  // TODO: c'est horrible
-  // const evaluationResults = run.evaluationResults.find(
-  //   (result) => result.evaluatorType === "language",
-  // )
-  // const languageDetections = evaluationResults?.result
-  // if (
-  //   languageDetections?.input &&
-  //   languageDetections?.output &&
-  //   languageDetections?.error
-  // ) {
-  //   if (Array.isArray(formattedRun.input)) {
-  //     for (let i = 0; i < formattedRun.input.length; i++) {
-  //       if (
-  //         typeof formattedRun.input[i] === "object" &&
-  //         languageDetections.input
-  //       ) {
-  //         formattedRun.input[i].languageDetection = languageDetections.input[i]
-  //       }
-  //     }
-  //   } else if (formattedRun.input && typeof formattedRun.input === "object") {
-  //     formattedRun.input.languageDetection = languageDetections.input[0]
-  //   }
-
-  //   if (Array.isArray(formattedRun.output)) {
-  //     for (let i = 0; i < run.output.length; i++) {
-  //       if (typeof formattedRun.output[i] === "object") {
-  //         formattedRun.output[i].languageDetection =
-  //           languageDetections.output[i]
-  //       }
-  //     }
-  //   } else if (formattedRun.output && typeof formattedRun.input === "object") {
-  //     formattedRun.output.languageDetection = languageDetections.output[0]
-  //   }
-
-  //   if (formattedRun.error && typeof formattedRun.input === "object") {
-  //     formattedRun.error.languageDetection = languageDetections.error[0]
-  //   }
-  // }
-
-  // const sentimentEvaluationResults = run.evaluationResults.find(
-  //   (result) => result.evaluatorType === "sentiment",
-  // )
-  // const sentimentAnalyses = sentimentEvaluationResults?.result
-  // if (
-  //   sentimentAnalyses?.input &&
-  //   sentimentAnalyses?.output &&
-  //   sentimentAnalyses?.error
-  // ) {
-  //   if (Array.isArray(formattedRun.input)) {
-  //     for (let i = 0; i < formattedRun.input.length; i++) {
-  //       if (typeof formattedRun.input[i] === "object") {
-  //         formattedRun.input[i].sentimentAnalysis = sentimentAnalyses.input[i]
-  //       }
-  //     }
-  //   } else if (formattedRun.input && typeof formattedRun.input === "object") {
-  //     formattedRun.input.sentimentAnalysis = sentimentAnalyses.input[0]
-  //   }
-  //   if (Array.isArray(formattedRun.output)) {
-  //     for (let i = 0; i < run.output.length; i++) {
-  //       if (formattedRun.output && typeof formattedRun.output[i] === "object") {
-  //         formattedRun.output[i].sentimentAnalysis = sentimentAnalyses.output[i]
-  //       }
-  //     }
-  //   } else if (formattedRun.output && typeof formattedRun.input === "object") {
-  //     formattedRun.output.sentimentAnalysis = sentimentAnalyses.output[0]
-  //   }
-  //   if (formattedRun.error && typeof formattedRun.input === "object") {
-  //     formattedRun.error.sentimentAnalysis = sentimentAnalyses.error[0]
-  //   }
-  // }
-
-  // for (let evaluationResult of run.evaluationResults || []) {
-  //   formattedRun[`enrichment-${evaluationResult.evaluatorId}`] =
-  //     evaluationResult
-  // }
+  try {
+    // TODO: put in process input function
+    if (Array.isArray(formattedRun.input)) {
+      for (const message of formattedRun.input) {
+        message.enrichments = []
+      }
+    } else if (typeof formattedRun.input === "object") {
+      formattedRun.input.enrichments = []
+    }
+
+    if (Array.isArray(formattedRun.output)) {
+      for (const message of formattedRun.output) {
+        message.enrichments = []
+      }
+    } else if (formattedRun.output && typeof formattedRun.output === "object") {
+      formattedRun.output.enrichments = []
+    }
+
+    if (formattedRun.error && typeof formattedRun.error === "object") {
+      formattedRun.error.enrichments = []
+    }
+
+    for (const {
+      result,
+      evaluatorType,
+      evaluatorId,
+    } of run.evaluationResults) {
+      if (!result?.input || !result?.output || !result?.error) {
+        continue
+      }
+
+      if (Array.isArray(formattedRun.input)) {
+        for (let i = 0; i < formattedRun.input.length; i++) {
+          const message = formattedRun.input[i]
+          if (typeof message === "object") {
+            message.enrichments.push({
+              result: result.input[i],
+              type: evaluatorType,
+              id: evaluatorId,
+            })
+          }
+        }
+      } else if (formattedRun.input && typeof formattedRun.input === "object") {
+        formattedRun.input.enrichments.push({
+          result: result.input[0],
+          type: evaluatorType,
+          id: evaluatorId,
+        })
+      }
+
+      if (Array.isArray(formattedRun.output)) {
+        for (let i = 0; i < formattedRun.output.length; i++) {
+          const message = formattedRun.output[i]
+          if (typeof message === "object") {
+            message.enrichments.push({
+              result: result.output[i],
+              type: evaluatorType,
+              id: evaluatorId,
+            })
+          }
+        }
+      } else if (
+        formattedRun.output &&
+        typeof formattedRun.output === "object"
+      ) {
+        formattedRun.output.enrichments.push({
+          result: result.output[0],
+          type: evaluatorType,
+          id: evaluatorId,
+        })
+      }
+
+      if (formattedRun.error && typeof formattedRun.error === "object") {
+        formattedRun.error.enrichments.push({
+          result: result.error[0],
+          type: evaluatorType,
+          id: evaluatorId,
+        })
+      }
+    }
+  } catch (error) {
+    console.error(error)
+  }
+
+  // TODO: put in an array nammed enrichment instead
+  for (let evaluationResult of run.evaluationResults || []) {
+    formattedRun[`enrichment-${evaluationResult.evaluatorId}`] =
+      evaluationResult
+  }
   return formattedRun
 }
 
@@ -222,13 +235,26 @@ runs.get("/", async (ctx: Context) => {
       eu.last_seen as user_last_seen,
       eu.props as user_props,
       t.slug as template_slug,
-      rpfc.feedback as parent_feedback
+      rpfc.feedback as parent_feedback,
+      coalesce(array_agg(
+          jsonb_build_object(
+              'evaluatorName', e.name,
+              'evaluatorSlug', e.slug,
+              'evaluatorType', e.type,
+              'evaluatorId', e.id,
+              'result', er.result, 
+              'createdAt', er.created_at,
+              'updatedAt', er.updated_at
+          )
+      ) filter (where er.run_id is not null), '{}') as evaluation_results
     from
       public.run r
       left join external_user eu on r.external_user_id = eu.id
       left join run_parent_feedback_cache rpfc on r.id = rpfc.id
       left join template_version tv on r.template_version_id = tv.id
       left join template t on tv.template_id = t.id
+      left join evaluation_result_v2 er on r.id = er.run_id 
+      left join evaluator e on er.evaluator_id = e.id
     where
       r.project_id = ${projectId}
       ${parentRunCheck}
@@ -258,6 +284,8 @@ runs.get("/", async (ctx: Context) => {
       left join run_parent_feedback_cache rpfc on r.id = rpfc.id
       left join template_version tv on r.template_version_id = tv.id
       left join template t on tv.template_id = t.id
+      left join evaluation_result_v2 er on r.id = er.run_id 
+      left join evaluator e on er.evaluator_id = e.id
     where 
       r.project_id = ${projectId}
       ${parentRunCheck}
@@ -417,6 +445,9 @@ runs.get("/:id", async (ctx) => {
     from
         run r
         left join external_user eu on r.external_user_id = eu.id
+        left join run_parent_feedback_cache rpfc on r.id = rpfc.id
+        left join template_version tv on r.template_version_id = tv.id
+        left join template t on tv.template_id = t.id
         left join evaluation_result_v2 er on r.id = er.run_id 
         left join evaluator e on er.evaluator_id = e.id
     where

--- packages/backend/src/api/v1/views.ts ---
@@ -3,7 +3,7 @@ import sql from "@/src/utils/db"
 import { clearUndefined } from "@/src/utils/ingest"
 import Context from "@/src/utils/koa"
 import Router from "koa-router"
-import { CheckLogic } from "shared"
+
 import { z } from "zod"
 
 const views = new Router({
@@ -15,6 +15,7 @@ const ViewSchema = z.object({
   data: z.any(),
   columns: z.any(),
   icon: z.string().optional(),
+  type: z.enum(["llm", "thread", "trace"]),
 })
 
 views.get("/", checkAccess("logs", "list"), async (ctx: Context) => {
@@ -39,7 +40,7 @@ views.post("/", async (ctx: Context) => {
   const { projectId, userId } = ctx.state
 
   const validatedData = ViewSchema.parse(ctx.request.body)
-  const { name, data, columns, icon } = validatedData
+  const { name, data, columns, icon, type } = validatedData
 
   const [insertedCheck] = await sql`
     insert into view ${sql({
@@ -49,6 +50,7 @@ views.post("/", async (ctx: Context) => {
       data,
       columns,
       icon,
+      type,
     })}
     returning *
   `

--- packages/backend/src/checks/index.ts ---
@@ -182,17 +182,21 @@ export const CHECK_RUNNERS: CheckRunner[] = [
         sql`e.type = 'pii'`,
         or(
           types.map((type: string) => {
-            const jsonSql = [{ type }]
-            return sql`(
-              er.result::jsonb -> 'input' @> ${sql.json(jsonSql)}
-              OR
-              er.result::jsonb -> 'output' @> ${sql.json(jsonSql)}
+            return sql`EXISTS (
+              SELECT 1
+              FROM jsonb_array_elements(er.result -> 'input') as input_array
+              WHERE input_array @> ${sql.json([{ type }])}
+            ) OR EXISTS (
+              SELECT 1
+              FROM jsonb_array_elements(er.result -> 'output') as output_array
+              WHERE output_array @> ${sql.json([{ type }])}
             )`
           }),
         ),
       ])
     },
   },
+
   {
     id: "sentiment",
     sql: ({ sentiment }) => {
@@ -435,12 +439,14 @@ export const CHECK_RUNNERS: CheckRunner[] = [
     id: "tokens",
     // sum completion_tokens and prompt_tokens if field is total
     sql: ({ field, operator, tokens }) => {
+      if (!tokens) return sql`true`
+
       if (field === "total") {
         return sql`completion_tokens + prompt_tokens ${postgresOperators(
           operator,
         )} ${tokens}`
       } else {
-        return sql`${sql(field + "_tokens")} ${postgresOperators(
+        return sql`${sql(field + "_tokens")} ${postgresisOperators(
           operator,
         )} ${tokens}`
       }

--- packages/backend/src/evaluators/assertion.ts ---
@@ -0,0 +1,24 @@
+import { callML } from "@/src/utils/ml"
+import { Run } from "shared"
+
+interface Params {
+  statement: string
+  model: string
+}
+
+export async function evaluate(run: Run, params: Params) {
+  try {
+    const { statement, model } = params
+    console.log(statement)
+    const result = await callML("assertion", {
+      input: run.input,
+      output: run.output,
+      statement,
+      model,
+    })
+    console.log(result)
+    return result
+  } catch (error) {
+    console.error(error)
+  }
+}

--- packages/backend/src/evaluators/index.ts ---
@@ -1,6 +1,6 @@
 import * as pii from "./pii"
 import * as language from "./language"
-import * as assert from "./assert"
+import * as assertion from "./assertion"
 import * as tone from "./tone"
 import * as topics from "./topics"
 import * as toxicity from "./toxicity"
@@ -11,7 +11,7 @@ import * as replies from "./replies"
 const evaluators = {
   pii,
   language,
-  assert,
+  assertion,
   tone,
   topics,
   toxicity,

--- packages/backend/src/evaluators/language.ts ---
@@ -132,7 +132,6 @@ export async function evaluate(run: Run, params: unknown) {
   }
 
   // TODO: zod for languages, SHOLUD NOT INGEST IN DB IF NOT CORRECT FORMAT
-
   return languages
 }
 

--- packages/backend/src/evaluators/old-assert.ts ---
@@ -7,6 +7,7 @@ interface AssertParams {
   conditions: string[]
 }
 
+// Used in playground
 export async function evaluate(run: Run, params: AssertParams) {
   const { conditions } = params
 

--- packages/backend/src/evaluators/pii.ts ---
@@ -58,20 +58,23 @@ export async function evaluate(run: Run, params: Params) {
     error: errorPIIs,
   }
 
-
   // TODO: zod for languages, SHOLUD NOT INGEST IN DB IF NOT CORRECT FORMAT
   return PIIs
 }
 
-// TODO: type
 async function detectPIIs(
   texts: string[],
   entityTypes: string[] = [],
   customRegexes: string[] = [],
-  excludedEntities: string[] = []
+  excludedEntities: string[] = [],
 ): Promise<any> {
   try {
-    return callML("pii", { texts, entityTypes, customRegexes, excludedEntities })
+    return callML("pii", {
+      texts,
+      entityTypes,
+      customRegexes,
+      excludedEntities,
+    })
   } catch (error) {
     console.error(error)
     console.log(texts)

--- packages/backend/src/evaluators/topics.ts ---
@@ -1,38 +1,78 @@
 import { Run } from "shared"
-import openai from "@/src/utils/openai"
-import lunary from "lunary"
-import { lastMsg } from "../checks"
+import { callML } from "../utils/ml"
 
 interface TopicsParams {
   topics: string[]
 }
 
-export async function evaluate(run: Run, params: TopicsParams) {
-  const { topics } = params
+// TOOD: refacto this with all the other parsing function already in use
+function parseMessages(messages: unknown) {
+  if (!messages) {
+    return [""]
+  }
+  if (typeof messages === "string" && messages.length) {
+    return [messages]
+  }
 
-  const input = lastMsg(run.input) + `\n\n` + lastMsg(run.output)
+  if (messages === "__NOT_INGESTED__") {
+    return [""]
+  }
 
-  const topicsList = topics.join("\n")
+  if (Array.isArray(messages)) {
+    let contentArray = []
+    for (const message of messages) {
+      if (message?.type === "system") {
+        continue
+      }
+      let content = message.content || message.text
+      if (typeof content === "string" && content.length) {
+        contentArray.push(content)
+      } else {
+        contentArray.push(JSON.stringify(message))
+      }
+    }
+    return contentArray
+  }
 
-  const template = await lunary.renderTemplate("topics", {
-    input,
-    topics: topicsList,
-  })
+  if (typeof messages === "object") {
+    return [JSON.stringify(messages)]
+  }
 
-  const res = await openai.chat.completions.create(template)
+  return [""]
+}
 
-  const output = res.choices[0]?.message?.content
+export async function evaluate(run: Run, params: TopicsParams) {
+  const { topics } = params
+  const input = parseMessages(run.input)
+  const output = parseMessages(run.output)
+  const error = parseMessages(run.error)
 
-  if (!output) return []
+  const [inputTopics, outputTopics, errorTopics] = await Promise.all([
+    detectTopics(input, topics),
+    detectTopics(output, topics),
+    detectTopics(error, topics),
+  ])
 
-  // if the first line is 'None' as instructed in the prompt, return an empty array
-  if (output.split("\n")[0].toLowerCase().includes("none")) {
-    return []
+  const result = {
+    input: inputTopics,
+    output: outputTopics,
+    error: errorTopics,
   }
 
-  const results = output
-    .split("\n")
-    .map((line: string) => line.toLowerCase().replace(".", "").trim())
+  return result
+}
 
-  return results
+async function detectTopics(
+  texts: string[],
+  topics: string[] = [],
+): Promise<any> {
+  try {
+    return callML("topic", {
+      texts,
+      topics,
+    })
+  } catch (error) {
+    console.error(error)
+    console.log(texts)
+  }
 }

--- packages/backend/src/evaluators/toxicity.ts ---
@@ -1,17 +1,65 @@
+import { callML } from "@/src/utils/ml"
 import { Run } from "shared"
-import { callML } from "../utils/ml"
-import { lastMsg } from "../checks"
+
+// TOOD: refacto this with all the other parsing function already in use
+function parseMessages(messages: unknown) {
+  if (!messages) {
+    return [""]
+  }
+  if (typeof messages === "string" && messages.length) {
+    return [messages]
+  }
+
+  if (messages === "__NOT_INGESTED__") {
+    return [""]
+  }
+
+  if (Array.isArray(messages)) {
+    let contentArray = []
+    for (const message of messages) {
+      let content = message.content || message.text
+      if (typeof content === "string" && content.length) {
+        contentArray.push(content)
+      } else {
+        contentArray.push(JSON.stringify(message))
+      }
+    }
+    return contentArray
+  }
+
+  if (typeof messages === "object") {
+    return [JSON.stringify(messages)]
+  }
+
+  return [""]
+}
 
 export async function evaluate(run: Run) {
-  const text = lastMsg(run.input) + lastMsg(run.output)
-  if (!text.length) {
-    return null
+  const input = parseMessages(run.input)
+  const output = parseMessages(run.output)
+  const error = parseMessages(run.error)
+
+  const [inputToxicity, outputToxicity] = await Promise.all([
+    detectToxicity(input),
+    detectToxicity(output),
+  ])
+
+  const toxicity = {
+    input: inputToxicity,
+    output: outputToxicity,
+    error: error.map((e) => null),
   }
 
-  const toxicityLabels = await callML("toxicity", {
-    text,
-  })
+  // TODO: zod for languages, SHOLUD NOT INGEST IN DB IF NOT CORRECT FORMAT
+  return toxicity
+}
 
-  // format: ['toxicity', 'severe_toxicity', 'obscene', 'threat', 'insult' ...]
-  return toxicityLabels
+// TODO: type
+async function detectToxicity(texts: string[]): Promise<any> {
+  try {
+    return callML("toxicity", { texts })
+  } catch (error) {
+    console.error(error)
+    console.log(texts)
+  }
 }

--- packages/backend/src/jobs/realtime-evaluators.ts ---
@@ -6,7 +6,7 @@ import { RealtimeEvaluator } from "shared/evaluators"
 import { sleep } from "../utils/misc"
 import evaluators from "../evaluators"
 
-const RUNS_BATCH_SIZE = 30
+const RUNS_BATCH_SIZE = 10
 
 async function runEvaluator(evaluator: RealtimeEvaluator, run: Run) {
   try {
@@ -71,7 +71,7 @@ async function evaluatorJob() {
     from 
       evaluator e 
     where
-      mode = 'realtime'
+      mode = 'realtime' and project_id = 'befa0759-fbf1-4c5e-a51c-dd2dbe70f053'
     order by 
       random()
   `

--- packages/backend/src/utils/calcCost.ts ---
@@ -227,12 +227,20 @@ export async function calcRunCost(run: any) {
     let inputUnits = 0
     let outputUnits = 0
 
+    let inputCost = 0
+    let outputCost = 0
+
     if (mapping.unit === "TOKENS") {
       inputUnits = run.promptTokens || 0
       outputUnits = run.completionTokens || 0
+
+      inputCost = (inputCost * inputUnits) / 1_000_000
+      outputCost = (outputCost * outputUnits) / 1_000_000
     } else if (mapping.unit === "MILLISECONDS") {
       inputUnits = run.duration || 0
       outputUnits = 0
+
+      inputCost = inputCost * inputUnits
     } else if (mapping.unit === "CHARACTERS") {
       inputUnits =
         (typeof run.input === "string" ? run.input : JSON.stringify(run.input))
@@ -242,10 +250,10 @@ export async function calcRunCost(run: any) {
           ? run.output
           : JSON.stringify(run.output)
         ).length || 0
-    }
 
-    const inputCost = (mapping.inputCost * inputUnits) / 1_000_000
-    const outputCost = (mapping.outputCost * outputUnits) / 1_000_000
+      inputCost = (inputCost * inputUnits) / 1_000_000
+      outputCost = (outputCost * outputUnits) / 1_000_000
+    }
 
     const finalCost = Number((inputCost + outputCost).toFixed(5))
 

--- packages/backend/src/utils/ingest.ts ---
@@ -1,5 +1,3 @@
-// import { completeRunUsage } from "@/lib/countTokens"
-
 import { completeRunUsage } from "./countToken"
 import sql from "./db"
 

--- packages/db/0026.sql ---
@@ -0,0 +1 @@
+alter table view add column type text not null default 'llm';
\ No newline at end of file

--- packages/frontend/components/SmartViewer/HighlightPii.tsx ---
@@ -0,0 +1,51 @@
+import Highlighter from "react-highlight-words"
+import { useProject, useProjectRules } from "@/utils/dataHooks"
+import { Tooltip } from "@mantine/core"
+import { getPIIColor } from "@/utils/colors"
+import classes from "./index.module.css"
+
+export default function HighlightPii({
+  text,
+  piiDetection,
+}: {
+  text: string
+  piiDetection: { type: string; entity: string }[] // Contains the detected PII
+}) {
+  if (!piiDetection || piiDetection.length === 0) {
+    return <>{text}</>
+  }
+
+  const { maskingRule } = useProjectRules()
+
+  const HighlightBadge = ({ children }) => {
+    const piiType = piiDetection.find((pii) => pii.entity === children)?.type
+    const bgColor = `light-dark(var(--mantine-color-${getPIIColor(piiType)}-2), var(--mantine-color-${getPIIColor(piiType)}-9))`
+    const length = children.length
+    return (
+      <Tooltip
+        label={`${piiType} ${maskingRule ? "masked" : "detected"}`}
+        position="top"
+        withArrow
+      >
+        <span
+          style={{
+            backgroundColor: bgColor,
+          }}
+          className={`${classes.piiBadge} ${maskingRule ? classes.blurred : ""}`}
+        >
+          {maskingRule ? "x".repeat(length) : children}
+        </span>
+      </Tooltip>
+    )
+  }
+
+  return (
+    <Highlighter
+      highlightTag={HighlightBadge}
+      searchWords={piiDetection.map((pii) => pii.entity)}
+      autoEscape={true}
+      caseSensitive={true}
+      textToHighlight={text}
+    />
+  )
+}

--- packages/frontend/components/SmartViewer/Message.tsx ---
@@ -1,4 +1,4 @@
-import { getColorForRole } from "@/utils/colors"
+import { getColorForRole, getPIIColor } from "@/utils/colors"
 import {
   ActionIcon,
   Box,
@@ -29,11 +29,12 @@ import ProtectedText from "../blocks/ProtectedText"
 import { RenderJson } from "./RenderJson"
 import classes from "./index.module.css"
 
-import { useEffect } from "react"
+import { useEffect, useMemo } from "react"
 
 import { openConfirmModal } from "@mantine/modals"
 import { getFlagEmoji, getLanguageName } from "@/utils/format"
 import { renderSentimentEnrichment } from "@/utils/enrichment"
+import HighlightPii from "./HighlightPii"
 
 const ghostTextAreaStyles = {
   variant: "unstyled",
@@ -47,7 +48,14 @@ const ghostTextAreaStyles = {
   width: "100%",
 }
 
-function RenderFunction({ color, editable, onChange, compact, data }) {
+function RenderFunction({
+  color,
+  editable,
+  onChange,
+  compact,
+  data,
+  piiDetection,
+}) {
   return (
     <Code className={classes.textMessage}>
       <Text
@@ -90,18 +98,36 @@ function RenderFunction({ color, editable, onChange, compact, data }) {
         </>
       ) : (
         <pre style={{ marginBottom: 0 }}>
-          <RenderJson compact={compact} data={data?.arguments} />
+          <RenderJson
+            compact={compact}
+            data={data?.arguments}
+            piiDetection={piiDetection}
+          />
         </pre>
       )}
     </Code>
   )
 }
 
-function FunctionCallMessage({ data, color, compact }) {
-  return <RenderFunction color={color} data={data} compact={compact} />
+function FunctionCallMessage({ data, color, compact, piiDetection }) {
+  return (
+    <RenderFunction
+      color={color}
+      data={data}
+      compact={compact}
+      piiDetection={piiDetection}
+    />
+  )
 }
 
-function ToolCallsMessage({ toolCalls, editable, onChange, color, compact }) {
+function ToolCallsMessage({
+  toolCalls,
+  editable,
+  onChange,
+  color,
+  compact,
+  piiDetection,
+}) {
   return (
     <>
       {toolCalls.map((toolCall, index) => (
@@ -138,6 +164,7 @@ function ToolCallsMessage({ toolCalls, editable, onChange, color, compact }) {
           <RenderFunction
             key={index}
             editable={editable}
+            piiDetection={piiDetection}
             onChange={(newData) => {
               const newToolCalls = [...toolCalls]
               newToolCalls[index].function = newData
@@ -178,7 +205,13 @@ function ToolCallsMessage({ toolCalls, editable, onChange, color, compact }) {
   )
 }
 
-function TextMessage({ data, compact, onChange = () => {}, editable = false }) {
+function TextMessage({
+  data,
+  compact,
+  onChange = () => {},
+  piiDetection,
+  editable = false,
+}) {
   const text = data.content || data.text
 
   return (
@@ -192,10 +225,15 @@ function TextMessage({ data, compact, onChange = () => {}, editable = false }) {
             onChange={(e) => onChange({ ...data, content: e.target.value })}
             {...ghostTextAreaStyles}
           />
-        ) : compact ? (
-          text?.substring(0, 150) // truncate text to render less
         ) : (
-          text
+          <HighlightPii
+            text={
+              compact
+                ? text?.substring(0, 150) // truncate text to render less
+                : text
+            }
+            piiDetection={piiDetection}
+          />
         )}
       </ProtectedText>
     </Code>
@@ -265,7 +303,7 @@ function ChatMessageContent({
   data,
   color,
   compact,
-
+  piiDetection,
   onChange,
   editable,
 }) {
@@ -303,6 +341,7 @@ function ChatMessageContent({
         <TextMessage
           data={data}
           compact={compact}
+          piiDetection={piiDetection}
           onChange={onChange}
           editable={editable}
         />
@@ -322,6 +361,7 @@ function ChatMessageContent({
         <ToolCallsMessage
           toolCalls={data.toolCalls || data.tool_calls}
           color={color}
+          piiDetection={piiDetection}
           editable={editable}
           onChange={(toolCalls) => onChange({ ...data, toolCalls })}
           compact={compact}
@@ -397,8 +437,6 @@ export function ChatMessage({
 
   const color = getColorForRole(data?.role)
 
-  const codeBg = `light-dark(rgba(255,255,255,0.5), rgba(0,0,0,0.6))`
-
   // Add/remove the 'id' and 'name' props required on tool calls
   useEffect(() => {
     if (!data || !editable) return
@@ -434,6 +472,23 @@ export function ChatMessage({
     }
   }, [data, editable])
 
+  const sentiment = useMemo(() => {
+    return data?.enrichments?.find(
+      (enrichment) => enrichment.type === "sentiment",
+    )?.result
+  }, [data?.enrichments])
+
+  const piiDetection = useMemo(() => {
+    return data?.enrichments?.find((enrichment) => enrichment.type === "pii")
+      ?.result
+  }, [data?.enrichments])
+
+  const language = useMemo(() => {
+    return data?.enrichments?.find(
+      (enrichment) => enrichment.type === "language",
+    )?.result
+  }, [data?.enrichments])
+
   return (
     <Paper
       className={`${classes.paper} ${compact ? classes.compact : ""}`}
@@ -461,20 +516,21 @@ export function ChatMessage({
             </Text>
           )}
           <Group>
-            {/* {renderSentimentEnrichment(data?.sentimentAnalysis?.score)} */}
-            {/* {data?.languageDetection && (
+            {renderSentimentEnrichment(sentiment?.score)}
+            {language && (
               <Tooltip
-                label={`${getLanguageName(data.languageDetection.isoCode)} (${Number(data.languageDetection.confidence.toFixed(3))})`}
+                label={`${getLanguageName(language.isoCode)} (${Number(language.confidence.toFixed(3))})`}
               >
-                <Box>{getFlagEmoji(data.languageDetection.isoCode)}</Box>
+                <Box>{getFlagEmoji(language.isoCode)}</Box>
               </Tooltip>
-            )} */}
+            )}
           </Group>
         </Group>
       )}
       <ChatMessageContent
         data={data}
         color={color}
+        piiDetection={piiDetection}
         compact={compact}
         onChange={onChange}
         editable={editable}
@@ -493,7 +549,7 @@ const ROLE_ICONS = {
 }
 
 // Used for chat replays
-export function BubbleMessage({ role, content, extra }) {
+export function BubbleMessage({ role, content, extra, enrichments }) {
   const alignLeft = ["ai", "assistant", "bot", "tool", "system"].includes(role)
 
   const Icon = ROLE_ICONS[role || "assistant"]
@@ -508,6 +564,10 @@ export function BubbleMessage({ role, content, extra }) {
     }
   }
 
+  const piiDetection = useMemo(() => {
+    return enrichments?.find((enrichment) => enrichment.type === "pii")?.result
+  }, [enrichments])
+
   return (
     <>
       <Flex
@@ -528,7 +588,9 @@ export function BubbleMessage({ role, content, extra }) {
             withBorder
             maw={430}
           >
-            <span style={{ whiteSpace: "pre-line" }}>{content}</span>
+            <span style={{ whiteSpace: "pre-line" }}>
+              <HighlightPii text={content} piiDetection={piiDetection} />
+            </span>
           </Paper>
           {extra}
         </div>

--- packages/frontend/components/SmartViewer/MessageViewer.tsx ---
@@ -10,7 +10,7 @@ function getLastMessage(messages) {
   return messages
 }
 
-export default function MessageViewer({ data, compact }) {
+export default function MessageViewer({ data, compact, piiDetection }) {
   const obj = Array.isArray(data) ? data : [data]
 
   return compact ? (

--- packages/frontend/components/SmartViewer/RenderJson.tsx ---
@@ -3,8 +3,9 @@ import ProtectedText from "../blocks/ProtectedText"
 // import { JsonView, defaultStyles } from "react-json-view-lite"
 // import errorHandler from "@/utils/errors"
 import ErrorBoundary from "../blocks/ErrorBoundary"
+import HighlightPii from "./HighlightPii"
 
-export const Json = ({ data, compact }) => {
+export const Json = ({ data, compact, piiDetection }) => {
   if (!data) return null
 
   const parsed = useMemo(() => {
@@ -31,13 +32,18 @@ export const Json = ({ data, compact }) => {
 
   return (
     <ProtectedText>
-      {compact ? JSON.stringify(parsed) : JSON.stringify(parsed, null, 2)}
+      <HighlightPii
+        text={
+          compact ? JSON.stringify(parsed) : JSON.stringify(parsed, null, 2)
+        }
+        piiDetection={piiDetection}
+      />
     </ProtectedText>
   )
 }
 
-export const RenderJson = ({ data, compact }) => (
+export const RenderJson = ({ data, compact, piiDetection }) => (
   <ErrorBoundary>
-    <Json data={data} compact={compact} />
+    <Json data={data} compact={compact} piiDetection={piiDetection} />
   </ErrorBoundary>
 )

--- packages/frontend/components/SmartViewer/index.module.css ---
@@ -16,6 +16,19 @@
   padding: var(--mantine-spacing-xs) !important;
 }
 
+.piiBadge {
+  padding: 2px 4px;
+  border-radius: 4px;
+  /* background-color: var(--mantine-color-red-1); */
+  /* color: var(--mantine-color-red-9); */
+  font-size: 12px;
+  font-weight: 500;
+
+  &.blurred {
+    filter: blur(3px);
+  }
+}
+
 .paper {
   padding: 12px;
   padding-top: 8px;

--- packages/frontend/components/SmartViewer/index.tsx ---
@@ -15,6 +15,7 @@ import { ChatMessage } from "./Message"
 import MessageViewer from "./MessageViewer"
 import { RenderJson } from "./RenderJson"
 import classes from "./index.module.css"
+import HighlightPii from "./HighlightPii"
 
 const checkIsMessage = (obj) => {
   return (

--- packages/frontend/components/analytics/BarList.tsx ---
@@ -24,7 +24,7 @@ type BarListProps = {
 function BarList({ data, columns, filterZero = true }: BarListProps) {
   const dataColumns = columns.filter((col) => !col.bar && col.key)
   const main = dataColumns.find((col) => col.main) || dataColumns[0]
-  const mainTotal = data.reduce((acc, item) => acc + (item[main.key] || 0), 0)
+  const mainTotal = data?.reduce((acc, item) => acc + (item[main.key] || 0), 0)
   const scheme = useComputedColorScheme()
 
   if (!data) return <>No data.</>

--- packages/frontend/components/blocks/RunChat.tsx ---
@@ -42,6 +42,8 @@ function parseMessageFromRun(run) {
       ),
       id: run.id,
       feedback: run.feedback,
+      enrichments: msg.enrichments,
+
       ...(siblingRunId && { siblingRunId }),
       ...(OUTPUT_ROLES.includes(role) && {
         took:
@@ -71,18 +73,20 @@ function Message({
   const runId = router?.query?.selected
   const { updateFeedback } = useRun(msg.id)
   const { data: relatedRuns } = useProjectSWR(runId && `/runs/${runId}/related`)
+
   return (
     <>
       <BubbleMessage
         role={msg.role}
         content={msg.content}
+        enrichments={msg.enrichments}
         extra={
           <>
-            {!!msg.took && (
+            {/* {!!msg.took && (
               <Text c="dimmed" size="xs">
                 {msg.took}ms
               </Text>
-            )}
+            )} */}
 
             {msg.role !== "user" && (
               <Feedbacks

--- packages/frontend/components/checks/ChecksInputs.tsx ---
@@ -32,12 +32,12 @@ const CheckInputs = {
       </Flex>
     )
   },
-  text: ({ placeholder, width, value, onChange }) => {
+  text: ({ placeholder, width, value, minimal, onChange }) => {
     return (
       <TextInput
-        size="xs"
+        size={minimal ? "xs" : "sm"}
         w={width}
-        variant="unstyled"
+        variant={minimal ? "unstyled" : "default"}
         placeholder={placeholder}
         value={value}
         onChange={(e) => onChange(e.currentTarget.value)}

--- packages/frontend/components/checks/Picker.tsx ---
@@ -14,13 +14,15 @@ export function RenderCheckNode({
   node,
   disabled,
   checks,
+  showAndOr,
   setNode,
   removeNode,
 }: {
   minimal: boolean
   node: CheckLogic
   checks: Check[]
   disabled?: boolean
+  showAndOr?: boolean
   setNode: (node: CheckLogic | LogicData) => void
   removeNode: () => void
 }) {
@@ -35,6 +37,7 @@ export function RenderCheckNode({
         key={i}
         checks={checks}
         disabled={disabled}
+        showAndOr={showAndOr}
         node={n as CheckLogic}
         removeNode={() => {
           const newNode = [...node]
@@ -50,15 +53,16 @@ export function RenderCheckNode({
     )
 
     return node.map((n, i) => {
-      const showOperator = i !== 0 && i !== node.length - 1 && !minimal
+      const showOperator =
+        i !== 0 && i !== node.length - 1 && (!minimal || showAndOr)
       return showOperator ? (
         <Group key={i} gap={showOperator ? "xs" : 0}>
           {showCheckNode(n, i)}
           {showOperator && (
             <Select
               variant="unstyled"
               c="dimmed"
-              w={80}
+              w={65}
               size="xs"
               fw="bold"
               data={["AND", "OR"]}
@@ -68,6 +72,7 @@ export function RenderCheckNode({
                 if (val !== null) {
                   newNodeArray[0] = val
                 }
+
                 setNode(newNodeArray as CheckLogic)
               }}
             />
@@ -159,6 +164,7 @@ export default function CheckPicker({
   value = ["AND"],
   onChange = (data) => {},
   minimal = false,
+  showAndOr = false,
   restrictTo = (filter) => true,
   defaultOpened = false,
   disabled = false,
@@ -167,6 +173,7 @@ export default function CheckPicker({
   value?: CheckLogic
   onChange?: (data: CheckLogic) => void
   minimal?: boolean
+  showAndOr?: boolean
   restrictTo?: (filter: Check) => boolean
   defaultOpened?: boolean
   disabled?: boolean
@@ -215,6 +222,7 @@ export default function CheckPicker({
             minimal={minimal}
             node={value}
             disabled={disabled}
+            showAndOr={showAndOr}
             setNode={(newNode) => {
               onChange(newNode as CheckLogic)
             }}

--- packages/frontend/components/layout/Sidebar.tsx ---
@@ -61,7 +61,6 @@ import config from "@/utils/config"
 import { useViews } from "@/utils/dataHooks/views"
 import { useDisclosure, useFocusTrap } from "@mantine/hooks"
 import { getIconComponent } from "../blocks/IconPicker"
-import { set } from "date-fns"
 
 function NavbarLink({
   icon: Icon,
@@ -73,10 +72,17 @@ function NavbarLink({
 }) {
   const router = useRouter()
 
-  // For logs pages, we want to compare the full url because it contains the view ID and filters info
+  // For logs pages, we want to compare the view param to see if a view is selected
+
   const active = router.pathname.startsWith("/logs")
-    ? router.asPath.includes(`&view`)
-      ? router.asPath.includes(`&view=${link.split("view=")[1]}`)
+    ? router.asPath.includes(`view=`)
+      ? (() => {
+          const linkParams = new URLSearchParams(link.split("?")[1])
+          const viewParam = linkParams.get("view")
+          return viewParam
+            ? router.asPath.includes(`view=${viewParam}`)
+            : router.asPath.startsWith(link)
+        })()
       : router.asPath.startsWith(link)
     : router.pathname.startsWith(link)
 
@@ -250,7 +256,7 @@ export default function Sidebar() {
       return {
         label: v.name,
         icon: Icon,
-        link: `/logs?${serialized}&view=${v.id}`,
+        link: `/logs?view=${v.id}&filters=${serialized}&type=${v.type}`,
         resource: "logs",
       }
     })

--- packages/frontend/package.json ---
@@ -33,6 +33,7 @@
     "react": "^18.3.1",
     "react-confetti": "^6.1.0",
     "react-dom": "^18.3.1",
+    "react-highlight-words": "^0.20.0",
     "react-json-view-lite": "^1.2.1",
     "recharts": "^2.12.7",
     "shared": "*",
@@ -48,4 +49,4 @@
     "postcss-simple-vars": "^7.0.1",
     "typescript": "^5.5.3"
   }
-}
\ No newline at end of file
+}

--- packages/frontend/pages/evaluations/new.tsx ---
@@ -176,13 +176,6 @@ export default function NewEvaluation() {
     hasAccess(user.role, "evaluations", "create")
 
   return (
-    // <Paywall
-    //   plan="unlimited"
-    //   feature="Evaluations"
-    //   Icon={IconFlask2Filled}
-    //   description="Experiment with different models and parameters to find the best performing combinations."
-    //   list={FEATURE_LIST}
-    // >
     <>
       <ChecklistModal
         open={checklistModal}
@@ -428,6 +421,5 @@ export default function NewEvaluation() {
         </Stack>
       </Container>
     </>
-    // </Paywall>
   )
 }

--- packages/frontend/pages/evaluations/realtime/index.tsx ---
@@ -18,14 +18,17 @@ import {
   Title,
 } from "@mantine/core"
 import {
+  IconActivity,
   IconActivityHeartbeat,
   IconDotsVertical,
   IconEdit,
+  IconPencil,
   IconPlus,
   IconTrash,
 } from "@tabler/icons-react"
 import { NextSeo } from "next-seo"
 import { useRouter } from "next/router"
+import Empty from "@/components/layout/Empty"
 
 const FEATURE_LIST = [
   "Real-time LLM-based evaluations on production data",
@@ -42,78 +45,87 @@ export default function RealtimeEvaluators() {
     return <Loader />
   }
 
+  // return (
+  //   <Paywall
+  //     plan="enterprise"
+  //     feature="Realtime Evaluations"
+  //     Icon={IconActivityHeartbeat}
+  //     p="xl"
+  //     enabled={!org.license.realtimeEvalsEnabled}
+  //     description="Run evaluations on your production data in real-time."
+  //     list={FEATURE_LIST}
+  //   >
+  //     <Container>
+  //       <Stack>
+  //         <Group align="center" justify="space-between">
+  //           <Group align="center">
+  //             <Title>Realtime Evaluations</Title>
+  //             <Badge variant="teal" color="violet">
+  //               Enteprise
+  //             </Badge>
+  //           </Group>
+
+  //           <Group>
+  //             <Button variant="default" leftSection={<IconPlus size={12} />}>
+  //               New
+  //             </Button>
+  //           </Group>
+  //         </Group>
+
+  //         <Text size="lg" mb="md">
+  //           Run evaluations on your production data in real-time. They can be
+  //           used to enrich your data with additional information, such as
+  //           sentiment analysis, topic recognition, and more.
+  //         </Text>
+  //       </Stack>
+  //     </Container>
+  //   </Paywall>
+  // )
+
   return (
-    <Paywall
-      plan="enterprise"
-      feature="Realtime Evaluations"
+    <Empty
+      enable={!evaluators.length}
       Icon={IconActivityHeartbeat}
-      p="xl"
-      enabled={!org.license.realtimeEvalsEnabled}
-      description="Run evaluations on your production data in real-time."
-      list={FEATURE_LIST}
+      title="Real-time Evaluations"
+      buttonLabel="Create First Evaluator"
+      onClick={() => router.push("/evaluations/realtime/new")}
+      description="Run evaluations on your production data in real-time with task-optimized models."
     >
       <Container>
         <Stack>
           <Group align="center" justify="space-between">
             <Group align="center">
-              <Title>Realtime Evaluations</Title>
-              <Badge variant="teal" color="violet">
-                Enteprise
+              <Title>Evaluators</Title>
+              <Badge variant="light" color="blue">
+                Beta
               </Badge>
             </Group>
 
-            <Group>
-              <Button variant="default" leftSection={<IconPlus size={12} />}>
-                New
-              </Button>
-            </Group>
+            <Button
+              leftSection={<IconPlus size={12} />}
+              variant="default"
+              onClick={() => router.push("/evaluations/realtime/new")}
+            >
+              New Evaluator
+            </Button>
           </Group>
 
-          <Text size="lg" mb="md">
-            Run evaluations on your production data in real-time. They can be
-            used to enrich your data with additional information, such as
-            sentiment analysis, topic recognition, and more.
+          <Text size="xl" mb="md">
+            Run evaluations on your production data in real-time.
           </Text>
-        </Stack>
-      </Container>
-    </Paywall>
-  )
 
-  return (
-    <Container>
-      <Stack>
-        <Group align="center" justify="space-between">
-          <Group align="center">
-            <Title>Evaluators</Title>
-            <Badge variant="light" color="blue">
-              Beta
-            </Badge>
-          </Group>
-
-          <Button
-            leftSection={<IconPlus size={12} />}
-            variant="default"
-            onClick={() => router.push("/evaluations/realtime/new")}
-          >
-            New Evaluator
-          </Button>
-        </Group>
-
-        <Text size="xl" mb="md">
-          Run evaluations on your production data in real-time.
-        </Text>
-
-        <Stack gap="xl">
-          {evaluators?.map((evaluator) => (
-            <EvaluationCard
-              key={evaluator.id}
-              id={evaluator.id}
-              initialData={evaluator}
-            />
-          ))}
+          <Stack gap="xl">
+            {evaluators?.map((evaluator) => (
+              <EvaluationCard
+                key={evaluator.id}
+                id={evaluator.id}
+                initialData={evaluator}
+              />
+            ))}
+          </Stack>
         </Stack>
-      </Stack>
-    </Container>
+      </Container>
+    </Empty>
   )
 }
 
@@ -150,6 +162,15 @@ function EvaluationCard({ id, initialData }) {
           </Menu.Target>
 
           <Menu.Dropdown>
+            <Menu.Item
+              leftSection={
+                <IconPencil color="blue" width="15px" height="15px" />
+              }
+              disabled
+              onClick={() => {}}
+            >
+              Update
+            </Menu.Item>
             <Menu.Item
               leftSection={<IconTrash color="red" width="15px" height="15px" />}
               onClick={() => deleteEvaluator()}

--- packages/frontend/pages/evaluations/realtime/new.tsx ---
@@ -82,7 +82,6 @@ function EvaluatorCard({
 }
 
 export default function NewRealtimeEvaluator() {
-  return ""
   const router = useRouter()
 
   const { user } = useUser()
@@ -93,10 +92,13 @@ export default function NewRealtimeEvaluator() {
   const [params, setParams] = useState<any>()
   const [isBenchmark, setIsBenchmark] = useState<boolean>(false)
   const [filters, setFilters] = useState<CheckLogic>([
-    "AND",
+    "OR",
     { id: "type", params: { type: "llm" } },
+    { id: "type", params: { type: "chat" } },
   ])
+
   const serializedFilters = serializeLogic(filters)
+
   const { count: logCount } = useLogCount(serializedFilters)
 
   const evaluatorTypes = Object.values(EVALUATOR_TYPES)
@@ -142,7 +144,7 @@ export default function NewRealtimeEvaluator() {
       mode: "realtime",
       params: params.params,
       type,
-      filters: serializedFilters,
+      filters,
       ownerId: user.id,
     })
     router.push("/evaluations/realtime")
@@ -229,9 +231,12 @@ export default function NewRealtimeEvaluator() {
               <CheckPicker
                 minimal
                 value={filters}
+                showAndOr
                 onChange={setFilters}
                 restrictTo={(filter) =>
-                  ["tags", "type", "users", "metadata"].includes(filter.id)
+                  ["tags", "type", "users", "metadata", "date"].includes(
+                    filter.id,
+                  )
                 }
               />
             </Box>

--- packages/frontend/pages/logs/index.tsx ---
@@ -58,7 +58,11 @@ import {
   useRun,
 } from "@/utils/dataHooks"
 
-import { useDebouncedState, useDidUpdate } from "@mantine/hooks"
+import {
+  useDebouncedState,
+  useDidUpdate,
+  useShallowEffect,
+} from "@mantine/hooks"
 import { ProjectContext } from "@/utils/context"
 
 import { useRouter } from "next/router"
@@ -68,10 +72,11 @@ import RenamableField from "@/components/blocks/RenamableField"
 import { VisibilityState } from "@tanstack/react-table"
 import { notifications } from "@mantine/notifications"
 
-import IconPicker from "@/components/blocks/IconPicker"
 import { deserializeLogic, serializeLogic } from "shared"
 import { useEvaluators } from "@/utils/dataHooks/evaluators"
-// import { useTraceUpdate } from "@/utils/hooks"
+import IconPicker from "@/components/blocks/IconPicker"
+import { useTraceUpdate } from "@/utils/hooks"
+import { set } from "date-fns"
 
 export const defaultColumns = {
   llm: [
@@ -120,20 +125,18 @@ export const CHECKS_BY_TYPE = {
   llm: [
     "date",
     "models",
-    // "enrichment",
     "tags",
     "users",
-    // "languages",
-    // "entities",
+    "languages",
+    "entities",
     "templates",
-    // "sentiment",
+    "sentiment",
     "status",
     "metadata",
     "feedback",
     "cost",
     "duration",
     "tokens",
-    // "radar",
   ],
   trace: [
     "date",
@@ -143,15 +146,13 @@ export const CHECKS_BY_TYPE = {
     // "feedback",
     "duration",
     "metadata",
-    // "radar",
   ],
   thread: [
     "date",
     "tags",
     "users",
     // "feedback",
     "metadata",
-    // "radar",
   ],
 }
 
@@ -177,22 +178,6 @@ function editCheck(filters, id, params) {
   return newChecks
 }
 
-// function useTraceUpdate(props) {
-//   const prev = useRef(props)
-//   useEffect(() => {
-//     const changedProps = Object.entries(props).reduce((ps, [k, v]) => {
-//       if (prev.current[k] !== v) {
-//         ps[k] = [prev.current[k], v]
-//       }
-//       return ps
-//     }, {})
-//     if (Object.keys(changedProps).length > 0) {
-//       console.log("Changed props:", changedProps)
-//     }
-//     prev.current = props
-//   })
-// }
-
 const DEFAULT_CHECK = ["AND"]
 
 export default function Logs() {
@@ -217,7 +202,7 @@ export default function Logs() {
     "selected",
     parseAsString,
   )
-  const [type] = useQueryState<string>(
+  const [type, setType] = useQueryState<string>(
     "type",
     parseAsStringEnum(["llm", "trace", "thread"]).withDefault("llm"),
   )
@@ -229,7 +214,6 @@ export default function Logs() {
     clearOnDefault: true,
   })
 
-
   const {
     view,
     update: updateView,
@@ -238,10 +222,6 @@ export default function Logs() {
   } = useView(viewId)
 
   const serializedChecks = useMemo(() => {
-    // TODO: find a better way, because it will call two times /runs
-    if (view) {
-      return serializeLogic(view.data)
-    }
     const checksWithType = editCheck(checks, "type", { type })
     return serializeLogic(checksWithType)
   }, [checks, type, view])
@@ -286,47 +266,6 @@ export default function Logs() {
     }
   }, [selectedRun?.projectId])
 
-  // useEffect(() => {
-  //   let newChecks = [...checks]
-  //   let shouldUpdate = false
-
-  //   // Add type filter if not present
-  //   const typeFilter = newChecks.find((filter) => filter.id === "type")
-  //   if (!typeFilter) {
-  //     newChecks = newChecks[0] === "AND" ? newChecks : ["AND", ...newChecks]
-  //     newChecks = [
-  //       newChecks[0],
-  //       { id: "type", params: { type } },
-  //       ...newChecks.slice(1),
-  //     ]
-  //     shouldUpdate = true
-  //   }
-
-  //   // Update type filter
-  //   newChecks = editCheck(newChecks, "type", { type }).filter(
-  //     (f) =>
-  //       f === "AND" ||
-  //       CHECKS_BY_TYPE[type].includes(f.id) ||
-  //       ["type", "search"].includes(f.id),
-  //   )
-  //   shouldUpdate = true
-
-  //   // Update search filter
-  //   if (query !== null) {
-  //     newChecks = editCheck(
-  //       newChecks,
-  //       "search",
-  //       query.length ? { query } : null,
-  //     )
-  //     shouldUpdate = true
-  //   }
-
-  //   // Only update if changes were made
-  //   if (shouldUpdate) {
-  //     setChecks(newChecks)
-  //   }
-  // }, [type, query])
-
   useDidUpdate(() => {
     // Update search filter
     if (query !== null) {
@@ -349,6 +288,14 @@ export default function Logs() {
     }
   }, [view, type, allColumns])
 
+  useEffect(() => {
+    if (!view) return
+
+    setType(view.type)
+    setChecks(view.data)
+    setVisibleColumns(view.columns)
+  }, [view, viewId])
+
   const exportUrl = useMemo(
     () => `/runs?${serializedChecks}&projectId=${projectId}`,
     [serializedChecks, projectId],
@@ -376,15 +323,16 @@ export default function Logs() {
 
       const newView = await insertView({
         name: "New View",
-        data: editCheck(checks, "type", { type }),
+        type,
+        data: checks,
         columns: visibleColumns,
         icon,
       })
 
       setViewId(newView.id)
     } else {
       await updateView({
-        data: editCheck(checks, "type", { type }),
+        data: checks,
         columns: visibleColumns,
       })
 
@@ -418,6 +366,7 @@ export default function Logs() {
     if (view) {
       const newView = await insertView({
         name: `Copy of ${view.name}`,
+        type: view.type,
         data: view.data,
         columns: view.columns,
         icon: view.icon,
@@ -431,6 +380,7 @@ export default function Logs() {
       setViewId(newView.id)
     }
   }
+
   // Show button if column changed or view has changes, or it's not a view
   const showSaveView = useMemo(
     () =>
@@ -441,24 +391,6 @@ export default function Logs() {
     [columnsTouched, checks, view],
   )
 
-  // useTraceUpdate({
-  //   projectId,
-  //   serializedChecks,
-  //   type,
-  //   checks,
-  //   query,
-  //   viewId,
-  //   selectedRunId,
-  //   allColumns,
-  //   evaluators,
-  //   visibleColumns,
-  //   showSaveView,
-  //   logs,
-  //   loading,
-  //   validating,
-  //   runLoading,
-  // })
-
   return (
     <Empty
       enable={
@@ -532,7 +464,7 @@ export default function Logs() {
             <Group>
               {view && (
                 <Group gap="xs">
-                  {/* <IconPicker
+                  <IconPicker
                     size={26}
                     variant="light"
                     value={view.icon}
@@ -541,7 +473,7 @@ export default function Logs() {
                         icon,
                       })
                     }}
-                  /> */}
+                  />
                   <RenamableField
                     defaultValue={view.name}
                     onRename={(newName) => {
@@ -557,12 +489,12 @@ export default function Logs() {
                       </ActionIcon>
                     </Menu.Target>
                     <Menu.Dropdown>
-                      {/* <Menu.Item
+                      <Menu.Item
                         leftSection={<IconStackPop size={16} />}
                         onClick={() => duplicateView()}
                       >
                         Duplicate
-                      </Menu.Item> */}
+                      </Menu.Item>
                       <Menu.Item
                         color="red"
                         leftSection={<IconTrash size={16} />}
@@ -574,14 +506,13 @@ export default function Logs() {
                   </Menu>
                 </Group>
               )}
-              {!view && (
-                <CheckPicker
-                  minimal
-                  value={checks}
-                  onChange={setChecks}
-                  restrictTo={(f) => CHECKS_BY_TYPE[type].includes(f.id)}
-                />
-              )}
+
+              <CheckPicker
+                minimal
+                value={checks}
+                onChange={setChecks}
+                restrictTo={(f) => CHECKS_BY_TYPE[type].includes(f.id)}
+              />
             </Group>
             {!!showSaveView && (
               <Button

--- packages/frontend/pages/settings/index.tsx ---
@@ -7,8 +7,12 @@ import {
   Container,
   Flex,
   Group,
+  Loader,
   Popover,
+  SegmentedControl,
   Stack,
+  Switch,
+  Tabs,
   Text,
 } from "@mantine/core"
 import { NextSeo } from "next-seo"
@@ -22,12 +26,13 @@ import {
   IconPencil,
   IconFilter,
   IconRefreshAlert,
+  IconIdBadge,
 } from "@tabler/icons-react"
 import errorHandler from "@/utils/errors"
 import { fetcher } from "@/utils/fetcher"
 import { modals } from "@mantine/modals"
 import { notifications } from "@mantine/notifications"
-import { useOrg, useProject, useUser } from "@/utils/dataHooks"
+import { useOrg, useProject, useProjectRules, useUser } from "@/utils/dataHooks"
 import { useEffect, useState } from "react"
 import { CheckLogic, hasAccess } from "shared"
 import useSWR from "swr"
@@ -142,29 +147,143 @@ function Keys() {
   )
 }
 
-export default function AppAnalytics() {
+function SmartDataRule() {
   const { org } = useOrg()
-  const { update, project, setProjectId, drop, updateSmartDatafilters } =
-    useProject()
-  const [isLoading, setIsLoading] = useState(false)
-  const { user } = useUser()
+  const { addRule, addRulesLoading, deleteRule, maskingRule, filteringRule } =
+    useProjectRules()
+
   const [filters, setChecks] = useState<CheckLogic>(["AND"])
 
-  useEffect(() => {
-    if (project) {
-      setChecks(project.filters)
-    }
-  }, [project])
+  const smartDataFilterEnabled = config.IS_SELF_HOSTED
+    ? org.license.dataFilteringEnabled
+    : org.dataFilteringEnabled
+
+  return (
+    <SettingsCard
+      title={<>Smart Data Rules </>}
+      align="start"
+      paywallConfig={{
+        Icon: IconFilter,
+        feature: "Smart Data Rules",
+        p: 12,
+        plan: "enterprise",
+        list: [
+          "Filter out sensitive data",
+          "LLM-powered detection or custom regex patterns",
+        ],
+        enabled: !smartDataFilterEnabled,
+      }}
+    >
+      <Text>Filter out or hide sensitive data from your project.</Text>
+
+      <Tabs variant="outline" defaultValue="filtering" w={"100%"}>
+        <Tabs.List>
+          <Tabs.Tab value="filtering">Ingestion Filtering</Tabs.Tab>
+          <Tabs.Tab value="masking">PII Masking</Tabs.Tab>
+        </Tabs.List>
+
+        <Tabs.Panel value="filtering" p="md">
+          <Stack>
+            <Text>
+              Prevent data from being ingested into your project. Click below
+              button to add conditions and filter out data based on metadata,
+              users, tags, tools, or models. Input and output data from runs
+              matching will be redacted.
+            </Text>
+            <CheckPicker
+              minimal={true}
+              showAndOr={true}
+              value={filteringRule?.filters}
+              onChange={setChecks}
+              buttonText="Add filter"
+              restrictTo={(f) =>
+                ["metadata", "users", "tags", "tools", "models"].includes(f.id)
+              }
+            />
+
+            <Flex justify="flex-end">
+              <Button
+                loading={addRulesLoading}
+                style={{ float: "right" }}
+                onClick={() => {
+                  addRule({ type: "filtering", filters })
+                }}
+                variant="full"
+              >
+                Save
+              </Button>
+            </Flex>
+          </Stack>
+        </Tabs.Panel>
+
+        <Tabs.Panel value="masking" p="md">
+          <Stack>
+            <Text>
+              Masking allows you to hide sensitive data in the dashboard.
+            </Text>
+
+            <Alert w="100%" icon={<IconIdBadge />}>
+              Masking requires a PII Real-time Evaluator enabled.
+            </Alert>
+            {addRulesLoading && <Loader />}
+            <Switch
+              size="lg"
+              label="Enabled"
+              checked={!!maskingRule}
+              onChange={(e) => {
+                const { checked } = e.currentTarget
+
+                if (checked) {
+                  addRule({
+                    type: "masking",
+                  })
+                } else {
+                  deleteRule(maskingRule.id)
+                }
+              }}
+            />
+
+            {/* // <Flex justify="flex-end">
+            //   <Button
+            //     loading={addRulesLoading}
+            //     style={{ float: "right" }}
+            //     onClick={async () => {
+            //       addRule({
+            //         type: "masking",
+            //         filters: ["AND"],
+            //         enabled: true,
+            //       })
+            //     }}
+            //     variant="full"
+            //   >
+            //     Save
+            //   </Button>
+            // </Flex> */}
+          </Stack>
+        </Tabs.Panel>
+      </Tabs>
+    </SettingsCard>
+  )
+}
+
+export default function AppAnalytics() {
+  const { org } = useOrg()
+  const {
+    update,
+    project,
+    setProjectId,
+    drop,
+    addSmartDataRule,
+    smartDataRuleLoading,
+  } = useProject()
+
+  const { user } = useUser()
 
   // TODO: better route for project usage
   const { data: projectUsage, isLoading: projectUsageLoading } = useSWR(
     project?.id && org && `/orgs/${org.id}/usage?projectId=${project?.id}`,
   )
 
-  const smartDataFilterEnabled = config.IS_SELF_HOSTED
-    ? org.license.dataFilteringEnabled
-    : org.dataFilteringEnabled
-
   return (
     <Container className="unblockable">
       <NextSeo title="Settings" />
@@ -205,51 +324,7 @@ export default function AppAnalytics() {
           </Button>
         </SettingsCard>
 
-        <SettingsCard
-          title={<>Smart Data Filtering </>}
-          align="start"
-          paywallConfig={{
-            Icon: IconFilter,
-            feature: "Smart Data Filtering",
-            p: 12,
-            plan: "enterprise",
-            list: [
-              "Filter out sensitive data",
-              "LLM-powered detection or custom regex patterns",
-            ],
-            enabled: !smartDataFilterEnabled,
-          }}
-        >
-          <Text>
-            Smart Data Filters allows you to filter out sensitive data from your
-            project.
-          </Text>
-          <CheckPicker
-            defaultOpened={true}
-            minimal={true}
-            value={filters}
-            onChange={setChecks}
-            buttonText="Add filter"
-            restrictTo={(f) =>
-              ["metadata", "users", "tags", "tools", "models"].includes(f.id)
-            }
-          />
-
-          <Flex justify="flex-end" w="100%">
-            <Button
-              loading={isLoading}
-              style={{ float: "right" }}
-              onClick={() => {
-                setIsLoading(true)
-                updateSmartDatafilters(filters)
-                setTimeout(() => setIsLoading(false), 1000)
-              }}
-              variant="full"
-            >
-              Save
-            </Button>
-          </Flex>
-        </SettingsCard>
+        <SmartDataRule />
 
         {user && hasAccess(user.role, "projects", "delete") && (
           <SettingsCard title="Danger Zone" align="start">

--- packages/frontend/pages/settings/models.tsx ---
@@ -124,23 +124,31 @@ export default function Models() {
               data={[
                 { value: "TOKENS", label: "Tokens" },
                 { value: "CHARACTERS", label: "Characters" },
-                { value: "MILLISECONDS", label: "Milliseconds" },
+                // { value: "MILLISECONDS", label: "Duration" }, disabled for now
               ]}
               key={form.key("unit")}
               {...form.getInputProps("unit")}
             />
             <NumberInput
               label="Input Cost"
               placeholder="Enter input cost in USD"
-              description="Cost per million"
+              description={
+                form.values.unit === "MILLISECONDS"
+                  ? "Cost per second"
+                  : "Cost per million"
+              }
               required
               key={form.key("inputCost")}
               {...form.getInputProps("inputCost")}
             />
             <NumberInput
               label="Output Cost"
               placeholder="Enter output cost in USD"
-              description="Cost per million"
+              description={
+                form.values.unit === "MILLISECONDS"
+                  ? "Cost per second"
+                  : "Cost per million"
+              }
               disabled={form.values.unit === "MILLISECONDS"}
               required
               key={form.key("outputCost")}

--- packages/frontend/utils/colors.ts ---
@@ -18,6 +18,21 @@ export function getColorForRole(role) {
   return colorMap[role] || defaultColor
 }
 
+export function getPIIColor(type) {
+  const defaultColor = "gray"
+  const colorMap = {
+    person: "blue",
+    email: "orange",
+    phone: "yellow",
+    location: "green",
+    cc: "red",
+    ip: "purple",
+    regex: "gray",
+  }
+
+  return colorMap[type] || defaultColor
+}
+
 export function getColorForRunType(type) {
   const defaultColor = "gray"
 

--- packages/frontend/utils/dataHooks/evaluators.ts ---
@@ -1,3 +1,4 @@
+import { CheckLogic } from "shared"
 import { useProjectMutation, useProjectSWR } from "."
 import { fetcher } from "../fetcher"
 
@@ -9,7 +10,7 @@ interface CreateEvaluatorData {
   type: string
   mode: string
   params: Record<string, any>
-  filters?: string
+  filters?: CheckLogic
 }
 
 export function useEvaluators() {

--- packages/frontend/utils/dataHooks/index.ts ---
@@ -221,10 +221,6 @@ export function useProject() {
     mutate(newProjects)
   }
 
-  async function updateSmartDatafilters(filters: CheckLogic) {
-    return updateMutation({ filters })
-  }
-
   async function drop(): Promise<Boolean> {
     try {
       await dropMutation()
@@ -240,14 +236,59 @@ export function useProject() {
   return {
     project,
     update,
-    updateSmartDatafilters,
     drop,
     setProjectId,
     mutate,
     isLoading,
   }
 }
 
+export function useProjectRules() {
+  const { projectId } = useContext(ProjectContext)
+
+  const {
+    data: rules,
+    isLoading,
+    mutate,
+  } = useProjectSWR(projectId && `/projects/${projectId}/rules`)
+
+  const { trigger: addRule, isMutating: addRulesLoading } = useSWRMutation(
+    projectId && `/projects/${projectId}/rules`,
+    fetcher.post,
+    {
+      onSuccess() {
+        mutate()
+      },
+    },
+  )
+
+  const { trigger: deleteRule, isMutating: deleteRulesLoading } =
+    useSWRMutation(
+      projectId && `/projects/${projectId}/rules`,
+      fetcher.delete,
+      {
+        onSuccess() {
+          mutate()
+        },
+      },
+    )
+
+  const maskingRule = rules?.find((r) => r.type === "masking")
+  const filteringRule = rules?.find((r) => r.type === "filtering")
+
+  return {
+    rules,
+    isLoading,
+    mutate,
+    addRule,
+    addRulesLoading,
+    deleteRule,
+    deleteRulesLoading,
+    maskingRule,
+    filteringRule,
+  }
+}
+
 export function useTemplates() {
   const { data: templates, isLoading, mutate } = useProjectSWR(`/templates`)
 

--- packages/frontend/utils/dataHooks/views.ts ---
@@ -9,17 +9,10 @@ export function useViews() {
     fetcher.post,
   )
 
-  const { trigger: update, isMutating: isUpdating } = useProjectMutation(
-    `/views`,
-    fetcher.patch,
-  )
-
   return {
     views: data,
     insert,
     isInserting,
-    update,
-    isUpdating,
     mutate,
     loading: isLoading,
   }
@@ -40,7 +33,8 @@ export function useView(id: string | null, initialData?: any) {
     id && `/views/${id}`,
     fetcher.patch,
     {
-      onSuccess() {
+      onSuccess(data) {
+        mutate(data)
         mutateViews()
       },
     },

--- packages/frontend/utils/enrichment.tsx ---
@@ -1,4 +1,4 @@
-import { Badge, Box, Group, Popover, Stack, Text, Tooltip } from "@mantine/core"
+import { Badge, Box, Group, Popover, Text, Tooltip } from "@mantine/core"
 import { useDisclosure } from "@mantine/hooks"
 import {
   IconCheck,
@@ -7,19 +7,25 @@ import {
   IconMoodSmile,
   IconX,
 } from "@tabler/icons-react"
-import { EnrichmentData, EvaluatorType, LanguageDetectionResult } from "shared"
+import {
+  AssertionResult,
+  EnrichmentData,
+  EvaluatorType,
+  LanguageDetectionResult,
+} from "shared"
 import { getFlagEmoji } from "./format"
 import ErrorBoundary from "@/components/blocks/ErrorBoundary"
+import { useMemo } from "react"
+import { getPIIColor } from "./colors"
 
 export function renderEnrichment(data: EnrichmentData, type: EvaluatorType) {
-  return ""
   const renderers: Record<EvaluatorType, (data: any) => any> = {
     language: renderLanguageEnrichment,
     pii: renderPIIEnrichment,
     toxicity: renderToxicityEnrichment,
     topics: renderTopicsEnrichment,
     sentiment: renderSentimentEnrichment,
-    assert: renderAssertEnrichment,
+    assertion: renderAssertionEnrichment,
     tone: renderToneEnrichment,
     guidelines: renderGuidelinesEnrichment,
     replies: renderRepliesEnrichment,
@@ -60,24 +66,33 @@ function renderLanguageEnrichment(languageDetections: LanguageDetectionResult) {
     </Group>
   )
 }
+
 function renderPIIEnrichment(data: EnrichmentData) {
   const [opened, { close, open }] = useDisclosure(false)
 
-  const uniqueEntities = new Set()
-  Object.values(data).forEach((items) =>
-    items
-      .filter(Boolean)
-      .forEach((item) =>
-        item.forEach((subItem: { entity: string }) =>
-          uniqueEntities.add(subItem.entity),
-        ),
-      ),
-  )
+  const uniqueEntities: { entity: string; type: string }[] = useMemo(() => {
+    const entities = new Set()
+    const entityTypeArray = []
 
-  const piiCount = uniqueEntities.size
+    for (const items of Object.values(data)) {
+      for (const item of items.filter(Boolean)) {
+        for (const subItem of item) {
+          if (!entities.has(subItem.entity)) {
+            entities.add(subItem.entity)
+            entityTypeArray.push({ entity: subItem.entity, type: subItem.type })
+          }
+        }
+      }
+    }
+    return entityTypeArray
+  }, [data])
+
+  const piiCount = uniqueEntities.length
 
   if (piiCount === 0) return null
 
+  const size = piiCount > 20 ? 500 : 350
+
   return (
     <Popover
       width={200}
@@ -87,17 +102,31 @@ function renderPIIEnrichment(data: EnrichmentData) {
       opened={opened}
     >
       <Popover.Target>
-        <Badge onMouseEnter={open} onMouseLeave={close} color="blue">
+        <Badge
+          color="orange"
+          variant="light"
+          onMouseEnter={open}
+          onMouseLeave={close}
+        >
           {piiCount} PII
         </Badge>
       </Popover.Target>
-      <Popover.Dropdown style={{ pointerEvents: "none" }} w={300}>
-        <Group>
-          {Array.from(uniqueEntities).map((entity) => (
-            <Badge key={entity as string} variant="light">
+      <Popover.Dropdown w={size}>
+        <Group p="sm" px={4}>
+          {uniqueEntities.slice(0, 40).map(({ entity, type }) => (
+            <Badge
+              key={entity as string}
+              variant="light"
+              color={getPIIColor(type)}
+            >
               {entity as string}
             </Badge>
           ))}
+          {uniqueEntities.length > 40 && (
+            <Badge variant="light" color="gray" ml="auto">
+              and {uniqueEntities.length - 40} more
+            </Badge>
+          )}
         </Group>
       </Popover.Dropdown>
     </Popover>
@@ -111,34 +140,67 @@ function renderToxicityEnrichment(data: EnrichmentData) {
     return ""
   }
 
-  return (
-    <Popover
-      width={200}
-      position="bottom"
-      withArrow
-      shadow="md"
-      opened={opened}
-    >
-      <Popover.Target>
-        <Badge onMouseEnter={open} onMouseLeave={close} color="red">
-          Toxicity
-        </Badge>
-      </Popover.Target>
-      <Popover.Dropdown style={{ pointerEvents: "none" }} w="300">
-        <Text size="sm">
-          <strong>Toxic Comments:</strong>
-          <div>{data.join(", ")}</div>
-        </Text>
-      </Popover.Dropdown>
-    </Popover>
-  )
+  const toxicityCategories = [
+    ...new Set([...data.input, ...data.output]),
+  ].filter((category) => category)
+
+  if (toxicityCategories.length) {
+    return (
+      <Popover
+        width={200}
+        position="bottom"
+        withArrow
+        shadow="md"
+        opened={opened}
+      >
+        <Popover.Target>
+          <Badge onMouseEnter={open} onMouseLeave={close} color="red">
+            Toxicity
+          </Badge>
+        </Popover.Target>
+        <Popover.Dropdown style={{ pointerEvents: "none" }} w="300">
+          <Text size="sm">
+            <strong>Toxic Comments:</strong>
+            {/* <div>{data.join(", ")}</div> */}
+          </Text>
+        </Popover.Dropdown>
+      </Popover>
+    )
+  }
 }
 
 function renderTopicsEnrichment(data: EnrichmentData) {
   const [opened, { close, open }] = useDisclosure(false)
 
-  if (data.length === 0) {
-    return ""
+  const uniqueTopics = Array.from(
+    new Set(
+      Object.values(data)
+        .flat()
+        .flat()
+        .filter(Boolean)
+        .map((t) => t.topic),
+    ),
+  )
+
+  if (uniqueTopics.length === 0) {
+    return null
+  }
+
+  if (uniqueTopics.length < 4) {
+    return (
+      <Group gap={3}>
+        {uniqueTopics.map((topic, index) => (
+          <Badge
+            key={index}
+            onMouseEnter={open}
+            onMouseLeave={close}
+            variant="default"
+          >
+            {topic}
+          </Badge>
+        ))}
+      </Group>
+    )
   }
 
   return (
@@ -150,37 +212,14 @@ function renderTopicsEnrichment(data: EnrichmentData) {
       opened={opened}
     >
       <Popover.Target>
-        <div>
-          {data.length < 3 ? (
-            <Group gap={2}>
-              {data.map((topic, index) => (
-                <Badge
-                  key={index}
-                  onMouseEnter={open}
-                  onMouseLeave={close}
-                  color="blue"
-                  styles={{ label: { textTransform: "lowercase" } }}
-                >
-                  {topic}
-                </Badge>
-              ))}
-            </Group>
-          ) : (
-            <Badge
-              onMouseEnter={open}
-              onMouseLeave={close}
-              color="blue"
-              styles={{ label: { textTransform: "lowercase" } }}
-            >
-              {data.length + " topics"}
-            </Badge>
-          )}
-        </div>
+        <Badge onMouseEnter={open} onMouseLeave={close} variant="default">
+          {uniqueTopics.length + " topics"}
+        </Badge>
       </Popover.Target>
       <Popover.Dropdown style={{ pointerEvents: "none" }} w="300">
         <Text size="sm">
           <strong>Topics:</strong>
-          <div>{data.join(", ")}</div>
+          <div>{uniqueTopics.join(", ")}</div>
         </Text>
       </Popover.Dropdown>
     </Popover>
@@ -260,18 +299,20 @@ export function renderSentimentEnrichment(data?: EnrichmentData) {
   )
 }
 
-function renderAssertEnrichment(data: any) {
+function renderAssertionEnrichment(data: AssertionResult) {
+  if (typeof data !== "object" || typeof data.result !== "boolean") return null
+
   return (
     <Tooltip label={data.reason} disabled={!data.reason?.length}>
-      <IconX color={data.result ? "green" : "red"} />
+      {data.result ? <IconCheck color="green" /> : <IconX color="red" />}
     </Tooltip>
   )
 }
 
 function renderGuidelinesEnrichment(data: any) {
   return (
     <Tooltip label={data.reason} disabled={!data.reason?.length}>
-      <IconX color={data.result ? "green" : "red"} />
+      {data.result ? <IconCheck color="green" /> : <IconX color={"red"} />}
     </Tooltip>
   )
 }

--- packages/frontend/utils/evaluators.ts ---
@@ -1,17 +1,11 @@
 import {
   IconBadge,
   IconBiohazard,
-  IconBrain,
-  IconCheck,
   IconEyeCheck,
   IconIdBadge,
   IconLanguage,
-  IconMessage2,
-  IconMessages,
   IconMoodSmile,
   IconTextWrap,
-  IconTools,
-  IconUserCheck,
 } from "@tabler/icons-react"
 
 // TODO: typescript
@@ -76,7 +70,8 @@ const EVALUATOR_TYPES = {
       {
         type: "label",
         label: "Custom Regex Expressions",
-        description: "Add custom regex expressions to detect PII (optional).",
+        description:
+          "Add custom regex expressions to detect PII (optional). Use the PCRE Regex format.",
       },
       {
         type: "select",
@@ -141,8 +136,8 @@ const EVALUATOR_TYPES = {
       "Detects toxic, offensive, obscene, or hateful language. English only at the moment.",
     params: [],
   },
-  assert: {
-    id: "assert",
+  assertion: {
+    id: "assertion",
     name: "Assertion",
     icon: IconEyeCheck,
     color: "blue",
@@ -152,22 +147,40 @@ const EVALUATOR_TYPES = {
     params: [
       {
         type: "label",
-        label: "List of conditions",
+        label: "Condition",
+        description: "Enter the condition to check for.",
+      },
+      {
+        type: "text",
+        id: "statement",
+        defaultValue: "The answer is spoken like a pirate.",
+        placeholder: "Is spoken like a pirate",
+        width: 400,
+      },
+      {
+        type: "label",
+        label: "Model to use",
+        description:
+          "Select or type a custom model to use for evaluating. Note: you need to configure the proper API key for the model.",
       },
       {
         type: "select",
-        multiple: true,
+        id: "model",
+        defaultValue: "gpt-4o-mini",
         allowCustom: true,
-        id: "conditions",
-        options: ["answer is spoken like a pirate"],
-        defaultValue: ["answer is spoken like a pirate"],
-        placeholder: "Is spoken like a pirate",
-        width: 300,
+        options: [
+          "gpt-4o-mini",
+          "gpt-4o",
+          "claude-3-5-sonnet-20240620",
+          "claude-3-haiku-20240307",
+          "bedrock/meta.llama3-8b-instruct-v1:0",
+        ],
+        width: 200,
       },
     ],
   },
   topics: {
-    name: "Classify",
+    name: "Topics",
     id: "topics",
     icon: IconBadge,
     color: "violet",
@@ -192,159 +205,6 @@ const EVALUATOR_TYPES = {
       },
     ],
   },
-  tone: {
-    name: "Tone",
-    id: "tone",
-    icon: IconUserCheck,
-    color: "blue",
-    description: "Uses AI to detect the tone of the assistant's response.",
-    params: [
-      {
-        type: "label",
-        label: "Pick tone between",
-      },
-      {
-        type: "select",
-        multiple: true,
-        allowCustom: true,
-        id: "tone",
-        defaultValue: [
-          "Casual",
-          "Empathetic",
-          "Enthusiastic",
-          "Formal",
-          "Friendly",
-          "Helpful",
-          "Humorous",
-          "Professional",
-          "Rude",
-          "Sarcastic",
-          "Sincere",
-          "Unprofessional",
-        ],
-        options: [
-          "Casual",
-          "Empathetic",
-          "Enthusiastic",
-          "Formal",
-          "Friendly",
-          "Helpful",
-          "Humorous",
-          "Professional",
-          "Rude",
-          "Sarcastic",
-          "Sincere",
-          "Unprofessional",
-        ],
-        width: 230,
-      },
-    ],
-  },
-  factualness: {
-    id: "factualness",
-    name: "Factualness",
-    description:
-      "Checks how correct the LLM's response is compared to the ideal output (ues OpenAI's eval prompt).",
-    soon: true,
-    icon: IconCheck,
-    color: "green",
-    params: [
-      {
-        type: "label",
-        label: "The answer",
-      },
-      {
-        type: "select",
-        id: "choices",
-        defaultValue: ["b", "c"],
-        multiple: true,
-        width: 200,
-        searchable: true,
-        options: [
-          {
-            label: "is a subset of",
-            value: "a",
-          },
-          {
-            label: "is a superset of",
-            value: "b",
-          },
-          {
-            label: "contains all the same details as",
-            value: "c",
-          },
-          {
-            label: "disagrees with",
-            value: "d",
-          },
-          {
-            label: "differs (but doesn't matter from a factual standpoint)",
-            value: "e",
-          },
-        ],
-      },
-      {
-        type: "label",
-        label: "the ideal output",
-      },
-    ],
-  },
-  geval: {
-    id: "geval",
-    icon: IconBrain,
-    color: "blue",
-    name: "G-Eval",
-    soon: true,
-    uiType: "ai",
-    description:
-      "G-Eval is a framework that uses LLMs with chain-of-thoughts (CoT) to evaluate LLM outputs based on ANY custom criteria",
-
-    params: [
-      {
-        type: "label",
-        label: "G-Eval",
-      },
-      {
-        type: "text",
-        id: "criteria",
-        value:
-          "Determine if the actual output is factually correct based on the expected output.",
-        placeholder: "Enter the main criteria",
-        width: 400,
-      },
-      {
-        id: "steps",
-        type: "select",
-        multiple: true,
-        allowCustom: true,
-        // options: ["step 1", "step 2", "step 3"],
-        defaultValue: [
-          "Check whether the facts in 'actual output' contradicts any facts in 'expected output'",
-          "You should also heavily penalize omission of detail",
-          "Vague language, or contradicting OPINIONS, are OK",
-        ],
-        label: "Steps",
-        placeholder: "Enter thinking steps",
-        width: 300,
-      },
-    ],
-  },
-  guidelines: {
-    id: "guidelines",
-    name: "System Guidelines",
-    icon: IconTools,
-    color: "gray",
-    description: `Checks if the assistant answer matches guidelines set in the 'system' message.`,
-    params: [],
-  },
-  replies: {
-    id: "replies",
-    name: "Successful Answer",
-    icon: IconMessages,
-    color: "blue",
-    description: `Checks if the assistant successfully answers the question asked by the user.`,
-    params: [],
-  },
 }
 
 export default EVALUATOR_TYPES

--- packages/frontend/utils/hooks.ts ---
@@ -36,24 +36,24 @@ export function useGlobalShortcut(shortcuts: Shortcut[]) {
 }
 
 // This helps to debug why a component is re-rendered
-// export function useTraceUpdate(props: any) {
-//   const prev = useRef(props)
-//   useEffect(() => {
-//     const changedProps = Object.entries(props).reduce(
-//       (lookup, [key, value]) => {
-//         if (prev.current[key] !== value) {
-//           lookup[key] = [prev.current[key], value]
-//         }
-//         return lookup
-//       },
-//       {},
-//     )
-//     if (Object.keys(changedProps).length > 0) {
-//       console.log("Changed props:", changedProps)
-//     }
-//     prev.current = props
-//   })
-// }
+export function useTraceUpdate(props: any) {
+  const prev = useRef(props)
+  useEffect(() => {
+    const changedProps = Object.entries(props).reduce(
+      (lookup, [key, value]) => {
+        if (prev.current[key] !== value) {
+          lookup[key] = [prev.current[key], value]
+        }
+        return lookup
+      },
+      {},
+    )
+    if (Object.keys(changedProps).length > 0) {
+      console.log("Changed props:", changedProps)
+    }
+    prev.current = props
+  })
+}
 
 /**
  * Custom hook to manage project ID storage.

--- packages/ml/README.md ---
@@ -1,21 +0,0 @@
-Those Python scripts are used for some of the evaluators used in Radars and Evaluations.
-
-Communication is done using zerorpc between the JS backend and the Python scripts.
-
-## Create venv
-
-To create a virtual environment, run the following command:
-
-```bash
-python3 -m venv venv
-```
-
-## Active venv
-
-To activate the virtual environment, run the following command:
-
-```bash
-source venv/bin/activate
-
-pip install -r requirements.txt
-```

--- packages/ml/lang.py ---
@@ -1,21 +0,0 @@
-import time
-from lingua import Language, LanguageDetectorBuilder
-
-# Only include most popular languages for performance 
-languages = [Language.ENGLISH, Language.FRENCH, Language.GERMAN, Language.SPANISH, Language.ITALIAN, Language.DUTCH, Language.PORTUGUESE, Language.RUSSIAN, Language.SWEDISH, Language.ICELANDIC, Language.DANISH, Language.FINNISH, Language.HUNGARIAN, Language.CZECH, Language.SLOVAK, Language.POLISH, Language.ROMANIAN, Language.BULGARIAN, Language.GREEK, Language.TURKISH, Language.ARABIC, Language.HEBREW, Language.HINDI, Language.BENGALI, Language.TAMIL, Language.URDU, Language.PUNJABI, Language.THAI,Language.VIETNAMESE, Language.INDONESIAN, Language.MALAY,  Language.AFRIKAANS, Language.CHINESE, Language.JAPANESE, Language.KOREAN, Language.CZECH, Language.PERSIAN]
-
-# with_low_accuracy_mode() is faster and takes less memory but works as well with longer inputs
-detector = LanguageDetectorBuilder.from_languages(*languages).with_low_accuracy_mode().build()
-
-def detect_potential_langs(text):
-    langs = detector.compute_language_confidence_values(text)
-    # only keep those with a confidence value greater than 5%
-    langs = [lang for lang in langs if lang.value > 0.05]
-
-    # return only the language code
-    codes = [lang.language.iso_code_639_1.name for lang in langs]
-    return codes
-
-def detect_lang(text):
-    lang = detector.detect_language_of(text)
-    return lang.language.iso_code_639_1.name
\ No newline at end of file

--- packages/ml/main.py ---
@@ -1,42 +0,0 @@
-from flask import Flask, request, jsonify
-from lang import detect_lang
-from toxicity import detect_toxicity
-from pii import detect_pii
-import sys
-
-app = Flask(__name__)
-
-# Disable the Flask red warning server banner
-cli = sys.modules['flask.cli']
-cli.show_server_banner = lambda *x: None
-
-@app.route('/health', methods=['GET'])
-def health_check():
-    return jsonify({"status": "healthy"}), 200
-
-@app.route('/lang', methods=['POST'])
-def language_route():
-    text = request.json.get('text', '')
-    result = detect_lang(text)
-    return jsonify(result)
-
-@app.route('/toxicity', methods=['POST'])
-def toxicity_route():
-    texts = request.json.get('texts', [])
-    results = detect_toxicity(texts)
-    return jsonify(results)
-
-# TODO: index errors
-@app.route('/pii', methods=['POST'])
-def pii_route():
-    model_id = request.json.get('bert_model', None)
-    custom_patterns = request.json.get('custom_patterns', [])
-    texts = request.json.get('texts', [])
-    entities = request.json.get('entities', [])
-    results = detect_pii(texts, entities, model_id, custom_patterns)
-    return jsonify(results)
-
-if __name__ == '__main__':
-    app.run(host='localhost', port=4242)
-
-print("Python ML Server running on port 4242")

--- packages/ml/pii.py ---
@@ -1,130 +0,0 @@
-from transformers import AutoTokenizer, AutoModelForTokenClassification
-from transformers import pipeline
-import re
-
-models = {}
-tokenizers = {}
-
-default_patterns = [
-    {"label": "email", "expression": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"},
-    {"label": "phone", "expression": r"\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})"}, # US
-    {"label": "phone", "expression": r"((\+44\s?\d{4}|\(?0\d{4}\)?)\s?\d{3}\s?\d{3})|((\+44\s?\d{3}|\(?0\d{3}\)?)\s?\d{3}\s?\d{4})|((\+44\s?\d{2}|\(?0\d{2}\)?)\s?\d{4}\s?\d{4})"}, # UK
-    {"label": "phone", "expression": r"^(?:(?:\+|00)33[\s.-]{0,3}(?:\(0\)[\s.-]{0,3})?|0)[1-9](?:(?:[\s.-]?\d{2}){4}|\d{2}(?:[\s.-]?\d{3}){2})$"}, # FR
-    {"label": "phone", "expression": r"(\(?([\d \-\)\\+\/\(]+){6,}\)?([ .\-\/]?)([\d]+))"}, # Germany
-    {"label": "phone", "expression": r"(?:(?:\+|00)86)?1(?:(?:3[\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\d])|(?:9[189]))\d{8}"}, # China
-    {"label": "phone", "expression": r"((\+*)((0[ -]*)*|((91 )*))((\d{12})+|(\d{10})+))|\d{5}([- ]*)\d{6}"}, # India
-    {"label": "phone", "expression": r"(^\+[0-9]{2}|^\+[0-9]{2}\(0\)|^\(\+[0-9]{2}\)\(0\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\-\s]{10}$)"}, # Sweden & Dutch
-    {"label": "ssn", "expression": r"(?!666|000|9\d{2})\d{3}-(?!00)\d{2}-(?!0{4})\d{4}"}
-]
-
-def detect_regex(texts, type, custom_patterns=[]):
-
-    all_patterns = default_patterns + custom_patterns
-    all_patterns = [pattern for pattern in all_patterns if pattern["label"] == type]
-
-    results = []
-    for text in texts:
-        for pattern in all_patterns:
-            found_items = re.findall(pattern["expression"], text)
-            for item in found_items:
-                if isinstance(item, tuple):
-                    results.extend([i.strip() for i in item if i])
-                else:
-                    results.append(item.strip())
-
-    return list(set(results))
-
-def load_ner_model(model_id):
-    if model_id not in models:
-        print(f"Loading NER model: {model_id}")
-        tokenizers[model_id] = AutoTokenizer.from_pretrained(model_id)
-        models[model_id] = AutoModelForTokenClassification.from_pretrained(model_id)
-
-def parse_entity_type(entity):
-    lower_entity = entity.lower()
-
-    parts = lower_entity.split("-")
-    second_part = parts[1] if len(parts) > 1 else lower_entity
-
-    if second_part.startswith("per"):
-        return "person"
-    elif second_part.startswith("loc"):
-        return "location"
-    elif second_part.startswith("org"):
-        return "org"
-    elif second_part.startswith("misc"):
-        return "misc"
-    else:
-        return "misc"
-
-def get_ner_labels(model_id, texts, entities):
-    global tokenizer
-    global model
-
-    load_ner_model(model_id)
-
-    nlp = pipeline("ner", model=models[model_id], tokenizer=tokenizers[model_id])
-    
-    results = {}
-
-    for text in texts:
-        ner_results = nlp(text)
-        entities = {}
-
-        current_entity = {"name": "", "score": 0, "type": "", "word_count": 0}
-
-        for word in ner_results:
-
-            full_entity_type = word['entity']  # Get full entity type e.g., B-Person
-            entity_prefix = full_entity_type.split("-")[0]
-            entity_type = parse_entity_type(full_entity_type)
-
-            if entity_type not in entities:
-                entities[entity_type] = []
-
-            cleaned_word = word['word']
-
-            if "##" in cleaned_word:
-                current_entity['name'] += cleaned_word.replace("##", "")
-                current_entity['score'] += word['score']
-                current_entity['word_count'] += 1
-            elif entity_prefix == "I":
-                current_entity['name'] += " " + cleaned_word
-                current_entity['score'] += word['score']
-                current_entity['word_count'] += 1
-            else:
-                if current_entity['word_count'] > 0 and current_entity['score'] / current_entity['word_count'] > 0.5 and current_entity['type']:
-                    entities[current_entity['type']].append(current_entity['name'].strip())
-                current_entity = {"name": cleaned_word, "score": word['score'], "type": entity_type, "word_count": 1}
-
-        # Check for the last entity
-        if current_entity['word_count'] > 0 and current_entity['score'] / current_entity['word_count'] > 0.5 and current_entity['type']:
-            entities[current_entity['type']].append(current_entity['name'].strip())
-
-        for type in entities:
-            results.setdefault(type, []).extend(entities.get(type, []))
-
-    return results
-
-# Allow loading custom HF NER model
-# Default model supports officialy: ar, de, en, es, fr, it, lv, nl, pt, zh
-# But also works decntly for other languages
-def detect_pii(texts, entities, model_id, custom_patterns=[]):
-
-    if model_id == None:
-        model_id = "Davlan/bert-base-multilingual-cased-ner-hrl"
-
-    results = {}
-    ner_types = ["person", "location", "org", "misc"]
-
-    # if ner types in types, use get_ner_labels
-    if any(ner_type in entities for ner_type in ner_types):
-        results = get_ner_labels(model_id, texts, entities)
-
-    # for all other types, use regex
-    for type in entities:
-        if type not in ner_types:
-            results.setdefault(type, []).extend(detect_regex(texts, type, custom_patterns))
-
-    return results
-

--- packages/ml/requirements.txt ---
@@ -1,7 +0,0 @@
---extra-index-url https://download.pytorch.org/whl/cpu
-waitress==3.0.0
-detoxify==0.5.2
-Flask==3.0.2
-lingua-language-detector==2.0.2
-requests==2.31.0
-transformers==4.39.1
\ No newline at end of file

--- packages/ml/toxicity.py ---
@@ -1,35 +0,0 @@
-from lang import detect_potential_langs
-import time
-from detoxify import Detoxify
-
-import time
-
-start_time = time.time()
-multilingual_model = Detoxify('multilingual')
-print(f"Time to load multilingual model: {time.time() - start_time:.2f} seconds")
-
-start_time = time.time()
-original_model = Detoxify('original')
-print(f"Time to load original model: {time.time() - start_time:.2f} seconds")
-
-def get_predicted_labels(model, text):
-    results = model.predict(text)
-    labels = [label for label, value in results.items() if value > 0.5]
-    return labels
-
-multilingual_model_langs = ['IT', 'FR', 'ES', 'PT', 'RU', 'TR']
-
-def detect_toxicity(texts):
-    start_time = time.time()
-    results = set()
-    for text in texts:
-        langs = detect_potential_langs(text)
-        if 'EN' in langs:
-            results.update(get_predicted_labels(original_model, text))
-        if any(lang in multilingual_model_langs for lang in langs):
-            results.update(get_predicted_labels(multilingual_model, text))
-    results = list(results)
-    end_time = time.time()
-    elapsed_time_ms = (end_time - start_time) * 1000
-    print(f"Time taken: {elapsed_time_ms:.2f} ms")
-    return results

--- packages/shared/checks/index.ts ---
@@ -517,45 +517,46 @@ export const CHECKS: Check[] = [
       },
     ],
   },
-  // {
-  //   id: "tokens",
-  //   name: "Tokens",
-  //   disableInEvals: true,
-  //   uiType: "basic",
-  //   params: [
-  //     {
-  //       type: "select",
-  //       id: "field",
-  //       width: 100,
-  //       defaultValue: "total",
-  //       options: [
-  //         {
-  //           label: "Completion",
-  //           value: "completion",
-  //         },
-  //         {
-  //           label: "Prompt",
-  //           value: "prompt",
-  //         },
-  //         {
-  //           label: "Total",
-  //           value: "total",
-  //         },
-  //       ],
-  //     },
-  //     {
-  //       type: "label",
-  //       label: "Tokens",
-  //     },
-  //     NUMBER_PARAM,
-  //     {
-  //       type: "number",
-  //       min: 0,
-  //       id: "tokens",
-  //       width: 70,
-  //     },
-  //   ],
-  // },
+  {
+    id: "tokens",
+    name: "Tokens",
+    disableInEvals: true,
+    uiType: "basic",
+    params: [
+      {
+        type: "select",
+        id: "field",
+        width: 100,
+        defaultValue: "total",
+        options: [
+          {
+            label: "Completion",
+            value: "completion",
+          },
+          {
+            label: "Prompt",
+            value: "prompt",
+          },
+          {
+            label: "Total",
+            value: "total",
+          },
+        ],
+      },
+      {
+        type: "label",
+        label: "Tokens",
+      },
+      NUMBER_PARAM,
+      {
+        type: "number",
+        min: 0,
+        defaultValue: 100,
+        id: "tokens",
+        width: 70,
+      },
+    ],
+  },
   {
     id: "languages",
     name: "Language",

--- packages/shared/checks/serialize.ts ---
@@ -64,23 +64,20 @@ export function serializeLogic(logic: CheckLogic): string {
       const all = param.map(serializeParamValue)
       return all.filter(Boolean).join(".")
     } else if (param && typeof param === "object" && param.params) {
-      const data = Object.entries(param.params)
-        .sort(([keyA], [keyB]) => {
-          if (keyA === "operator") {
-            return -1
-          }
-          if (keyB === "operator") {
-            return 1
-          }
-        })
-        .map(([key, value]) => {
-          const filterParam = CHECKS.find(
-            (filter) => filter.id === param.id,
-          )?.params.find((param) => (param as CheckParam).id === key)
+      const filter = CHECKS.find((filter) => filter.id === param.id)
+      if (!filter) {
+        return ""
+      }
 
-          if (!filterParam || filterParam.type === "label") {
-            return ""
-          }
+      const filterParams = filter.params.filter(
+        (param) => param.type !== "label",
+      ) as CheckParam[]
+
+      // we look at the original filter params keys to make sure they are oredered correctly
+      const data = filterParams
+        .map((filterParam) => {
+          const value =
+            filterParam.id in param.params ? param.params[filterParam.id] : ""
 
           const serialized = paramSerializer(filterParam, value)
           return serialized !== undefined ? serialized : ""
@@ -93,7 +90,14 @@ export function serializeLogic(logic: CheckLogic): string {
     return ""
   }
 
-  return logic.map(serializeParamValue).filter(Boolean).join("&")
+  let finalResult = logic.map(serializeParamValue).filter(Boolean).join("&")
+
+  // Check if the first logic item is 'OR' and prepend it to the serialized string
+  if (logic[0] === "OR") {
+    finalResult = "OR&" + finalResult
+  }
+
+  return finalResult
 }
 
 export function deserializeLogic(
@@ -144,6 +148,12 @@ export function deserializeLogic(
     }
   }
 
-  const logic = logicString.split("&").map(deserializeParam).filter(Boolean)
-  return ["AND", ...logic] as CheckLogic
+  const isOrLogic = logicString.startsWith("OR&")
+  const logic = logicString
+    .replace(/^OR&/, "")
+    .split("&")
+    .map(deserializeParam)
+    .filter(Boolean)
+
+  return [isOrLogic ? "OR" : "AND", ...logic] as CheckLogic
 }

--- packages/shared/evaluators/index.ts ---
@@ -4,7 +4,7 @@ export type EvaluatorType =
   | "sentiment"
   | "language"
   | "toxicity"
-  | "assert"
+  | "assertion"
   | "topics"
   | "tone"
   | "factualness"
@@ -54,3 +54,8 @@ export type LanguageDetectionResult = EnrichmentData & {
   output: Array<BaseLanguageDetectionResult | null>
   error: Array<BaseLanguageDetectionResult | null>
 }
+
+export type AssertionResult = {
+  result: boolean
+  reason: string
+}

