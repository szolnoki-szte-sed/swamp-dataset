--- src/cpp/rtps/messages/MessageReceiver.cpp ---
@@ -843,8 +843,20 @@ bool MessageReceiver::proc_Submsg_Data(
     if (dataFlag || keyFlag)
     {
         uint32_t payload_size;
-        payload_size = smh->submessageLength -
-                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);
+        const uint32_t submsg_no_payload_size =
+                RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize;
+
+        // Prevent integer overflow of variable payload_size
+        if (smh->submessageLength < submsg_no_payload_size)
+        {
+            EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING "Serialized Payload avoided overflow "
+                    "(" << smh->submessageLength << "/" << submsg_no_payload_size << ")");
+            ch.serializedPayload.data = nullptr;
+            ch.inline_qos.data = nullptr;
+            return false;
+        }
+
+        payload_size = smh->submessageLength - submsg_no_payload_size;
 
         if (dataFlag)
         {

--- test/blackbox/CMakeLists.txt ---
@@ -56,28 +56,31 @@ endif()
 
 file(GLOB RTPS_BLACKBOXTESTS_TEST_SOURCE "common/RTPSBlackboxTests*.cpp")
 set(RTPS_BLACKBOXTESTS_SOURCE ${RTPS_BLACKBOXTESTS_TEST_SOURCE}
+    types/Data1mb.cxx
+    types/Data1mbPubSubTypes.cxx
+    types/Data1mbv1.cxx
+    types/Data64kb.cxx
+    types/Data64kbPubSubTypes.cxx
+    types/Data64kbv1.cxx
+    types/FixedSized.cxx
+    types/FixedSizedPubSubTypes.cxx
+    types/FixedSizedv1.cxx
     types/HelloWorld.cxx
-    types/HelloWorldv1.cxx
     types/HelloWorldPubSubTypes.cxx
     types/HelloWorldTypeObject.cxx
+    types/HelloWorldv1.cxx
+    types/KeyedData1mb.cxx
+    types/KeyedData1mbPubSubTypes.cxx
+    types/KeyedData1mbv1.cxx
     types/KeyedHelloWorld.cxx
-    types/KeyedHelloWorldv1.cxx
     types/KeyedHelloWorldPubSubTypes.cxx
+    types/KeyedHelloWorldv1.cxx
     types/StringTest.cxx
-    types/StringTestv1.cxx
     types/StringTestPubSubTypes.cxx
-    types/Data64kb.cxx
-    types/Data64kbv1.cxx
-    types/Data64kbPubSubTypes.cxx
-    types/Data1mb.cxx
-    types/Data1mbv1.cxx
-    types/Data1mbPubSubTypes.cxx
-    types/KeyedData1mb.cxx
-    types/KeyedData1mbv1.cxx
-    types/KeyedData1mbPubSubTypes.cxx
-    types/FixedSized.cxx
-    types/FixedSizedv1.cxx
-    types/FixedSizedPubSubTypes.cxx
+    types/StringTestv1.cxx
+    types/UnboundedHelloWorld.cxx
+    types/UnboundedHelloWorldPubSubTypes.cxx
+    types/UnboundedHelloWorldv1.cxx
 
     utils/data_generators.cpp
     utils/lambda_functions.cpp
@@ -103,35 +106,38 @@ gtest_discover_tests(BlackboxTests_RTPS
 
 file(GLOB BLACKBOXTESTS_TEST_SOURCE "common/BlackboxTests*.cpp")
 set(BLACKBOXTESTS_SOURCE ${BLACKBOXTESTS_TEST_SOURCE}
+    types/Data1mb.cxx
+    types/Data1mbPubSubTypes.cxx
+    types/Data1mbv1.cxx
+    types/Data64kb.cxx
+    types/Data64kbPubSubTypes.cxx
+    types/Data64kbv1.cxx
+    types/FixedSized.cxx
+    types/FixedSizedPubSubTypes.cxx
+    types/FixedSizedv1.cxx
     types/HelloWorld.cxx
-    types/HelloWorldv1.cxx
     types/HelloWorldPubSubTypes.cxx
     types/HelloWorldTypeObject.cxx
+    types/HelloWorldv1.cxx
+    types/KeyedData1mb.cxx
+    types/KeyedData1mbPubSubTypes.cxx
+    types/KeyedData1mbv1.cxx
     types/KeyedHelloWorld.cxx
-    types/KeyedHelloWorldv1.cxx
     types/KeyedHelloWorldPubSubTypes.cxx
+    types/KeyedHelloWorldv1.cxx
     types/StringTest.cxx
-    types/StringTestv1.cxx
     types/StringTestPubSubTypes.cxx
-    types/Data64kb.cxx
-    types/Data64kbv1.cxx
-    types/Data64kbPubSubTypes.cxx
-    types/Data1mb.cxx
-    types/Data1mbv1.cxx
-    types/Data1mbPubSubTypes.cxx
-    types/KeyedData1mb.cxx
-    types/KeyedData1mbv1.cxx
-    types/KeyedData1mbPubSubTypes.cxx
-    types/FixedSized.cxx
-    types/FixedSizedv1.cxx
-    types/FixedSizedPubSubTypes.cxx
+    types/StringTestv1.cxx
     types/TestIncludeRegression3361.cxx
-    types/TestIncludeRegression3361v1.cxx
     types/TestIncludeRegression3361TypeObject.cxx
+    types/TestIncludeRegression3361v1.cxx
     types/TestRegression3361.cxx
-    types/TestRegression3361v1.cxx
     types/TestRegression3361PubSubTypes.cxx
     types/TestRegression3361TypeObject.cxx
+    types/TestRegression3361v1.cxx
+    types/UnboundedHelloWorld.cxx
+    types/UnboundedHelloWorldPubSubTypes.cxx
+    types/UnboundedHelloWorldv1.cxx
 
     utils/data_generators.cpp
     utils/lambda_functions.cpp

--- test/blackbox/api/fastrtps_deprecated/PubSubReader.hpp ---
@@ -333,7 +333,8 @@ class PubSubReader
 
             if (subscriber_ != nullptr)
             {
-                std::cout << "Created subscriber " << subscriber_->getGuid() << " for topic " <<
+                subscriber_guid_ = subscriber_->getGuid();
+                std::cout << "Created subscriber " << subscriber_guid_ << " for topic " <<
                     subscriber_attr_.topic.topicName << std::endl;
 
                 initialized_ = true;
@@ -1433,6 +1434,11 @@ class PubSubReader
         return participant_guid_;
     }
 
+    const eprosima::fastrtps::rtps::GUID_t& datareader_guid() const
+    {
+        return subscriber_guid_;
+    }
+
 private:
 
     void receive_one(
@@ -1524,6 +1530,7 @@ class PubSubReader
     eprosima::fastrtps::SubscriberAttributes subscriber_attr_;
     std::string topic_name_;
     eprosima::fastrtps::rtps::GUID_t participant_guid_;
+    eprosima::fastrtps::rtps::GUID_t subscriber_guid_;
     bool initialized_;
     std::list<type> total_msgs_;
     std::mutex mutex_;

--- test/blackbox/common/BlackboxTests.hpp ---
@@ -31,13 +31,14 @@
 #include <unistd.h>
 #endif // if defined(_WIN32)
 
-#include "../types/HelloWorldPubSubTypes.h"
+#include "../types/Data1mbPubSubTypes.h"
+#include "../types/Data64kbPubSubTypes.h"
 #include "../types/FixedSizedPubSubTypes.h"
+#include "../types/HelloWorldPubSubTypes.h"
+#include "../types/KeyedData1mbPubSubTypes.h"
 #include "../types/KeyedHelloWorldPubSubTypes.h"
 #include "../types/StringTestPubSubTypes.h"
-#include "../types/Data64kbPubSubTypes.h"
-#include "../types/Data1mbPubSubTypes.h"
-#include "../types/KeyedData1mbPubSubTypes.h"
+#include "../types/UnboundedHelloWorldPubSubTypes.h"
 
 #include <algorithm>
 #include <cstddef>
@@ -170,6 +171,9 @@ std::list<Data1mb> default_data96kb_data300kb_data_generator(
 std::list<KeyedData1mb> default_keyeddata300kb_data_generator(
         size_t max = 0);
 
+std::list<UnboundedHelloWorld> default_unbounded_helloworld_data_generator(
+        size_t max = 0);
+
 /****** Auxiliary lambda functions  ******/
 extern const std::function<void(const HelloWorld&)>  default_helloworld_print;
 

--- test/blackbox/common/BlackboxTestsSecurity.cpp ---
@@ -27,6 +27,7 @@
 #include "PubSubWriter.hpp"
 #include "PubSubWriterReader.hpp"
 #include "PubSubParticipant.hpp"
+#include "UDPMessageSender.hpp"
 
 #include <fastdds/dds/log/Log.hpp>
 #include <fastdds/rtps/common/EntityId_t.hpp>
@@ -89,32 +90,6 @@ class Security : public testing::TestWithParam<communication_type>
 
 };
 
-struct UDPMessageSender
-{
-    asio::io_service service;
-    asio::ip::udp::socket socket;
-
-    UDPMessageSender()
-        : service()
-        , socket(service)
-    {
-        socket.open(asio::ip::udp::v4());
-    }
-
-    void send(
-            const CDRMessage_t& msg,
-            const Locator_t& destination)
-    {
-        std::string addr = IPLocator::toIPv4string(destination);
-        unsigned short port = static_cast<unsigned short>(destination.port);
-        auto remote = asio::ip::udp::endpoint(asio::ip::address::from_string(addr), port);
-        asio::error_code ec;
-
-        socket.send_to(asio::buffer(msg.buffer, msg.length), remote, 0, ec);
-    }
-
-};
-
 class SecurityPkcs : public ::testing::Test
 {
 public:

--- test/blackbox/common/BlackboxTestsTransportUDP.cpp ---
@@ -29,6 +29,7 @@
 #include "DatagramInjectionTransport.hpp"
 #include "PubSubReader.hpp"
 #include "PubSubWriter.hpp"
+#include "UDPMessageSender.hpp"
 
 using namespace eprosima::fastrtps;
 using namespace eprosima::fastrtps::rtps;
@@ -555,6 +556,104 @@ TEST(TransportUDP, DatagramInjection)
     deliver_datagram_from_file(receivers, "datagrams/20140.bin");
 }
 
+TEST(TransportUDP, MaliciousManipulatedDataOctetsToNextHeaderIgnore)
+{
+    // Force using UDP transport
+    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();
+
+    PubSubWriter<UnboundedHelloWorldPubSubType> writer(TEST_TOPIC_NAME);
+    PubSubReader<UnboundedHelloWorldPubSubType> reader(TEST_TOPIC_NAME);
+
+    struct MaliciousManipulatedDataOctetsToNextHeader
+    {
+        std::array<char, 4> rtps_id{ {'R', 'T', 'P', 'S'} };
+        std::array<uint8_t, 2> protocol_version{ {2, 3} };
+        std::array<uint8_t, 2> vendor_id{ {0x01, 0x0F} };
+        GuidPrefix_t sender_prefix{};
+
+        struct DataSubMsg
+        {
+            struct Header
+            {
+                uint8_t submessage_id = 0x15;
+#if FASTDDS_IS_BIG_ENDIAN_TARGET
+                uint8_t flags = 0x04;
+#else
+                uint8_t flags = 0x05;
+#endif  // FASTDDS_IS_BIG_ENDIAN_TARGET
+                uint16_t octets_to_next_header = 0x30;
+                uint16_t extra_flags = 0;
+                uint16_t octets_to_inline_qos = 0x2d;
+                EntityId_t reader_id{};
+                EntityId_t writer_id{};
+                SequenceNumber_t sn{100};
+            };
+
+            struct SerializedData
+            {
+                uint16_t encapsulation;
+                uint16_t encapsulation_opts;
+                octet data[24];
+            };
+
+            Header header;
+            SerializedData payload;
+        }
+        data;
+
+        uint8_t additional_bytes[8] {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+
+    };
+
+    UDPMessageSender fake_msg_sender;
+
+    // Set common QoS
+    reader.disable_builtin_transport().add_user_transport_to_pparams(udp_transport)
+            .history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);
+    writer.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);
+
+    // Set custom reader locator so we can send malicious data to a known location
+    Locator_t reader_locator;
+    ASSERT_TRUE(IPLocator::setIPv4(reader_locator, "127.0.0.1"));
+    reader_locator.port = 7000;
+    reader.add_to_unicast_locator_list("127.0.0.1", 7000);
+
+    // Initialize and wait for discovery
+    reader.init();
+    ASSERT_TRUE(reader.isInitialized());
+    writer.init();
+    ASSERT_TRUE(writer.isInitialized());
+
+    reader.wait_discovery();
+    writer.wait_discovery();
+
+    auto data = default_unbounded_helloworld_data_generator();
+    reader.startReception(data);
+    writer.send(data);
+    ASSERT_TRUE(data.empty());
+
+    // Send malicious data
+    {
+        auto writer_guid = writer.datawriter_guid();
+
+        MaliciousManipulatedDataOctetsToNextHeader malicious_packet{};
+        malicious_packet.sender_prefix = writer_guid.guidPrefix;
+        malicious_packet.data.header.writer_id = writer_guid.entityId;
+        malicious_packet.data.header.reader_id = reader.datareader_guid().entityId;
+        malicious_packet.data.payload.encapsulation = CDR_LE;
+
+        CDRMessage_t msg(0);
+        uint32_t msg_len = static_cast<uint32_t>(sizeof(malicious_packet));
+        msg.init(reinterpret_cast<octet*>(&malicious_packet), msg_len);
+        msg.length = msg_len;
+        msg.pos = msg_len;
+        fake_msg_sender.send(msg, reader_locator);
+    }
+
+    // Block reader until reception finished or timeout.
+    reader.block_for_all();
+}
+
 // Test for ==operator UDPTransportDescriptor is not required as it is an abstract class and in UDPv4 is same method
 // Test for copy UDPTransportDescriptor is not required as it is an abstract class and in UDPv4 is same method
 

--- test/blackbox/common/UDPMessageSender.hpp ---
@@ -0,0 +1,34 @@
+#include <asio/io_service.hpp>
+#include <asio/ip/udp.hpp>
+
+#include <fastdds/rtps/common/CDRMessage_t.h>
+#include <fastrtps/utils/IPLocator.h>
+
+using namespace eprosima::fastrtps;
+using namespace eprosima::fastrtps::rtps;
+
+struct UDPMessageSender
+{
+    asio::io_service service;
+    asio::ip::udp::socket socket;
+
+    UDPMessageSender()
+        : service()
+        , socket(service)
+    {
+        socket.open(asio::ip::udp::v4());
+    }
+
+    void send(
+            const CDRMessage_t& msg,
+            const Locator_t& destination)
+    {
+        std::string addr = IPLocator::toIPv4string(destination);
+        unsigned short port = static_cast<unsigned short>(destination.port);
+        auto remote = asio::ip::udp::endpoint(asio::ip::address::from_string(addr), port);
+        asio::error_code ec;
+
+        socket.send_to(asio::buffer(msg.buffer, msg.length), remote, 0, ec);
+    }
+
+};

--- test/blackbox/types/UnboundedHelloWorld.cxx ---
@@ -0,0 +1,168 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorld.cpp
+ * This source file contains the implementation of the described types in the IDL file.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+#ifdef _WIN32
+// Remove linker warning LNK4221 on Visual Studio
+namespace {
+char dummy;
+}  // namespace
+#endif  // _WIN32
+
+#include "UnboundedHelloWorld.h"
+
+#if FASTCDR_VERSION_MAJOR > 1
+
+#include <fastcdr/Cdr.h>
+
+
+#include <fastcdr/exceptions/BadParamException.h>
+using namespace eprosima::fastcdr::exception;
+
+#include <utility>
+
+
+
+
+UnboundedHelloWorld::UnboundedHelloWorld()
+{
+}
+
+UnboundedHelloWorld::~UnboundedHelloWorld()
+{
+}
+
+UnboundedHelloWorld::UnboundedHelloWorld(
+        const UnboundedHelloWorld& x)
+{
+    m_index = x.m_index;
+    m_message = x.m_message;
+}
+
+UnboundedHelloWorld::UnboundedHelloWorld(
+        UnboundedHelloWorld&& x) noexcept
+{
+    m_index = x.m_index;
+    m_message = std::move(x.m_message);
+}
+
+UnboundedHelloWorld& UnboundedHelloWorld::operator =(
+        const UnboundedHelloWorld& x)
+{
+
+    m_index = x.m_index;
+    m_message = x.m_message;
+    return *this;
+}
+
+UnboundedHelloWorld& UnboundedHelloWorld::operator =(
+        UnboundedHelloWorld&& x) noexcept
+{
+
+    m_index = x.m_index;
+    m_message = std::move(x.m_message);
+    return *this;
+}
+
+bool UnboundedHelloWorld::operator ==(
+        const UnboundedHelloWorld& x) const
+{
+    return (m_index == x.m_index &&
+           m_message == x.m_message);
+}
+
+bool UnboundedHelloWorld::operator !=(
+        const UnboundedHelloWorld& x) const
+{
+    return !(*this == x);
+}
+
+/*!
+ * @brief This function sets a value in member index
+ * @param _index New value for member index
+ */
+void UnboundedHelloWorld::index(
+        uint16_t _index)
+{
+    m_index = _index;
+}
+
+/*!
+ * @brief This function returns the value of member index
+ * @return Value of member index
+ */
+uint16_t UnboundedHelloWorld::index() const
+{
+    return m_index;
+}
+
+/*!
+ * @brief This function returns a reference to member index
+ * @return Reference to member index
+ */
+uint16_t& UnboundedHelloWorld::index()
+{
+    return m_index;
+}
+
+
+/*!
+ * @brief This function copies the value in member message
+ * @param _message New value to be copied in member message
+ */
+void UnboundedHelloWorld::message(
+        const std::string& _message)
+{
+    m_message = _message;
+}
+
+/*!
+ * @brief This function moves the value in member message
+ * @param _message New value to be moved in member message
+ */
+void UnboundedHelloWorld::message(
+        std::string&& _message)
+{
+    m_message = std::move(_message);
+}
+
+/*!
+ * @brief This function returns a constant reference to member message
+ * @return Constant reference to member message
+ */
+const std::string& UnboundedHelloWorld::message() const
+{
+    return m_message;
+}
+
+/*!
+ * @brief This function returns a reference to member message
+ * @return Reference to member message
+ */
+std::string& UnboundedHelloWorld::message()
+{
+    return m_message;
+}
+
+
+// Include auxiliary functions like for serializing/deserializing.
+#include "UnboundedHelloWorldCdrAux.ipp"
+
+#endif // FASTCDR_VERSION_MAJOR > 1

--- test/blackbox/types/UnboundedHelloWorld.h ---
@@ -0,0 +1,195 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorld.h
+ * This header file contains the declaration of the described types in the IDL file.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+#include <fastcdr/config.h>
+#include "UnboundedHelloWorldv1.h"
+
+#if FASTCDR_VERSION_MAJOR > 1
+
+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_
+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_
+
+#include <array>
+#include <bitset>
+#include <cstdint>
+#include <map>
+#include <string>
+#include <vector>
+
+#include <fastcdr/cdr/fixed_size_string.hpp>
+#include <fastcdr/xcdr/external.hpp>
+#include <fastcdr/xcdr/optional.hpp>
+
+
+
+#if defined(_WIN32)
+#if defined(EPROSIMA_USER_DLL_EXPORT)
+#define eProsima_user_DllExport __declspec( dllexport )
+#else
+#define eProsima_user_DllExport
+#endif  // EPROSIMA_USER_DLL_EXPORT
+#else
+#define eProsima_user_DllExport
+#endif  // _WIN32
+
+#if defined(_WIN32)
+#if defined(EPROSIMA_USER_DLL_EXPORT)
+#if defined(UNBOUNDEDHELLOWORLD_SOURCE)
+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllexport )
+#else
+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllimport )
+#endif // UNBOUNDEDHELLOWORLD_SOURCE
+#else
+#define UNBOUNDEDHELLOWORLD_DllAPI
+#endif  // EPROSIMA_USER_DLL_EXPORT
+#else
+#define UNBOUNDEDHELLOWORLD_DllAPI
+#endif // _WIN32
+
+namespace eprosima {
+namespace fastcdr {
+class Cdr;
+class CdrSizeCalculator;
+} // namespace fastcdr
+} // namespace eprosima
+
+
+
+
+
+/*!
+ * @brief This class represents the structure UnboundedHelloWorld defined by the user in the IDL file.
+ * @ingroup UnboundedHelloWorld
+ */
+class UnboundedHelloWorld
+{
+public:
+
+    /*!
+     * @brief Default constructor.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld();
+
+    /*!
+     * @brief Default destructor.
+     */
+    eProsima_user_DllExport ~UnboundedHelloWorld();
+
+    /*!
+     * @brief Copy constructor.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld(
+            const UnboundedHelloWorld& x);
+
+    /*!
+     * @brief Move constructor.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld(
+            UnboundedHelloWorld&& x) noexcept;
+
+    /*!
+     * @brief Copy assignment.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld& operator =(
+            const UnboundedHelloWorld& x);
+
+    /*!
+     * @brief Move assignment.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld& operator =(
+            UnboundedHelloWorld&& x) noexcept;
+
+    /*!
+     * @brief Comparison operator.
+     * @param x UnboundedHelloWorld object to compare.
+     */
+    eProsima_user_DllExport bool operator ==(
+            const UnboundedHelloWorld& x) const;
+
+    /*!
+     * @brief Comparison operator.
+     * @param x UnboundedHelloWorld object to compare.
+     */
+    eProsima_user_DllExport bool operator !=(
+            const UnboundedHelloWorld& x) const;
+
+    /*!
+     * @brief This function sets a value in member index
+     * @param _index New value for member index
+     */
+    eProsima_user_DllExport void index(
+            uint16_t _index);
+
+    /*!
+     * @brief This function returns the value of member index
+     * @return Value of member index
+     */
+    eProsima_user_DllExport uint16_t index() const;
+
+    /*!
+     * @brief This function returns a reference to member index
+     * @return Reference to member index
+     */
+    eProsima_user_DllExport uint16_t& index();
+
+
+    /*!
+     * @brief This function copies the value in member message
+     * @param _message New value to be copied in member message
+     */
+    eProsima_user_DllExport void message(
+            const std::string& _message);
+
+    /*!
+     * @brief This function moves the value in member message
+     * @param _message New value to be moved in member message
+     */
+    eProsima_user_DllExport void message(
+            std::string&& _message);
+
+    /*!
+     * @brief This function returns a constant reference to member message
+     * @return Constant reference to member message
+     */
+    eProsima_user_DllExport const std::string& message() const;
+
+    /*!
+     * @brief This function returns a reference to member message
+     * @return Reference to member message
+     */
+    eProsima_user_DllExport std::string& message();
+
+private:
+
+    uint16_t m_index{0};
+    std::string m_message;
+
+};
+
+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_
+
+
+
+#endif // FASTCDR_VERSION_MAJOR > 1

--- test/blackbox/types/UnboundedHelloWorld.idl ---
@@ -0,0 +1,5 @@
+struct UnboundedHelloWorld
+{
+	unsigned short index;
+	string message;
+};
\ No newline at end of file

--- test/blackbox/types/UnboundedHelloWorldCdrAux.hpp ---
@@ -0,0 +1,48 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorldCdrAux.hpp
+ * This source file contains some definitions of CDR related functions.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_HPP_
+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_HPP_
+
+#include "UnboundedHelloWorld.h"
+
+constexpr uint32_t UnboundedHelloWorld_max_cdr_typesize {268UL};
+constexpr uint32_t UnboundedHelloWorld_max_key_cdr_typesize {0UL};
+
+
+namespace eprosima {
+namespace fastcdr {
+
+class Cdr;
+class CdrSizeCalculator;
+
+
+
+eProsima_user_DllExport void serialize_key(
+        eprosima::fastcdr::Cdr& scdr,
+        const UnboundedHelloWorld& data);
+
+
+} // namespace fastcdr
+} // namespace eprosima
+
+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_HPP_
+

--- test/blackbox/types/UnboundedHelloWorldCdrAux.ipp ---
@@ -0,0 +1,128 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorldCdrAux.ipp
+ * This source file contains some declarations of CDR related functions.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_IPP_
+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_IPP_
+
+#include "UnboundedHelloWorldCdrAux.hpp"
+
+#include <fastcdr/Cdr.h>
+#include <fastcdr/CdrSizeCalculator.hpp>
+
+
+#include <fastcdr/exceptions/BadParamException.h>
+using namespace eprosima::fastcdr::exception;
+
+namespace eprosima {
+namespace fastcdr {
+
+
+
+template<>
+eProsima_user_DllExport size_t calculate_serialized_size(
+        eprosima::fastcdr::CdrSizeCalculator& calculator,
+        const UnboundedHelloWorld& data,
+        size_t& current_alignment)
+{
+    static_cast<void>(data);
+
+    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
+    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
+                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
+                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
+                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
+                                current_alignment)};
+
+
+        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
+                data.index(), current_alignment);
+
+        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
+                data.message(), current_alignment);
+
+
+    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);
+
+    return calculated_size;
+}
+
+template<>
+eProsima_user_DllExport void serialize(
+        eprosima::fastcdr::Cdr& scdr,
+        const UnboundedHelloWorld& data)
+{
+    eprosima::fastcdr::Cdr::state current_state(scdr);
+    scdr.begin_serialize_type(current_state,
+            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
+            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
+            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
+
+    scdr
+        << eprosima::fastcdr::MemberId(0) << data.index()
+        << eprosima::fastcdr::MemberId(1) << data.message()
+;
+    scdr.end_serialize_type(current_state);
+}
+
+template<>
+eProsima_user_DllExport void deserialize(
+        eprosima::fastcdr::Cdr& cdr,
+        UnboundedHelloWorld& data)
+{
+    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
+            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
+            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
+            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
+            {
+                bool ret_value = true;
+                switch (mid.id)
+                {
+                                        case 0:
+                                                dcdr >> data.index();
+                                            break;
+
+                                        case 1:
+                                                dcdr >> data.message();
+                                            break;
+
+                    default:
+                        ret_value = false;
+                        break;
+                }
+                return ret_value;
+            });
+}
+
+void serialize_key(
+        eprosima::fastcdr::Cdr& scdr,
+        const UnboundedHelloWorld& data)
+{
+    static_cast<void>(scdr);
+    static_cast<void>(data);
+}
+
+
+
+} // namespace fastcdr
+} // namespace eprosima
+
+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_IPP_
+

--- test/blackbox/types/UnboundedHelloWorldPubSubTypes.cxx ---
@@ -0,0 +1,221 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorldPubSubTypes.cpp
+ * This header file contains the implementation of the serialization functions.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+
+#include <fastdds/rtps/common/CdrSerialization.hpp>
+
+#include "UnboundedHelloWorldPubSubTypes.h"
+#include "UnboundedHelloWorldCdrAux.hpp"
+
+using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
+using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;
+using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;
+
+
+
+UnboundedHelloWorldPubSubType::UnboundedHelloWorldPubSubType()
+{
+    setName("UnboundedHelloWorld");
+    uint32_t type_size =
+#if FASTCDR_VERSION_MAJOR == 1
+        static_cast<uint32_t>(UnboundedHelloWorld::getMaxCdrSerializedSize());
+#else
+        UnboundedHelloWorld_max_cdr_typesize;
+#endif
+    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
+    m_typeSize = type_size + 4; /*encapsulation*/
+    m_isGetKeyDefined = false;
+    uint32_t keyLength = UnboundedHelloWorld_max_key_cdr_typesize > 16 ? UnboundedHelloWorld_max_key_cdr_typesize : 16;
+    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
+    memset(m_keyBuffer, 0, keyLength);
+}
+
+UnboundedHelloWorldPubSubType::~UnboundedHelloWorldPubSubType()
+{
+    if (m_keyBuffer != nullptr)
+    {
+        free(m_keyBuffer);
+    }
+}
+
+bool UnboundedHelloWorldPubSubType::serialize(
+        void* data,
+        SerializedPayload_t* payload,
+        DataRepresentationId_t data_representation)
+{
+    UnboundedHelloWorld* p_type = static_cast<UnboundedHelloWorld*>(data);
+
+    // Object that manages the raw buffer.
+    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
+    // Object that serializes the data.
+    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
+            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
+            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
+    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
+#if FASTCDR_VERSION_MAJOR > 1
+    ser.set_encoding_flag(
+        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
+        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
+        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
+#endif // FASTCDR_VERSION_MAJOR > 1
+
+    try
+    {
+        // Serialize encapsulation
+        ser.serialize_encapsulation();
+        // Serialize the object.
+        ser << *p_type;
+    }
+    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
+    {
+        return false;
+    }
+
+    // Get the serialized length
+#if FASTCDR_VERSION_MAJOR == 1
+    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
+#else
+    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
+#endif // FASTCDR_VERSION_MAJOR == 1
+    return true;
+}
+
+bool UnboundedHelloWorldPubSubType::deserialize(
+        SerializedPayload_t* payload,
+        void* data)
+{
+    try
+    {
+        // Convert DATA to pointer of your type
+        UnboundedHelloWorld* p_type = static_cast<UnboundedHelloWorld*>(data);
+
+        // Object that manages the raw buffer.
+        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);
+
+        // Object that deserializes the data.
+        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
+#if FASTCDR_VERSION_MAJOR == 1
+                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
+#endif // FASTCDR_VERSION_MAJOR == 1
+                );
+
+        // Deserialize encapsulation.
+        deser.read_encapsulation();
+        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
+
+        // Deserialize the object.
+        deser >> *p_type;
+    }
+    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
+    {
+        return false;
+    }
+
+    return true;
+}
+
+std::function<uint32_t()> UnboundedHelloWorldPubSubType::getSerializedSizeProvider(
+        void* data,
+        DataRepresentationId_t data_representation)
+{
+    return [data, data_representation]() -> uint32_t
+           {
+#if FASTCDR_VERSION_MAJOR == 1
+               static_cast<void>(data_representation);
+               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<UnboundedHelloWorld*>(data))) +
+                      4u /*encapsulation*/;
+#else
+               try
+               {
+                   eprosima::fastcdr::CdrSizeCalculator calculator(
+                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
+                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
+                   size_t current_alignment {0};
+                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
+                               *static_cast<UnboundedHelloWorld*>(data), current_alignment)) +
+                           4u /*encapsulation*/;
+               }
+               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
+               {
+                   return 0;
+               }
+#endif // FASTCDR_VERSION_MAJOR == 1
+           };
+}
+
+void* UnboundedHelloWorldPubSubType::createData()
+{
+    return reinterpret_cast<void*>(new UnboundedHelloWorld());
+}
+
+void UnboundedHelloWorldPubSubType::deleteData(
+        void* data)
+{
+    delete(reinterpret_cast<UnboundedHelloWorld*>(data));
+}
+
+bool UnboundedHelloWorldPubSubType::getKey(
+        void* data,
+        InstanceHandle_t* handle,
+        bool force_md5)
+{
+    if (!m_isGetKeyDefined)
+    {
+        return false;
+    }
+
+    UnboundedHelloWorld* p_type = static_cast<UnboundedHelloWorld*>(data);
+
+    // Object that manages the raw buffer.
+    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
+            UnboundedHelloWorld_max_key_cdr_typesize);
+
+    // Object that serializes the data.
+    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
+#if FASTCDR_VERSION_MAJOR == 1
+    p_type->serializeKey(ser);
+#else
+    eprosima::fastcdr::serialize_key(ser, *p_type);
+#endif // FASTCDR_VERSION_MAJOR == 1
+    if (force_md5 || UnboundedHelloWorld_max_key_cdr_typesize > 16)
+    {
+        m_md5.init();
+#if FASTCDR_VERSION_MAJOR == 1
+        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
+#else
+        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
+#endif // FASTCDR_VERSION_MAJOR == 1
+        m_md5.finalize();
+        for (uint8_t i = 0; i < 16; ++i)
+        {
+            handle->value[i] = m_md5.digest[i];
+        }
+    }
+    else
+    {
+        for (uint8_t i = 0; i < 16; ++i)
+        {
+            handle->value[i] = m_keyBuffer[i];
+        }
+    }
+    return true;
+}
+

--- test/blackbox/types/UnboundedHelloWorldPubSubTypes.h ---
@@ -0,0 +1,132 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorldPubSubTypes.h
+ * This header file contains the declaration of the serialization functions.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+
+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_PUBSUBTYPES_H_
+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_PUBSUBTYPES_H_
+
+#include <fastdds/dds/core/policy/QosPolicies.hpp>
+#include <fastdds/dds/topic/TopicDataType.hpp>
+#include <fastdds/rtps/common/InstanceHandle.h>
+#include <fastdds/rtps/common/SerializedPayload.h>
+#include <fastrtps/utils/md5.h>
+
+#include "UnboundedHelloWorld.h"
+
+
+#if !defined(GEN_API_VER) || (GEN_API_VER != 2)
+#error \
+    Generated UnboundedHelloWorld is not compatible with current installed Fast DDS. Please, regenerate it with fastddsgen.
+#endif  // GEN_API_VER
+
+
+
+
+/*!
+ * @brief This class represents the TopicDataType of the type UnboundedHelloWorld defined by the user in the IDL file.
+ * @ingroup UnboundedHelloWorld
+ */
+class UnboundedHelloWorldPubSubType : public eprosima::fastdds::dds::TopicDataType
+{
+public:
+
+    typedef UnboundedHelloWorld type;
+
+    eProsima_user_DllExport UnboundedHelloWorldPubSubType();
+
+    eProsima_user_DllExport ~UnboundedHelloWorldPubSubType() override;
+
+    eProsima_user_DllExport bool serialize(
+            void* data,
+            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override
+    {
+        return serialize(data, payload, eprosima::fastdds::dds::DEFAULT_DATA_REPRESENTATION);
+    }
+
+    eProsima_user_DllExport bool serialize(
+            void* data,
+            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
+            eprosima::fastdds::dds::DataRepresentationId_t data_representation) override;
+
+    eProsima_user_DllExport bool deserialize(
+            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
+            void* data) override;
+
+    eProsima_user_DllExport std::function<uint32_t()> getSerializedSizeProvider(
+            void* data) override
+    {
+        return getSerializedSizeProvider(data, eprosima::fastdds::dds::DEFAULT_DATA_REPRESENTATION);
+    }
+
+    eProsima_user_DllExport std::function<uint32_t()> getSerializedSizeProvider(
+            void* data,
+            eprosima::fastdds::dds::DataRepresentationId_t data_representation) override;
+
+    eProsima_user_DllExport bool getKey(
+            void* data,
+            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
+            bool force_md5 = false) override;
+
+    eProsima_user_DllExport void* createData() override;
+
+    eProsima_user_DllExport void deleteData(
+            void* data) override;
+
+#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
+    eProsima_user_DllExport inline bool is_bounded() const override
+    {
+        return false;
+    }
+
+#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
+
+#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
+    eProsima_user_DllExport inline bool is_plain() const override
+    {
+        return false;
+    }
+
+    eProsima_user_DllExport inline bool is_plain(
+        eprosima::fastdds::dds::DataRepresentationId_t data_representation) const override
+    {
+        static_cast<void>(data_representation);
+        return false;
+    }
+
+#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
+
+#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
+    eProsima_user_DllExport inline bool construct_sample(
+            void* memory) const override
+    {
+        static_cast<void>(memory);
+        return false;
+    }
+
+#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
+
+    MD5 m_md5;
+    unsigned char* m_keyBuffer;
+
+};
+
+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_PUBSUBTYPES_H_
+

--- test/blackbox/types/UnboundedHelloWorldv1.cxx ---
@@ -0,0 +1,286 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorld.cpp
+ * This source file contains the implementation of the described types in the IDL file.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+#ifdef _WIN32
+// Remove linker warning LNK4221 on Visual Studio
+namespace {
+char dummy;
+}  // namespace
+#endif  // _WIN32
+
+#include "UnboundedHelloWorld.h"
+
+#if FASTCDR_VERSION_MAJOR == 1
+
+#include <fastcdr/Cdr.h>
+
+
+#include <fastcdr/exceptions/BadParamException.h>
+using namespace eprosima::fastcdr::exception;
+
+#include <utility>
+
+namespace helper { namespace internal {
+
+enum class Size {
+    UInt8,
+    UInt16,
+    UInt32,
+    UInt64,
+};
+
+constexpr Size get_size(int s) {
+    return (s <= 8 ) ? Size::UInt8:
+           (s <= 16) ? Size::UInt16:
+           (s <= 32) ? Size::UInt32: Size::UInt64;
+}
+
+template<Size s>
+struct FindTypeH;
+
+template<>
+struct FindTypeH<Size::UInt8> {
+    using type = std::uint8_t;
+};
+
+template<>
+struct FindTypeH<Size::UInt16> {
+    using type = std::uint16_t;
+};
+
+template<>
+struct FindTypeH<Size::UInt32> {
+    using type = std::uint32_t;
+};
+
+template<>
+struct FindTypeH<Size::UInt64> {
+    using type = std::uint64_t;
+};
+}
+
+template<int S>
+struct FindType {
+    using type = typename internal::FindTypeH<internal::get_size(S)>::type;
+};
+}
+
+#define UnboundedHelloWorld_max_cdr_typesize 268ULL;
+
+
+
+
+UnboundedHelloWorld::UnboundedHelloWorld()
+{
+    // unsigned short m_index
+    m_index = 0;
+    // /type_d() m_message
+
+
+}
+
+UnboundedHelloWorld::~UnboundedHelloWorld()
+{
+}
+
+UnboundedHelloWorld::UnboundedHelloWorld(
+        const UnboundedHelloWorld& x)
+{
+    m_index = x.m_index;
+
+
+    m_message = x.m_message;
+
+}
+
+UnboundedHelloWorld::UnboundedHelloWorld(
+        UnboundedHelloWorld&& x) noexcept
+{
+    m_index = x.m_index;
+
+
+    m_message = std::move(x.m_message);
+
+}
+
+UnboundedHelloWorld& UnboundedHelloWorld::operator =(
+        const UnboundedHelloWorld& x)
+{
+    m_index = x.m_index;
+
+
+    m_message = x.m_message;
+
+    return *this;
+}
+
+UnboundedHelloWorld& UnboundedHelloWorld::operator =(
+        UnboundedHelloWorld&& x) noexcept
+{
+    m_index = x.m_index;
+
+
+    m_message = std::move(x.m_message);
+
+    return *this;
+}
+
+bool UnboundedHelloWorld::operator ==(
+        const UnboundedHelloWorld& x) const
+{
+    return (m_index == x.m_index &&
+           m_message == x.m_message);
+}
+
+bool UnboundedHelloWorld::operator !=(
+        const UnboundedHelloWorld& x) const
+{
+    return !(*this == x);
+}
+
+size_t UnboundedHelloWorld::getMaxCdrSerializedSize(
+        size_t current_alignment)
+{
+    static_cast<void>(current_alignment);
+    return UnboundedHelloWorld_max_cdr_typesize;
+}
+
+size_t UnboundedHelloWorld::getCdrSerializedSize(
+        const UnboundedHelloWorld& data,
+        size_t current_alignment)
+{
+    (void)data;
+    size_t initial_alignment = current_alignment;
+
+    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
+
+
+    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;
+
+
+    return current_alignment - initial_alignment;
+}
+
+
+void UnboundedHelloWorld::serialize(
+        eprosima::fastcdr::Cdr& scdr) const
+{
+    scdr << m_index;
+
+    scdr << m_message.c_str();
+
+}
+
+void UnboundedHelloWorld::deserialize(
+        eprosima::fastcdr::Cdr& dcdr)
+{
+    dcdr >> m_index;
+
+
+
+    dcdr >> m_message;
+
+
+}
+
+
+bool UnboundedHelloWorld::isKeyDefined()
+{
+    return false;
+}
+
+void UnboundedHelloWorld::serializeKey(
+        eprosima::fastcdr::Cdr& scdr) const
+{
+    (void) scdr;
+}
+
+/*!
+ * @brief This function sets a value in member index
+ * @param _index New value for member index
+ */
+void UnboundedHelloWorld::index(
+        uint16_t _index)
+{
+    m_index = _index;
+}
+
+/*!
+ * @brief This function returns the value of member index
+ * @return Value of member index
+ */
+uint16_t UnboundedHelloWorld::index() const
+{
+    return m_index;
+}
+
+/*!
+ * @brief This function returns a reference to member index
+ * @return Reference to member index
+ */
+uint16_t& UnboundedHelloWorld::index()
+{
+    return m_index;
+}
+
+
+/*!
+ * @brief This function copies the value in member message
+ * @param _message New value to be copied in member message
+ */
+void UnboundedHelloWorld::message(
+        const std::string& _message)
+{
+    m_message = _message;
+}
+
+/*!
+ * @brief This function moves the value in member message
+ * @param _message New value to be moved in member message
+ */
+void UnboundedHelloWorld::message(
+        std::string&& _message)
+{
+    m_message = std::move(_message);
+}
+
+/*!
+ * @brief This function returns a constant reference to member message
+ * @return Constant reference to member message
+ */
+const std::string& UnboundedHelloWorld::message() const
+{
+    return m_message;
+}
+
+/*!
+ * @brief This function returns a reference to member message
+ * @return Reference to member message
+ */
+std::string& UnboundedHelloWorld::message()
+{
+    return m_message;
+}
+
+
+
+
+#endif // FASTCDR_VERSION_MAJOR == 1

--- test/blackbox/types/UnboundedHelloWorldv1.h ---
@@ -0,0 +1,244 @@
+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*!
+ * @file UnboundedHelloWorld.h
+ * This header file contains the declaration of the described types in the IDL file.
+ *
+ * This file was generated by the tool fastddsgen.
+ */
+
+#include <fastcdr/config.h>
+
+#if FASTCDR_VERSION_MAJOR == 1
+
+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_
+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_
+
+
+#include <fastrtps/utils/fixed_size_string.hpp>
+
+#include <array>
+#include <bitset>
+#include <cstdint>
+#include <map>
+#include <stdint.h>
+#include <string>
+#include <vector>
+
+#if defined(_WIN32)
+#if defined(EPROSIMA_USER_DLL_EXPORT)
+#define eProsima_user_DllExport __declspec( dllexport )
+#else
+#define eProsima_user_DllExport
+#endif  // EPROSIMA_USER_DLL_EXPORT
+#else
+#define eProsima_user_DllExport
+#endif  // _WIN32
+
+#if defined(_WIN32)
+#if defined(EPROSIMA_USER_DLL_EXPORT)
+#if defined(UNBOUNDEDHELLOWORLD_SOURCE)
+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllexport )
+#else
+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllimport )
+#endif // UNBOUNDEDHELLOWORLD_SOURCE
+#else
+#define UNBOUNDEDHELLOWORLD_DllAPI
+#endif  // EPROSIMA_USER_DLL_EXPORT
+#else
+#define UNBOUNDEDHELLOWORLD_DllAPI
+#endif // _WIN32
+
+namespace eprosima {
+namespace fastcdr {
+class Cdr;
+} // namespace fastcdr
+} // namespace eprosima
+
+
+
+
+
+/*!
+ * @brief This class represents the structure UnboundedHelloWorld defined by the user in the IDL file.
+ * @ingroup UnboundedHelloWorld
+ */
+class UnboundedHelloWorld
+{
+public:
+
+    /*!
+     * @brief Default constructor.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld();
+
+    /*!
+     * @brief Default destructor.
+     */
+    eProsima_user_DllExport ~UnboundedHelloWorld();
+
+    /*!
+     * @brief Copy constructor.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld(
+            const UnboundedHelloWorld& x);
+
+    /*!
+     * @brief Move constructor.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld(
+            UnboundedHelloWorld&& x) noexcept;
+
+    /*!
+     * @brief Copy assignment.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld& operator =(
+            const UnboundedHelloWorld& x);
+
+    /*!
+     * @brief Move assignment.
+     * @param x Reference to the object UnboundedHelloWorld that will be copied.
+     */
+    eProsima_user_DllExport UnboundedHelloWorld& operator =(
+            UnboundedHelloWorld&& x) noexcept;
+
+    /*!
+     * @brief Comparison operator.
+     * @param x UnboundedHelloWorld object to compare.
+     */
+    eProsima_user_DllExport bool operator ==(
+            const UnboundedHelloWorld& x) const;
+
+    /*!
+     * @brief Comparison operator.
+     * @param x UnboundedHelloWorld object to compare.
+     */
+    eProsima_user_DllExport bool operator !=(
+            const UnboundedHelloWorld& x) const;
+
+    /*!
+     * @brief This function sets a value in member index
+     * @param _index New value for member index
+     */
+    eProsima_user_DllExport void index(
+            uint16_t _index);
+
+    /*!
+     * @brief This function returns the value of member index
+     * @return Value of member index
+     */
+    eProsima_user_DllExport uint16_t index() const;
+
+    /*!
+     * @brief This function returns a reference to member index
+     * @return Reference to member index
+     */
+    eProsima_user_DllExport uint16_t& index();
+
+
+    /*!
+     * @brief This function copies the value in member message
+     * @param _message New value to be copied in member message
+     */
+    eProsima_user_DllExport void message(
+            const std::string& _message);
+
+    /*!
+     * @brief This function moves the value in member message
+     * @param _message New value to be moved in member message
+     */
+    eProsima_user_DllExport void message(
+            std::string&& _message);
+
+    /*!
+     * @brief This function returns a constant reference to member message
+     * @return Constant reference to member message
+     */
+    eProsima_user_DllExport const std::string& message() const;
+
+    /*!
+     * @brief This function returns a reference to member message
+     * @return Reference to member message
+     */
+    eProsima_user_DllExport std::string& message();
+
+
+    /*!
+    * @brief This function returns the maximum serialized size of an object
+    * depending on the buffer alignment.
+    * @param current_alignment Buffer alignment.
+    * @return Maximum serialized size.
+    */
+    eProsima_user_DllExport static size_t getMaxCdrSerializedSize(
+            size_t current_alignment = 0);
+
+    /*!
+     * @brief This function returns the serialized size of a data depending on the buffer alignment.
+     * @param data Data which is calculated its serialized size.
+     * @param current_alignment Buffer alignment.
+     * @return Serialized size.
+     */
+    eProsima_user_DllExport static size_t getCdrSerializedSize(
+            const UnboundedHelloWorld& data,
+            size_t current_alignment = 0);
+
+
+
+    /*!
+     * @brief This function serializes an object using CDR serialization.
+     * @param cdr CDR serialization object.
+     */
+    eProsima_user_DllExport void serialize(
+            eprosima::fastcdr::Cdr& cdr) const;
+
+    /*!
+     * @brief This function deserializes an object using CDR serialization.
+     * @param cdr CDR serialization object.
+     */
+    eProsima_user_DllExport void deserialize(
+            eprosima::fastcdr::Cdr& cdr);
+
+
+
+
+    /*!
+    * @brief This function tells you if the Key has been defined for this type
+    */
+    eProsima_user_DllExport static bool isKeyDefined();
+
+    /*!
+    * @brief This function serializes the key members of an object using CDR serialization.
+    * @param cdr CDR serialization object.
+    */
+    eProsima_user_DllExport void serializeKey(
+            eprosima::fastcdr::Cdr& cdr) const;
+
+
+private:
+
+    uint16_t m_index;
+    std::string m_message;
+
+};
+
+
+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_
+
+
+
+#endif // FASTCDR_VERSION_MAJOR == 1

--- test/blackbox/utils/data_generators.cpp ---
@@ -277,3 +277,24 @@ std::list<KeyedData1mb> default_keyeddata300kb_data_generator(
 
     return returnedValue;
 }
+
+std::list<UnboundedHelloWorld> default_unbounded_helloworld_data_generator(
+        size_t max)
+{
+    uint16_t index = 1;
+    size_t maximum = max ? max : 10;
+    std::list<UnboundedHelloWorld> returnedValue(maximum);
+
+    std::generate(returnedValue.begin(), returnedValue.end(), [&index]
+            {
+                UnboundedHelloWorld hello;
+                hello.index(index);
+                std::stringstream ss;
+                ss << "HelloWorld " << index;
+                hello.message(ss.str());
+                ++index;
+                return hello;
+            });
+
+    return returnedValue;
+}

