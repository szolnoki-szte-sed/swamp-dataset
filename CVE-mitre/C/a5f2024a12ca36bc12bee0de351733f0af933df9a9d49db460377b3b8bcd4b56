--- docs/kernel/configuration.rst ---
@@ -107,6 +107,9 @@ The main.cfg ``[main]`` section parameters are explained bellow.
   section, then the response codes list given will be considered as
   valid response code when downloading input data (sample value:
   ``404,400``).
+* ``allowedPaths``: if this parameter is present, then the files using the
+  file:// protocol will be checked against the list of allowed paths. The 
+  list of allowed paths should be separated by a coma.
 
 .. warning:: 
   The ``libPath`` parameter is currently only recognized by services implemented

--- zoo-project/zoo-kernel/caching.c ---
@@ -670,6 +670,31 @@ int runHttpRequests(maps** m,maps** inputs,HINTERNET* hInternet,map** error){
   return hasAFailure;
 }
 
+/**
+ * Ensure that the file:// protocol is used only for allowed paths.
+ *
+ * @param pmsConf the maps containing the settings of the main.cfg file
+ * @param pccPath the path to check
+ * @return true if the path is accessible, false otherwise
+ */
+bool isAllowedPath(maps* pmsConf,const char* pccPath){
+  map* pmAccessiblePaths=getMapFromMaps(pmsConf,"main","allowedPaths");
+  if(pmAccessiblePaths!=NULL){
+    char *pcTmp=zStrdup(pmAccessiblePaths->value);
+    char *pcToken, *pcSavePtr;
+    pcToken=strtok_r(pcTmp,",",&pcSavePtr);
+    while(pcToken!=NULL){
+      if(strstr(pccPath,pcToken)!=NULL){
+        free(pcTmp);
+        return true;
+      }
+      pcToken=strtok_r(NULL,",",&pcSavePtr);
+    }
+    free(pcTmp);
+  }
+  return false;
+}
+
 /**
  * Add a request in the download queue
  *

--- zoo-project/zoo-kernel/caching.h ---
@@ -31,6 +31,7 @@ extern "C" {
 
   void addToCache(maps*,char*,char*,char*,int,char*,size_t);
   char* isInCache(maps*,char*);
+  bool isAllowedPath(maps*,const char*);
   int runHttpRequests(maps**,maps**,HINTERNET*,map**);
   void addRequestToQueue(maps**,HINTERNET*,const char*,bool);
   int loadRemoteFile(maps**,map**,HINTERNET*,char*);

--- zoo-project/zoo-kernel/request_parser.c ---
@@ -305,15 +305,23 @@ int kvpParseInputs(maps** pmsConf,service* s,map *request_inputs,maps** request_
             addToMap (tmpmaps->content, tmpn1, tmpv1 + 1);
           else if (tmpv1 != NULL){
             char *tmpx2 = url_decode (tmpv1 + 1);
-            if (strncasecmp (tmpx2, "http://", 7) != 0 &&
-              strncasecmp (tmpx2, "ftp://", 6) != 0 &&
-              strncasecmp (tmpx2, "https://", 8) != 0 &&
-              strncasecmp (tmpx2, "file://", 7) != 0){
+            bool bIsAllowedPath = isAllowedPath(*pmsConf,tmpx2);
+            if ((strncasecmp (tmpx2, "http://", 7) != 0 &&
+                strncasecmp (tmpx2, "ftp://", 6) != 0 &&
+                strncasecmp (tmpx2, "https://", 8) != 0 &&
+                strncasecmp (tmpx2, "file://", 7) != 0)
+                ||
+                (strncasecmp (tmpx2, "file://", 7) == 0 && !bIsAllowedPath)){
               char emsg[1024];
-              sprintf (emsg,
-                _
-                ("Unable to find a valid protocol to download the remote file %s"),
-                tmpv1 + 1);
+              if(strncasecmp (tmpx2, "file://", 7) == 0 && !bIsAllowedPath){
+                sprintf (emsg,
+                  _("Access to the provided file URL is not allowed %s"),
+                  tmpv1 + 1);
+              }else{
+                sprintf (emsg,
+                  _("Unable to find a valid protocol to download the remote file %s"),
+                  tmpv1 + 1);
+              }
               free (inputs_as_text);
               free(cursor_input);
               free(tmp);

