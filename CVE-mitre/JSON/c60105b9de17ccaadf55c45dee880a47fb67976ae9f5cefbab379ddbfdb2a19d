--- .pubnub.yml ---
@@ -1,5 +1,12 @@
 ---
 changelog:
+  - date: 2023-10-16
+    version: v7.4.0
+    changes:
+      - type: feature
+        text: "Add crypto module that allows configure SDK to encrypt and decrypt messages."
+      - type: bug
+        text: "Improved security of crypto implementation by adding enhanced AES-CBC cryptor."
   - date: 2023-09-11
     version: v7.3.3
     changes:
@@ -895,7 +902,7 @@ supported-platforms:
       - 'Ubuntu 14.04 and up'
       - 'Windows 7 and up'
     version: 'Pubnub Javascript for Node'
-version: '7.3.3'
+version: '7.4.0'
 sdks:
   - full-name: PubNub Javascript SDK
     short-name: Javascript
@@ -911,7 +918,7 @@ sdks:
           - distribution-type: source
             distribution-repository: GitHub release
             package-name: pubnub.js
-            location: https://github.com/pubnub/javascript/archive/refs/tags/v7.3.3.zip
+            location: https://github.com/pubnub/javascript/archive/refs/tags/v7.4.0.zip
             requires:
               - name: 'agentkeepalive'
                 min-version: '3.5.2'
@@ -1582,7 +1589,7 @@ sdks:
           - distribution-type: library
             distribution-repository: GitHub release
             package-name: pubnub.js
-            location: https://github.com/pubnub/javascript/releases/download/v7.3.3/pubnub.7.3.3.js
+            location: https://github.com/pubnub/javascript/releases/download/v7.4.0/pubnub.7.4.0.js
             requires:
               - name: 'agentkeepalive'
                 min-version: '3.5.2'

--- CHANGELOG.md ---
@@ -1,3 +1,12 @@
+## v7.4.0
+October 16 2023
+
+#### Added
+- Add crypto module that allows configure SDK to encrypt and decrypt messages.
+
+#### Fixed
+- Improved security of crypto implementation by adding enhanced AES-CBC cryptor.
+
 ## v7.3.3
 September 11 2023
 

--- LICENSE ---
@@ -1,27 +1,29 @@
-PubNub Real-time Cloud-Hosted Push API and Push Notification Client Frameworks
-Copyright (c) 2013 PubNub Inc.
-http://www.pubnub.com/
-http://www.pubnub.com/terms
+PubNub Software Development Kit License Agreement
+Copyright © 2023 PubNub Inc. All rights reserved.
 
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
+Subject to the terms and conditions of the license, you are hereby granted
+a non-exclusive, worldwide, royalty-free license to (a) copy and modify
+the software in source code or binary form for use with the software services
+and interfaces provided by PubNub, and (b) redistribute unmodified copies
+of the software to third parties. The software may not be incorporated in
+or used to provide any product or service competitive with the products
+and services of PubNub.
 
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
+The above copyright notice and this license shall be included
+in or with all copies or substantial portions of the software.
 
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
+This license does not grant you permission to use the trade names, trademarks,
+service marks, or product names of PubNub, except as required for reasonable
+and customary use in describing the origin of the software and reproducing
+the content of this license.
 
-PubNub Real-time Cloud-Hosted Push API and Push Notification Client Frameworks
-Copyright (c) 2013 PubNub Inc.
-http://www.pubnub.com/
-http://www.pubnub.com/terms
+THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
+EVENT SHALL PUBNUB OR THE AUTHORS OR COPYRIGHT HOLDERS OF THE SOFTWARE BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+https://www.pubnub.com/
+https://www.pubnub.com/terms

--- README.md ---
@@ -28,8 +28,8 @@ Watch [Getting Started with PubNub JS SDK](https://app.dashcam.io/replay/64ee0d2
      npm install pubnub
      ```
    * or download one of our builds from our CDN: 
-     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.3.3.js
-     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.3.3.min.js
+     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.js
+     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.min.js
 
 2. Configure your keys:
 

--- dist/web/pubnub.js ---
@@ -636,7 +636,7 @@
             this.sdkFamily = setup.sdkFamily;
             this.partnerId = setup.partnerId;
             this.setAuthKey(setup.authKey);
-            this.setCipherKey(setup.cipherKey);
+            this.cryptoModule = setup.cryptoModule;
             this.setFilterExpression(setup.filterExpression);
             if (typeof setup.origin !== 'string' && !Array.isArray(setup.origin) && setup.origin !== undefined) {
                 throw new Error('Origin must be either undefined, a string or a list of strings.');
@@ -695,6 +695,7 @@
                 }
                 this.setUUID(setup.uuid);
             }
+            this.setCipherKey(setup.cipherKey, setup);
         }
         // exposed setters
         default_1.prototype.getAuthKey = function () {
@@ -704,8 +705,15 @@
             this.authKey = val;
             return this;
         };
-        default_1.prototype.setCipherKey = function (val) {
+        default_1.prototype.setCipherKey = function (val, setup, modules) {
+            var _a;
             this.cipherKey = val;
+            if (this.cipherKey) {
+                this.cryptoModule =
+                    (_a = setup.cryptoModule) !== null && _a !== void 0 ? _a : setup.initCryptoModule({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs });
+                if (modules)
+                    modules.cryptoModule = this.cryptoModule;
+            }
             return this;
         };
         default_1.prototype.getUUID = function () {
@@ -783,7 +791,7 @@
             return this;
         };
         default_1.prototype.getVersion = function () {
-            return '7.3.3';
+            return '7.4.0';
         };
         default_1.prototype._addPnsdkSuffix = function (name, suffix) {
             this._PNSDKSuffix[name] = suffix;
@@ -841,6 +849,45 @@
         }
         return data;
     }
+    function encode$1(input) {
+        var base64 = '';
+        var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+        var bytes = new Uint8Array(input);
+        var byteLength = bytes.byteLength;
+        var byteRemainder = byteLength % 3;
+        var mainLength = byteLength - byteRemainder;
+        var a, b, c, d;
+        var chunk;
+        // Main loop deals with bytes in chunks of 3
+        for (var i = 0; i < mainLength; i = i + 3) {
+            // Combine the three bytes into a single integer
+            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
+            // Use bitmasks to extract 6-bit segments from the triplet
+            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
+            b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
+            c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
+            d = chunk & 63; // 63       = 2^6 - 1
+            // Convert the raw binary segments to the appropriate ASCII encoding
+            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
+        }
+        // Deal with the remaining bytes and padding
+        if (byteRemainder == 1) {
+            chunk = bytes[mainLength];
+            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
+            // Set the 4 least significant bits to zero
+            b = (chunk & 3) << 4; // 3   = 2^2 - 1
+            base64 += encodings[a] + encodings[b] + '==';
+        }
+        else if (byteRemainder == 2) {
+            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
+            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
+            b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
+            // Set the 2 least significant bits to zero
+            c = (chunk & 15) << 2; // 15    = 2^4 - 1
+            base64 += encodings[a] + encodings[b] + encodings[c] + '=';
+        }
+        return base64;
+    }
 
     /*eslint-disable */
     /*
@@ -1764,11 +1811,20 @@
         });
         return { promise: promise, reject: failureResolve, fulfill: successResolve };
     }
+    function stringToArrayBuffer(str) {
+        var buf = new ArrayBuffer(str.length * 2);
+        var bufView = new Uint16Array(buf);
+        for (var i = 0, strLen = str.length; i < strLen; i++) {
+            bufView[i] = str.charCodeAt(i);
+        }
+        return buf;
+    }
     var utils$5 = {
         signPamFromParams: signPamFromParams,
         endsWith: endsWith,
         createPromise: createPromise,
         encodeString: encodeString,
+        stringToArrayBuffer: stringToArrayBuffer,
     };
 
     /*       */
@@ -1795,7 +1851,7 @@
 
     var default_1$7 = /** @class */ (function () {
         function default_1(_a) {
-            var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager;
+            var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager, cryptoModule = _a.cryptoModule;
             this._listenerManager = listenerManager;
             this._config = config;
             this._leaveEndpoint = leaveEndpoint;
@@ -1804,6 +1860,7 @@
             this._subscribeEndpoint = subscribeEndpoint;
             this._getFileUrl = getFileUrl;
             this._crypto = crypto;
+            this._cryptoModule = cryptoModule;
             this._channels = {};
             this._presenceChannels = {};
             this._heartbeatChannels = {};
@@ -1819,6 +1876,8 @@
             this._isOnline = true;
             this._reconnectionManager = new default_1$9({ timeEndpoint: timeEndpoint });
             this._dedupingManager = new default_1$8({ config: config });
+            if (this._cryptoModule)
+                this._decoder = new TextDecoder();
         }
         default_1.prototype.adaptStateChange = function (args, callback) {
             var _this = this;
@@ -2286,9 +2345,20 @@
                     announce.timetoken = publishMetaData.publishTimetoken;
                     announce.publisher = message.issuingClientId;
                     var msgPayload = message.payload;
-                    if (_this._config.cipherKey) {
-                        var decryptedPayload = _this._crypto.decrypt(message.payload);
-                        if (typeof decryptedPayload === 'object' && decryptedPayload !== null) {
+                    if (_this._cryptoModule) {
+                        var decryptedPayload = void 0;
+                        try {
+                            var decryptedData = _this._cryptoModule.decrypt(message.payload);
+                            decryptedPayload =
+                                decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;
+                        }
+                        catch (e) {
+                            decryptedPayload = null;
+                            if (console && console.log) {
+                                console.log('decryption error', e.message);
+                            }
+                        }
+                        if (decryptedPayload !== null) {
                             msgPayload = decryptedPayload;
                         }
                     }
@@ -2322,8 +2392,26 @@
                     if (message.userMetadata) {
                         announce.userMetadata = message.userMetadata;
                     }
-                    if (_this._config.cipherKey) {
-                        announce.message = _this._crypto.decrypt(message.payload);
+                    if (_this._cryptoModule) {
+                        var decryptedPayload = void 0;
+                        try {
+                            var decryptedData = _this._cryptoModule.decrypt(message.payload);
+                            decryptedPayload =
+                                decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;
+                        }
+                        catch (e) {
+                            decryptedPayload = null;
+                            // eslint-disable-next-line
+                            if (console && console.log) {
+                                console.log('decryption error', e.message); //eslint-disable-line
+                            }
+                        }
+                        if (decryptedPayload != null) {
+                            announce.message = decryptedPayload;
+                        }
+                        else {
+                            announce.message = message.payload;
+                        }
                     }
                     else {
                         announce.message = message.payload;
@@ -4622,11 +4710,11 @@
     };
 
     /**       */
-    var preparePayload = function (_a, payload) {
-        var crypto = _a.crypto, config = _a.config;
+    var preparePayload = function (modules, payload) {
         var stringifiedPayload = JSON.stringify(payload);
-        if (config.cipherKey) {
-            stringifiedPayload = crypto.encrypt(stringifiedPayload);
+        if (modules.cryptoModule) {
+            var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);
+            stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode$1(encrypted);
             stringifiedPayload = JSON.stringify(stringifiedPayload);
         }
         return stringifiedPayload || '';
@@ -4681,13 +4769,13 @@
 
     var sendFile = function (_a) {
         var _this = this;
-        var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, networking = _b.networking;
+        var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, cryptoModule = _b.cryptoModule, networking = _b.networking;
         return function (_a) {
             var channel = _a.channel, input = _a.file, message = _a.message, cipherKey = _a.cipherKey, meta = _a.meta, ttl = _a.ttl, storeInHistory = _a.storeInHistory;
             return __awaiter(_this, void 0, void 0, function () {
-                var file, _b, _c, url, formFields, _d, id, name, formFieldsWithMimeType, result, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, e_1, errorBody, reason, retries, wasSuccessful, publishResult;
-                return __generator(this, function (_s) {
-                    switch (_s.label) {
+                var file, _b, _c, url, formFields, _d, id, name, _e, formFieldsWithMimeType, result, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, e_1, errorBody, reason, retries, wasSuccessful, publishResult;
+                return __generator(this, function (_t) {
+                    switch (_t.label) {
                         case 0:
                             if (!channel) {
                                 throw new PubNubError('Validation failed, check status for details', createValidationError("channel can't be empty"));
@@ -4698,13 +4786,21 @@
                             file = PubNubFile.create(input);
                             return [4 /*yield*/, generateUploadUrl({ channel: channel, name: file.name })];
                         case 1:
-                            _b = _s.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;
-                            if (!(PubNubFile.supportsEncryptFile && (cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey))) return [3 /*break*/, 3];
-                            return [4 /*yield*/, cryptography.encryptFile(cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey, file, PubNubFile)];
+                            _b = _t.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;
+                            if (!(PubNubFile.supportsEncryptFile && (cipherKey || cryptoModule))) return [3 /*break*/, 6];
+                            if (!(cipherKey == null)) return [3 /*break*/, 3];
+                            return [4 /*yield*/, cryptoModule.encryptFile(file, PubNubFile)];
                         case 2:
-                            file = _s.sent();
-                            _s.label = 3;
-                        case 3:
+                            _e = _t.sent();
+                            return [3 /*break*/, 5];
+                        case 3: return [4 /*yield*/, cryptography.encryptFile(cipherKey, file, PubNubFile)];
+                        case 4:
+                            _e = _t.sent();
+                            _t.label = 5;
+                        case 5:
+                            file = _e;
+                            _t.label = 6;
+                        case 6:
                             formFieldsWithMimeType = formFields;
                             if (file.mimeType) {
                                 formFieldsWithMimeType = formFields.map(function (entry) {
@@ -4713,48 +4809,48 @@
                                     return entry;
                                 });
                             }
-                            _s.label = 4;
-                        case 4:
-                            _s.trys.push([4, 18, , 19]);
-                            if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 7];
-                            _f = (_e = networking).POSTFILE;
-                            _g = [url, formFieldsWithMimeType];
-                            return [4 /*yield*/, file.toFileUri()];
-                        case 5: return [4 /*yield*/, _f.apply(_e, _g.concat([_s.sent()]))];
-                        case 6:
-                            result = _s.sent();
-                            return [3 /*break*/, 17];
+                            _t.label = 7;
                         case 7:
-                            if (!PubNubFile.supportsFile) return [3 /*break*/, 10];
-                            _j = (_h = networking).POSTFILE;
-                            _k = [url, formFieldsWithMimeType];
-                            return [4 /*yield*/, file.toFile()];
-                        case 8: return [4 /*yield*/, _j.apply(_h, _k.concat([_s.sent()]))];
+                            _t.trys.push([7, 21, , 22]);
+                            if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 10];
+                            _g = (_f = networking).POSTFILE;
+                            _h = [url, formFieldsWithMimeType];
+                            return [4 /*yield*/, file.toFileUri()];
+                        case 8: return [4 /*yield*/, _g.apply(_f, _h.concat([_t.sent()]))];
                         case 9:
-                            result = _s.sent();
-                            return [3 /*break*/, 17];
+                            result = _t.sent();
+                            return [3 /*break*/, 20];
                         case 10:
-                            if (!PubNubFile.supportsBuffer) return [3 /*break*/, 13];
-                            _m = (_l = networking).POSTFILE;
-                            _o = [url, formFieldsWithMimeType];
-                            return [4 /*yield*/, file.toBuffer()];
-                        case 11: return [4 /*yield*/, _m.apply(_l, _o.concat([_s.sent()]))];
+                            if (!PubNubFile.supportsFile) return [3 /*break*/, 13];
+                            _k = (_j = networking).POSTFILE;
+                            _l = [url, formFieldsWithMimeType];
+                            return [4 /*yield*/, file.toFile()];
+                        case 11: return [4 /*yield*/, _k.apply(_j, _l.concat([_t.sent()]))];
                         case 12:
-                            result = _s.sent();
-                            return [3 /*break*/, 17];
+                            result = _t.sent();
+                            return [3 /*break*/, 20];
                         case 13:
-                            if (!PubNubFile.supportsBlob) return [3 /*break*/, 16];
-                            _q = (_p = networking).POSTFILE;
-                            _r = [url, formFieldsWithMimeType];
-                            return [4 /*yield*/, file.toBlob()];
-                        case 14: return [4 /*yield*/, _q.apply(_p, _r.concat([_s.sent()]))];
+                            if (!PubNubFile.supportsBuffer) return [3 /*break*/, 16];
+                            _o = (_m = networking).POSTFILE;
+                            _p = [url, formFieldsWithMimeType];
+                            return [4 /*yield*/, file.toBuffer()];
+                        case 14: return [4 /*yield*/, _o.apply(_m, _p.concat([_t.sent()]))];
                         case 15:
-                            result = _s.sent();
-                            return [3 /*break*/, 17];
-                        case 16: throw new Error('Unsupported environment');
-                        case 17: return [3 /*break*/, 19];
+                            result = _t.sent();
+                            return [3 /*break*/, 20];
+                        case 16:
+                            if (!PubNubFile.supportsBlob) return [3 /*break*/, 19];
+                            _r = (_q = networking).POSTFILE;
+                            _s = [url, formFieldsWithMimeType];
+                            return [4 /*yield*/, file.toBlob()];
+                        case 17: return [4 /*yield*/, _r.apply(_q, _s.concat([_t.sent()]))];
                         case 18:
-                            e_1 = _s.sent();
+                            result = _t.sent();
+                            return [3 /*break*/, 20];
+                        case 19: throw new Error('Unsupported environment');
+                        case 20: return [3 /*break*/, 22];
+                        case 21:
+                            e_1 = _t.sent();
                             if (e_1.response && typeof e_1.response.text === 'string') {
                                 errorBody = e_1.response.text;
                                 reason = /<Message>(.*)<\/Message>/gi.exec(errorBody);
@@ -4763,16 +4859,16 @@
                             else {
                                 throw new PubNubError('Upload to bucket failed.', e_1);
                             }
-                        case 19:
+                        case 22:
                             if (result.status !== 204) {
                                 throw new PubNubError('Upload to bucket was unsuccessful', result);
                             }
                             retries = config.fileUploadPublishRetryLimit;
                             wasSuccessful = false;
                             publishResult = { timetoken: '0' };
-                            _s.label = 20;
-                        case 20:
-                            _s.trys.push([20, 22, , 23]);
+                            _t.label = 23;
+                        case 23:
+                            _t.trys.push([23, 25, , 26]);
                             return [4 /*yield*/, publishFile({
                                     channel: channel,
                                     message: message,
@@ -4782,19 +4878,19 @@
                                     storeInHistory: storeInHistory,
                                     ttl: ttl,
                                 })];
-                        case 21:
+                        case 24:
                             /* eslint-disable-next-line no-await-in-loop */
-                            publishResult = _s.sent();
+                            publishResult = _t.sent();
                             wasSuccessful = true;
-                            return [3 /*break*/, 23];
-                        case 22:
-                            _s.sent();
+                            return [3 /*break*/, 26];
+                        case 25:
+                            _t.sent();
                             retries -= 1;
-                            return [3 /*break*/, 23];
-                        case 23:
-                            if (!wasSuccessful && retries > 0) return [3 /*break*/, 20];
-                            _s.label = 24;
-                        case 24:
+                            return [3 /*break*/, 26];
+                        case 26:
+                            if (!wasSuccessful && retries > 0) return [3 /*break*/, 23];
+                            _t.label = 27;
+                        case 27:
                             if (!wasSuccessful) {
                                 throw new PubNubError('Publish failed. You may want to execute that operation manually using pubnub.publishFile', {
                                     channel: channel,
@@ -4861,7 +4957,7 @@
         return "".concat(networking.getStandardOrigin()).concat(url);
     });
 
-    /**       */
+    // Download_file.js
     var endpoint$g = {
         getOperation: function () { return OPERATIONS.PNDownloadFileOperation; },
         validateParams: function (_, params) {
@@ -4889,20 +4985,28 @@
         forceBuffered: function () { return true; },
         prepareParams: function () { return ({}); },
         handleResponse: function (_a, res, params) {
-            var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography;
+            var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography, cryptoModule = _a.cryptoModule;
             return __awaiter(void 0, void 0, void 0, function () {
-                var body;
-                var _b, _c, _d;
+                var body, _b;
+                var _c, _d;
                 return __generator(this, function (_e) {
                     switch (_e.label) {
                         case 0:
                             body = res.response.body;
-                            if (!(PubNubFile.supportsEncryptFile && ((_b = params.cipherKey) !== null && _b !== void 0 ? _b : config.cipherKey))) return [3 /*break*/, 2];
-                            return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];
+                            if (!(PubNubFile.supportsEncryptFile && (params.cipherKey || cryptoModule))) return [3 /*break*/, 5];
+                            if (!(params.cipherKey == null)) return [3 /*break*/, 2];
+                            return [4 /*yield*/, cryptoModule.decryptFile(PubNubFile.create({ data: body, name: params.name }), PubNubFile)];
                         case 1:
-                            body = _e.sent();
-                            _e.label = 2;
-                        case 2: return [2 /*return*/, PubNubFile.create({
+                            _b = (_e.sent()).data;
+                            return [3 /*break*/, 4];
+                        case 2: return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];
+                        case 3:
+                            _b = _e.sent();
+                            _e.label = 4;
+                        case 4:
+                            body = _b;
+                            _e.label = 5;
+                        case 5: return [2 /*return*/, PubNubFile.create({
                                 data: body,
                                 name: (_d = res.response.name) !== null && _d !== void 0 ? _d : params.name,
                                 mimeType: res.response.type,
@@ -5996,13 +6100,13 @@
 
     /*       */
     function prepareMessagePayload$1(modules, messagePayload) {
-        var crypto = modules.crypto, config = modules.config;
         var stringifiedPayload = JSON.stringify(messagePayload);
-        if (config.cipherKey) {
-            stringifiedPayload = crypto.encrypt(stringifiedPayload);
+        if (modules.cryptoModule) {
+            var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);
+            stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode$1(encrypted);
             stringifiedPayload = JSON.stringify(stringifiedPayload);
         }
-        return stringifiedPayload;
+        return stringifiedPayload || '';
     }
     function getOperation$7() {
         return OPERATIONS.PNPublishOperation;
@@ -6135,13 +6239,16 @@
 
     /*       */
     function __processMessage$1(modules, message) {
-        var config = modules.config, crypto = modules.crypto;
-        if (!config.cipherKey)
+        if (!modules.cryptoModule)
             return message;
         try {
-            return crypto.decrypt(message);
+            var decryptedData = modules.cryptoModule.decrypt(message);
+            var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;
+            return decryptedPayload;
         }
         catch (e) {
+            if (console && console.log)
+                console.log('decryption error', e.message);
             return message;
         }
     }
@@ -6331,13 +6438,16 @@
 
     /*       */
     function __processMessage(modules, message) {
-        var config = modules.config, crypto = modules.crypto;
-        if (!config.cipherKey)
+        if (!modules.cryptoModule)
             return message;
         try {
-            return crypto.decrypt(message);
+            var decryptedData = modules.cryptoModule.decrypt(message);
+            var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;
+            return decryptedPayload;
         }
         catch (e) {
+            if (console && console.log)
+                console.log('decryption error', e.message);
             return message;
         }
     }
@@ -7375,6 +7485,7 @@
                 maximumSamplesCount: 60000,
             });
             this._telemetryManager = telemetryManager;
+            var cryptoModule = this._config.cryptoModule;
             var modules = {
                 config: config,
                 networking: networking,
@@ -7383,10 +7494,23 @@
                 tokenManager: tokenManager,
                 telemetryManager: telemetryManager,
                 PubNubFile: setup.PubNubFile,
+                cryptoModule: cryptoModule,
             };
             this.File = setup.PubNubFile;
-            this.encryptFile = function (key, file) { return cryptography.encryptFile(key, file, _this.File); };
-            this.decryptFile = function (key, file) { return cryptography.decryptFile(key, file, _this.File); };
+            this.encryptFile = function (key, file) {
+                if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {
+                    file = key;
+                    return modules.cryptoModule.encryptFile(file, this.File);
+                }
+                return cryptography.encryptFile(key, file, this.File);
+            };
+            this.decryptFile = function (key, file) {
+                if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {
+                    file = key;
+                    return modules.cryptoModule.decryptFile(file, this.File);
+                }
+                return cryptography.decryptFile(key, file, this.File);
+            };
             var timeEndpoint = endpointCreator.bind(this, modules, timeEndpointConfig);
             var leaveEndpoint = endpointCreator.bind(this, modules, presenceLeaveEndpointConfig);
             var heartbeatEndpoint = endpointCreator.bind(this, modules, presenceHeartbeatEndpointConfig);
@@ -7417,6 +7541,7 @@
                     config: modules.config,
                     listenerManager: listenerManager,
                     getFileUrl: function (params) { return getFileUrlFunction(modules, params); },
+                    cryptoModule: modules.cryptoModule,
                 });
                 this.subscribe = subscriptionManager_1.adaptSubscribeChange.bind(subscriptionManager_1);
                 this.unsubscribe = subscriptionManager_1.adaptUnsubscribeChange.bind(subscriptionManager_1);
@@ -7706,18 +7831,35 @@
             this.stop = this.destroy; // --------
             // --- deprecated  ------------------
             // mount crypto
-            this.encrypt = crypto.encrypt.bind(crypto);
-            this.decrypt = crypto.decrypt.bind(crypto);
+            this.encrypt = function (data, key) {
+                if (typeof key === 'undefined' && modules.cryptoModule) {
+                    var encrypted = modules.cryptoModule.encrypt(data);
+                    return typeof encrypted === 'string' ? encrypted : encode$1(encrypted);
+                }
+                else {
+                    return crypto.encrypt(data, key);
+                }
+            };
+            this.decrypt = function (data, key) {
+                if (typeof key === 'undefined' && cryptoModule) {
+                    var decrypted = modules.cryptoModule.decrypt(data);
+                    return decrypted instanceof ArrayBuffer ? encode$1(decrypted) : decrypted;
+                }
+                else {
+                    return crypto.decrypt(data, key);
+                }
+            };
             /* config */
             this.getAuthKey = modules.config.getAuthKey.bind(modules.config);
             this.setAuthKey = modules.config.setAuthKey.bind(modules.config);
-            this.setCipherKey = modules.config.setCipherKey.bind(modules.config);
             this.getUUID = modules.config.getUUID.bind(modules.config);
             this.setUUID = modules.config.setUUID.bind(modules.config);
             this.getUserId = modules.config.getUserId.bind(modules.config);
             this.setUserId = modules.config.setUserId.bind(modules.config);
             this.getFilterExpression = modules.config.getFilterExpression.bind(modules.config);
             this.setFilterExpression = modules.config.setFilterExpression.bind(modules.config);
+            // this.setCipherKey = modules.config.setCipherKey.bind(modules.config);
+            this.setCipherKey = function (key) { return modules.config.setCipherKey(key, setup, modules); };
             this.setHeartbeatInterval = modules.config.setHeartbeatInterval.bind(modules.config);
             if (networking.hasModule('proxy')) {
                 this.setProxy = function (proxy) {
@@ -12534,10 +12676,13 @@
                 var bKey, abPlaindata, abCipherdata;
                 return __generator(this, function (_a) {
                     switch (_a.label) {
-                        case 0: return [4 /*yield*/, this.getKey(key)];
+                        case 0:
+                            if (file.data.byteLength <= 0)
+                                throw new Error('encryption error. empty content');
+                            return [4 /*yield*/, this.getKey(key)];
                         case 1:
                             bKey = _a.sent();
-                            return [4 /*yield*/, file.toArrayBuffer()];
+                            return [4 /*yield*/, file.data.arrayBuffer()];
                         case 2:
                             abPlaindata = _a.sent();
                             return [4 /*yield*/, this.encryptArrayBuffer(bKey, abPlaindata)];
@@ -12560,7 +12705,7 @@
                         case 0: return [4 /*yield*/, this.getKey(key)];
                         case 1:
                             bKey = _a.sent();
-                            return [4 /*yield*/, file.toArrayBuffer()];
+                            return [4 /*yield*/, file.data.arrayBuffer()];
                         case 2:
                             abCipherdata = _a.sent();
                             return [4 /*yield*/, this.decryptArrayBuffer(bKey, abCipherdata)];
@@ -12576,15 +12721,16 @@
         };
         WebCryptography.prototype.getKey = function (key) {
             return __awaiter(this, void 0, void 0, function () {
-                var bKey, abHash, abKey;
+                var digest, hashHex, abKey;
                 return __generator(this, function (_a) {
                     switch (_a.label) {
-                        case 0:
-                            bKey = Buffer.from(key);
-                            return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];
+                        case 0: return [4 /*yield*/, crypto.subtle.digest('SHA-256', WebCryptography.encoder.encode(key))];
                         case 1:
-                            abHash = _a.sent();
-                            abKey = Buffer.from(Buffer.from(abHash).toString('hex').slice(0, 32), 'utf8').buffer;
+                            digest = _a.sent();
+                            hashHex = Array.from(new Uint8Array(digest))
+                                .map(function (b) { return b.toString(16).padStart(2, '0'); })
+                                .join('');
+                            abKey = WebCryptography.encoder.encode(hashHex.slice(0, 32)).buffer;
                             return [2 /*return*/, crypto.subtle.importKey('raw', abKey, 'AES-CBC', true, ['encrypt', 'decrypt'])];
                     }
                 });
@@ -12607,10 +12753,18 @@
         };
         WebCryptography.prototype.decryptArrayBuffer = function (key, ciphertext) {
             return __awaiter(this, void 0, void 0, function () {
-                var abIv;
+                var abIv, data;
                 return __generator(this, function (_a) {
-                    abIv = ciphertext.slice(0, 16);
-                    return [2 /*return*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(16))];
+                    switch (_a.label) {
+                        case 0:
+                            abIv = ciphertext.slice(0, 16);
+                            if (ciphertext.slice(WebCryptography.IV_LENGTH).byteLength <= 0)
+                                throw new Error('decryption error: empty content');
+                            return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(WebCryptography.IV_LENGTH))];
+                        case 1:
+                            data = _a.sent();
+                            return [2 /*return*/, data];
+                    }
                 });
             });
         };
@@ -12621,12 +12775,12 @@
                     switch (_a.label) {
                         case 0:
                             abIv = crypto.getRandomValues(new Uint8Array(16));
-                            abPlaintext = Buffer.from(plaintext).buffer;
+                            abPlaintext = WebCryptography.encoder.encode(plaintext).buffer;
                             return [4 /*yield*/, crypto.subtle.encrypt({ name: 'AES-CBC', iv: abIv }, key, abPlaintext)];
                         case 1:
                             abPayload = _a.sent();
                             ciphertext = concatArrayBuffer(abIv.buffer, abPayload);
-                            return [2 /*return*/, Buffer.from(ciphertext).toString('utf8')];
+                            return [2 /*return*/, WebCryptography.decoder.decode(ciphertext)];
                     }
                 });
             });
@@ -12637,18 +12791,20 @@
                 return __generator(this, function (_a) {
                     switch (_a.label) {
                         case 0:
-                            abCiphertext = Buffer.from(ciphertext);
+                            abCiphertext = WebCryptography.encoder.encode(ciphertext).buffer;
                             abIv = abCiphertext.slice(0, 16);
                             abPayload = abCiphertext.slice(16);
                             return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, abPayload)];
                         case 1:
                             abPlaintext = _a.sent();
-                            return [2 /*return*/, Buffer.from(abPlaintext).toString('utf8')];
+                            return [2 /*return*/, WebCryptography.decoder.decode(abPlaintext)];
                     }
                 });
             });
         };
         WebCryptography.IV_LENGTH = 16;
+        WebCryptography.encoder = new TextEncoder();
+        WebCryptography.decoder = new TextDecoder();
         return WebCryptography;
     }());
 
@@ -12764,6 +12920,443 @@
         _a.supportsFileUri = false,
         _a);
 
+    var LegacyCryptor = /** @class */ (function () {
+        function LegacyCryptor(config) {
+            this.config = config;
+            this.cryptor = new default_1$a({ config: config });
+            this.fileCryptor = new WebCryptography();
+        }
+        Object.defineProperty(LegacyCryptor.prototype, "identifier", {
+            get: function () {
+                return '';
+            },
+            enumerable: false,
+            configurable: true
+        });
+        LegacyCryptor.prototype.encrypt = function (data) {
+            var stringData = typeof data === 'string' ? data : new TextDecoder().decode(data);
+            return {
+                data: this.cryptor.encrypt(stringData),
+                metadata: null,
+            };
+        };
+        LegacyCryptor.prototype.decrypt = function (encryptedData) {
+            var data = typeof encryptedData.data === 'string' ? encryptedData.data : encode$1(encryptedData.data);
+            return this.cryptor.decrypt(data);
+        };
+        LegacyCryptor.prototype.encryptFile = function (file, File) {
+            var _a;
+            return __awaiter(this, void 0, void 0, function () {
+                return __generator(this, function (_b) {
+                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+                    //@ts-ignore: can not detect cipherKey from old Config
+                    return [2 /*return*/, this.fileCryptor.encryptFile((_a = this.config) === null || _a === void 0 ? void 0 : _a.cipherKey, file, File)];
+                });
+            });
+        };
+        LegacyCryptor.prototype.decryptFile = function (file, File) {
+            return __awaiter(this, void 0, void 0, function () {
+                return __generator(this, function (_a) {
+                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+                    //@ts-ignore: can not detect cipherKey from old Config
+                    return [2 /*return*/, this.fileCryptor.decryptFile(this.config.cipherKey, file, File)];
+                });
+            });
+        };
+        return LegacyCryptor;
+    }());
+
+    var AesCbcCryptor = /** @class */ (function () {
+        function AesCbcCryptor(configuration) {
+            this.cipherKey = configuration.cipherKey;
+            this.CryptoJS = hmacSha256;
+            this.encryptedKey = this.CryptoJS.SHA256(this.cipherKey);
+        }
+        Object.defineProperty(AesCbcCryptor.prototype, "algo", {
+            get: function () {
+                return 'AES-CBC';
+            },
+            enumerable: false,
+            configurable: true
+        });
+        Object.defineProperty(AesCbcCryptor.prototype, "identifier", {
+            get: function () {
+                return 'ACRH';
+            },
+            enumerable: false,
+            configurable: true
+        });
+        AesCbcCryptor.prototype.getIv = function () {
+            return crypto.getRandomValues(new Uint8Array(AesCbcCryptor.BLOCK_SIZE));
+        };
+        AesCbcCryptor.prototype.getKey = function () {
+            return __awaiter(this, void 0, void 0, function () {
+                var bKey, abHash;
+                return __generator(this, function (_a) {
+                    switch (_a.label) {
+                        case 0:
+                            bKey = AesCbcCryptor.encoder.encode(this.cipherKey);
+                            return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];
+                        case 1:
+                            abHash = _a.sent();
+                            return [2 /*return*/, crypto.subtle.importKey('raw', abHash, this.algo, true, ['encrypt', 'decrypt'])];
+                    }
+                });
+            });
+        };
+        AesCbcCryptor.prototype.encrypt = function (data) {
+            var stringData = typeof data === 'string' ? data : AesCbcCryptor.decoder.decode(data);
+            if (stringData.length === 0)
+                throw new Error('encryption error. empty content');
+            var abIv = this.getIv();
+            return {
+                metadata: abIv,
+                data: decode$1(this.CryptoJS.AES.encrypt(data, this.encryptedKey, {
+                    iv: this.bufferToWordArray(abIv),
+                    mode: this.CryptoJS.mode.CBC,
+                }).ciphertext.toString(this.CryptoJS.enc.Base64)),
+            };
+        };
+        AesCbcCryptor.prototype.decrypt = function (encryptedData) {
+            var iv = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.metadata));
+            var data = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.data));
+            return AesCbcCryptor.encoder.encode(this.CryptoJS.AES.decrypt({ ciphertext: data }, this.encryptedKey, {
+                iv: iv,
+                mode: this.CryptoJS.mode.CBC,
+            }).toString(this.CryptoJS.enc.Utf8)).buffer;
+        };
+        AesCbcCryptor.prototype.encryptFileData = function (data) {
+            return __awaiter(this, void 0, void 0, function () {
+                var key, iv;
+                var _a;
+                return __generator(this, function (_b) {
+                    switch (_b.label) {
+                        case 0: return [4 /*yield*/, this.getKey()];
+                        case 1:
+                            key = _b.sent();
+                            iv = this.getIv();
+                            _a = {};
+                            return [4 /*yield*/, crypto.subtle.encrypt({ name: this.algo, iv: iv }, key, data)];
+                        case 2: return [2 /*return*/, (_a.data = _b.sent(),
+                                _a.metadata = iv,
+                                _a)];
+                    }
+                });
+            });
+        };
+        AesCbcCryptor.prototype.decryptFileData = function (encryptedData) {
+            return __awaiter(this, void 0, void 0, function () {
+                var key;
+                return __generator(this, function (_a) {
+                    switch (_a.label) {
+                        case 0: return [4 /*yield*/, this.getKey()];
+                        case 1:
+                            key = _a.sent();
+                            return [2 /*return*/, crypto.subtle.decrypt({ name: this.algo, iv: encryptedData.metadata }, key, encryptedData.data)];
+                    }
+                });
+            });
+        };
+        AesCbcCryptor.prototype.bufferToWordArray = function (b) {
+            var wa = [];
+            var i;
+            for (i = 0; i < b.length; i += 1) {
+                wa[(i / 4) | 0] |= b[i] << (24 - 8 * i);
+            }
+            return this.CryptoJS.lib.WordArray.create(wa, b.length);
+        };
+        AesCbcCryptor.BLOCK_SIZE = 16;
+        AesCbcCryptor.encoder = new TextEncoder();
+        AesCbcCryptor.decoder = new TextDecoder();
+        return AesCbcCryptor;
+    }());
+
+    var CryptoModule = /** @class */ (function () {
+        function CryptoModule(cryptoModuleConfiguration) {
+            var _a;
+            this.defaultCryptor = cryptoModuleConfiguration.default;
+            this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];
+        }
+        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+        //@ts-ignore: type detection issue with old Config type assignment
+        CryptoModule.legacyCryptoModule = function (config) {
+            var _a;
+            return new this({
+                default: new LegacyCryptor({
+                    cipherKey: config.cipherKey,
+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+                }),
+                cryptors: [new AesCbcCryptor({ cipherKey: config.cipherKey })],
+            });
+        };
+        CryptoModule.aesCbcCryptoModule = function (config) {
+            var _a;
+            return new this({
+                default: new AesCbcCryptor({ cipherKey: config.cipherKey }),
+                cryptors: [
+                    new LegacyCryptor({
+                        cipherKey: config.cipherKey,
+                        useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+                    }),
+                ],
+            });
+        };
+        CryptoModule.withDefaultCryptor = function (defaultCryptor) {
+            return new this({ default: defaultCryptor });
+        };
+        CryptoModule.prototype.getAllCryptors = function () {
+            return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);
+        };
+        CryptoModule.prototype.encrypt = function (data) {
+            var encrypted = this.defaultCryptor.encrypt(data);
+            if (!encrypted.metadata)
+                return encrypted.data;
+            var headerData = this.getHeaderData(encrypted);
+            return this.concatArrayBuffer(headerData, encrypted.data);
+        };
+        CryptoModule.prototype.decrypt = function (data) {
+            var encryptedData = typeof data === 'string' ? decode$1(data) : data;
+            var header = CryptorHeader.tryParse(encryptedData);
+            var cryptor = this.getCryptor(header);
+            var metadata = header.length > 0
+                ? encryptedData.slice(header.length - header.metadataLength, header.length)
+                : null;
+            if (encryptedData.slice(header.length).byteLength <= 0)
+                throw new Error('decryption error. empty content');
+            return cryptor.decrypt({
+                data: encryptedData.slice(header.length),
+                metadata: metadata,
+            });
+        };
+        CryptoModule.prototype.encryptFile = function (file, File) {
+            return __awaiter(this, void 0, void 0, function () {
+                var fileData, encrypted;
+                return __generator(this, function (_a) {
+                    switch (_a.label) {
+                        case 0:
+                            if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)
+                                return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];
+                            fileData = this.getFileData(file.data);
+                            return [4 /*yield*/, this.defaultCryptor.encryptFileData(fileData)];
+                        case 1:
+                            encrypted = _a.sent();
+                            return [2 /*return*/, File.create({
+                                    name: file.name,
+                                    mimeType: 'application/octet-stream',
+                                    data: this.concatArrayBuffer(this.getHeaderData(encrypted), encrypted.data),
+                                })];
+                    }
+                });
+            });
+        };
+        CryptoModule.prototype.decryptFile = function (file, File) {
+            return __awaiter(this, void 0, void 0, function () {
+                var data, header, cryptor, fileData, metadata, _a, _b;
+                var _c;
+                return __generator(this, function (_d) {
+                    switch (_d.label) {
+                        case 0: return [4 /*yield*/, file.data.arrayBuffer()];
+                        case 1:
+                            data = _d.sent();
+                            header = CryptorHeader.tryParse(data);
+                            cryptor = this.getCryptor(header);
+                            if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER) {
+                                return [2 /*return*/, cryptor.decryptFile(file, File)];
+                            }
+                            fileData = this.getFileData(data);
+                            metadata = fileData.slice(header.length - header.metadataLength, header.length);
+                            _b = (_a = File).create;
+                            _c = {
+                                name: file.name
+                            };
+                            return [4 /*yield*/, this.defaultCryptor.decryptFileData({
+                                    data: data.slice(header.length),
+                                    metadata: metadata,
+                                })];
+                        case 2: return [2 /*return*/, _b.apply(_a, [(_c.data = _d.sent(),
+                                    _c)])];
+                    }
+                });
+            });
+        };
+        CryptoModule.prototype.getCryptor = function (header) {
+            if (header === '') {
+                var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });
+                if (cryptor)
+                    return cryptor;
+                throw new Error('unknown cryptor error');
+            }
+            else if (header instanceof CryptorHeaderV1) {
+                return this.getCryptorFromId(header.identifier);
+            }
+        };
+        CryptoModule.prototype.getCryptorFromId = function (id) {
+            var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });
+            if (cryptor) {
+                return cryptor;
+            }
+            throw Error('unknown cryptor error');
+        };
+        CryptoModule.prototype.concatArrayBuffer = function (ab1, ab2) {
+            var tmp = new Uint8Array(ab1.byteLength + ab2.byteLength);
+            tmp.set(new Uint8Array(ab1), 0);
+            tmp.set(new Uint8Array(ab2), ab1.byteLength);
+            return tmp.buffer;
+        };
+        CryptoModule.prototype.getHeaderData = function (encrypted) {
+            if (!encrypted.metadata)
+                return;
+            var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);
+            var headerData = new Uint8Array(header.length);
+            var pos = 0;
+            headerData.set(header.data, pos);
+            pos += header.length - encrypted.metadata.byteLength;
+            headerData.set(new Uint8Array(encrypted.metadata), pos);
+            return headerData.buffer;
+        };
+        CryptoModule.prototype.getFileData = function (input) {
+            if (input instanceof ArrayBuffer) {
+                return input;
+            }
+            if (typeof input === 'string') {
+                return CryptoModule.encoder.encode(input);
+            }
+            throw new Error('Cannot decrypt/encrypt file. In browsers file decryption supports only string or ArrayBuffer');
+        };
+        CryptoModule.LEGACY_IDENTIFIER = '';
+        CryptoModule.encoder = new TextEncoder();
+        CryptoModule.decoder = new TextDecoder();
+        return CryptoModule;
+    }());
+    // CryptorHeader Utility
+    var CryptorHeader = /** @class */ (function () {
+        function CryptorHeader() {
+        }
+        CryptorHeader.from = function (id, metadata) {
+            if (id === CryptorHeader.LEGACY_IDENTIFIER)
+                return;
+            return new CryptorHeaderV1(id, metadata.byteLength);
+        };
+        CryptorHeader.tryParse = function (data) {
+            var encryptedData = new Uint8Array(data);
+            var sentinel = '';
+            var version = null;
+            if (encryptedData.byteLength >= 4) {
+                sentinel = encryptedData.slice(0, 4);
+                if (this.decoder.decode(sentinel) !== CryptorHeader.SENTINEL)
+                    return '';
+            }
+            if (encryptedData.byteLength >= 5) {
+                version = encryptedData[4];
+            }
+            else {
+                throw new Error('decryption error. invalid header version');
+            }
+            if (version > CryptorHeader.MAX_VERSION)
+                throw new Error('unknown cryptor error');
+            var identifier = '';
+            var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;
+            if (encryptedData.byteLength >= pos) {
+                identifier = encryptedData.slice(5, pos);
+            }
+            else {
+                throw new Error('decryption error. invalid crypto identifier');
+            }
+            var metadataLength = null;
+            if (encryptedData.byteLength >= pos + 1) {
+                metadataLength = encryptedData[pos];
+            }
+            else {
+                throw new Error('decryption error. invalid metadata length');
+            }
+            pos += 1;
+            if (metadataLength === 255 && encryptedData.byteLength >= pos + 2) {
+                metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);
+                pos += 2;
+            }
+            return new CryptorHeaderV1(this.decoder.decode(identifier), metadataLength);
+        };
+        CryptorHeader.SENTINEL = 'PNED';
+        CryptorHeader.LEGACY_IDENTIFIER = '';
+        CryptorHeader.IDENTIFIER_LENGTH = 4;
+        CryptorHeader.VERSION = 1;
+        CryptorHeader.MAX_VERSION = 1;
+        CryptorHeader.decoder = new TextDecoder();
+        return CryptorHeader;
+    }());
+    // v1 CryptorHeader
+    var CryptorHeaderV1 = /** @class */ (function () {
+        function CryptorHeaderV1(id, metadataLength) {
+            this._identifier = id;
+            this._metadataLength = metadataLength;
+        }
+        Object.defineProperty(CryptorHeaderV1.prototype, "identifier", {
+            get: function () {
+                return this._identifier;
+            },
+            set: function (value) {
+                this._identifier = value;
+            },
+            enumerable: false,
+            configurable: true
+        });
+        Object.defineProperty(CryptorHeaderV1.prototype, "metadataLength", {
+            get: function () {
+                return this._metadataLength;
+            },
+            set: function (value) {
+                this._metadataLength = value;
+            },
+            enumerable: false,
+            configurable: true
+        });
+        Object.defineProperty(CryptorHeaderV1.prototype, "version", {
+            get: function () {
+                return CryptorHeader.VERSION;
+            },
+            enumerable: false,
+            configurable: true
+        });
+        Object.defineProperty(CryptorHeaderV1.prototype, "length", {
+            get: function () {
+                return (CryptorHeader.SENTINEL.length +
+                    1 +
+                    CryptorHeader.IDENTIFIER_LENGTH +
+                    (this.metadataLength < 255 ? 1 : 3) +
+                    this.metadataLength);
+            },
+            enumerable: false,
+            configurable: true
+        });
+        Object.defineProperty(CryptorHeaderV1.prototype, "data", {
+            get: function () {
+                var pos = 0;
+                var header = new Uint8Array(this.length);
+                var encoder = new TextEncoder();
+                header.set(encoder.encode(CryptorHeader.SENTINEL));
+                pos += CryptorHeader.SENTINEL.length;
+                header[pos] = this.version;
+                pos++;
+                if (this.identifier)
+                    header.set(encoder.encode(this.identifier), pos);
+                pos += CryptorHeader.IDENTIFIER_LENGTH;
+                var metadataLength = this.metadataLength;
+                if (metadataLength < 255) {
+                    header[pos] = metadataLength;
+                }
+                else {
+                    header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);
+                }
+                return header;
+            },
+            enumerable: false,
+            configurable: true
+        });
+        CryptorHeaderV1.IDENTIFIER_LENGTH = 4;
+        CryptorHeaderV1.SENTINEL = 'PNED';
+        return CryptorHeaderV1;
+    }());
+
     /* eslint no-bitwise: ["error", { "allow": ["~", "&", ">>"] }] */
     function sendBeacon(url) {
         if (navigator && navigator.sendBeacon) {
@@ -12792,6 +13385,15 @@
             setup.cbor = new default_1$1(function (arrayBuffer) { return stringifyBufferKeys(CborReader.decode(arrayBuffer)); }, decode$1);
             setup.PubNubFile = PubNubFile;
             setup.cryptography = new WebCryptography();
+            setup.initCryptoModule = function (cryptoConfiguration) {
+                return new CryptoModule({
+                    default: new LegacyCryptor({
+                        cipherKey: cryptoConfiguration.cipherKey,
+                        useRandomIVs: cryptoConfiguration.useRandomIVs,
+                    }),
+                    cryptors: [new AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],
+                });
+            };
             _this = _super.call(this, setup) || this;
             if (listenToBrowserNetworkEvents) {
                 // mount network events.
@@ -12804,6 +13406,7 @@
             }
             return _this;
         }
+        default_1.CryptoModule = CryptoModule;
         return default_1;
     }(default_1$3));
 

--- lib/core/components/base64_codec.js ---
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.decode = void 0;
+exports.encode = exports.decode = void 0;
 var BASE64_CHARMAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
 /**
  * Decode a Base64 encoded string.
@@ -48,3 +48,43 @@ function decode(paddedInput) {
     return data;
 }
 exports.decode = decode;
+function encode(input) {
+    var base64 = '';
+    var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+    var bytes = new Uint8Array(input);
+    var byteLength = bytes.byteLength;
+    var byteRemainder = byteLength % 3;
+    var mainLength = byteLength - byteRemainder;
+    var a, b, c, d;
+    var chunk;
+    // Main loop deals with bytes in chunks of 3
+    for (var i = 0; i < mainLength; i = i + 3) {
+        // Combine the three bytes into a single integer
+        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
+        // Use bitmasks to extract 6-bit segments from the triplet
+        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
+        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
+        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
+        d = chunk & 63; // 63       = 2^6 - 1
+        // Convert the raw binary segments to the appropriate ASCII encoding
+        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
+    }
+    // Deal with the remaining bytes and padding
+    if (byteRemainder == 1) {
+        chunk = bytes[mainLength];
+        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
+        // Set the 4 least significant bits to zero
+        b = (chunk & 3) << 4; // 3   = 2^2 - 1
+        base64 += encodings[a] + encodings[b] + '==';
+    }
+    else if (byteRemainder == 2) {
+        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
+        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
+        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
+        // Set the 2 least significant bits to zero
+        c = (chunk & 15) << 2; // 15    = 2^4 - 1
+        base64 += encodings[a] + encodings[b] + encodings[c] + '=';
+    }
+    return base64;
+}
+exports.encode = encode;

--- lib/core/components/config.js ---
@@ -22,7 +22,7 @@ var default_1 = /** @class */ (function () {
         this.sdkFamily = setup.sdkFamily;
         this.partnerId = setup.partnerId;
         this.setAuthKey(setup.authKey);
-        this.setCipherKey(setup.cipherKey);
+        this.cryptoModule = setup.cryptoModule;
         this.setFilterExpression(setup.filterExpression);
         if (typeof setup.origin !== 'string' && !Array.isArray(setup.origin) && setup.origin !== undefined) {
             throw new Error('Origin must be either undefined, a string or a list of strings.');
@@ -81,6 +81,7 @@ var default_1 = /** @class */ (function () {
             }
             this.setUUID(setup.uuid);
         }
+        this.setCipherKey(setup.cipherKey, setup);
     }
     // exposed setters
     default_1.prototype.getAuthKey = function () {
@@ -90,8 +91,15 @@ var default_1 = /** @class */ (function () {
         this.authKey = val;
         return this;
     };
-    default_1.prototype.setCipherKey = function (val) {
+    default_1.prototype.setCipherKey = function (val, setup, modules) {
+        var _a;
         this.cipherKey = val;
+        if (this.cipherKey) {
+            this.cryptoModule =
+                (_a = setup.cryptoModule) !== null && _a !== void 0 ? _a : setup.initCryptoModule({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs });
+            if (modules)
+                modules.cryptoModule = this.cryptoModule;
+        }
         return this;
     };
     default_1.prototype.getUUID = function () {
@@ -169,7 +177,7 @@ var default_1 = /** @class */ (function () {
         return this;
     };
     default_1.prototype.getVersion = function () {
-        return '7.3.3';
+        return '7.4.0';
     };
     default_1.prototype._addPnsdkSuffix = function (name, suffix) {
         this._PNSDKSuffix[name] = suffix;

--- lib/core/components/subscription_manager.js ---
@@ -31,7 +31,7 @@ var utils_1 = __importDefault(require("../utils"));
 var categories_1 = __importDefault(require("../constants/categories"));
 var default_1 = /** @class */ (function () {
     function default_1(_a) {
-        var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager;
+        var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager, cryptoModule = _a.cryptoModule;
         this._listenerManager = listenerManager;
         this._config = config;
         this._leaveEndpoint = leaveEndpoint;
@@ -40,6 +40,7 @@ var default_1 = /** @class */ (function () {
         this._subscribeEndpoint = subscribeEndpoint;
         this._getFileUrl = getFileUrl;
         this._crypto = crypto;
+        this._cryptoModule = cryptoModule;
         this._channels = {};
         this._presenceChannels = {};
         this._heartbeatChannels = {};
@@ -55,6 +56,8 @@ var default_1 = /** @class */ (function () {
         this._isOnline = true;
         this._reconnectionManager = new reconnection_manager_1.default({ timeEndpoint: timeEndpoint });
         this._dedupingManager = new deduping_manager_1.default({ config: config });
+        if (this._cryptoModule)
+            this._decoder = new TextDecoder();
     }
     default_1.prototype.adaptStateChange = function (args, callback) {
         var _this = this;
@@ -522,9 +525,20 @@ var default_1 = /** @class */ (function () {
                 announce.timetoken = publishMetaData.publishTimetoken;
                 announce.publisher = message.issuingClientId;
                 var msgPayload = message.payload;
-                if (_this._config.cipherKey) {
-                    var decryptedPayload = _this._crypto.decrypt(message.payload);
-                    if (typeof decryptedPayload === 'object' && decryptedPayload !== null) {
+                if (_this._cryptoModule) {
+                    var decryptedPayload = void 0;
+                    try {
+                        var decryptedData = _this._cryptoModule.decrypt(message.payload);
+                        decryptedPayload =
+                            decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;
+                    }
+                    catch (e) {
+                        decryptedPayload = null;
+                        if (console && console.log) {
+                            console.log('decryption error', e.message);
+                        }
+                    }
+                    if (decryptedPayload !== null) {
                         msgPayload = decryptedPayload;
                     }
                 }
@@ -558,8 +572,26 @@ var default_1 = /** @class */ (function () {
                 if (message.userMetadata) {
                     announce.userMetadata = message.userMetadata;
                 }
-                if (_this._config.cipherKey) {
-                    announce.message = _this._crypto.decrypt(message.payload);
+                if (_this._cryptoModule) {
+                    var decryptedPayload = void 0;
+                    try {
+                        var decryptedData = _this._cryptoModule.decrypt(message.payload);
+                        decryptedPayload =
+                            decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;
+                    }
+                    catch (e) {
+                        decryptedPayload = null;
+                        // eslint-disable-next-line
+                        if (console && console.log) {
+                            console.log('decryption error', e.message); //eslint-disable-line
+                        }
+                    }
+                    if (decryptedPayload != null) {
+                        announce.message = decryptedPayload;
+                    }
+                    else {
+                        announce.message = message.payload;
+                    }
                 }
                 else {
                     announce.message = message.payload;

--- lib/core/endpoints/fetch_messages.js ---
@@ -8,13 +8,16 @@ exports.handleResponse = exports.prepareParams = exports.isAuthSupported = expor
 var operations_1 = __importDefault(require("../constants/operations"));
 var utils_1 = __importDefault(require("../utils"));
 function __processMessage(modules, message) {
-    var config = modules.config, crypto = modules.crypto;
-    if (!config.cipherKey)
+    if (!modules.cryptoModule)
         return message;
     try {
-        return crypto.decrypt(message);
+        var decryptedData = modules.cryptoModule.decrypt(message);
+        var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;
+        return decryptedPayload;
     }
     catch (e) {
+        if (console && console.log)
+            console.log('decryption error', e.message);
         return message;
     }
 }

--- lib/core/endpoints/file_upload/download_file.js ---
@@ -1,5 +1,5 @@
 "use strict";
-/**       */
+// Download_file.js
 var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
     function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
     return new (P || (P = Promise))(function (resolve, reject) {
@@ -40,6 +40,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
+/**       */
 var operations_1 = __importDefault(require("../../constants/operations"));
 var utils_1 = __importDefault(require("../../utils"));
 var endpoint = {
@@ -69,20 +70,28 @@ var endpoint = {
     forceBuffered: function () { return true; },
     prepareParams: function () { return ({}); },
     handleResponse: function (_a, res, params) {
-        var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography;
+        var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography, cryptoModule = _a.cryptoModule;
         return __awaiter(void 0, void 0, void 0, function () {
-            var body;
-            var _b, _c, _d;
+            var body, _b;
+            var _c, _d;
             return __generator(this, function (_e) {
                 switch (_e.label) {
                     case 0:
                         body = res.response.body;
-                        if (!(PubNubFile.supportsEncryptFile && ((_b = params.cipherKey) !== null && _b !== void 0 ? _b : config.cipherKey))) return [3 /*break*/, 2];
-                        return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];
+                        if (!(PubNubFile.supportsEncryptFile && (params.cipherKey || cryptoModule))) return [3 /*break*/, 5];
+                        if (!(params.cipherKey == null)) return [3 /*break*/, 2];
+                        return [4 /*yield*/, cryptoModule.decryptFile(PubNubFile.create({ data: body, name: params.name }), PubNubFile)];
                     case 1:
-                        body = _e.sent();
-                        _e.label = 2;
-                    case 2: return [2 /*return*/, PubNubFile.create({
+                        _b = (_e.sent()).data;
+                        return [3 /*break*/, 4];
+                    case 2: return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];
+                    case 3:
+                        _b = _e.sent();
+                        _e.label = 4;
+                    case 4:
+                        body = _b;
+                        _e.label = 5;
+                    case 5: return [2 /*return*/, PubNubFile.create({
                             data: body,
                             name: (_d = res.response.name) !== null && _d !== void 0 ? _d : params.name,
                             mimeType: res.response.type,

--- lib/core/endpoints/file_upload/publish_file.js ---
@@ -6,11 +6,12 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 Object.defineProperty(exports, "__esModule", { value: true });
 var operations_1 = __importDefault(require("../../constants/operations"));
 var utils_1 = __importDefault(require("../../utils"));
-var preparePayload = function (_a, payload) {
-    var crypto = _a.crypto, config = _a.config;
+var base64_codec_1 = require("../../components/base64_codec");
+var preparePayload = function (modules, payload) {
     var stringifiedPayload = JSON.stringify(payload);
-    if (config.cipherKey) {
-        stringifiedPayload = crypto.encrypt(stringifiedPayload);
+    if (modules.cryptoModule) {
+        var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);
+        stringifiedPayload = typeof encrypted === 'string' ? encrypted : (0, base64_codec_1.encode)(encrypted);
         stringifiedPayload = JSON.stringify(stringifiedPayload);
     }
     return stringifiedPayload || '';

--- lib/core/endpoints/file_upload/send_file.js ---
@@ -39,13 +39,13 @@ Object.defineProperty(exports, "__esModule", { value: true });
 var endpoint_1 = require("../../components/endpoint");
 var sendFile = function (_a) {
     var _this = this;
-    var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, networking = _b.networking;
+    var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, cryptoModule = _b.cryptoModule, networking = _b.networking;
     return function (_a) {
         var channel = _a.channel, input = _a.file, message = _a.message, cipherKey = _a.cipherKey, meta = _a.meta, ttl = _a.ttl, storeInHistory = _a.storeInHistory;
         return __awaiter(_this, void 0, void 0, function () {
-            var file, _b, _c, url, formFields, _d, id, name, formFieldsWithMimeType, result, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, e_1, errorBody, reason, retries, wasSuccessful, publishResult, e_2;
-            return __generator(this, function (_s) {
-                switch (_s.label) {
+            var file, _b, _c, url, formFields, _d, id, name, _e, formFieldsWithMimeType, result, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, e_1, errorBody, reason, retries, wasSuccessful, publishResult, e_2;
+            return __generator(this, function (_t) {
+                switch (_t.label) {
                     case 0:
                         if (!channel) {
                             throw new endpoint_1.PubNubError('Validation failed, check status for details', (0, endpoint_1.createValidationError)("channel can't be empty"));
@@ -56,13 +56,21 @@ var sendFile = function (_a) {
                         file = PubNubFile.create(input);
                         return [4 /*yield*/, generateUploadUrl({ channel: channel, name: file.name })];
                     case 1:
-                        _b = _s.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;
-                        if (!(PubNubFile.supportsEncryptFile && (cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey))) return [3 /*break*/, 3];
-                        return [4 /*yield*/, cryptography.encryptFile(cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey, file, PubNubFile)];
+                        _b = _t.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;
+                        if (!(PubNubFile.supportsEncryptFile && (cipherKey || cryptoModule))) return [3 /*break*/, 6];
+                        if (!(cipherKey == null)) return [3 /*break*/, 3];
+                        return [4 /*yield*/, cryptoModule.encryptFile(file, PubNubFile)];
                     case 2:
-                        file = _s.sent();
-                        _s.label = 3;
-                    case 3:
+                        _e = _t.sent();
+                        return [3 /*break*/, 5];
+                    case 3: return [4 /*yield*/, cryptography.encryptFile(cipherKey, file, PubNubFile)];
+                    case 4:
+                        _e = _t.sent();
+                        _t.label = 5;
+                    case 5:
+                        file = _e;
+                        _t.label = 6;
+                    case 6:
                         formFieldsWithMimeType = formFields;
                         if (file.mimeType) {
                             formFieldsWithMimeType = formFields.map(function (entry) {
@@ -71,48 +79,48 @@ var sendFile = function (_a) {
                                 return entry;
                             });
                         }
-                        _s.label = 4;
-                    case 4:
-                        _s.trys.push([4, 18, , 19]);
-                        if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 7];
-                        _f = (_e = networking).POSTFILE;
-                        _g = [url, formFieldsWithMimeType];
-                        return [4 /*yield*/, file.toFileUri()];
-                    case 5: return [4 /*yield*/, _f.apply(_e, _g.concat([_s.sent()]))];
-                    case 6:
-                        result = _s.sent();
-                        return [3 /*break*/, 17];
+                        _t.label = 7;
                     case 7:
-                        if (!PubNubFile.supportsFile) return [3 /*break*/, 10];
-                        _j = (_h = networking).POSTFILE;
-                        _k = [url, formFieldsWithMimeType];
-                        return [4 /*yield*/, file.toFile()];
-                    case 8: return [4 /*yield*/, _j.apply(_h, _k.concat([_s.sent()]))];
+                        _t.trys.push([7, 21, , 22]);
+                        if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 10];
+                        _g = (_f = networking).POSTFILE;
+                        _h = [url, formFieldsWithMimeType];
+                        return [4 /*yield*/, file.toFileUri()];
+                    case 8: return [4 /*yield*/, _g.apply(_f, _h.concat([_t.sent()]))];
                     case 9:
-                        result = _s.sent();
-                        return [3 /*break*/, 17];
+                        result = _t.sent();
+                        return [3 /*break*/, 20];
                     case 10:
-                        if (!PubNubFile.supportsBuffer) return [3 /*break*/, 13];
-                        _m = (_l = networking).POSTFILE;
-                        _o = [url, formFieldsWithMimeType];
-                        return [4 /*yield*/, file.toBuffer()];
-                    case 11: return [4 /*yield*/, _m.apply(_l, _o.concat([_s.sent()]))];
+                        if (!PubNubFile.supportsFile) return [3 /*break*/, 13];
+                        _k = (_j = networking).POSTFILE;
+                        _l = [url, formFieldsWithMimeType];
+                        return [4 /*yield*/, file.toFile()];
+                    case 11: return [4 /*yield*/, _k.apply(_j, _l.concat([_t.sent()]))];
                     case 12:
-                        result = _s.sent();
-                        return [3 /*break*/, 17];
+                        result = _t.sent();
+                        return [3 /*break*/, 20];
                     case 13:
-                        if (!PubNubFile.supportsBlob) return [3 /*break*/, 16];
-                        _q = (_p = networking).POSTFILE;
-                        _r = [url, formFieldsWithMimeType];
-                        return [4 /*yield*/, file.toBlob()];
-                    case 14: return [4 /*yield*/, _q.apply(_p, _r.concat([_s.sent()]))];
+                        if (!PubNubFile.supportsBuffer) return [3 /*break*/, 16];
+                        _o = (_m = networking).POSTFILE;
+                        _p = [url, formFieldsWithMimeType];
+                        return [4 /*yield*/, file.toBuffer()];
+                    case 14: return [4 /*yield*/, _o.apply(_m, _p.concat([_t.sent()]))];
                     case 15:
-                        result = _s.sent();
-                        return [3 /*break*/, 17];
-                    case 16: throw new Error('Unsupported environment');
-                    case 17: return [3 /*break*/, 19];
+                        result = _t.sent();
+                        return [3 /*break*/, 20];
+                    case 16:
+                        if (!PubNubFile.supportsBlob) return [3 /*break*/, 19];
+                        _r = (_q = networking).POSTFILE;
+                        _s = [url, formFieldsWithMimeType];
+                        return [4 /*yield*/, file.toBlob()];
+                    case 17: return [4 /*yield*/, _r.apply(_q, _s.concat([_t.sent()]))];
                     case 18:
-                        e_1 = _s.sent();
+                        result = _t.sent();
+                        return [3 /*break*/, 20];
+                    case 19: throw new Error('Unsupported environment');
+                    case 20: return [3 /*break*/, 22];
+                    case 21:
+                        e_1 = _t.sent();
                         if (e_1.response && typeof e_1.response.text === 'string') {
                             errorBody = e_1.response.text;
                             reason = /<Message>(.*)<\/Message>/gi.exec(errorBody);
@@ -121,17 +129,17 @@ var sendFile = function (_a) {
                         else {
                             throw new endpoint_1.PubNubError('Upload to bucket failed.', e_1);
                         }
-                        return [3 /*break*/, 19];
-                    case 19:
+                        return [3 /*break*/, 22];
+                    case 22:
                         if (result.status !== 204) {
                             throw new endpoint_1.PubNubError('Upload to bucket was unsuccessful', result);
                         }
                         retries = config.fileUploadPublishRetryLimit;
                         wasSuccessful = false;
                         publishResult = { timetoken: '0' };
-                        _s.label = 20;
-                    case 20:
-                        _s.trys.push([20, 22, , 23]);
+                        _t.label = 23;
+                    case 23:
+                        _t.trys.push([23, 25, , 26]);
                         return [4 /*yield*/, publishFile({
                                 channel: channel,
                                 message: message,
@@ -141,19 +149,19 @@ var sendFile = function (_a) {
                                 storeInHistory: storeInHistory,
                                 ttl: ttl,
                             })];
-                    case 21:
+                    case 24:
                         /* eslint-disable-next-line no-await-in-loop */
-                        publishResult = _s.sent();
+                        publishResult = _t.sent();
                         wasSuccessful = true;
-                        return [3 /*break*/, 23];
-                    case 22:
-                        e_2 = _s.sent();
+                        return [3 /*break*/, 26];
+                    case 25:
+                        e_2 = _t.sent();
                         retries -= 1;
-                        return [3 /*break*/, 23];
-                    case 23:
-                        if (!wasSuccessful && retries > 0) return [3 /*break*/, 20];
-                        _s.label = 24;
-                    case 24:
+                        return [3 /*break*/, 26];
+                    case 26:
+                        if (!wasSuccessful && retries > 0) return [3 /*break*/, 23];
+                        _t.label = 27;
+                    case 27:
                         if (!wasSuccessful) {
                             throw new endpoint_1.PubNubError('Publish failed. You may want to execute that operation manually using pubnub.publishFile', {
                                 channel: channel,

--- lib/core/endpoints/history/get_history.js ---
@@ -8,13 +8,16 @@ exports.handleResponse = exports.prepareParams = exports.isAuthSupported = expor
 var operations_1 = __importDefault(require("../../constants/operations"));
 var utils_1 = __importDefault(require("../../utils"));
 function __processMessage(modules, message) {
-    var config = modules.config, crypto = modules.crypto;
-    if (!config.cipherKey)
+    if (!modules.cryptoModule)
         return message;
     try {
-        return crypto.decrypt(message);
+        var decryptedData = modules.cryptoModule.decrypt(message);
+        var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;
+        return decryptedPayload;
     }
     catch (e) {
+        if (console && console.log)
+            console.log('decryption error', e.message);
         return message;
     }
 }

--- lib/core/endpoints/publish.js ---
@@ -7,14 +7,15 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.handleResponse = exports.prepareParams = exports.postPayload = exports.isAuthSupported = exports.getRequestTimeout = exports.postURL = exports.getURL = exports.usePost = exports.validateParams = exports.getOperation = void 0;
 var operations_1 = __importDefault(require("../constants/operations"));
 var utils_1 = __importDefault(require("../utils"));
+var base64_codec_1 = require("../components/base64_codec");
 function prepareMessagePayload(modules, messagePayload) {
-    var crypto = modules.crypto, config = modules.config;
     var stringifiedPayload = JSON.stringify(messagePayload);
-    if (config.cipherKey) {
-        stringifiedPayload = crypto.encrypt(stringifiedPayload);
+    if (modules.cryptoModule) {
+        var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);
+        stringifiedPayload = typeof encrypted === 'string' ? encrypted : (0, base64_codec_1.encode)(encrypted);
         stringifiedPayload = JSON.stringify(stringifiedPayload);
     }
-    return stringifiedPayload;
+    return stringifiedPayload || '';
 }
 function getOperation() {
     return operations_1.default.PNPublishOperation;

--- lib/core/pubnub-common.js ---
@@ -60,6 +60,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 Object.defineProperty(exports, "__esModule", { value: true });
 var config_1 = __importDefault(require("./components/config"));
 var index_1 = __importDefault(require("./components/cryptography/index"));
+var base64_codec_1 = require("./components/base64_codec");
 var subscription_manager_1 = __importDefault(require("./components/subscription_manager"));
 var telemetry_manager_1 = __importDefault(require("./components/telemetry_manager"));
 var push_payload_1 = __importDefault(require("./components/push_payload"));
@@ -141,6 +142,7 @@ var default_1 = /** @class */ (function () {
             maximumSamplesCount: 60000,
         });
         this._telemetryManager = telemetryManager;
+        var cryptoModule = this._config.cryptoModule;
         var modules = {
             config: config,
             networking: networking,
@@ -149,10 +151,23 @@ var default_1 = /** @class */ (function () {
             tokenManager: tokenManager,
             telemetryManager: telemetryManager,
             PubNubFile: setup.PubNubFile,
+            cryptoModule: cryptoModule,
         };
         this.File = setup.PubNubFile;
-        this.encryptFile = function (key, file) { return cryptography.encryptFile(key, file, _this.File); };
-        this.decryptFile = function (key, file) { return cryptography.decryptFile(key, file, _this.File); };
+        this.encryptFile = function (key, file) {
+            if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {
+                file = key;
+                return modules.cryptoModule.encryptFile(file, this.File);
+            }
+            return cryptography.encryptFile(key, file, this.File);
+        };
+        this.decryptFile = function (key, file) {
+            if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {
+                file = key;
+                return modules.cryptoModule.decryptFile(file, this.File);
+            }
+            return cryptography.decryptFile(key, file, this.File);
+        };
         var timeEndpoint = endpoint_1.default.bind(this, modules, timeEndpointConfig);
         var leaveEndpoint = endpoint_1.default.bind(this, modules, presenceLeaveEndpointConfig);
         var heartbeatEndpoint = endpoint_1.default.bind(this, modules, presenceHeartbeatEndpointConfig);
@@ -183,6 +198,7 @@ var default_1 = /** @class */ (function () {
                 config: modules.config,
                 listenerManager: listenerManager,
                 getFileUrl: function (params) { return (0, get_file_url_1.default)(modules, params); },
+                cryptoModule: modules.cryptoModule,
             });
             this.subscribe = subscriptionManager_1.adaptSubscribeChange.bind(subscriptionManager_1);
             this.unsubscribe = subscriptionManager_1.adaptUnsubscribeChange.bind(subscriptionManager_1);
@@ -472,18 +488,35 @@ var default_1 = /** @class */ (function () {
         this.stop = this.destroy; // --------
         // --- deprecated  ------------------
         // mount crypto
-        this.encrypt = crypto.encrypt.bind(crypto);
-        this.decrypt = crypto.decrypt.bind(crypto);
+        this.encrypt = function (data, key) {
+            if (typeof key === 'undefined' && modules.cryptoModule) {
+                var encrypted = modules.cryptoModule.encrypt(data);
+                return typeof encrypted === 'string' ? encrypted : (0, base64_codec_1.encode)(encrypted);
+            }
+            else {
+                return crypto.encrypt(data, key);
+            }
+        };
+        this.decrypt = function (data, key) {
+            if (typeof key === 'undefined' && cryptoModule) {
+                var decrypted = modules.cryptoModule.decrypt(data);
+                return decrypted instanceof ArrayBuffer ? (0, base64_codec_1.encode)(decrypted) : decrypted;
+            }
+            else {
+                return crypto.decrypt(data, key);
+            }
+        };
         /* config */
         this.getAuthKey = modules.config.getAuthKey.bind(modules.config);
         this.setAuthKey = modules.config.setAuthKey.bind(modules.config);
-        this.setCipherKey = modules.config.setCipherKey.bind(modules.config);
         this.getUUID = modules.config.getUUID.bind(modules.config);
         this.setUUID = modules.config.setUUID.bind(modules.config);
         this.getUserId = modules.config.getUserId.bind(modules.config);
         this.setUserId = modules.config.setUserId.bind(modules.config);
         this.getFilterExpression = modules.config.getFilterExpression.bind(modules.config);
         this.setFilterExpression = modules.config.setFilterExpression.bind(modules.config);
+        // this.setCipherKey = modules.config.setCipherKey.bind(modules.config);
+        this.setCipherKey = function (key) { return modules.config.setCipherKey(key, setup, modules); };
         this.setHeartbeatInterval = modules.config.setHeartbeatInterval.bind(modules.config);
         if (networking.hasModule('proxy')) {
             this.setProxy = function (proxy) {

--- lib/core/utils.js ---
@@ -26,9 +26,18 @@ function createPromise() {
     });
     return { promise: promise, reject: failureResolve, fulfill: successResolve };
 }
+function stringToArrayBuffer(str) {
+    var buf = new ArrayBuffer(str.length * 2);
+    var bufView = new Uint16Array(buf);
+    for (var i = 0, strLen = str.length; i < strLen; i++) {
+        bufView[i] = str.charCodeAt(i);
+    }
+    return buf;
+}
 module.exports = {
     signPamFromParams: signPamFromParams,
     endsWith: endsWith,
     createPromise: createPromise,
     encodeString: encodeString,
+    stringToArrayBuffer: stringToArrayBuffer,
 };

--- lib/crypto/modules/NodeCryptoModule/ICryptor.js ---
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });

--- lib/crypto/modules/NodeCryptoModule/ILegacyCryptor.js ---
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });

--- lib/crypto/modules/NodeCryptoModule/NodeCryptoModule.js ---
@@ -0,0 +1,446 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+var __read = (this && this.__read) || function (o, n) {
+    var m = typeof Symbol === "function" && o[Symbol.iterator];
+    if (!m) return o;
+    var i = m.call(o), r, ar = [], e;
+    try {
+        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
+    }
+    catch (error) { e = { error: error }; }
+    finally {
+        try {
+            if (r && !r.done && (m = i["return"])) m.call(i);
+        }
+        finally { if (e) throw e.error; }
+    }
+    return ar;
+};
+var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
+    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
+        if (ar || !(i in from)) {
+            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
+            ar[i] = from[i];
+        }
+    }
+    return to.concat(ar || Array.prototype.slice.call(from));
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CryptoModule = exports.AesCbcCryptor = exports.LegacyCryptor = void 0;
+var stream_1 = require("stream");
+var base64_codec_1 = require("../../../core/components/base64_codec");
+var legacyCryptor_1 = __importDefault(require("./legacyCryptor"));
+exports.LegacyCryptor = legacyCryptor_1.default;
+var aesCbcCryptor_1 = __importDefault(require("./aesCbcCryptor"));
+exports.AesCbcCryptor = aesCbcCryptor_1.default;
+var CryptoModule = /** @class */ (function () {
+    function CryptoModule(cryptoModuleConfiguration) {
+        var _a;
+        this.defaultCryptor = cryptoModuleConfiguration.default;
+        this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];
+    }
+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+    // @ts-ignore: type detection issue with old Config type assignment
+    CryptoModule.legacyCryptoModule = function (config) {
+        var _a;
+        return new this({
+            default: new legacyCryptor_1.default({
+                cipherKey: config.cipherKey,
+                useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+            }),
+            cryptors: [new aesCbcCryptor_1.default({ cipherKey: config.cipherKey })],
+        });
+    };
+    CryptoModule.aesCbcCryptoModule = function (config) {
+        var _a;
+        return new this({
+            default: new aesCbcCryptor_1.default({ cipherKey: config.cipherKey }),
+            cryptors: [
+                new legacyCryptor_1.default({
+                    cipherKey: config.cipherKey,
+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+                }),
+            ],
+        });
+    };
+    CryptoModule.withDefaultCryptor = function (defaultCryptor) {
+        return new this({ default: defaultCryptor });
+    };
+    CryptoModule.prototype.getAllCryptors = function () {
+        return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);
+    };
+    CryptoModule.prototype.getLegacyCryptor = function () {
+        return this.getAllCryptors().find(function (c) { return c.identifier === ''; });
+    };
+    CryptoModule.prototype.encrypt = function (data) {
+        var encrypted = this.defaultCryptor.encrypt(data);
+        if (!encrypted.metadata)
+            return encrypted.data;
+        var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);
+        var headerData = new Uint8Array(header.length);
+        var pos = 0;
+        headerData.set(header.data, pos);
+        pos = header.length - encrypted.metadata.length;
+        headerData.set(encrypted.metadata, pos);
+        return Buffer.concat([headerData, Buffer.from(encrypted.data)]);
+    };
+    CryptoModule.prototype.decrypt = function (data) {
+        var encryptedData = Buffer.from(typeof data === 'string' ? (0, base64_codec_1.decode)(data) : data);
+        var header = CryptorHeader.tryParse(encryptedData);
+        var cryptor = this.getCryptor(header);
+        var metadata = header.length > 0
+            ? encryptedData.slice(header.length - header.metadataLength, header.length)
+            : null;
+        if (encryptedData.slice(header.length).byteLength <= 0)
+            throw new Error('decryption error. empty content');
+        return cryptor.decrypt({
+            data: encryptedData.slice(header.length),
+            metadata: metadata,
+        });
+    };
+    CryptoModule.prototype.encryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var encryptedStream, header, payload, pos, output;
+            return __generator(this, function (_a) {
+                switch (_a.label) {
+                    case 0:
+                        /**
+                         * Files handled differently in case of Legacy cryptor.
+                         * (as long as we support legacy need to check on intsance type)
+                         */
+                        if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)
+                            return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];
+                        if (file.data instanceof Buffer) {
+                            return [2 /*return*/, File.create({
+                                    name: file.name,
+                                    mimeType: 'application/octet-stream',
+                                    data: Buffer.from(this.encrypt(file.data)),
+                                })];
+                        }
+                        if (!(file.data instanceof stream_1.Readable)) return [3 /*break*/, 2];
+                        if (file.contentLength === 0)
+                            throw new Error('encryption error. empty content');
+                        return [4 /*yield*/, this.defaultCryptor.encryptStream(file.data)];
+                    case 1:
+                        encryptedStream = _a.sent();
+                        header = CryptorHeader.from(this.defaultCryptor.identifier, encryptedStream.metadata);
+                        payload = new Uint8Array(header.length);
+                        pos = 0;
+                        payload.set(header.data, pos);
+                        pos += header.length;
+                        if (encryptedStream.metadata) {
+                            pos -= encryptedStream.metadata.length;
+                            payload.set(encryptedStream.metadata, pos);
+                        }
+                        output = new stream_1.PassThrough();
+                        output.write(payload);
+                        encryptedStream.stream.pipe(output);
+                        return [2 /*return*/, File.create({
+                                name: file.name,
+                                mimeType: 'application/octet-stream',
+                                stream: output,
+                            })];
+                    case 2: return [2 /*return*/];
+                }
+            });
+        });
+    };
+    CryptoModule.prototype.decryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var header, cryptor, stream_2;
+            var _this = this;
+            return __generator(this, function (_a) {
+                if ((file === null || file === void 0 ? void 0 : file.data) instanceof Buffer) {
+                    header = CryptorHeader.tryParse(file.data);
+                    cryptor = this.getCryptor(header);
+                    /**
+                     * If It's legacyone then redirect it.
+                     * (as long as we support legacy need to check on instance type)
+                     */
+                    if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER)
+                        return [2 /*return*/, cryptor.decryptFile(file, File)];
+                    return [2 /*return*/, File.create({
+                            name: file.name,
+                            data: Buffer.from(this.decrypt(file === null || file === void 0 ? void 0 : file.data)),
+                        })];
+                }
+                if (file.data instanceof stream_1.Readable) {
+                    stream_2 = file.data;
+                    return [2 /*return*/, new Promise(function (resolve) {
+                            stream_2.on('readable', function () { return resolve(_this.onStreamReadable(stream_2, file, File)); });
+                        })];
+                }
+                return [2 /*return*/];
+            });
+        });
+    };
+    CryptoModule.prototype.onStreamReadable = function (stream, file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var magicBytes, versionByte, identifier, cryptor, headerSize, _a, _b;
+            var _c;
+            return __generator(this, function (_d) {
+                switch (_d.label) {
+                    case 0:
+                        stream.removeAllListeners('readable');
+                        magicBytes = stream.read(4);
+                        if (!CryptorHeader.isSentinel(magicBytes)) {
+                            if (magicBytes === null)
+                                throw new Error('decryption error. empty content');
+                            stream.unshift(magicBytes);
+                            return [2 /*return*/, this.decryptLegacyFileStream(stream, file, File)];
+                        }
+                        versionByte = stream.read(1);
+                        CryptorHeader.validateVersion(versionByte[0]);
+                        identifier = stream.read(4);
+                        cryptor = this.getCryptorFromId(CryptorHeader.tryGetIdentifier(identifier));
+                        headerSize = CryptorHeader.tryGetMetadataSizeFromStream(stream);
+                        if (file.contentLength <= CryptorHeader.MIN_HEADER_LEGTH + headerSize)
+                            throw new Error('decryption error. empty content');
+                        _b = (_a = File).create;
+                        _c = {
+                            name: file.name,
+                            mimeType: 'application/octet-stream'
+                        };
+                        return [4 /*yield*/, cryptor.decryptStream({ stream: stream, metadataLength: headerSize })];
+                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.stream = _d.sent(),
+                                _c)])];
+                }
+            });
+        });
+    };
+    CryptoModule.prototype.decryptLegacyFileStream = function (stream, file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var cryptor;
+            return __generator(this, function (_a) {
+                if (file.contentLength <= 16)
+                    throw new Error('decryption error: empty content');
+                cryptor = this.getLegacyCryptor();
+                if (cryptor) {
+                    return [2 /*return*/, cryptor.decryptFile(File.create({
+                            name: file.name,
+                            stream: stream,
+                        }), File)];
+                }
+                else {
+                    throw new Error('unknown cryptor error');
+                }
+                return [2 /*return*/];
+            });
+        });
+    };
+    CryptoModule.prototype.getCryptor = function (header) {
+        if (header === '') {
+            var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });
+            if (cryptor)
+                return cryptor;
+            throw new Error('unknown cryptor error');
+        }
+        else if (header instanceof CryptorHeaderV1) {
+            return this.getCryptorFromId(header.identifier);
+        }
+    };
+    CryptoModule.prototype.getCryptorFromId = function (id) {
+        var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });
+        if (cryptor) {
+            return cryptor;
+        }
+        throw new Error('unknown cryptor error');
+    };
+    CryptoModule.LEGACY_IDENTIFIER = '';
+    return CryptoModule;
+}());
+exports.CryptoModule = CryptoModule;
+// CryptorHeader Utility
+var CryptorHeader = /** @class */ (function () {
+    function CryptorHeader() {
+    }
+    CryptorHeader.from = function (id, metadata) {
+        if (id === CryptorHeader.LEGACY_IDENTIFIER)
+            return;
+        return new CryptorHeaderV1(id, metadata.length);
+    };
+    CryptorHeader.isSentinel = function (bytes) {
+        if (bytes && bytes.byteLength >= 4) {
+            if (bytes.toString('utf8') == CryptorHeader.SENTINEL)
+                return true;
+        }
+    };
+    CryptorHeader.validateVersion = function (data) {
+        if (data && data > CryptorHeader.MAX_VERSION)
+            throw new Error('decryption error. invalid header version');
+        return data;
+    };
+    CryptorHeader.tryGetIdentifier = function (data) {
+        if (data.byteLength < 4) {
+            throw new Error('unknown cryptor error. decryption failed');
+        }
+        else {
+            return data.toString('utf8');
+        }
+    };
+    CryptorHeader.tryGetMetadataSizeFromStream = function (stream) {
+        var sizeBuf = stream.read(1);
+        if (sizeBuf && sizeBuf[0] < 255) {
+            return sizeBuf[0];
+        }
+        if (sizeBuf[0] === 255) {
+            var nextBuf = stream.read(2);
+            if (nextBuf.length >= 2) {
+                return new Uint16Array([nextBuf[0], nextBuf[1]]).reduce(function (acc, val) { return (acc << 8) + val; }, 0);
+            }
+        }
+        throw new Error('decryption error. Invalid metadata size');
+    };
+    CryptorHeader.tryParse = function (encryptedData) {
+        var sentinel = '';
+        var version = null;
+        if (encryptedData.length >= 4) {
+            sentinel = encryptedData.slice(0, 4);
+            if (sentinel.toString('utf8') !== CryptorHeader.SENTINEL)
+                return '';
+        }
+        if (encryptedData.length >= 5) {
+            version = encryptedData[4];
+        }
+        else {
+            throw new Error('decryption error. invalid header version');
+        }
+        if (version > CryptorHeader.MAX_VERSION)
+            throw new Error('unknown cryptor error');
+        var identifier;
+        var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;
+        if (encryptedData.length >= pos) {
+            identifier = encryptedData.slice(5, pos);
+        }
+        else {
+            throw new Error('decryption error. invalid crypto identifier');
+        }
+        var metadataLength = null;
+        if (encryptedData.length >= pos + 1) {
+            metadataLength = encryptedData[pos];
+        }
+        else {
+            throw new Error('decryption error. invalid metadata length');
+        }
+        pos += 1;
+        if (metadataLength === 255 && encryptedData.length >= pos + 2) {
+            metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);
+            pos += 2;
+        }
+        return new CryptorHeaderV1(identifier.toString('utf8'), metadataLength);
+    };
+    CryptorHeader.SENTINEL = 'PNED';
+    CryptorHeader.LEGACY_IDENTIFIER = '';
+    CryptorHeader.IDENTIFIER_LENGTH = 4;
+    CryptorHeader.VERSION = 1;
+    CryptorHeader.MAX_VERSION = 1;
+    CryptorHeader.MIN_HEADER_LEGTH = 10;
+    return CryptorHeader;
+}());
+// v1 CryptorHeader
+var CryptorHeaderV1 = /** @class */ (function () {
+    function CryptorHeaderV1(id, metadataLength) {
+        this._identifier = id;
+        this._metadataLength = metadataLength;
+    }
+    Object.defineProperty(CryptorHeaderV1.prototype, "identifier", {
+        get: function () {
+            return this._identifier;
+        },
+        set: function (value) {
+            this._identifier = value;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "metadataLength", {
+        get: function () {
+            return this._metadataLength;
+        },
+        set: function (value) {
+            this._metadataLength = value;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "version", {
+        get: function () {
+            return CryptorHeader.VERSION;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "length", {
+        get: function () {
+            return (CryptorHeader.SENTINEL.length +
+                1 +
+                CryptorHeader.IDENTIFIER_LENGTH +
+                (this.metadataLength < 255 ? 1 : 3) +
+                this.metadataLength);
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "data", {
+        get: function () {
+            var pos = 0;
+            var header = new Uint8Array(this.length);
+            header.set(Buffer.from(CryptorHeader.SENTINEL));
+            pos += CryptorHeader.SENTINEL.length;
+            header[pos] = this.version;
+            pos++;
+            if (this.identifier)
+                header.set(Buffer.from(this.identifier), pos);
+            pos += CryptorHeader.IDENTIFIER_LENGTH;
+            var metadataLength = this.metadataLength;
+            if (metadataLength < 255) {
+                header[pos] = metadataLength;
+            }
+            else {
+                header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);
+            }
+            return header;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    return CryptorHeaderV1;
+}());

--- lib/crypto/modules/NodeCryptoModule/aesCbcCryptor.js ---
@@ -0,0 +1,146 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+var stream_1 = require("stream");
+var crypto_1 = require("crypto");
+var AesCbcCryptor = /** @class */ (function () {
+    function AesCbcCryptor(configuration) {
+        this.cipherKey = configuration.cipherKey;
+    }
+    Object.defineProperty(AesCbcCryptor.prototype, "algo", {
+        get: function () {
+            return 'aes-256-cbc';
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(AesCbcCryptor.prototype, "identifier", {
+        get: function () {
+            return 'ACRH';
+        },
+        enumerable: false,
+        configurable: true
+    });
+    AesCbcCryptor.prototype.getIv = function () {
+        return (0, crypto_1.randomBytes)(AesCbcCryptor.BLOCK_SIZE);
+    };
+    AesCbcCryptor.prototype.getKey = function () {
+        var sha = (0, crypto_1.createHash)('sha256');
+        sha.update(Buffer.from(this.cipherKey, 'utf8'));
+        return Buffer.from(sha.digest());
+    };
+    AesCbcCryptor.prototype.encrypt = function (data) {
+        var iv = this.getIv();
+        var key = this.getKey();
+        var plainData = typeof data === 'string' ? new TextEncoder().encode(data) : data;
+        var bPlain = Buffer.from(plainData);
+        if (bPlain.byteLength === 0)
+            throw new Error('encryption error. empty content');
+        var aes = (0, crypto_1.createCipheriv)(this.algo, key, iv);
+        return {
+            metadata: iv,
+            data: Buffer.concat([aes.update(bPlain), aes.final()]),
+        };
+    };
+    AesCbcCryptor.prototype.decrypt = function (encryptedData) {
+        var data = typeof encryptedData.data === 'string' ? new TextEncoder().encode(encryptedData.data) : encryptedData.data;
+        if (data.byteLength <= 0)
+            throw new Error('decryption error: empty content');
+        var aes = (0, crypto_1.createDecipheriv)(this.algo, this.getKey(), encryptedData.metadata);
+        return Uint8Array.from(Buffer.concat([aes.update(data), aes.final()])).buffer;
+    };
+    AesCbcCryptor.prototype.encryptStream = function (stream) {
+        return __awaiter(this, void 0, void 0, function () {
+            var output, bIv, aes;
+            return __generator(this, function (_a) {
+                output = new stream_1.PassThrough();
+                bIv = this.getIv();
+                if (stream.readable === false)
+                    throw new Error('encryption error. empty stream');
+                aes = (0, crypto_1.createCipheriv)(this.algo, this.getKey(), bIv);
+                stream.pipe(aes).pipe(output);
+                return [2 /*return*/, {
+                        stream: output,
+                        metadata: bIv,
+                        metadataLength: AesCbcCryptor.BLOCK_SIZE,
+                    }];
+            });
+        });
+    };
+    AesCbcCryptor.prototype.decryptStream = function (encryptedStream) {
+        return __awaiter(this, void 0, void 0, function () {
+            var decryptedStream, bIv, aes, onReadable;
+            var _this = this;
+            return __generator(this, function (_a) {
+                decryptedStream = new stream_1.PassThrough();
+                bIv = Buffer.alloc(0);
+                aes = null;
+                onReadable = function () {
+                    var data = encryptedStream.stream.read();
+                    while (data !== null) {
+                        if (data) {
+                            var bChunk = Buffer.from(data);
+                            var sliceLen = encryptedStream.metadataLength - bIv.byteLength;
+                            if (bChunk.byteLength < sliceLen) {
+                                bIv = Buffer.concat([bIv, bChunk]);
+                            }
+                            else {
+                                bIv = Buffer.concat([bIv, bChunk.slice(0, sliceLen)]);
+                                aes = (0, crypto_1.createDecipheriv)(_this.algo, _this.getKey(), bIv);
+                                aes.pipe(decryptedStream);
+                                aes.write(bChunk.slice(sliceLen));
+                            }
+                        }
+                        data = encryptedStream.stream.read();
+                    }
+                };
+                encryptedStream.stream.on('readable', onReadable);
+                encryptedStream.stream.on('end', function () {
+                    if (aes) {
+                        aes.end();
+                    }
+                    decryptedStream.end();
+                });
+                return [2 /*return*/, decryptedStream];
+            });
+        });
+    };
+    AesCbcCryptor.BLOCK_SIZE = 16;
+    return AesCbcCryptor;
+}());
+exports.default = AesCbcCryptor;

--- lib/crypto/modules/NodeCryptoModule/legacyCryptor.js ---
@@ -0,0 +1,86 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+var index_1 = __importDefault(require("../../../core/components/cryptography/index"));
+var base64_codec_1 = require("../../../core/components/base64_codec");
+var node_1 = __importDefault(require("../node"));
+var LegacyCryptor = /** @class */ (function () {
+    function LegacyCryptor(config) {
+        this.config = config;
+        this.cryptor = new index_1.default({ config: config });
+        this.fileCryptor = new node_1.default();
+    }
+    Object.defineProperty(LegacyCryptor.prototype, "identifier", {
+        get: function () {
+            return '';
+        },
+        enumerable: false,
+        configurable: true
+    });
+    LegacyCryptor.prototype.encrypt = function (data) {
+        if (data.length === 0)
+            throw new Error('encryption error. empty content');
+        return {
+            data: this.cryptor.encrypt(data),
+            metadata: null,
+        };
+    };
+    LegacyCryptor.prototype.decrypt = function (encryptedData) {
+        var data = typeof encryptedData.data === 'string' ? encryptedData.data : (0, base64_codec_1.encode)(encryptedData.data);
+        return this.cryptor.decrypt(data);
+    };
+    LegacyCryptor.prototype.encryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            return __generator(this, function (_a) {
+                return [2 /*return*/, this.fileCryptor.encryptFile(this.config.cipherKey, file, File)];
+            });
+        });
+    };
+    LegacyCryptor.prototype.decryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            return __generator(this, function (_a) {
+                return [2 /*return*/, this.fileCryptor.decryptFile(this.config.cipherKey, file, File)];
+            });
+        });
+    };
+    return LegacyCryptor;
+}());
+exports.default = LegacyCryptor;

--- lib/crypto/modules/NodeCryptoModule/nodeCryptoModule.js ---
@@ -0,0 +1,446 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+var __read = (this && this.__read) || function (o, n) {
+    var m = typeof Symbol === "function" && o[Symbol.iterator];
+    if (!m) return o;
+    var i = m.call(o), r, ar = [], e;
+    try {
+        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
+    }
+    catch (error) { e = { error: error }; }
+    finally {
+        try {
+            if (r && !r.done && (m = i["return"])) m.call(i);
+        }
+        finally { if (e) throw e.error; }
+    }
+    return ar;
+};
+var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
+    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
+        if (ar || !(i in from)) {
+            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
+            ar[i] = from[i];
+        }
+    }
+    return to.concat(ar || Array.prototype.slice.call(from));
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CryptoModule = exports.AesCbcCryptor = exports.LegacyCryptor = void 0;
+var stream_1 = require("stream");
+var base64_codec_1 = require("../../../core/components/base64_codec");
+var legacyCryptor_1 = __importDefault(require("./legacyCryptor"));
+exports.LegacyCryptor = legacyCryptor_1.default;
+var aesCbcCryptor_1 = __importDefault(require("./aesCbcCryptor"));
+exports.AesCbcCryptor = aesCbcCryptor_1.default;
+var CryptoModule = /** @class */ (function () {
+    function CryptoModule(cryptoModuleConfiguration) {
+        var _a;
+        this.defaultCryptor = cryptoModuleConfiguration.default;
+        this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];
+    }
+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+    // @ts-ignore: type detection issue with old Config type assignment
+    CryptoModule.legacyCryptoModule = function (config) {
+        var _a;
+        return new this({
+            default: new legacyCryptor_1.default({
+                cipherKey: config.cipherKey,
+                useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+            }),
+            cryptors: [new aesCbcCryptor_1.default({ cipherKey: config.cipherKey })],
+        });
+    };
+    CryptoModule.aesCbcCryptoModule = function (config) {
+        var _a;
+        return new this({
+            default: new aesCbcCryptor_1.default({ cipherKey: config.cipherKey }),
+            cryptors: [
+                new legacyCryptor_1.default({
+                    cipherKey: config.cipherKey,
+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+                }),
+            ],
+        });
+    };
+    CryptoModule.withDefaultCryptor = function (defaultCryptor) {
+        return new this({ default: defaultCryptor });
+    };
+    CryptoModule.prototype.getAllCryptors = function () {
+        return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);
+    };
+    CryptoModule.prototype.getLegacyCryptor = function () {
+        return this.getAllCryptors().find(function (c) { return c.identifier === ''; });
+    };
+    CryptoModule.prototype.encrypt = function (data) {
+        var encrypted = this.defaultCryptor.encrypt(data);
+        if (!encrypted.metadata)
+            return encrypted.data;
+        var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);
+        var headerData = new Uint8Array(header.length);
+        var pos = 0;
+        headerData.set(header.data, pos);
+        pos = header.length - encrypted.metadata.length;
+        headerData.set(encrypted.metadata, pos);
+        return Buffer.concat([headerData, Buffer.from(encrypted.data)]);
+    };
+    CryptoModule.prototype.decrypt = function (data) {
+        var encryptedData = Buffer.from(typeof data === 'string' ? (0, base64_codec_1.decode)(data) : data);
+        var header = CryptorHeader.tryParse(encryptedData);
+        var cryptor = this.getCryptor(header);
+        var metadata = header.length > 0
+            ? encryptedData.slice(header.length - header.metadataLength, header.length)
+            : null;
+        if (encryptedData.slice(header.length).byteLength <= 0)
+            throw new Error('decryption error. empty content');
+        return cryptor.decrypt({
+            data: encryptedData.slice(header.length),
+            metadata: metadata,
+        });
+    };
+    CryptoModule.prototype.encryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var encryptedStream, header, payload, pos, output;
+            return __generator(this, function (_a) {
+                switch (_a.label) {
+                    case 0:
+                        /**
+                         * Files handled differently in case of Legacy cryptor.
+                         * (as long as we support legacy need to check on intsance type)
+                         */
+                        if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)
+                            return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];
+                        if (file.data instanceof Buffer) {
+                            return [2 /*return*/, File.create({
+                                    name: file.name,
+                                    mimeType: 'application/octet-stream',
+                                    data: Buffer.from(this.encrypt(file.data)),
+                                })];
+                        }
+                        if (!(file.data instanceof stream_1.Readable)) return [3 /*break*/, 2];
+                        if (file.contentLength === 0)
+                            throw new Error('encryption error. empty content');
+                        return [4 /*yield*/, this.defaultCryptor.encryptStream(file.data)];
+                    case 1:
+                        encryptedStream = _a.sent();
+                        header = CryptorHeader.from(this.defaultCryptor.identifier, encryptedStream.metadata);
+                        payload = new Uint8Array(header.length);
+                        pos = 0;
+                        payload.set(header.data, pos);
+                        pos += header.length;
+                        if (encryptedStream.metadata) {
+                            pos -= encryptedStream.metadata.length;
+                            payload.set(encryptedStream.metadata, pos);
+                        }
+                        output = new stream_1.PassThrough();
+                        output.write(payload);
+                        encryptedStream.stream.pipe(output);
+                        return [2 /*return*/, File.create({
+                                name: file.name,
+                                mimeType: 'application/octet-stream',
+                                stream: output,
+                            })];
+                    case 2: return [2 /*return*/];
+                }
+            });
+        });
+    };
+    CryptoModule.prototype.decryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var header, cryptor, stream_2;
+            var _this = this;
+            return __generator(this, function (_a) {
+                if ((file === null || file === void 0 ? void 0 : file.data) instanceof Buffer) {
+                    header = CryptorHeader.tryParse(file.data);
+                    cryptor = this.getCryptor(header);
+                    /**
+                     * If It's legacyone then redirect it.
+                     * (as long as we support legacy need to check on instance type)
+                     */
+                    if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER)
+                        return [2 /*return*/, cryptor.decryptFile(file, File)];
+                    return [2 /*return*/, File.create({
+                            name: file.name,
+                            data: Buffer.from(this.decrypt(file === null || file === void 0 ? void 0 : file.data)),
+                        })];
+                }
+                if (file.data instanceof stream_1.Readable) {
+                    stream_2 = file.data;
+                    return [2 /*return*/, new Promise(function (resolve) {
+                            stream_2.on('readable', function () { return resolve(_this.onStreamReadable(stream_2, file, File)); });
+                        })];
+                }
+                return [2 /*return*/];
+            });
+        });
+    };
+    CryptoModule.prototype.onStreamReadable = function (stream, file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var magicBytes, versionByte, identifier, cryptor, headerSize, _a, _b;
+            var _c;
+            return __generator(this, function (_d) {
+                switch (_d.label) {
+                    case 0:
+                        stream.removeAllListeners('readable');
+                        magicBytes = stream.read(4);
+                        if (!CryptorHeader.isSentinel(magicBytes)) {
+                            if (magicBytes === null)
+                                throw new Error('decryption error. empty content');
+                            stream.unshift(magicBytes);
+                            return [2 /*return*/, this.decryptLegacyFileStream(stream, file, File)];
+                        }
+                        versionByte = stream.read(1);
+                        CryptorHeader.validateVersion(versionByte[0]);
+                        identifier = stream.read(4);
+                        cryptor = this.getCryptorFromId(CryptorHeader.tryGetIdentifier(identifier));
+                        headerSize = CryptorHeader.tryGetMetadataSizeFromStream(stream);
+                        if (file.contentLength <= CryptorHeader.MIN_HEADER_LEGTH + headerSize)
+                            throw new Error('decryption error. empty content');
+                        _b = (_a = File).create;
+                        _c = {
+                            name: file.name,
+                            mimeType: 'application/octet-stream'
+                        };
+                        return [4 /*yield*/, cryptor.decryptStream({ stream: stream, metadataLength: headerSize })];
+                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.stream = _d.sent(),
+                                _c)])];
+                }
+            });
+        });
+    };
+    CryptoModule.prototype.decryptLegacyFileStream = function (stream, file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var cryptor;
+            return __generator(this, function (_a) {
+                if (file.contentLength <= 16)
+                    throw new Error('decryption error: empty content');
+                cryptor = this.getLegacyCryptor();
+                if (cryptor) {
+                    return [2 /*return*/, cryptor.decryptFile(File.create({
+                            name: file.name,
+                            stream: stream,
+                        }), File)];
+                }
+                else {
+                    throw new Error('unknown cryptor error');
+                }
+                return [2 /*return*/];
+            });
+        });
+    };
+    CryptoModule.prototype.getCryptor = function (header) {
+        if (header === '') {
+            var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });
+            if (cryptor)
+                return cryptor;
+            throw new Error('unknown cryptor error');
+        }
+        else if (header instanceof CryptorHeaderV1) {
+            return this.getCryptorFromId(header.identifier);
+        }
+    };
+    CryptoModule.prototype.getCryptorFromId = function (id) {
+        var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });
+        if (cryptor) {
+            return cryptor;
+        }
+        throw new Error('unknown cryptor error');
+    };
+    CryptoModule.LEGACY_IDENTIFIER = '';
+    return CryptoModule;
+}());
+exports.CryptoModule = CryptoModule;
+// CryptorHeader Utility
+var CryptorHeader = /** @class */ (function () {
+    function CryptorHeader() {
+    }
+    CryptorHeader.from = function (id, metadata) {
+        if (id === CryptorHeader.LEGACY_IDENTIFIER)
+            return;
+        return new CryptorHeaderV1(id, metadata.length);
+    };
+    CryptorHeader.isSentinel = function (bytes) {
+        if (bytes && bytes.byteLength >= 4) {
+            if (bytes.toString('utf8') == CryptorHeader.SENTINEL)
+                return true;
+        }
+    };
+    CryptorHeader.validateVersion = function (data) {
+        if (data && data > CryptorHeader.MAX_VERSION)
+            throw new Error('decryption error. invalid header version');
+        return data;
+    };
+    CryptorHeader.tryGetIdentifier = function (data) {
+        if (data.byteLength < 4) {
+            throw new Error('unknown cryptor error. decryption failed');
+        }
+        else {
+            return data.toString('utf8');
+        }
+    };
+    CryptorHeader.tryGetMetadataSizeFromStream = function (stream) {
+        var sizeBuf = stream.read(1);
+        if (sizeBuf && sizeBuf[0] < 255) {
+            return sizeBuf[0];
+        }
+        if (sizeBuf[0] === 255) {
+            var nextBuf = stream.read(2);
+            if (nextBuf.length >= 2) {
+                return new Uint16Array([nextBuf[0], nextBuf[1]]).reduce(function (acc, val) { return (acc << 8) + val; }, 0);
+            }
+        }
+        throw new Error('decryption error. Invalid metadata size');
+    };
+    CryptorHeader.tryParse = function (encryptedData) {
+        var sentinel = '';
+        var version = null;
+        if (encryptedData.length >= 4) {
+            sentinel = encryptedData.slice(0, 4);
+            if (sentinel.toString('utf8') !== CryptorHeader.SENTINEL)
+                return '';
+        }
+        if (encryptedData.length >= 5) {
+            version = encryptedData[4];
+        }
+        else {
+            throw new Error('decryption error. invalid header version');
+        }
+        if (version > CryptorHeader.MAX_VERSION)
+            throw new Error('unknown cryptor error');
+        var identifier;
+        var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;
+        if (encryptedData.length >= pos) {
+            identifier = encryptedData.slice(5, pos);
+        }
+        else {
+            throw new Error('decryption error. invalid crypto identifier');
+        }
+        var metadataLength = null;
+        if (encryptedData.length >= pos + 1) {
+            metadataLength = encryptedData[pos];
+        }
+        else {
+            throw new Error('decryption error. invalid metadata length');
+        }
+        pos += 1;
+        if (metadataLength === 255 && encryptedData.length >= pos + 2) {
+            metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);
+            pos += 2;
+        }
+        return new CryptorHeaderV1(identifier.toString('utf8'), metadataLength);
+    };
+    CryptorHeader.SENTINEL = 'PNED';
+    CryptorHeader.LEGACY_IDENTIFIER = '';
+    CryptorHeader.IDENTIFIER_LENGTH = 4;
+    CryptorHeader.VERSION = 1;
+    CryptorHeader.MAX_VERSION = 1;
+    CryptorHeader.MIN_HEADER_LEGTH = 10;
+    return CryptorHeader;
+}());
+// v1 CryptorHeader
+var CryptorHeaderV1 = /** @class */ (function () {
+    function CryptorHeaderV1(id, metadataLength) {
+        this._identifier = id;
+        this._metadataLength = metadataLength;
+    }
+    Object.defineProperty(CryptorHeaderV1.prototype, "identifier", {
+        get: function () {
+            return this._identifier;
+        },
+        set: function (value) {
+            this._identifier = value;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "metadataLength", {
+        get: function () {
+            return this._metadataLength;
+        },
+        set: function (value) {
+            this._metadataLength = value;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "version", {
+        get: function () {
+            return CryptorHeader.VERSION;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "length", {
+        get: function () {
+            return (CryptorHeader.SENTINEL.length +
+                1 +
+                CryptorHeader.IDENTIFIER_LENGTH +
+                (this.metadataLength < 255 ? 1 : 3) +
+                this.metadataLength);
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "data", {
+        get: function () {
+            var pos = 0;
+            var header = new Uint8Array(this.length);
+            header.set(Buffer.from(CryptorHeader.SENTINEL));
+            pos += CryptorHeader.SENTINEL.length;
+            header[pos] = this.version;
+            pos++;
+            if (this.identifier)
+                header.set(Buffer.from(this.identifier), pos);
+            pos += CryptorHeader.IDENTIFIER_LENGTH;
+            var metadataLength = this.metadataLength;
+            if (metadataLength < 255) {
+                header[pos] = metadataLength;
+            }
+            else {
+                header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);
+            }
+            return header;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    return CryptorHeaderV1;
+}());

--- lib/crypto/modules/WebCryptoModule/ICryptor.js ---
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });

--- lib/crypto/modules/WebCryptoModule/ILegacyCryptor.js ---
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });

--- lib/crypto/modules/WebCryptoModule/aesCbcCryptor.js ---
@@ -0,0 +1,148 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+var hmac_sha256_1 = __importDefault(require("../../../core/components/cryptography/hmac-sha256"));
+var base64_codec_1 = require("../../../core/components/base64_codec");
+var AesCbcCryptor = /** @class */ (function () {
+    function AesCbcCryptor(configuration) {
+        this.cipherKey = configuration.cipherKey;
+        this.CryptoJS = hmac_sha256_1.default;
+        this.encryptedKey = this.CryptoJS.SHA256(this.cipherKey);
+    }
+    Object.defineProperty(AesCbcCryptor.prototype, "algo", {
+        get: function () {
+            return 'AES-CBC';
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(AesCbcCryptor.prototype, "identifier", {
+        get: function () {
+            return 'ACRH';
+        },
+        enumerable: false,
+        configurable: true
+    });
+    AesCbcCryptor.prototype.getIv = function () {
+        return crypto.getRandomValues(new Uint8Array(AesCbcCryptor.BLOCK_SIZE));
+    };
+    AesCbcCryptor.prototype.getKey = function () {
+        return __awaiter(this, void 0, void 0, function () {
+            var bKey, abHash;
+            return __generator(this, function (_a) {
+                switch (_a.label) {
+                    case 0:
+                        bKey = AesCbcCryptor.encoder.encode(this.cipherKey);
+                        return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];
+                    case 1:
+                        abHash = _a.sent();
+                        return [2 /*return*/, crypto.subtle.importKey('raw', abHash, this.algo, true, ['encrypt', 'decrypt'])];
+                }
+            });
+        });
+    };
+    AesCbcCryptor.prototype.encrypt = function (data) {
+        var stringData = typeof data === 'string' ? data : AesCbcCryptor.decoder.decode(data);
+        if (stringData.length === 0)
+            throw new Error('encryption error. empty content');
+        var abIv = this.getIv();
+        return {
+            metadata: abIv,
+            data: (0, base64_codec_1.decode)(this.CryptoJS.AES.encrypt(data, this.encryptedKey, {
+                iv: this.bufferToWordArray(abIv),
+                mode: this.CryptoJS.mode.CBC,
+            }).ciphertext.toString(this.CryptoJS.enc.Base64)),
+        };
+    };
+    AesCbcCryptor.prototype.decrypt = function (encryptedData) {
+        var iv = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.metadata));
+        var data = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.data));
+        return AesCbcCryptor.encoder.encode(this.CryptoJS.AES.decrypt({ ciphertext: data }, this.encryptedKey, {
+            iv: iv,
+            mode: this.CryptoJS.mode.CBC,
+        }).toString(this.CryptoJS.enc.Utf8)).buffer;
+    };
+    AesCbcCryptor.prototype.encryptFileData = function (data) {
+        return __awaiter(this, void 0, void 0, function () {
+            var key, iv;
+            var _a;
+            return __generator(this, function (_b) {
+                switch (_b.label) {
+                    case 0: return [4 /*yield*/, this.getKey()];
+                    case 1:
+                        key = _b.sent();
+                        iv = this.getIv();
+                        _a = {};
+                        return [4 /*yield*/, crypto.subtle.encrypt({ name: this.algo, iv: iv }, key, data)];
+                    case 2: return [2 /*return*/, (_a.data = _b.sent(),
+                            _a.metadata = iv,
+                            _a)];
+                }
+            });
+        });
+    };
+    AesCbcCryptor.prototype.decryptFileData = function (encryptedData) {
+        return __awaiter(this, void 0, void 0, function () {
+            var key;
+            return __generator(this, function (_a) {
+                switch (_a.label) {
+                    case 0: return [4 /*yield*/, this.getKey()];
+                    case 1:
+                        key = _a.sent();
+                        return [2 /*return*/, crypto.subtle.decrypt({ name: this.algo, iv: encryptedData.metadata }, key, encryptedData.data)];
+                }
+            });
+        });
+    };
+    AesCbcCryptor.prototype.bufferToWordArray = function (b) {
+        var wa = [];
+        var i;
+        for (i = 0; i < b.length; i += 1) {
+            wa[(i / 4) | 0] |= b[i] << (24 - 8 * i);
+        }
+        return this.CryptoJS.lib.WordArray.create(wa, b.length);
+    };
+    AesCbcCryptor.BLOCK_SIZE = 16;
+    AesCbcCryptor.encoder = new TextEncoder();
+    AesCbcCryptor.decoder = new TextDecoder();
+    return AesCbcCryptor;
+}());
+exports.default = AesCbcCryptor;

--- lib/crypto/modules/WebCryptoModule/legacyCryptor.js ---
@@ -0,0 +1,90 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+var index_1 = __importDefault(require("../../../core/components/cryptography/index"));
+var web_1 = __importDefault(require("../web"));
+var base64_codec_1 = require("../../../core/components/base64_codec");
+var LegacyCryptor = /** @class */ (function () {
+    function LegacyCryptor(config) {
+        this.config = config;
+        this.cryptor = new index_1.default({ config: config });
+        this.fileCryptor = new web_1.default();
+    }
+    Object.defineProperty(LegacyCryptor.prototype, "identifier", {
+        get: function () {
+            return '';
+        },
+        enumerable: false,
+        configurable: true
+    });
+    LegacyCryptor.prototype.encrypt = function (data) {
+        var stringData = typeof data === 'string' ? data : new TextDecoder().decode(data);
+        return {
+            data: this.cryptor.encrypt(stringData),
+            metadata: null,
+        };
+    };
+    LegacyCryptor.prototype.decrypt = function (encryptedData) {
+        var data = typeof encryptedData.data === 'string' ? encryptedData.data : (0, base64_codec_1.encode)(encryptedData.data);
+        return this.cryptor.decrypt(data);
+    };
+    LegacyCryptor.prototype.encryptFile = function (file, File) {
+        var _a;
+        return __awaiter(this, void 0, void 0, function () {
+            return __generator(this, function (_b) {
+                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+                //@ts-ignore: can not detect cipherKey from old Config
+                return [2 /*return*/, this.fileCryptor.encryptFile((_a = this.config) === null || _a === void 0 ? void 0 : _a.cipherKey, file, File)];
+            });
+        });
+    };
+    LegacyCryptor.prototype.decryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            return __generator(this, function (_a) {
+                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+                //@ts-ignore: can not detect cipherKey from old Config
+                return [2 /*return*/, this.fileCryptor.decryptFile(this.config.cipherKey, file, File)];
+            });
+        });
+    };
+    return LegacyCryptor;
+}());
+exports.default = LegacyCryptor;

--- lib/crypto/modules/WebCryptoModule/webCryptoModule.js ---
@@ -0,0 +1,358 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+var __read = (this && this.__read) || function (o, n) {
+    var m = typeof Symbol === "function" && o[Symbol.iterator];
+    if (!m) return o;
+    var i = m.call(o), r, ar = [], e;
+    try {
+        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
+    }
+    catch (error) { e = { error: error }; }
+    finally {
+        try {
+            if (r && !r.done && (m = i["return"])) m.call(i);
+        }
+        finally { if (e) throw e.error; }
+    }
+    return ar;
+};
+var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
+    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
+        if (ar || !(i in from)) {
+            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
+            ar[i] = from[i];
+        }
+    }
+    return to.concat(ar || Array.prototype.slice.call(from));
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CryptoModule = exports.AesCbcCryptor = exports.LegacyCryptor = void 0;
+var legacyCryptor_1 = __importDefault(require("./legacyCryptor"));
+exports.LegacyCryptor = legacyCryptor_1.default;
+var aesCbcCryptor_1 = __importDefault(require("./aesCbcCryptor"));
+exports.AesCbcCryptor = aesCbcCryptor_1.default;
+var base64_codec_1 = require("../../../core/components/base64_codec");
+var CryptoModule = /** @class */ (function () {
+    function CryptoModule(cryptoModuleConfiguration) {
+        var _a;
+        this.defaultCryptor = cryptoModuleConfiguration.default;
+        this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];
+    }
+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+    //@ts-ignore: type detection issue with old Config type assignment
+    CryptoModule.legacyCryptoModule = function (config) {
+        var _a;
+        return new this({
+            default: new legacyCryptor_1.default({
+                cipherKey: config.cipherKey,
+                useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+            }),
+            cryptors: [new aesCbcCryptor_1.default({ cipherKey: config.cipherKey })],
+        });
+    };
+    CryptoModule.aesCbcCryptoModule = function (config) {
+        var _a;
+        return new this({
+            default: new aesCbcCryptor_1.default({ cipherKey: config.cipherKey }),
+            cryptors: [
+                new legacyCryptor_1.default({
+                    cipherKey: config.cipherKey,
+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,
+                }),
+            ],
+        });
+    };
+    CryptoModule.withDefaultCryptor = function (defaultCryptor) {
+        return new this({ default: defaultCryptor });
+    };
+    CryptoModule.prototype.getAllCryptors = function () {
+        return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);
+    };
+    CryptoModule.prototype.encrypt = function (data) {
+        var encrypted = this.defaultCryptor.encrypt(data);
+        if (!encrypted.metadata)
+            return encrypted.data;
+        var headerData = this.getHeaderData(encrypted);
+        return this.concatArrayBuffer(headerData, encrypted.data);
+    };
+    CryptoModule.prototype.decrypt = function (data) {
+        var encryptedData = typeof data === 'string' ? (0, base64_codec_1.decode)(data) : data;
+        var header = CryptorHeader.tryParse(encryptedData);
+        var cryptor = this.getCryptor(header);
+        var metadata = header.length > 0
+            ? encryptedData.slice(header.length - header.metadataLength, header.length)
+            : null;
+        if (encryptedData.slice(header.length).byteLength <= 0)
+            throw new Error('decryption error. empty content');
+        return cryptor.decrypt({
+            data: encryptedData.slice(header.length),
+            metadata: metadata,
+        });
+    };
+    CryptoModule.prototype.encryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var fileData, encrypted;
+            return __generator(this, function (_a) {
+                switch (_a.label) {
+                    case 0:
+                        if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)
+                            return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];
+                        fileData = this.getFileData(file.data);
+                        return [4 /*yield*/, this.defaultCryptor.encryptFileData(fileData)];
+                    case 1:
+                        encrypted = _a.sent();
+                        return [2 /*return*/, File.create({
+                                name: file.name,
+                                mimeType: 'application/octet-stream',
+                                data: this.concatArrayBuffer(this.getHeaderData(encrypted), encrypted.data),
+                            })];
+                }
+            });
+        });
+    };
+    CryptoModule.prototype.decryptFile = function (file, File) {
+        return __awaiter(this, void 0, void 0, function () {
+            var data, header, cryptor, fileData, metadata, _a, _b;
+            var _c;
+            return __generator(this, function (_d) {
+                switch (_d.label) {
+                    case 0: return [4 /*yield*/, file.data.arrayBuffer()];
+                    case 1:
+                        data = _d.sent();
+                        header = CryptorHeader.tryParse(data);
+                        cryptor = this.getCryptor(header);
+                        if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER) {
+                            return [2 /*return*/, cryptor.decryptFile(file, File)];
+                        }
+                        fileData = this.getFileData(data);
+                        metadata = fileData.slice(header.length - header.metadataLength, header.length);
+                        _b = (_a = File).create;
+                        _c = {
+                            name: file.name
+                        };
+                        return [4 /*yield*/, this.defaultCryptor.decryptFileData({
+                                data: data.slice(header.length),
+                                metadata: metadata,
+                            })];
+                    case 2: return [2 /*return*/, _b.apply(_a, [(_c.data = _d.sent(),
+                                _c)])];
+                }
+            });
+        });
+    };
+    CryptoModule.prototype.getCryptor = function (header) {
+        if (header === '') {
+            var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });
+            if (cryptor)
+                return cryptor;
+            throw new Error('unknown cryptor error');
+        }
+        else if (header instanceof CryptorHeaderV1) {
+            return this.getCryptorFromId(header.identifier);
+        }
+    };
+    CryptoModule.prototype.getCryptorFromId = function (id) {
+        var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });
+        if (cryptor) {
+            return cryptor;
+        }
+        throw Error('unknown cryptor error');
+    };
+    CryptoModule.prototype.concatArrayBuffer = function (ab1, ab2) {
+        var tmp = new Uint8Array(ab1.byteLength + ab2.byteLength);
+        tmp.set(new Uint8Array(ab1), 0);
+        tmp.set(new Uint8Array(ab2), ab1.byteLength);
+        return tmp.buffer;
+    };
+    CryptoModule.prototype.getHeaderData = function (encrypted) {
+        if (!encrypted.metadata)
+            return;
+        var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);
+        var headerData = new Uint8Array(header.length);
+        var pos = 0;
+        headerData.set(header.data, pos);
+        pos += header.length - encrypted.metadata.byteLength;
+        headerData.set(new Uint8Array(encrypted.metadata), pos);
+        return headerData.buffer;
+    };
+    CryptoModule.prototype.getFileData = function (input) {
+        if (input instanceof ArrayBuffer) {
+            return input;
+        }
+        if (typeof input === 'string') {
+            return CryptoModule.encoder.encode(input);
+        }
+        throw new Error('Cannot decrypt/encrypt file. In browsers file decryption supports only string or ArrayBuffer');
+    };
+    CryptoModule.LEGACY_IDENTIFIER = '';
+    CryptoModule.encoder = new TextEncoder();
+    CryptoModule.decoder = new TextDecoder();
+    return CryptoModule;
+}());
+exports.CryptoModule = CryptoModule;
+// CryptorHeader Utility
+var CryptorHeader = /** @class */ (function () {
+    function CryptorHeader() {
+    }
+    CryptorHeader.from = function (id, metadata) {
+        if (id === CryptorHeader.LEGACY_IDENTIFIER)
+            return;
+        return new CryptorHeaderV1(id, metadata.byteLength);
+    };
+    CryptorHeader.tryParse = function (data) {
+        var encryptedData = new Uint8Array(data);
+        var sentinel = '';
+        var version = null;
+        if (encryptedData.byteLength >= 4) {
+            sentinel = encryptedData.slice(0, 4);
+            if (this.decoder.decode(sentinel) !== CryptorHeader.SENTINEL)
+                return '';
+        }
+        if (encryptedData.byteLength >= 5) {
+            version = encryptedData[4];
+        }
+        else {
+            throw new Error('decryption error. invalid header version');
+        }
+        if (version > CryptorHeader.MAX_VERSION)
+            throw new Error('unknown cryptor error');
+        var identifier = '';
+        var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;
+        if (encryptedData.byteLength >= pos) {
+            identifier = encryptedData.slice(5, pos);
+        }
+        else {
+            throw new Error('decryption error. invalid crypto identifier');
+        }
+        var metadataLength = null;
+        if (encryptedData.byteLength >= pos + 1) {
+            metadataLength = encryptedData[pos];
+        }
+        else {
+            throw new Error('decryption error. invalid metadata length');
+        }
+        pos += 1;
+        if (metadataLength === 255 && encryptedData.byteLength >= pos + 2) {
+            metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);
+            pos += 2;
+        }
+        return new CryptorHeaderV1(this.decoder.decode(identifier), metadataLength);
+    };
+    CryptorHeader.SENTINEL = 'PNED';
+    CryptorHeader.LEGACY_IDENTIFIER = '';
+    CryptorHeader.IDENTIFIER_LENGTH = 4;
+    CryptorHeader.VERSION = 1;
+    CryptorHeader.MAX_VERSION = 1;
+    CryptorHeader.decoder = new TextDecoder();
+    return CryptorHeader;
+}());
+// v1 CryptorHeader
+var CryptorHeaderV1 = /** @class */ (function () {
+    function CryptorHeaderV1(id, metadataLength) {
+        this._identifier = id;
+        this._metadataLength = metadataLength;
+    }
+    Object.defineProperty(CryptorHeaderV1.prototype, "identifier", {
+        get: function () {
+            return this._identifier;
+        },
+        set: function (value) {
+            this._identifier = value;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "metadataLength", {
+        get: function () {
+            return this._metadataLength;
+        },
+        set: function (value) {
+            this._metadataLength = value;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "version", {
+        get: function () {
+            return CryptorHeader.VERSION;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "length", {
+        get: function () {
+            return (CryptorHeader.SENTINEL.length +
+                1 +
+                CryptorHeader.IDENTIFIER_LENGTH +
+                (this.metadataLength < 255 ? 1 : 3) +
+                this.metadataLength);
+        },
+        enumerable: false,
+        configurable: true
+    });
+    Object.defineProperty(CryptorHeaderV1.prototype, "data", {
+        get: function () {
+            var pos = 0;
+            var header = new Uint8Array(this.length);
+            var encoder = new TextEncoder();
+            header.set(encoder.encode(CryptorHeader.SENTINEL));
+            pos += CryptorHeader.SENTINEL.length;
+            header[pos] = this.version;
+            pos++;
+            if (this.identifier)
+                header.set(encoder.encode(this.identifier), pos);
+            pos += CryptorHeader.IDENTIFIER_LENGTH;
+            var metadataLength = this.metadataLength;
+            if (metadataLength < 255) {
+                header[pos] = metadataLength;
+            }
+            else {
+                header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);
+            }
+            return header;
+        },
+        enumerable: false,
+        configurable: true
+    });
+    CryptorHeaderV1.IDENTIFIER_LENGTH = 4;
+    CryptorHeaderV1.SENTINEL = 'PNED';
+    return CryptorHeaderV1;
+}());

--- lib/crypto/modules/node.js ---
@@ -94,6 +94,8 @@ var NodeCryptography = /** @class */ (function () {
                     case 0:
                         bKey = this.getKey(key);
                         if (!(file.data instanceof Buffer)) return [3 /*break*/, 2];
+                        if (file.data.byteLength <= 0)
+                            throw new Error('encryption error. empty content');
                         _b = (_a = File).create;
                         _e = {
                             name: file.name,
@@ -104,6 +106,8 @@ var NodeCryptography = /** @class */ (function () {
                                 _e)])];
                     case 2:
                         if (!(file.data instanceof stream_1.Readable)) return [3 /*break*/, 4];
+                        if (file.contentLength === 0)
+                            throw new Error('encryption error. empty content');
                         _d = (_c = File).create;
                         _f = {
                             name: file.name,
@@ -176,16 +180,32 @@ var NodeCryptography = /** @class */ (function () {
     NodeCryptography.prototype.decryptBuffer = function (key, ciphertext) {
         var bIv = ciphertext.slice(0, NodeCryptography.IV_LENGTH);
         var bCiphertext = ciphertext.slice(NodeCryptography.IV_LENGTH);
+        if (bCiphertext.byteLength <= 0)
+            throw new Error('decryption error: empty content');
         var aes = (0, crypto_1.createDecipheriv)(this.algo, key, bIv);
         return Buffer.concat([aes.update(bCiphertext), aes.final()]);
     };
     NodeCryptography.prototype.encryptStream = function (key, stream) {
-        var output = new stream_1.PassThrough();
-        var bIv = this.getIv();
-        var aes = (0, crypto_1.createCipheriv)(this.algo, key, bIv);
-        output.write(bIv);
-        stream.pipe(aes).pipe(output);
-        return output;
+        return __awaiter(this, void 0, void 0, function () {
+            var bIv, aes, inited;
+            return __generator(this, function (_a) {
+                bIv = this.getIv();
+                aes = (0, crypto_1.createCipheriv)('aes-256-cbc', key, bIv).setAutoPadding(true);
+                inited = false;
+                return [2 /*return*/, stream.pipe(aes).pipe(new stream_1.Transform({
+                        transform: function (chunk, _, cb) {
+                            if (!inited) {
+                                inited = true;
+                                this.push(Buffer.concat([bIv, chunk]));
+                            }
+                            else {
+                                this.push(chunk);
+                            }
+                            cb();
+                        },
+                    }))];
+            });
+        });
     };
     NodeCryptography.prototype.decryptStream = function (key, stream) {
         var _this = this;

--- lib/crypto/modules/web.js ---
@@ -96,10 +96,13 @@ var WebCryptography = /** @class */ (function () {
             var bKey, abPlaindata, abCipherdata;
             return __generator(this, function (_a) {
                 switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.getKey(key)];
+                    case 0:
+                        if (file.data.byteLength <= 0)
+                            throw new Error('encryption error. empty content');
+                        return [4 /*yield*/, this.getKey(key)];
                     case 1:
                         bKey = _a.sent();
-                        return [4 /*yield*/, file.toArrayBuffer()];
+                        return [4 /*yield*/, file.data.arrayBuffer()];
                     case 2:
                         abPlaindata = _a.sent();
                         return [4 /*yield*/, this.encryptArrayBuffer(bKey, abPlaindata)];
@@ -122,7 +125,7 @@ var WebCryptography = /** @class */ (function () {
                     case 0: return [4 /*yield*/, this.getKey(key)];
                     case 1:
                         bKey = _a.sent();
-                        return [4 /*yield*/, file.toArrayBuffer()];
+                        return [4 /*yield*/, file.data.arrayBuffer()];
                     case 2:
                         abCipherdata = _a.sent();
                         return [4 /*yield*/, this.decryptArrayBuffer(bKey, abCipherdata)];
@@ -138,15 +141,16 @@ var WebCryptography = /** @class */ (function () {
     };
     WebCryptography.prototype.getKey = function (key) {
         return __awaiter(this, void 0, void 0, function () {
-            var bKey, abHash, abKey;
+            var digest, hashHex, abKey;
             return __generator(this, function (_a) {
                 switch (_a.label) {
-                    case 0:
-                        bKey = Buffer.from(key);
-                        return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];
+                    case 0: return [4 /*yield*/, crypto.subtle.digest('SHA-256', WebCryptography.encoder.encode(key))];
                     case 1:
-                        abHash = _a.sent();
-                        abKey = Buffer.from(Buffer.from(abHash).toString('hex').slice(0, 32), 'utf8').buffer;
+                        digest = _a.sent();
+                        hashHex = Array.from(new Uint8Array(digest))
+                            .map(function (b) { return b.toString(16).padStart(2, '0'); })
+                            .join('');
+                        abKey = WebCryptography.encoder.encode(hashHex.slice(0, 32)).buffer;
                         return [2 /*return*/, crypto.subtle.importKey('raw', abKey, 'AES-CBC', true, ['encrypt', 'decrypt'])];
                 }
             });
@@ -169,10 +173,18 @@ var WebCryptography = /** @class */ (function () {
     };
     WebCryptography.prototype.decryptArrayBuffer = function (key, ciphertext) {
         return __awaiter(this, void 0, void 0, function () {
-            var abIv;
+            var abIv, data;
             return __generator(this, function (_a) {
-                abIv = ciphertext.slice(0, 16);
-                return [2 /*return*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(16))];
+                switch (_a.label) {
+                    case 0:
+                        abIv = ciphertext.slice(0, 16);
+                        if (ciphertext.slice(WebCryptography.IV_LENGTH).byteLength <= 0)
+                            throw new Error('decryption error: empty content');
+                        return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(WebCryptography.IV_LENGTH))];
+                    case 1:
+                        data = _a.sent();
+                        return [2 /*return*/, data];
+                }
             });
         });
     };
@@ -183,12 +195,12 @@ var WebCryptography = /** @class */ (function () {
                 switch (_a.label) {
                     case 0:
                         abIv = crypto.getRandomValues(new Uint8Array(16));
-                        abPlaintext = Buffer.from(plaintext).buffer;
+                        abPlaintext = WebCryptography.encoder.encode(plaintext).buffer;
                         return [4 /*yield*/, crypto.subtle.encrypt({ name: 'AES-CBC', iv: abIv }, key, abPlaintext)];
                     case 1:
                         abPayload = _a.sent();
                         ciphertext = concatArrayBuffer(abIv.buffer, abPayload);
-                        return [2 /*return*/, Buffer.from(ciphertext).toString('utf8')];
+                        return [2 /*return*/, WebCryptography.decoder.decode(ciphertext)];
                 }
             });
         });
@@ -199,18 +211,20 @@ var WebCryptography = /** @class */ (function () {
             return __generator(this, function (_a) {
                 switch (_a.label) {
                     case 0:
-                        abCiphertext = Buffer.from(ciphertext);
+                        abCiphertext = WebCryptography.encoder.encode(ciphertext).buffer;
                         abIv = abCiphertext.slice(0, 16);
                         abPayload = abCiphertext.slice(16);
                         return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, abPayload)];
                     case 1:
                         abPlaintext = _a.sent();
-                        return [2 /*return*/, Buffer.from(abPlaintext).toString('utf8')];
+                        return [2 /*return*/, WebCryptography.decoder.decode(abPlaintext)];
                 }
             });
         });
     };
     WebCryptography.IV_LENGTH = 16;
+    WebCryptography.encoder = new TextEncoder();
+    WebCryptography.decoder = new TextDecoder();
     return WebCryptography;
 }());
 exports.default = WebCryptography;

--- lib/file/modules/node.js ---
@@ -1,5 +1,4 @@
 "use strict";
-/**       */
 var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
     function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
     return new (P || (P = Promise))(function (resolve, reject) {
@@ -36,19 +35,23 @@ var __generator = (this && this.__generator) || function (thisArg, body) {
         if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
     }
 };
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
 var _a;
 Object.defineProperty(exports, "__esModule", { value: true });
 var stream_1 = require("stream");
-var fs_1 = require("fs");
+var fs_1 = __importDefault(require("fs"));
 var path_1 = require("path");
 var PubNubFile = (_a = /** @class */ (function () {
         function PubNubFile(_a) {
             var stream = _a.stream, data = _a.data, encoding = _a.encoding, name = _a.name, mimeType = _a.mimeType;
             if (stream instanceof stream_1.Readable) {
                 this.data = stream;
-                if (stream instanceof fs_1.ReadStream) {
+                if (stream instanceof fs_1.default.ReadStream) {
                     // $FlowFixMe: incomplete flow node definitions
                     this.name = (0, path_1.basename)(stream.path);
+                    this.contentLength = fs_1.default.statSync(stream.path).size;
                 }
             }
             else if (data instanceof Buffer) {

--- lib/node/index.js ---
@@ -17,6 +17,7 @@ var __extends = (this && this.__extends) || (function () {
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
+var _a;
 var cbor_sync_1 = __importDefault(require("cbor-sync"));
 var pubnub_common_1 = __importDefault(require("../core/pubnub-common"));
 var networking_1 = __importDefault(require("../networking"));
@@ -26,29 +27,41 @@ var web_node_1 = require("../networking/modules/web-node");
 var node_1 = require("../networking/modules/node");
 var node_2 = __importDefault(require("../crypto/modules/node"));
 var node_3 = __importDefault(require("../file/modules/node"));
-module.exports = /** @class */ (function (_super) {
-    __extends(class_1, _super);
-    function class_1(setup) {
-        var _this = this;
-        setup.cbor = new common_1.default(function (buffer) { return cbor_sync_1.default.decode(Buffer.from(buffer)); }, base64_codec_1.decode);
-        setup.networking = new networking_1.default({
-            keepAlive: node_1.keepAlive,
-            del: web_node_1.del,
-            get: web_node_1.get,
-            post: web_node_1.post,
-            patch: web_node_1.patch,
-            proxy: node_1.proxy,
-            getfile: web_node_1.getfile,
-            postfile: web_node_1.postfile,
-        });
-        setup.sdkFamily = 'Nodejs';
-        setup.PubNubFile = node_3.default;
-        setup.cryptography = new node_2.default();
-        if (!('ssl' in setup)) {
-            setup.ssl = true;
+var nodeCryptoModule_1 = require("../crypto/modules/NodeCryptoModule/nodeCryptoModule");
+module.exports = (_a = /** @class */ (function (_super) {
+        __extends(class_1, _super);
+        function class_1(setup) {
+            var _this = this;
+            setup.cbor = new common_1.default(function (buffer) { return cbor_sync_1.default.decode(Buffer.from(buffer)); }, base64_codec_1.decode);
+            setup.networking = new networking_1.default({
+                keepAlive: node_1.keepAlive,
+                del: web_node_1.del,
+                get: web_node_1.get,
+                post: web_node_1.post,
+                patch: web_node_1.patch,
+                proxy: node_1.proxy,
+                getfile: web_node_1.getfile,
+                postfile: web_node_1.postfile,
+            });
+            setup.sdkFamily = 'Nodejs';
+            setup.PubNubFile = node_3.default;
+            setup.cryptography = new node_2.default();
+            setup.initCryptoModule = function (cryptoConfiguration) {
+                return new nodeCryptoModule_1.CryptoModule({
+                    default: new nodeCryptoModule_1.LegacyCryptor({
+                        cipherKey: cryptoConfiguration.cipherKey,
+                        useRandomIVs: cryptoConfiguration.useRandomIVs,
+                    }),
+                    cryptors: [new nodeCryptoModule_1.AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],
+                });
+            };
+            if (!('ssl' in setup)) {
+                setup.ssl = true;
+            }
+            _this = _super.call(this, setup) || this;
+            return _this;
         }
-        _this = _super.call(this, setup) || this;
-        return _this;
-    }
-    return class_1;
-}(pubnub_common_1.default));
+        return class_1;
+    }(pubnub_common_1.default)),
+    _a.CryptoModule = nodeCryptoModule_1.CryptoModule,
+    _a);

--- lib/web/index.js ---
@@ -29,6 +29,7 @@ var common_1 = __importDefault(require("../cbor/common"));
 var web_node_1 = require("../networking/modules/web-node");
 var web_1 = __importDefault(require("../crypto/modules/web"));
 var web_2 = __importDefault(require("../file/modules/web"));
+var webCryptoModule_1 = require("../crypto/modules/WebCryptoModule/webCryptoModule");
 function sendBeacon(url) {
     if (navigator && navigator.sendBeacon) {
         navigator.sendBeacon(url);
@@ -56,6 +57,15 @@ var default_1 = /** @class */ (function (_super) {
         setup.cbor = new common_1.default(function (arrayBuffer) { return (0, stringify_buffer_keys_1.stringifyBufferKeys)(cbor_js_1.default.decode(arrayBuffer)); }, base64_codec_1.decode);
         setup.PubNubFile = web_2.default;
         setup.cryptography = new web_1.default();
+        setup.initCryptoModule = function (cryptoConfiguration) {
+            return new webCryptoModule_1.CryptoModule({
+                default: new webCryptoModule_1.LegacyCryptor({
+                    cipherKey: cryptoConfiguration.cipherKey,
+                    useRandomIVs: cryptoConfiguration.useRandomIVs,
+                }),
+                cryptors: [new webCryptoModule_1.AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],
+            });
+        };
         _this = _super.call(this, setup) || this;
         if (listenToBrowserNetworkEvents) {
             // mount network events.
@@ -68,6 +78,7 @@ var default_1 = /** @class */ (function (_super) {
         }
         return _this;
     }
+    default_1.CryptoModule = webCryptoModule_1.CryptoModule;
     return default_1;
 }(pubnub_common_1.default));
 exports.default = default_1;

--- package.json ---
@@ -1,6 +1,6 @@
 {
   "name": "pubnub",
-  "version": "7.3.3",
+  "version": "7.4.0",
   "author": "PubNub <support@pubnub.com>",
   "description": "Publish & Subscribe Real-time Messaging with PubNub",
   "scripts": {
@@ -102,4 +102,4 @@
   "engine": {
     "node": ">=0.8"
   }
-}
+}
\ No newline at end of file

--- src/core/components/base64_codec.ts ---
@@ -53,3 +53,55 @@ export function decode(paddedInput: string): ArrayBuffer {
 
   return data;
 }
+
+export function encode(input: ArrayBuffer): string {
+  let base64 = '';
+  const encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+
+  const bytes = new Uint8Array(input);
+  const byteLength = bytes.byteLength;
+  const byteRemainder = byteLength % 3;
+  const mainLength = byteLength - byteRemainder;
+
+  let a, b, c, d;
+  let chunk;
+
+  // Main loop deals with bytes in chunks of 3
+  for (let i = 0; i < mainLength; i = i + 3) {
+    // Combine the three bytes into a single integer
+    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
+
+    // Use bitmasks to extract 6-bit segments from the triplet
+    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
+    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
+    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
+    d = chunk & 63; // 63       = 2^6 - 1
+
+    // Convert the raw binary segments to the appropriate ASCII encoding
+    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
+  }
+
+  // Deal with the remaining bytes and padding
+  if (byteRemainder == 1) {
+    chunk = bytes[mainLength];
+
+    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
+
+    // Set the 4 least significant bits to zero
+    b = (chunk & 3) << 4; // 3   = 2^2 - 1
+
+    base64 += encodings[a] + encodings[b] + '==';
+  } else if (byteRemainder == 2) {
+    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
+
+    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
+    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
+
+    // Set the 2 least significant bits to zero
+    c = (chunk & 15) << 2; // 15    = 2^4 - 1
+
+    base64 += encodings[a] + encodings[b] + encodings[c] + '=';
+  }
+
+  return base64;
+}

--- src/core/components/config.js ---
@@ -129,7 +129,7 @@ export default class {
   maximumCacheSize;
 
   /*
-    support customp encryption and decryption functions.
+    support custom encryption and decryption functions.
   */
   customEncrypt; // function to support custome encryption of messages
 
@@ -142,6 +142,11 @@ export default class {
   useRandomIVs;
   enableSubscribeBeta;
 
+  /*
+    set cryptoModule to encrypt/decrypt messages and files.
+  */
+  cryptoModule;
+
   constructor({ setup }) {
     this._PNSDKSuffix = {};
 
@@ -153,7 +158,7 @@ export default class {
     this.sdkFamily = setup.sdkFamily;
     this.partnerId = setup.partnerId;
     this.setAuthKey(setup.authKey);
-    this.setCipherKey(setup.cipherKey);
+    this.cryptoModule = setup.cryptoModule;
 
     this.setFilterExpression(setup.filterExpression);
 
@@ -227,6 +232,7 @@ export default class {
 
       this.setUUID(setup.uuid);
     }
+    this.setCipherKey(setup.cipherKey, setup);
   }
 
   // exposed setters
@@ -239,8 +245,13 @@ export default class {
     return this;
   }
 
-  setCipherKey(val) {
+  setCipherKey(val, setup, modules) {
     this.cipherKey = val;
+    if (this.cipherKey) {
+      this.cryptoModule =
+        setup.cryptoModule ?? setup.initCryptoModule({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs });
+      if (modules) modules.cryptoModule = this.cryptoModule;
+    }
     return this;
   }
 
@@ -339,7 +350,7 @@ export default class {
   }
 
   getVersion() {
-    return '7.3.3';
+    return '7.4.0';
   }
 
   _addPnsdkSuffix(name, suffix) {

--- src/core/components/cryptography/index.js ---
@@ -26,7 +26,6 @@ export default class {
 
   constructor({ config }) {
     this._config = config;
-
     this._iv = '0123456789012345';
 
     this._allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];

--- src/core/components/subscription_manager.js ---
@@ -58,6 +58,10 @@ export default class {
   _pendingChannelGroupSubscriptions;
   //
 
+  _cryptoModule;
+
+  _decoder;
+
   _dedupingManager;
 
   constructor({
@@ -70,6 +74,7 @@ export default class {
     config,
     crypto,
     listenerManager,
+    cryptoModule,
   }) {
     this._listenerManager = listenerManager;
     this._config = config;
@@ -81,6 +86,7 @@ export default class {
     this._getFileUrl = getFileUrl;
 
     this._crypto = crypto;
+    this._cryptoModule = cryptoModule;
 
     this._channels = {};
     this._presenceChannels = {};
@@ -104,6 +110,8 @@ export default class {
 
     this._reconnectionManager = new ReconnectionManager({ timeEndpoint });
     this._dedupingManager = new DedupingManager({ config });
+
+    if (this._cryptoModule) this._decoder = new TextDecoder();
   }
 
   adaptStateChange(args, callback) {
@@ -683,10 +691,19 @@ export default class {
 
         let msgPayload = message.payload;
 
-        if (this._config.cipherKey) {
-          const decryptedPayload = this._crypto.decrypt(message.payload);
-
-          if (typeof decryptedPayload === 'object' && decryptedPayload !== null) {
+        if (this._cryptoModule) {
+          let decryptedPayload;
+          try {
+            const decryptedData = this._cryptoModule.decrypt(message.payload);
+            decryptedPayload =
+              decryptedData instanceof ArrayBuffer ? JSON.parse(this._decoder.decode(decryptedData)) : decryptedData;
+          } catch (e) {
+            decryptedPayload = null;
+            if (console && console.log) {
+              console.log('decryption error', e.message);
+            }
+          }
+          if (decryptedPayload !== null) {
             msgPayload = decryptedPayload;
           }
         }
@@ -727,8 +744,24 @@ export default class {
           announce.userMetadata = message.userMetadata;
         }
 
-        if (this._config.cipherKey) {
-          announce.message = this._crypto.decrypt(message.payload);
+        if (this._cryptoModule) {
+          let decryptedPayload;
+          try {
+            const decryptedData = this._cryptoModule.decrypt(message.payload);
+            decryptedPayload =
+              decryptedData instanceof ArrayBuffer ? JSON.parse(this._decoder.decode(decryptedData)) : decryptedData;
+          } catch (e) {
+            decryptedPayload = null;
+            // eslint-disable-next-line
+            if (console && console.log) {
+              console.log('decryption error', e.message); //eslint-disable-line
+            }
+          }
+          if (decryptedPayload != null) {
+            announce.message = decryptedPayload;
+          } else {
+            announce.message = message.payload;
+          }
         } else {
           announce.message = message.payload;
         }

--- src/core/endpoints/fetch_messages.js ---
@@ -11,12 +11,14 @@ import operationConstants from '../constants/operations';
 import utils from '../utils';
 
 function __processMessage(modules, message) {
-  const { config, crypto } = modules;
-  if (!config.cipherKey) return message;
-
+  if (!modules.cryptoModule) return message;
   try {
-    return crypto.decrypt(message);
+    const decryptedData = modules.cryptoModule.decrypt(message);
+    const decryptedPayload =
+      decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;
+    return decryptedPayload;
   } catch (e) {
+    if (console && console.log) console.log('decryption error', e.message);
     return message;
   }
 }

--- src/core/endpoints/file_upload/download_file.js ---
@@ -1,3 +1,5 @@
+// Download_file.js
+
 /**       */
 
 import operationConstants from '../../constants/operations';
@@ -34,11 +36,13 @@ const endpoint = {
 
   prepareParams: () => ({}),
 
-  handleResponse: async ({ PubNubFile, config, cryptography }, res, params) => {
+  handleResponse: async ({ PubNubFile, config, cryptography, cryptoModule }, res, params) => {
     let { body } = res.response;
-
-    if (PubNubFile.supportsEncryptFile && (params.cipherKey ?? config.cipherKey)) {
-      body = await cryptography.decrypt(params.cipherKey ?? config.cipherKey, body);
+    if (PubNubFile.supportsEncryptFile && (params.cipherKey || cryptoModule)) {
+      body =
+        params.cipherKey == null
+          ? (await cryptoModule.decryptFile(PubNubFile.create({ data: body, name: params.name }), PubNubFile)).data
+          : await cryptography.decrypt(params.cipherKey ?? config.cipherKey, body);
     }
 
     return PubNubFile.create({

--- src/core/endpoints/file_upload/publish_file.js ---
@@ -1,17 +1,16 @@
 /**       */
 
 import operationConstants from '../../constants/operations';
-
 import utils from '../../utils';
+import { encode } from '../../components/base64_codec';
 
-const preparePayload = ({ crypto, config }, payload) => {
+const preparePayload = (modules, payload) => {
   let stringifiedPayload = JSON.stringify(payload);
-
-  if (config.cipherKey) {
-    stringifiedPayload = crypto.encrypt(stringifiedPayload);
+  if (modules.cryptoModule) {
+    const encrypted = modules.cryptoModule.encrypt(stringifiedPayload);
+    stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode(encrypted);
     stringifiedPayload = JSON.stringify(stringifiedPayload);
   }
-
   return stringifiedPayload || '';
 };
 

--- src/core/endpoints/file_upload/send_file.js ---
@@ -3,7 +3,7 @@ import { PubNubError, createValidationError } from '../../components/endpoint';
 const sendFile = function ({
   generateUploadUrl,
   publishFile,
-  modules: { PubNubFile, config, cryptography, networking },
+  modules: { PubNubFile, config, cryptography, cryptoModule, networking },
 }) {
   return async ({ channel, file: input, message, cipherKey, meta, ttl, storeInHistory }) => {
     if (!channel) {
@@ -27,8 +27,11 @@ const sendFile = function ({
       data: { id, name },
     } = await generateUploadUrl({ channel, name: file.name });
 
-    if (PubNubFile.supportsEncryptFile && (cipherKey ?? config.cipherKey)) {
-      file = await cryptography.encryptFile(cipherKey ?? config.cipherKey, file, PubNubFile);
+    if (PubNubFile.supportsEncryptFile && (cipherKey || cryptoModule)) {
+      file =
+        cipherKey == null
+          ? await cryptoModule.encryptFile(file, PubNubFile)
+          : await cryptography.encryptFile(cipherKey, file, PubNubFile);
     }
 
     let formFieldsWithMimeType = formFields;

--- src/core/endpoints/history/get_history.js ---
@@ -5,12 +5,14 @@ import operationConstants from '../../constants/operations';
 import utils from '../../utils';
 
 function __processMessage(modules, message) {
-  const { config, crypto } = modules;
-  if (!config.cipherKey) return message;
-
+  if (!modules.cryptoModule) return message;
   try {
-    return crypto.decrypt(message);
+    const decryptedData = modules.cryptoModule.decrypt(message);
+    const decryptedPayload =
+      decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;
+    return decryptedPayload;
   } catch (e) {
+    if (console && console.log) console.log('decryption error', e.message);
     return message;
   }
 }

--- src/core/endpoints/publish.js ---
@@ -3,17 +3,17 @@
 import { PublishResponse, PublishArguments, ModulesInject } from '../flow_interfaces';
 import operationConstants from '../constants/operations';
 import utils from '../utils';
+import { encode } from '../components/base64_codec';
 
 function prepareMessagePayload(modules, messagePayload) {
-  const { crypto, config } = modules;
   let stringifiedPayload = JSON.stringify(messagePayload);
 
-  if (config.cipherKey) {
-    stringifiedPayload = crypto.encrypt(stringifiedPayload);
+  if (modules.cryptoModule) {
+    const encrypted = modules.cryptoModule.encrypt(stringifiedPayload);
+    stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode(encrypted);
     stringifiedPayload = JSON.stringify(stringifiedPayload);
   }
-
-  return stringifiedPayload;
+  return stringifiedPayload || '';
 }
 
 export function getOperation() {

--- src/core/pubnub-common.js ---
@@ -1,5 +1,6 @@
 import Config from './components/config';
 import Crypto from './components/cryptography/index';
+import { encode } from './components/base64_codec';
 import SubscriptionManager from './components/subscription_manager';
 import TelemetryManager from './components/telemetry_manager';
 import NotificationsPayload from './components/push_payload';
@@ -291,6 +292,7 @@ export default class {
     });
 
     this._telemetryManager = telemetryManager;
+    const cryptoModule = this._config.cryptoModule;
 
     const modules = {
       config,
@@ -300,12 +302,25 @@ export default class {
       tokenManager,
       telemetryManager,
       PubNubFile: setup.PubNubFile,
+      cryptoModule: cryptoModule,
     };
 
     this.File = setup.PubNubFile;
 
-    this.encryptFile = (key, file) => cryptography.encryptFile(key, file, this.File);
-    this.decryptFile = (key, file) => cryptography.decryptFile(key, file, this.File);
+    this.encryptFile = function (key, file) {
+      if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {
+        file = key;
+        return modules.cryptoModule.encryptFile(file, this.File);
+      }
+      return cryptography.encryptFile(key, file, this.File);
+    };
+    this.decryptFile = function (key, file) {
+      if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {
+        file = key;
+        return modules.cryptoModule.decryptFile(file, this.File);
+      }
+      return cryptography.decryptFile(key, file, this.File);
+    };
 
     const timeEndpoint = endpointCreator.bind(this, modules, timeEndpointConfig);
     const leaveEndpoint = endpointCreator.bind(this, modules, presenceLeaveEndpointConfig);
@@ -341,6 +356,7 @@ export default class {
         config: modules.config,
         listenerManager,
         getFileUrl: (params) => getFileUrlFunction(modules, params),
+        cryptoModule: modules.cryptoModule,
       });
 
       this.subscribe = subscriptionManager.adaptSubscribeChange.bind(subscriptionManager);
@@ -664,20 +680,34 @@ export default class {
     // --- deprecated  ------------------
 
     // mount crypto
-    this.encrypt = crypto.encrypt.bind(crypto);
-    this.decrypt = crypto.decrypt.bind(crypto);
+    this.encrypt = function (data, key) {
+      if (typeof key === 'undefined' && modules.cryptoModule) {
+        const encrypted = modules.cryptoModule.encrypt(data);
+        return typeof encrypted === 'string' ? encrypted : encode(encrypted);
+      } else {
+        return crypto.encrypt(data, key);
+      }
+    };
+    this.decrypt = function (data, key) {
+      if (typeof key === 'undefined' && cryptoModule) {
+        const decrypted = modules.cryptoModule.decrypt(data);
+        return decrypted instanceof ArrayBuffer ? encode(decrypted) : decrypted;
+      } else {
+        return crypto.decrypt(data, key);
+      }
+    };
 
     /* config */
     this.getAuthKey = modules.config.getAuthKey.bind(modules.config);
     this.setAuthKey = modules.config.setAuthKey.bind(modules.config);
-    this.setCipherKey = modules.config.setCipherKey.bind(modules.config);
     this.getUUID = modules.config.getUUID.bind(modules.config);
     this.setUUID = modules.config.setUUID.bind(modules.config);
     this.getUserId = modules.config.getUserId.bind(modules.config);
     this.setUserId = modules.config.setUserId.bind(modules.config);
     this.getFilterExpression = modules.config.getFilterExpression.bind(modules.config);
     this.setFilterExpression = modules.config.setFilterExpression.bind(modules.config);
-
+    // this.setCipherKey = modules.config.setCipherKey.bind(modules.config);
+    this.setCipherKey = (key) => modules.config.setCipherKey(key, setup, modules);
     this.setHeartbeatInterval = modules.config.setHeartbeatInterval.bind(modules.config);
 
     if (networking.hasModule('proxy')) {

--- src/core/utils.js ---
@@ -32,9 +32,19 @@ function createPromise() {
   return { promise, reject: failureResolve, fulfill: successResolve };
 }
 
+function stringToArrayBuffer(str) {
+  var buf = new ArrayBuffer(str.length * 2);
+  var bufView = new Uint16Array(buf);
+  for (var i = 0, strLen = str.length; i < strLen; i++) {
+    bufView[i] = str.charCodeAt(i);
+  }
+  return buf;
+}
+
 module.exports = {
   signPamFromParams,
   endsWith,
   createPromise,
   encodeString,
+  stringToArrayBuffer,
 };

--- src/crypto/modules/NodeCryptoModule/ICryptor.ts ---
@@ -0,0 +1,19 @@
+export type EncryptedDataType = {
+  data: Buffer | string;
+  metadata: Buffer | null;
+};
+
+export type EncryptedStream = {
+  stream: NodeJS.ReadableStream;
+  metadataLength: number;
+  metadata?: Buffer | undefined;
+};
+
+export interface ICryptor {
+  get identifier(): string;
+  encrypt(data: BufferSource | string): EncryptedDataType;
+  decrypt(data: EncryptedDataType): ArrayBuffer;
+
+  encryptStream(stream: NodeJS.ReadableStream): Promise<EncryptedStream>;
+  decryptStream(encryptedStream: EncryptedStream): Promise<NodeJS.ReadableStream>;
+}

--- src/crypto/modules/NodeCryptoModule/ILegacyCryptor.ts ---
@@ -0,0 +1,26 @@
+import { EncryptedDataType } from './ICryptor';
+
+export type PubNubFileType = {
+  stream: NodeJS.ReadStream;
+  data: NodeJS.ReadStream | Buffer;
+  name: string;
+  mimeType: string;
+  contentLength: number;
+
+  create(config: any): PubNubFileType;
+
+  toBuffer(): Buffer;
+  toArrayBuffer(): ArrayBuffer;
+  toString(): string;
+  toStream(): NodeJS.ReadStream;
+};
+
+export interface ILegacyCryptor<T extends PubNubFileType> {
+  get identifier(): string;
+
+  encrypt(data: string | ArrayBuffer): EncryptedDataType;
+  decrypt(data: EncryptedDataType): BufferSource | string;
+
+  encryptFile(file: T, File: T): Promise<T>;
+  decryptFile(file: T, File: T): Promise<T>;
+}

--- src/crypto/modules/NodeCryptoModule/aesCbcCryptor.ts ---
@@ -0,0 +1,97 @@
+import { PassThrough } from 'stream';
+import { createCipheriv, createDecipheriv, createHash, randomBytes } from 'crypto';
+import { ICryptor, EncryptedDataType, EncryptedStream } from './ICryptor';
+
+export default class AesCbcCryptor implements ICryptor {
+  static BLOCK_SIZE = 16;
+
+  cipherKey: string;
+  constructor(configuration: { cipherKey: string }) {
+    this.cipherKey = configuration.cipherKey;
+  }
+
+  get algo() {
+    return 'aes-256-cbc';
+  }
+
+  get identifier() {
+    return 'ACRH';
+  }
+
+  getIv() {
+    return randomBytes(AesCbcCryptor.BLOCK_SIZE);
+  }
+
+  getKey() {
+    const sha = createHash('sha256');
+    sha.update(Buffer.from(this.cipherKey, 'utf8'));
+    return Buffer.from(sha.digest());
+  }
+
+  encrypt(data: ArrayBuffer | string) {
+    const iv = this.getIv();
+    const key = this.getKey();
+    const plainData = typeof data === 'string' ? new TextEncoder().encode(data) : data;
+    const bPlain = Buffer.from(plainData);
+    if (bPlain.byteLength === 0) throw new Error('encryption error. empty content');
+    const aes = createCipheriv(this.algo, key, iv);
+
+    return {
+      metadata: iv,
+      data: Buffer.concat([aes.update(bPlain), aes.final()]),
+    };
+  }
+
+  decrypt(encryptedData: EncryptedDataType) {
+    const data =
+      typeof encryptedData.data === 'string' ? new TextEncoder().encode(encryptedData.data) : encryptedData.data;
+    if (data.byteLength <= 0) throw new Error('decryption error: empty content');
+    const aes = createDecipheriv(this.algo, this.getKey(), encryptedData.metadata);
+    return Uint8Array.from(Buffer.concat([aes.update(data), aes.final()])).buffer;
+  }
+
+  async encryptStream(stream: NodeJS.ReadableStream) {
+    const output = new PassThrough();
+    const bIv = this.getIv();
+    if (stream.readable === false) throw new Error('encryption error. empty stream');
+    const aes = createCipheriv(this.algo, this.getKey(), bIv);
+    stream.pipe(aes).pipe(output);
+    return {
+      stream: output,
+      metadata: bIv,
+      metadataLength: AesCbcCryptor.BLOCK_SIZE,
+    };
+  }
+
+  async decryptStream(encryptedStream: EncryptedStream) {
+    const decryptedStream = new PassThrough();
+    let bIv = Buffer.alloc(0);
+    let aes: any = null;
+    const onReadable = () => {
+      let data = encryptedStream.stream.read();
+      while (data !== null) {
+        if (data) {
+          const bChunk = Buffer.from(data);
+          const sliceLen = encryptedStream.metadataLength - bIv.byteLength;
+          if (bChunk.byteLength < sliceLen) {
+            bIv = Buffer.concat([bIv, bChunk]);
+          } else {
+            bIv = Buffer.concat([bIv, bChunk.slice(0, sliceLen)]);
+            aes = createDecipheriv(this.algo, this.getKey(), bIv);
+            aes.pipe(decryptedStream);
+            aes.write(bChunk.slice(sliceLen));
+          }
+        }
+        data = encryptedStream.stream.read();
+      }
+    };
+    encryptedStream.stream.on('readable', onReadable);
+    encryptedStream.stream.on('end', () => {
+      if (aes) {
+        aes.end();
+      }
+      decryptedStream.end();
+    });
+    return decryptedStream;
+  }
+}

--- src/crypto/modules/NodeCryptoModule/legacyCryptor.ts ---
@@ -0,0 +1,41 @@
+import Crypto from '../../../core/components/cryptography/index';
+import { encode } from '../../../core/components/base64_codec';
+import FileCryptor from '../node';
+import { EncryptedDataType } from './ICryptor';
+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';
+
+export default class LegacyCryptor implements ILegacyCryptor<PubNubFileType> {
+  config;
+
+  cryptor;
+  fileCryptor;
+
+  constructor(config: any) {
+    this.config = config;
+    this.cryptor = new Crypto({ config });
+    this.fileCryptor = new FileCryptor();
+  }
+  get identifier() {
+    return '';
+  }
+  encrypt(data: string) {
+    if (data.length === 0) throw new Error('encryption error. empty content');
+    return {
+      data: this.cryptor.encrypt(data),
+      metadata: null,
+    };
+  }
+
+  decrypt(encryptedData: EncryptedDataType) {
+    const data = typeof encryptedData.data === 'string' ? encryptedData.data : encode(encryptedData.data);
+    return this.cryptor.decrypt(data);
+  }
+
+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {
+    return this.fileCryptor.encryptFile(this.config.cipherKey, file, File);
+  }
+
+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {
+    return this.fileCryptor.decryptFile(this.config.cipherKey, file, File);
+  }
+}

--- src/crypto/modules/NodeCryptoModule/nodeCryptoModule.ts ---
@@ -0,0 +1,350 @@
+import { Readable, PassThrough } from 'stream';
+import { decode } from '../../../core/components/base64_codec';
+import LegacyCryptor from './legacyCryptor';
+import AesCbcCryptor from './aesCbcCryptor';
+import { ICryptor } from './ICryptor';
+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';
+
+export { LegacyCryptor, AesCbcCryptor };
+
+type CryptorType = ICryptor | ILegacyCryptor<PubNubFileType>;
+
+type CryptoModuleConfiguration = {
+  default: CryptorType;
+  cryptors?: Array<CryptorType>;
+};
+
+export class CryptoModule {
+  static LEGACY_IDENTIFIER = '';
+
+  defaultCryptor: CryptorType;
+  cryptors: Array<CryptorType>;
+
+  constructor(cryptoModuleConfiguration: CryptoModuleConfiguration) {
+    this.defaultCryptor = cryptoModuleConfiguration.default;
+    this.cryptors = cryptoModuleConfiguration.cryptors ?? [];
+  }
+
+  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+  // @ts-ignore: type detection issue with old Config type assignment
+  static legacyCryptoModule(config) {
+    return new this({
+      default: new LegacyCryptor({
+        cipherKey: config.cipherKey,
+        useRandomIVs: config.useRandomIVs ?? true,
+      }),
+      cryptors: [new AesCbcCryptor({ cipherKey: config.cipherKey })],
+    });
+  }
+
+  static aesCbcCryptoModule(config: any) {
+    return new this({
+      default: new AesCbcCryptor({ cipherKey: config.cipherKey }),
+      cryptors: [
+        new LegacyCryptor({
+          cipherKey: config.cipherKey,
+          useRandomIVs: config.useRandomIVs ?? true,
+        }),
+      ],
+    });
+  }
+  static withDefaultCryptor(defaultCryptor: CryptorType) {
+    return new this({ default: defaultCryptor });
+  }
+
+  private getAllCryptors() {
+    return [this.defaultCryptor, ...this.cryptors];
+  }
+
+  private getLegacyCryptor() {
+    return this.getAllCryptors().find((c) => c.identifier === '');
+  }
+
+  encrypt(data: ArrayBuffer | string) {
+    const encrypted = this.defaultCryptor.encrypt(data);
+    if (!encrypted.metadata) return encrypted.data;
+
+    const header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);
+
+    const headerData = new Uint8Array(header!.length);
+    let pos = 0;
+    headerData.set(header!.data, pos);
+    pos = header!.length - encrypted.metadata.length;
+    headerData.set(encrypted.metadata, pos);
+    return Buffer.concat([headerData, Buffer.from(encrypted.data)]);
+  }
+
+  decrypt(data: ArrayBuffer | string) {
+    const encryptedData = Buffer.from(typeof data === 'string' ? decode(data) : data);
+    const header = CryptorHeader.tryParse(encryptedData);
+    const cryptor = this.getCryptor(header);
+    const metadata =
+      header.length > 0
+        ? encryptedData.slice(header.length - (header as CryptorHeaderV1).metadataLength, header.length)
+        : null;
+    if (encryptedData.slice(header.length).byteLength <= 0) throw new Error('decryption error. empty content');
+    return cryptor!.decrypt({
+      data: encryptedData.slice(header.length),
+      metadata: metadata,
+    });
+  }
+
+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {
+    /**
+     * Files handled differently in case of Legacy cryptor.
+     * (as long as we support legacy need to check on intsance type)
+     */
+    if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)
+      return (this.defaultCryptor as ILegacyCryptor<PubNubFileType>).encryptFile(file, File);
+    if (file.data instanceof Buffer) {
+      return File.create({
+        name: file.name,
+        mimeType: 'application/octet-stream',
+        data: Buffer.from(this.encrypt(file.data!) as Buffer),
+      });
+    }
+    if (file.data instanceof Readable) {
+      if (file.contentLength === 0) throw new Error('encryption error. empty content');
+      const encryptedStream = await (this.defaultCryptor as ICryptor).encryptStream(file.data);
+      const header = CryptorHeader.from(this.defaultCryptor.identifier, encryptedStream.metadata!);
+      const payload = new Uint8Array(header!.length);
+      let pos = 0;
+      payload.set(header!.data, pos);
+      pos += header!.length;
+      if (encryptedStream.metadata) {
+        pos -= encryptedStream.metadata.length;
+        payload.set(encryptedStream.metadata, pos);
+      }
+      const output = new PassThrough();
+      output.write(payload);
+      encryptedStream.stream.pipe(output);
+      return File.create({
+        name: file.name,
+        mimeType: 'application/octet-stream',
+        stream: output,
+      });
+    }
+  }
+
+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {
+    if (file?.data instanceof Buffer) {
+      const header = CryptorHeader.tryParse(file.data);
+      const cryptor = this.getCryptor(header);
+      /**
+       * If It's legacyone then redirect it.
+       * (as long as we support legacy need to check on instance type)
+       */
+      if (cryptor?.identifier === CryptoModule.LEGACY_IDENTIFIER)
+        return (cryptor as ILegacyCryptor<PubNubFileType>).decryptFile(file, File);
+      return File.create({
+        name: file.name,
+        data: Buffer.from(this.decrypt(file?.data) as ArrayBuffer),
+      });
+    }
+
+    if (file.data instanceof Readable) {
+      const stream = file.data;
+      return new Promise((resolve) => {
+        stream.on('readable', () => resolve(this.onStreamReadable(stream, file, File)));
+      });
+    }
+  }
+
+  private async onStreamReadable(stream: NodeJS.ReadableStream, file: PubNubFileType, File: PubNubFileType) {
+    stream.removeAllListeners('readable');
+    const magicBytes = stream.read(4);
+    if (!CryptorHeader.isSentinel(magicBytes as Buffer)) {
+      if (magicBytes === null) throw new Error('decryption error. empty content');
+      stream.unshift(magicBytes);
+      return this.decryptLegacyFileStream(stream, file, File);
+    }
+    const versionByte = stream.read(1);
+    CryptorHeader.validateVersion(versionByte[0] as number);
+    const identifier = stream.read(4);
+    const cryptor = this.getCryptorFromId(CryptorHeader.tryGetIdentifier(identifier as Buffer));
+    const headerSize = CryptorHeader.tryGetMetadataSizeFromStream(stream);
+    if (file.contentLength <= CryptorHeader.MIN_HEADER_LEGTH + headerSize)
+      throw new Error('decryption error. empty content');
+    return File.create({
+      name: file.name,
+      mimeType: 'application/octet-stream',
+      stream: await (cryptor as ICryptor).decryptStream({ stream: stream, metadataLength: headerSize as number }),
+    });
+  }
+
+  private async decryptLegacyFileStream(stream: NodeJS.ReadableStream, file: PubNubFileType, File: PubNubFileType) {
+    if (file.contentLength <= 16) throw new Error('decryption error: empty content');
+    const cryptor = this.getLegacyCryptor();
+    if (cryptor) {
+      return (cryptor as ILegacyCryptor<PubNubFileType>).decryptFile(
+        File.create({
+          name: file.name,
+          stream: stream,
+        }),
+        File,
+      );
+    } else {
+      throw new Error('unknown cryptor error');
+    }
+  }
+
+  private getCryptor(header: CryptorHeader) {
+    if (header === '') {
+      const cryptor = this.getAllCryptors().find((c) => c.identifier === '');
+      if (cryptor) return cryptor;
+      throw new Error('unknown cryptor error');
+    } else if (header instanceof CryptorHeaderV1) {
+      return this.getCryptorFromId(header.identifier);
+    }
+  }
+
+  private getCryptorFromId(id: string) {
+    const cryptor = this.getAllCryptors().find((c) => id === c.identifier);
+    if (cryptor) {
+      return cryptor;
+    }
+    throw new Error('unknown cryptor error');
+  }
+}
+
+// CryptorHeader Utility
+class CryptorHeader {
+  static SENTINEL = 'PNED';
+  static LEGACY_IDENTIFIER = '';
+  static IDENTIFIER_LENGTH = 4;
+  static VERSION = 1;
+  static MAX_VERSION = 1;
+  static MIN_HEADER_LEGTH = 10;
+
+  static from(id: string, metadata: Buffer) {
+    if (id === CryptorHeader.LEGACY_IDENTIFIER) return;
+    return new CryptorHeaderV1(id, metadata.length);
+  }
+
+  static isSentinel(bytes: Buffer) {
+    if (bytes && bytes.byteLength >= 4) {
+      if (bytes.toString('utf8') == CryptorHeader.SENTINEL) return true;
+    }
+  }
+
+  static validateVersion(data: number) {
+    if (data && data > CryptorHeader.MAX_VERSION) throw new Error('decryption error. invalid header version');
+    return data;
+  }
+
+  static tryGetIdentifier(data: Buffer) {
+    if (data.byteLength < 4) {
+      throw new Error('unknown cryptor error. decryption failed');
+    } else {
+      return data.toString('utf8');
+    }
+  }
+
+  static tryGetMetadataSizeFromStream(stream: NodeJS.ReadableStream) {
+    const sizeBuf = stream.read(1);
+    if (sizeBuf && (sizeBuf[0] as number) < 255) {
+      return sizeBuf[0] as number;
+    }
+    if ((sizeBuf[0] as number) === 255) {
+      const nextBuf = stream.read(2);
+      if (nextBuf.length >= 2) {
+        return new Uint16Array([nextBuf[0] as number, nextBuf[1] as number]).reduce((acc, val) => (acc << 8) + val, 0);
+      }
+    }
+    throw new Error('decryption error. Invalid metadata size');
+  }
+  static tryParse(encryptedData: Buffer) {
+    let sentinel: any = '';
+    let version = null;
+    if (encryptedData.length >= 4) {
+      sentinel = encryptedData.slice(0, 4);
+      if (sentinel.toString('utf8') !== CryptorHeader.SENTINEL) return '';
+    }
+
+    if (encryptedData.length >= 5) {
+      version = encryptedData[4];
+    } else {
+      throw new Error('decryption error. invalid header version');
+    }
+    if (version > CryptorHeader.MAX_VERSION) throw new Error('unknown cryptor error');
+
+    let identifier: Buffer;
+    let pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;
+    if (encryptedData.length >= pos) {
+      identifier = encryptedData.slice(5, pos);
+    } else {
+      throw new Error('decryption error. invalid crypto identifier');
+    }
+    let metadataLength = null;
+    if (encryptedData.length >= pos + 1) {
+      metadataLength = encryptedData[pos];
+    } else {
+      throw new Error('decryption error. invalid metadata length');
+    }
+    pos += 1;
+    if (metadataLength === 255 && encryptedData.length >= pos + 2) {
+      metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce((acc, val) => (acc << 8) + val, 0);
+      pos += 2;
+    }
+    return new CryptorHeaderV1(identifier.toString('utf8'), metadataLength);
+  }
+}
+
+// v1 CryptorHeader
+class CryptorHeaderV1 {
+  _identifier;
+  _metadataLength;
+
+  constructor(id: string, metadataLength: number) {
+    this._identifier = id;
+    this._metadataLength = metadataLength;
+  }
+
+  get identifier() {
+    return this._identifier;
+  }
+
+  set identifier(value) {
+    this._identifier = value;
+  }
+
+  get metadataLength() {
+    return this._metadataLength;
+  }
+
+  set metadataLength(value) {
+    this._metadataLength = value;
+  }
+
+  get version() {
+    return CryptorHeader.VERSION;
+  }
+
+  get length() {
+    return (
+      CryptorHeader.SENTINEL.length +
+      1 +
+      CryptorHeader.IDENTIFIER_LENGTH +
+      (this.metadataLength < 255 ? 1 : 3) +
+      this.metadataLength
+    );
+  }
+
+  get data() {
+    let pos = 0;
+    const header = new Uint8Array(this.length);
+    header.set(Buffer.from(CryptorHeader.SENTINEL));
+    pos += CryptorHeader.SENTINEL.length;
+    header[pos] = this.version;
+    pos++;
+    if (this.identifier) header.set(Buffer.from(this.identifier), pos);
+    pos += CryptorHeader.IDENTIFIER_LENGTH;
+    const metadataLength = this.metadataLength;
+    if (metadataLength < 255) {
+      header[pos] = metadataLength;
+    } else {
+      header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);
+    }
+    return header;
+  }
+}

--- src/crypto/modules/WebCryptoModule/ICryptor.ts ---
@@ -0,0 +1,13 @@
+export type EncryptedDataType = {
+  data: ArrayBuffer;
+  metadata: ArrayBuffer | null;
+};
+
+export interface ICryptor {
+  get identifier(): string;
+  encrypt(data: ArrayBuffer | string): EncryptedDataType;
+  decrypt(data: EncryptedDataType): ArrayBuffer;
+
+  encryptFileData(data: ArrayBuffer): Promise<EncryptedDataType>;
+  decryptFileData(data: EncryptedDataType): Promise<ArrayBuffer>;
+}

--- src/crypto/modules/WebCryptoModule/ILegacyCryptor.ts ---
@@ -0,0 +1,24 @@
+import { EncryptedDataType } from './ICryptor';
+
+export type PubNubFileType = {
+  data: File | Blob;
+  name: string;
+  mimeType: string;
+
+  create(config: any): PubNubFileType;
+
+  toArrayBuffer(): ArrayBuffer;
+  toBlob(): Blob;
+  toString(): string;
+  toFile(): File;
+};
+
+export interface ILegacyCryptor<T extends PubNubFileType> {
+  get identifier(): string;
+
+  encrypt(data: ArrayBuffer | string): EncryptedDataType;
+  decrypt(data: EncryptedDataType): ArrayBuffer | string;
+
+  encryptFile(file: T, File: T): Promise<T>;
+  decryptFile(file: T, File: T): Promise<T>;
+}

--- src/crypto/modules/WebCryptoModule/aesCbcCryptor.ts ---
@@ -0,0 +1,86 @@
+import { ICryptor, EncryptedDataType } from './ICryptor';
+import cryptoJS from '../../../core/components/cryptography/hmac-sha256';
+import { decode } from '../../../core/components/base64_codec';
+
+export default class AesCbcCryptor implements ICryptor {
+  static BLOCK_SIZE = 16;
+  static encoder = new TextEncoder();
+  static decoder = new TextDecoder();
+
+  cipherKey: string;
+  encryptedKey: any;
+  CryptoJS: any;
+
+  constructor(configuration: { cipherKey: string }) {
+    this.cipherKey = configuration.cipherKey;
+    this.CryptoJS = cryptoJS;
+    this.encryptedKey = this.CryptoJS.SHA256(this.cipherKey);
+  }
+
+  get algo() {
+    return 'AES-CBC';
+  }
+
+  get identifier() {
+    return 'ACRH';
+  }
+
+  private getIv() {
+    return crypto.getRandomValues(new Uint8Array(AesCbcCryptor.BLOCK_SIZE));
+  }
+
+  private async getKey() {
+    const bKey = AesCbcCryptor.encoder.encode(this.cipherKey);
+    const abHash = await crypto.subtle.digest('SHA-256', bKey.buffer);
+    return crypto.subtle.importKey('raw', abHash, this.algo, true, ['encrypt', 'decrypt']);
+  }
+
+  encrypt(data: ArrayBuffer | string) {
+    const stringData = typeof data === 'string' ? data : AesCbcCryptor.decoder.decode(data);
+    if (stringData.length === 0) throw new Error('encryption error. empty content');
+    const abIv = this.getIv();
+    return {
+      metadata: abIv,
+      data: decode(
+        this.CryptoJS.AES.encrypt(data, this.encryptedKey, {
+          iv: this.bufferToWordArray(abIv),
+          mode: this.CryptoJS.mode.CBC,
+        }).ciphertext.toString(this.CryptoJS.enc.Base64),
+      ),
+    };
+  }
+
+  decrypt(encryptedData: EncryptedDataType) {
+    const iv = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.metadata!));
+    const data = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.data));
+    return AesCbcCryptor.encoder.encode(
+      this.CryptoJS.AES.decrypt({ ciphertext: data }, this.encryptedKey, {
+        iv,
+        mode: this.CryptoJS.mode.CBC,
+      }).toString(this.CryptoJS.enc.Utf8),
+    ).buffer;
+  }
+
+  async encryptFileData(data: ArrayBuffer): Promise<EncryptedDataType> {
+    const key = await this.getKey();
+    const iv = this.getIv();
+    return {
+      data: await crypto.subtle.encrypt({ name: this.algo, iv: iv }, key, data),
+      metadata: iv,
+    };
+  }
+
+  async decryptFileData(encryptedData: EncryptedDataType): Promise<ArrayBuffer> {
+    const key = await this.getKey();
+    return crypto.subtle.decrypt({ name: this.algo, iv: encryptedData.metadata! }, key, encryptedData.data);
+  }
+
+  private bufferToWordArray(b: any) {
+    const wa: any[] = [];
+    let i;
+    for (i = 0; i < b.length; i += 1) {
+      wa[(i / 4) | 0] |= b[i] << (24 - 8 * i);
+    }
+    return this.CryptoJS.lib.WordArray.create(wa, b.length);
+  }
+}

--- src/crypto/modules/WebCryptoModule/legacyCryptor.ts ---
@@ -0,0 +1,46 @@
+import Crypto from '../../../core/components/cryptography/index';
+import FileCryptor from '../web';
+import { EncryptedDataType } from './ICryptor';
+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';
+import { encode } from '../../../core/components/base64_codec';
+
+export default class LegacyCryptor implements ILegacyCryptor<PubNubFileType> {
+  config;
+
+  cryptor;
+  fileCryptor;
+
+  constructor(config: any) {
+    this.config = config;
+    this.cryptor = new Crypto({ config });
+    this.fileCryptor = new FileCryptor();
+  }
+
+  get identifier() {
+    return '';
+  }
+  encrypt(data: ArrayBuffer | string) {
+    const stringData = typeof data === 'string' ? data : new TextDecoder().decode(data);
+    return {
+      data: this.cryptor.encrypt(stringData),
+      metadata: null,
+    };
+  }
+
+  decrypt(encryptedData: EncryptedDataType) {
+    const data = typeof encryptedData.data === 'string' ? encryptedData.data : encode(encryptedData.data);
+    return this.cryptor.decrypt(data);
+  }
+
+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {
+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+    //@ts-ignore: can not detect cipherKey from old Config
+    return this.fileCryptor.encryptFile(this.config?.cipherKey, file, File);
+  }
+
+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {
+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+    //@ts-ignore: can not detect cipherKey from old Config
+    return this.fileCryptor.decryptFile(this.config.cipherKey, file, File);
+  }
+}

--- src/crypto/modules/WebCryptoModule/webCryptoModule.ts ---
@@ -0,0 +1,273 @@
+import LegacyCryptor from './legacyCryptor';
+import AesCbcCryptor from './aesCbcCryptor';
+import { EncryptedDataType, ICryptor } from './ICryptor';
+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';
+import { decode } from '../../../core/components/base64_codec';
+
+export { LegacyCryptor, AesCbcCryptor };
+
+type CryptorType = ICryptor | ILegacyCryptor<PubNubFileType>;
+
+type CryptoModuleConfiguration = {
+  default: CryptorType;
+  cryptors?: Array<CryptorType>;
+};
+
+export class CryptoModule {
+  static LEGACY_IDENTIFIER = '';
+  static encoder = new TextEncoder();
+  static decoder = new TextDecoder();
+  defaultCryptor: CryptorType;
+  cryptors: Array<CryptorType>;
+
+  constructor(cryptoModuleConfiguration: CryptoModuleConfiguration) {
+    this.defaultCryptor = cryptoModuleConfiguration.default;
+    this.cryptors = cryptoModuleConfiguration.cryptors ?? [];
+  }
+
+  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+  //@ts-ignore: type detection issue with old Config type assignment
+  static legacyCryptoModule(config) {
+    return new this({
+      default: new LegacyCryptor({
+        cipherKey: config.cipherKey,
+        useRandomIVs: config.useRandomIVs ?? true,
+      }),
+      cryptors: [new AesCbcCryptor({ cipherKey: config.cipherKey })],
+    });
+  }
+
+  static aesCbcCryptoModule(config: any) {
+    return new this({
+      default: new AesCbcCryptor({ cipherKey: config.cipherKey }),
+      cryptors: [
+        new LegacyCryptor({
+          cipherKey: config.cipherKey,
+          useRandomIVs: config.useRandomIVs ?? true,
+        }),
+      ],
+    });
+  }
+
+  static withDefaultCryptor(defaultCryptor: CryptorType) {
+    return new this({ default: defaultCryptor });
+  }
+
+  private getAllCryptors() {
+    return [this.defaultCryptor, ...this.cryptors];
+  }
+
+  encrypt(data: ArrayBuffer | string) {
+    const encrypted = (this.defaultCryptor as ICryptor).encrypt(data);
+    if (!encrypted.metadata) return encrypted.data;
+    const headerData = this.getHeaderData(encrypted);
+    return this.concatArrayBuffer(headerData!, encrypted.data);
+  }
+
+  decrypt(data: ArrayBuffer | string) {
+    const encryptedData = typeof data === 'string' ? decode(data) : data;
+    const header = CryptorHeader.tryParse(encryptedData);
+    const cryptor = this.getCryptor(header);
+    const metadata =
+      header.length > 0
+        ? encryptedData.slice(header.length - (header as CryptorHeaderV1).metadataLength, header.length)
+        : null;
+    if (encryptedData.slice(header.length).byteLength <= 0) throw new Error('decryption error. empty content');
+    return cryptor!.decrypt({
+      data: encryptedData.slice(header.length),
+      metadata: metadata,
+    });
+  }
+
+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {
+    if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)
+      return (this.defaultCryptor as ILegacyCryptor<PubNubFileType>).encryptFile(file, File);
+    const fileData = this.getFileData(file.data);
+    const encrypted = await (this.defaultCryptor as ICryptor).encryptFileData(fileData);
+    return File.create({
+      name: file.name,
+      mimeType: 'application/octet-stream',
+      data: this.concatArrayBuffer(this.getHeaderData(encrypted)!, encrypted.data),
+    });
+  }
+
+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {
+    const data = await file.data.arrayBuffer();
+    const header = CryptorHeader.tryParse(data);
+    const cryptor = this.getCryptor(header);
+    if (cryptor?.identifier === CryptoModule.LEGACY_IDENTIFIER) {
+      return (cryptor as ILegacyCryptor<PubNubFileType>).decryptFile(file, File);
+    }
+    const fileData = this.getFileData(data);
+    const metadata = fileData.slice(header.length - (header as CryptorHeaderV1).metadataLength, header.length);
+    return File.create({
+      name: file.name,
+      data: await (this.defaultCryptor as ICryptor).decryptFileData({
+        data: data.slice(header.length),
+        metadata: metadata,
+      }),
+    });
+  }
+
+  private getCryptor(header: string | CryptorHeaderV1) {
+    if (header === '') {
+      const cryptor = this.getAllCryptors().find((c) => c.identifier === '');
+      if (cryptor) return cryptor;
+      throw new Error('unknown cryptor error');
+    } else if (header instanceof CryptorHeaderV1) {
+      return this.getCryptorFromId(header.identifier);
+    }
+  }
+
+  private getCryptorFromId(id: string) {
+    const cryptor = this.getAllCryptors().find((c) => id === c.identifier);
+    if (cryptor) {
+      return cryptor;
+    }
+    throw Error('unknown cryptor error');
+  }
+
+  private concatArrayBuffer(ab1: ArrayBuffer, ab2: ArrayBuffer) {
+    const tmp = new Uint8Array(ab1.byteLength + ab2.byteLength);
+
+    tmp.set(new Uint8Array(ab1), 0);
+    tmp.set(new Uint8Array(ab2), ab1.byteLength);
+
+    return tmp.buffer;
+  }
+
+  private getHeaderData(encrypted: EncryptedDataType) {
+    if (!encrypted.metadata) return;
+    const header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);
+    const headerData = new Uint8Array(header!.length);
+    let pos = 0;
+    headerData.set(header!.data, pos);
+    pos += header!.length - encrypted.metadata.byteLength;
+    headerData.set(new Uint8Array(encrypted.metadata), pos);
+    return headerData.buffer;
+  }
+
+  private getFileData(input: any) {
+    if (input instanceof ArrayBuffer) {
+      return input;
+    }
+    if (typeof input === 'string') {
+      return CryptoModule.encoder.encode(input);
+    }
+    throw new Error('Cannot decrypt/encrypt file. In browsers file decryption supports only string or ArrayBuffer');
+  }
+}
+
+// CryptorHeader Utility
+class CryptorHeader {
+  static SENTINEL = 'PNED';
+  static LEGACY_IDENTIFIER = '';
+  static IDENTIFIER_LENGTH = 4;
+  static VERSION = 1;
+  static MAX_VERSION = 1;
+  static decoder = new TextDecoder();
+
+  static from(id: string, metadata: ArrayBuffer) {
+    if (id === CryptorHeader.LEGACY_IDENTIFIER) return;
+    return new CryptorHeaderV1(id, metadata.byteLength);
+  }
+
+  static tryParse(data: ArrayBuffer) {
+    const encryptedData = new Uint8Array(data);
+    let sentinel: any = '';
+    let version = null;
+    if (encryptedData.byteLength >= 4) {
+      sentinel = encryptedData.slice(0, 4);
+      if (this.decoder.decode(sentinel) !== CryptorHeader.SENTINEL) return '';
+    }
+    if (encryptedData.byteLength >= 5) {
+      version = (encryptedData as Uint8Array)[4] as number;
+    } else {
+      throw new Error('decryption error. invalid header version');
+    }
+    if (version > CryptorHeader.MAX_VERSION) throw new Error('unknown cryptor error');
+
+    let identifier: any = '';
+    let pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;
+    if (encryptedData.byteLength >= pos) {
+      identifier = encryptedData.slice(5, pos);
+    } else {
+      throw new Error('decryption error. invalid crypto identifier');
+    }
+    let metadataLength = null;
+    if (encryptedData.byteLength >= pos + 1) {
+      metadataLength = (encryptedData as Uint8Array)[pos];
+    } else {
+      throw new Error('decryption error. invalid metadata length');
+    }
+    pos += 1;
+    if (metadataLength === 255 && encryptedData.byteLength >= pos + 2) {
+      metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce((acc, val) => (acc << 8) + val, 0);
+      pos += 2;
+    }
+    return new CryptorHeaderV1(this.decoder.decode(identifier), metadataLength);
+  }
+}
+
+// v1 CryptorHeader
+class CryptorHeaderV1 {
+  static IDENTIFIER_LENGTH = 4;
+  static SENTINEL = 'PNED';
+
+  _identifier;
+  _metadataLength;
+
+  constructor(id: string, metadataLength: number) {
+    this._identifier = id;
+    this._metadataLength = metadataLength;
+  }
+
+  get identifier() {
+    return this._identifier;
+  }
+
+  set identifier(value) {
+    this._identifier = value;
+  }
+
+  get metadataLength() {
+    return this._metadataLength;
+  }
+
+  set metadataLength(value) {
+    this._metadataLength = value;
+  }
+
+  get version() {
+    return CryptorHeader.VERSION;
+  }
+
+  get length() {
+    return (
+      CryptorHeader.SENTINEL.length +
+      1 +
+      CryptorHeader.IDENTIFIER_LENGTH +
+      (this.metadataLength < 255 ? 1 : 3) +
+      this.metadataLength
+    );
+  }
+
+  get data() {
+    let pos = 0;
+    const header = new Uint8Array(this.length);
+    const encoder = new TextEncoder();
+    header.set(encoder.encode(CryptorHeader.SENTINEL));
+    pos += CryptorHeader.SENTINEL.length;
+    header[pos] = this.version;
+    pos++;
+    if (this.identifier) header.set(encoder.encode(this.identifier), pos);
+    pos += CryptorHeader.IDENTIFIER_LENGTH;
+    const metadataLength = this.metadataLength;
+    if (metadataLength < 255) {
+      header[pos] = metadataLength;
+    } else {
+      header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);
+    }
+    return header;
+  }
+}

--- src/crypto/modules/node.js ---
@@ -1,5 +1,5 @@
 /**       */
-import { Readable, PassThrough } from 'stream';
+import { Readable, PassThrough, Transform } from 'stream';
 import { createCipheriv, createDecipheriv, createHash, randomBytes } from 'crypto';
 
 export default class NodeCryptography {
@@ -41,13 +41,15 @@ export default class NodeCryptography {
     const bKey = this.getKey(key);
 
     if (file.data instanceof Buffer) {
+      if (file.data.byteLength <= 0) throw new Error('encryption error. empty content');
       return File.create({
         name: file.name,
         mimeType: 'application/octet-stream',
         data: await this.encryptBuffer(bKey, file.data),
       });
     }
     if (file.data instanceof Readable) {
+      if (file.contentLength === 0) throw new Error('encryption error. empty content');
       return File.create({
         name: file.name,
         mimeType: 'application/octet-stream',
@@ -118,22 +120,29 @@ export default class NodeCryptography {
   decryptBuffer(key, ciphertext) {
     const bIv = ciphertext.slice(0, NodeCryptography.IV_LENGTH);
     const bCiphertext = ciphertext.slice(NodeCryptography.IV_LENGTH);
-
+    if (bCiphertext.byteLength <= 0) throw new Error('decryption error: empty content');
     const aes = createDecipheriv(this.algo, key, bIv);
 
     return Buffer.concat([aes.update(bCiphertext), aes.final()]);
   }
 
-  encryptStream(key, stream) {
-    const output = new PassThrough();
+  async encryptStream(key, stream) {
     const bIv = this.getIv();
-
-    const aes = createCipheriv(this.algo, key, bIv);
-
-    output.write(bIv);
-    stream.pipe(aes).pipe(output);
-
-    return output;
+    const aes = createCipheriv('aes-256-cbc', key, bIv).setAutoPadding(true);
+    let inited = false;
+    return stream.pipe(aes).pipe(
+      new Transform({
+        transform(chunk, _, cb) {
+          if (!inited) {
+            inited = true;
+            this.push(Buffer.concat([bIv, chunk]));
+          } else {
+            this.push(chunk);
+          }
+          cb();
+        },
+      }),
+    );
   }
 
   decryptStream(key, stream) {

--- src/crypto/modules/web.js ---
@@ -11,6 +11,8 @@ function concatArrayBuffer(ab1, ab2) {
 
 export default class WebCryptography {
   static IV_LENGTH = 16;
+  static encoder = new TextEncoder();
+  static decoder = new TextDecoder();
 
   get algo() {
     return 'aes-256-cbc';
@@ -30,7 +32,6 @@ export default class WebCryptography {
 
   async decrypt(key, input) {
     const cKey = await this.getKey(key);
-
     if (input instanceof ArrayBuffer) {
       return this.decryptArrayBuffer(cKey, input);
     }
@@ -41,9 +42,10 @@ export default class WebCryptography {
   }
 
   async encryptFile(key, file, File) {
+    if (file.data.byteLength <= 0) throw new Error('encryption error. empty content');
     const bKey = await this.getKey(key);
 
-    const abPlaindata = await file.toArrayBuffer();
+    const abPlaindata = await file.data.arrayBuffer();
 
     const abCipherdata = await this.encryptArrayBuffer(bKey, abPlaindata);
 
@@ -57,8 +59,7 @@ export default class WebCryptography {
   async decryptFile(key, file, File) {
     const bKey = await this.getKey(key);
 
-    const abCipherdata = await file.toArrayBuffer();
-
+    const abCipherdata = await file.data.arrayBuffer();
     const abPlaindata = await this.decryptArrayBuffer(bKey, abCipherdata);
 
     return File.create({
@@ -68,11 +69,11 @@ export default class WebCryptography {
   }
 
   async getKey(key) {
-    const bKey = Buffer.from(key);
-    const abHash = await crypto.subtle.digest('SHA-256', bKey.buffer);
-
-    const abKey = Buffer.from(Buffer.from(abHash).toString('hex').slice(0, 32), 'utf8').buffer;
-
+    const digest = await crypto.subtle.digest('SHA-256', WebCryptography.encoder.encode(key));
+    const hashHex = Array.from(new Uint8Array(digest))
+      .map((b) => b.toString(16).padStart(2, '0'))
+      .join('');
+    const abKey = WebCryptography.encoder.encode(hashHex.slice(0, 32)).buffer;
     return crypto.subtle.importKey('raw', abKey, 'AES-CBC', true, ['encrypt', 'decrypt']);
   }
 
@@ -84,28 +85,33 @@ export default class WebCryptography {
 
   async decryptArrayBuffer(key, ciphertext) {
     const abIv = ciphertext.slice(0, 16);
-
-    return crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(16));
+    if (ciphertext.slice(WebCryptography.IV_LENGTH).byteLength <= 0) throw new Error('decryption error: empty content');
+    const data = await crypto.subtle.decrypt(
+      { name: 'AES-CBC', iv: abIv },
+      key,
+      ciphertext.slice(WebCryptography.IV_LENGTH),
+    );
+    return data;
   }
 
   async encryptString(key, plaintext) {
     const abIv = crypto.getRandomValues(new Uint8Array(16));
 
-    const abPlaintext = Buffer.from(plaintext).buffer;
+    const abPlaintext = WebCryptography.encoder.encode(plaintext).buffer;
     const abPayload = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: abIv }, key, abPlaintext);
 
     const ciphertext = concatArrayBuffer(abIv.buffer, abPayload);
 
-    return Buffer.from(ciphertext).toString('utf8');
+    return WebCryptography.decoder.decode(ciphertext);
   }
 
   async decryptString(key, ciphertext) {
-    const abCiphertext = Buffer.from(ciphertext);
+    const abCiphertext = WebCryptography.encoder.encode(ciphertext).buffer;
     const abIv = abCiphertext.slice(0, 16);
     const abPayload = abCiphertext.slice(16);
 
     const abPlaintext = await crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, abPayload);
 
-    return Buffer.from(abPlaintext).toString('utf8');
+    return WebCryptography.decoder.decode(abPlaintext);
   }
 }

--- src/file/modules/node.js ---
@@ -1,11 +1,7 @@
-/**       */
-
 import { Readable, PassThrough } from 'stream';
-import { ReadStream } from 'fs';
+import fs from 'fs';
 import { basename } from 'path';
 
-import { IFile, FileClass } from '..';
-
 const PubNubFile = class PubNubFile {
   static supportsBlob = false;
 
@@ -29,6 +25,8 @@ const PubNubFile = class PubNubFile {
 
   mimeType;
 
+  contentLength;
+
   static create(config) {
     return new this(config);
   }
@@ -37,9 +35,10 @@ const PubNubFile = class PubNubFile {
     if (stream instanceof Readable) {
       this.data = stream;
 
-      if (stream instanceof ReadStream) {
+      if (stream instanceof fs.ReadStream) {
         // $FlowFixMe: incomplete flow node definitions
         this.name = basename(stream.path);
+        this.contentLength = fs.statSync(stream.path).size;
       }
     } else if (data instanceof Buffer) {
       this.data = Buffer.from(data);

--- src/node/index.ts ---
@@ -8,8 +8,10 @@ import { keepAlive, proxy } from '../networking/modules/node';
 
 import NodeCryptography from '../crypto/modules/node';
 import PubNubFile from '../file/modules/node';
+import { CryptoModule, LegacyCryptor, AesCbcCryptor } from '../crypto/modules/NodeCryptoModule/nodeCryptoModule';
 
 export = class extends PubNubCore {
+  static CryptoModule = CryptoModule;
   constructor(setup: any) {
     setup.cbor = new Cbor((buffer: ArrayBuffer) => CborReader.decode(Buffer.from(buffer)), decode);
     setup.networking = new Networking({
@@ -27,6 +29,16 @@ export = class extends PubNubCore {
     setup.PubNubFile = PubNubFile;
     setup.cryptography = new NodeCryptography();
 
+    setup.initCryptoModule = (cryptoConfiguration: any) => {
+      return new CryptoModule({
+        default: new LegacyCryptor({
+          cipherKey: cryptoConfiguration.cipherKey,
+          useRandomIVs: cryptoConfiguration.useRandomIVs,
+        }),
+        cryptors: [new AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],
+      });
+    };
+
     if (!('ssl' in setup)) {
       setup.ssl = true;
     }

--- src/web/index.js ---
@@ -11,6 +11,7 @@ import { del, get, post, patch, getfile, postfile } from '../networking/modules/
 
 import WebCryptography from '../crypto/modules/web';
 import PubNubFile from '../file/modules/web';
+import { CryptoModule, LegacyCryptor, AesCbcCryptor } from '../crypto/modules/WebCryptoModule/webCryptoModule';
 
 function sendBeacon(url) {
   if (navigator && navigator.sendBeacon) {
@@ -21,10 +22,10 @@ function sendBeacon(url) {
 }
 
 export default class extends PubNubCore {
+  static CryptoModule = CryptoModule;
   constructor(setup) {
     // extract config.
     const { listenToBrowserNetworkEvents = true } = setup;
-
     setup.sdkFamily = 'Web';
     setup.networking = new Networking({
       del,
@@ -40,6 +41,16 @@ export default class extends PubNubCore {
     setup.PubNubFile = PubNubFile;
     setup.cryptography = new WebCryptography();
 
+    setup.initCryptoModule = (cryptoConfiguration) => {
+      return new CryptoModule({
+        default: new LegacyCryptor({
+          cipherKey: cryptoConfiguration.cipherKey,
+          useRandomIVs: cryptoConfiguration.useRandomIVs,
+        }),
+        cryptors: [new AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],
+      });
+    };
+
     super(setup);
 
     if (listenToBrowserNetworkEvents) {

--- test/contract/steps/cryptoModule/cryptoModule.ts ---
@@ -0,0 +1,178 @@
+import { Given, When, Then, Before } from '@cucumber/cucumber';
+import { expect } from 'chai';
+import fs from 'fs';
+
+import {
+  CryptoModule,
+  AesCbcCryptor,
+  LegacyCryptor,
+} from '../../../../lib/crypto/modules/NodeCryptoModule/nodeCryptoModule.js';
+
+Before(function () {
+  this.useRandomIVs = true;
+});
+
+Given('Crypto module with {string} cryptor', function (cryptorIdentifier: string) {
+  this.cryptorIdentifier = cryptorIdentifier;
+});
+
+Given(
+  'Crypto module with default {string} and additional {string} cryptors',
+  function (defaultCryptorId: string, additionalCryptorId: string) {
+    this.defaultCryptorId = defaultCryptorId;
+    this.additionalCryptorId = additionalCryptorId;
+  },
+);
+
+Given('with {string} cipher key', function (cipherKey: string) {
+  this.cipherKey = cipherKey;
+});
+
+Given('with {string} vector', function (vector: string) {
+  if (vector === 'constant') this.useRandomIVs = false;
+  this._initCryptor = (id: string) => {
+    return id === 'legacy'
+      ? new LegacyCryptor({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs })
+      : new AesCbcCryptor({ cipherKey: this.cipherKey });
+  };
+});
+
+When('I decrypt {string} file', async function (fileName: string) {
+  if (this.cryptorIdentifier === 'acrh') {
+    const cryptor = new AesCbcCryptor({ cipherKey: this.cipherKey });
+    this.cryptoModule = CryptoModule.withDefaultCryptor(cryptor);
+  }
+  const pubnub = await this.getPubnub({ subscribeKey: 'key' });
+  const fileData = fs.readFileSync(this.getFilePath(fileName));
+  const file = pubnub.File.create({
+    name: fileName,
+    mimeType: 'text/plain',
+    data: fileData,
+  });
+  try {
+    const result = await this.cryptoModule.decryptFile(file, pubnub.File);
+  } catch (e: any) {
+    this.errorMessage = e?.message;
+  }
+});
+
+When('I decrypt {string} file as {string}', async function (fileName: string, format: string) {
+  if (this.defaultCryptorId && this.additionalCryptorId) {
+    this.cryptoModule = new CryptoModule({
+      default: this._initCryptor(this.defaultCryptorId),
+      cryptors: [this._initCryptor(this.additionalCryptorId)],
+    });
+  } else {
+    this.cryptoModule = CryptoModule.withDefaultCryptor(this._initCryptor(this.cryptorIdentifier));
+  }
+
+  const pubnub = await this.getPubnub({ subscribeKey: 'key' });
+
+  if (format === 'binary') {
+    this.isBinary = true;
+    if (!this.useRandomIVs) return;
+    let encrypteFile = pubnub.File.create({
+      name: fileName,
+      data: fs.readFileSync(this.getFilePath(fileName)),
+    });
+    try {
+      this.binaryFileResult = await this.cryptoModule.decryptFile(encrypteFile, pubnub.File);
+    } catch (e: any) {
+      this.errorMessage = e?.message;
+    }
+  } else if (format === 'stream') {
+    this.isStream = true;
+    const filestream = fs.createReadStream(this.getFilePath(fileName));
+    this.file = pubnub.File.create({
+      name: fileName,
+      stream: filestream,
+    });
+    try {
+      this.streamFileResult = await this.cryptoModule.decryptFile(this.file, pubnub.File);
+    } catch (e: any) {
+      this.errorMessage = e?.message;
+    }
+  }
+});
+
+Then('Decrypted file content equal to the {string} file content', async function (sourceFile: string) {
+  if (this.isBinary && !this.useRandomIVs) return;
+  if (this.isStream) {
+    const fileStream = await this.streamFileResult.toStream();
+    const tempFilePath = `${__dirname}/${this.file.name}`;
+    const outputStream = fs.createWriteStream(tempFilePath);
+    const expected = fs.readFileSync(this.getFilePath(sourceFile));
+    fileStream.pipe(outputStream);
+    return new Promise((resolve) => {
+      outputStream.on('finish', () => {
+        try {
+          const actual = fs.readFileSync(tempFilePath);
+          expect(Buffer.compare(actual, expected.slice(0, actual.length)) === 0).to.be.true;
+        } finally {
+          fs.unlink(tempFilePath, () => {});
+        }
+        resolve(0);
+      });
+    });
+  }
+  expect(this.binaryFileResult.data.equals(fs.readFileSync(this.getFilePath(sourceFile)))).to.be.true;
+});
+
+Then('I receive {string}', async function (result: string) {
+  if ((this.isBinaryFile || this.isBinary) && !this.useRandomIVs) return;
+  if (result === 'success') {
+    expect(this.errorMessage).to.be.undefined;
+  } else {
+    expect(this.errorMessage).to.have.string(result);
+  }
+});
+
+Given('Legacy code with {string} cipher key and {string} vector', function (cipherKey: string, vector: string) {
+  const cryptor = new LegacyCryptor({ cipherKey: cipherKey, useRandomIVs: vector === 'random' ? true : false });
+  this.cryptoModule = CryptoModule.withDefaultCryptor(cryptor);
+});
+
+When('I encrypt {string} file as {string}', async function (fileName: string, format: string) {
+  this.pubnub = await this.getPubnub({ subscribeKey: 'key' });
+  this.fileDataBuffer = fs.readFileSync(this.getFilePath(fileName));
+  if (format === 'stream') {
+    this.file = this.pubnub.File.create({
+      name: fileName,
+      mimeType: 'application/octet-stream',
+      stream: fs.createReadStream(this.getFilePath(fileName)),
+    });
+    this.isStream = true;
+  } else {
+    this.file = this.pubnub.File.create({
+      name: fileName,
+      mimeType: 'application/octet-stream',
+      data: this.fileDataBuffer,
+    });
+    this.isBinaryFile = true;
+  }
+  if (!this.cryptoModule) {
+    this.cryptoModule = CryptoModule.withDefaultCryptor(this._initCryptor(this.cryptorIdentifier));
+  }
+  try {
+    this.encryptedFile = await this.cryptoModule.encryptFile(this.file, this.pubnub.File);
+  } catch (e: any) {
+    this.errorMessage = e?.message;
+  }
+});
+
+Then('Successfully decrypt an encrypted file with legacy code', async function () {
+  const decryptedFile = await this.cryptoModule.decryptFile(this.encryptedFile, this.pubnub.File);
+  if (this.isStream) {
+    const fileStream = await decryptedFile.toStream();
+    const tempFilePath = `${__dirname}/${this.file.name}`;
+    const outputStream = fs.createWriteStream(tempFilePath);
+    fileStream.pipe(outputStream);
+    outputStream.on('end', () => {
+      const actualFileBuffer = fs.readFileSync(tempFilePath);
+      expect(actualFileBuffer).to.equalBytes(this.fileDataBuffer);
+      fs.unlink(tempFilePath, () => {});
+    });
+  } else {
+    expect(decryptedFile.data.toString('utf8')).to.equal(this.fileDataBuffer.toString('utf8'));
+  }
+});

--- test/contract/utils.ts ---
@@ -7,3 +7,7 @@ export function loadFixtureFile(persona) {
   );
   return JSON.parse(fileData);
 }
+
+export function getFilePath(filename) {
+  return `${process.cwd()}/dist/contract/contract/features/encryption/assets/${filename}`;
+}

--- test/contract/world.ts ---
@@ -4,7 +4,7 @@ import {
   World
 } from '@cucumber/cucumber';
 import PubNub from '../../lib/node/index.js';
-import { loadFixtureFile } from './utils';
+import { loadFixtureFile, getFilePath } from './utils';
 import * as http from 'http';
 
 interface State {
@@ -134,6 +134,9 @@ class PubnubWorld extends World{
     }
     return this.fileFixtures[name];
   }
+  getFilePath(filename) {
+    return getFilePath(filename);
+  }
 }
 
 setWorldConstructor(PubnubWorld);

--- tsconfig.json ---
@@ -1,18 +1,20 @@
 {
   "$schema": "https://json.schemastore.org/tsconfig",
-
   "compilerOptions": {
     "target": "ES5",
     "module": "CommonJS",
     "moduleResolution": "Node",
     "esModuleInterop": true,
-
     "allowJs": true,
     "noEmitOnError": true,
     "strict": true,
     "outDir": "./lib",
     "downlevelIteration": true
   },
-  "include": ["src/**/*"],
-  "exclude": ["node_modules"]
-}
+  "include": [
+    "src/**/*"
+  ],
+  "exclude": [
+    "node_modules"
+  ]
+}
\ No newline at end of file

