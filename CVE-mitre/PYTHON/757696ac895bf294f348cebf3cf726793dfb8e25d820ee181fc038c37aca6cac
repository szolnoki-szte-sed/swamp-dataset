--- changelog.d/20250108_143745_roman_sign_tracker_states.md ---
@@ -0,0 +1,4 @@
+### Security
+
+- Protected tracker functions against deserializing untrusted input
+  (<https://github.com/cvat-ai/cvat/security/advisories/GHSA-wq36-mxf8-hv62>)

--- cvat/apps/lambda_manager/tests/test_lambda.py ---
@@ -12,6 +12,7 @@
 
 import requests
 from django.contrib.auth.models import Group, User
+from django.core.signing import TimestampSigner
 from django.http import HttpResponseNotFound, HttpResponseServerError
 from rest_framework import status
 
@@ -115,8 +116,8 @@ def _invoke_function(self, func, payload):
                 data = []
         elif type_function == "tracker":
             data = {
-                "shape": [12.34, 34.0, 35.01, 41.99],
-                "state": {"key": "value"},
+                "shapes": [[12.34, 34.0, 35.01, 41.99]],
+                "states": [{"key": "value"}],
             }
         elif type_function == "interactor":
             data = [
@@ -779,22 +780,12 @@ def test_api_v2_lambda_functions_create_tracker(self):
         data_main_task = {
             "task": self.main_task["id"],
             "frame": 0,
-            "shape": [
-                12.12,
-                34.45,
-                54.0,
-                76.12,
-            ],
+            "shapes": [[12.12, 34.45, 54.0, 76.12]],
         }
         data_assigneed_to_user_task = {
             "task": self.assigneed_to_user_task["id"],
             "frame": 0,
-            "shape": [
-                12.12,
-                34.45,
-                54.0,
-                76.12,
-            ],
+            "shapes": [[12.12, 34.45, 54.0, 76.12]],
         }
 
         response = self._post_request(
@@ -812,6 +803,22 @@ def test_api_v2_lambda_functions_create_tracker(self):
         )
         self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
 
+    def test_api_v2_lambda_functions_create_tracker_bad_signature(self):
+        signer = TimestampSigner(key="bad key")
+
+        data = {
+            "task": self.main_task["id"],
+            "frame": 0,
+            "shapes": [[12.12, 34.45, 54.0, 76.12]],
+            "states": [signer.sign("{}")],
+        }
+
+        response = self._post_request(
+            f"{LAMBDA_FUNCTIONS_PATH}/{id_function_tracker}", self.admin, data
+        )
+        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
+        self.assertIn("Invalid or expired tracker state", response.content.decode("UTF-8"))
+
     def test_api_v2_lambda_functions_create_reid(self):
         data_main_task = {
             "task": self.main_task["id"],

--- cvat/apps/lambda_manager/views.py ---
@@ -21,6 +21,7 @@
 import rq
 from django.conf import settings
 from django.core.exceptions import ObjectDoesNotExist, ValidationError
+from django.core.signing import BadSignature, TimestampSigner
 from drf_spectacular.types import OpenApiTypes
 from drf_spectacular.utils import (
     OpenApiParameter,
@@ -162,6 +163,8 @@ class LambdaFunction:
         ("frame1", "end frame"),
     )
 
+    TRACKER_STATE_MAX_AGE = timedelta(hours=8)
+
     def __init__(self, gateway, data):
         # ID of the function (e.g. omz.public.yolo-v3)
         self.id = data["metadata"]["name"]
@@ -461,13 +464,27 @@ def validate_attributes_mapping(attributes_mapping, model_attributes, db_attribu
             if max_distance:
                 payload.update({"max_distance": max_distance})
         elif self.kind == FunctionKind.TRACKER:
-            payload.update(
-                {
-                    "image": self._get_image(db_task, mandatory_arg("frame")),
-                    "shapes": data.get("shapes", []),
-                    "states": data.get("states", []),
-                }
-            )
+            signer = TimestampSigner(salt=f"cvat-tracker-state:{self.id}")
+
+            try:
+                payload.update(
+                    {
+                        "image": self._get_image(db_task, mandatory_arg("frame")),
+                        "shapes": data.get("shapes", []),
+                        "states": [
+                            (
+                                None
+                                if state is None
+                                else json.loads(
+                                    signer.unsign(state, max_age=self.TRACKER_STATE_MAX_AGE)
+                                )
+                            )
+                            for state in data.get("states", [])
+                        ],
+                    }
+                )
+            except BadSignature as ex:
+                raise ValidationError("Invalid or expired tracker state") from ex
         else:
             raise ValidationError(
                 "`{}` lambda function has incorrect type: {}".format(self.id, self.kind),
@@ -536,6 +553,14 @@ def transform_attributes(input_attributes, attr_mapping, db_attributes):
                 response_filtered.append(item)
 
             response = response_filtered
+        elif self.kind == FunctionKind.TRACKER:
+            response["states"] = [
+                # We could've used .sign_object, but that unconditionally applies
+                # an extra layer of Base64 encoding, bloating each state by 33%.
+                # So we just encode the state manually instead.
+                signer.sign(json.dumps(state, separators=(",", ":")))
+                for state in response["states"]
+            ]
 
         return response
 

