--- lib/Optimizer/Scalar/SimpleCallGraphProvider.cpp ---
@@ -66,6 +66,13 @@ static bool identifyCallees(CallInst *CI, llvh::DenseSet<Function *> &callees) {
 static bool identifyCallsites(
     Function *F,
     llvh::DenseSet<CallInst *> &callSites) {
+  // Non-strict functions can be aliased in multiple ways (
+  // arguments.callee, Function.prototype.caller etc). Do not try to identify
+  // the callsites for those.
+  if (!F->isStrictMode()) {
+    return false;
+  }
+
   for (auto *CU : F->getUsers()) {
     if (auto *CI = llvh::dyn_cast<CallInst>(CU)) {
       if (!isDirectCallee(F, CI))

--- test/Optimizer/non-strict-opts.js ---
@@ -39,7 +39,7 @@ function main()  {
 // CHECK-NEXT:  %3 = ReturnInst undefined : undefined
 // CHECK-NEXT:function_end
 
-// CHECK:function foo#1#2(p1 : number)#3 : string
+// CHECK:function foo#1#2(p1)#3 : string
 // CHECK-NEXT:S{foo#1#2()#3} = []
 // CHECK-NEXT:%BB0:
 // CHECK-NEXT:  %0 = CreateScopeInst %S{foo#1#2()#3}

--- test/hermes/regress-arguments-callee.js ---
@@ -0,0 +1,133 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+// RUN: %hermes %s
+
+var f;
+var funcp;
+var argumentsp;
+var callee = _ => "callee";
+
+function calleeDirectly(a) {
+    return a.callee;
+}
+
+function calleeIndirectly(a) {
+    return a[callee()];
+}
+
+print("directArgumentsCallee");
+(function directArgumentsCallee(param) {
+    try {
+        funcp = arguments.callee;
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = funcp({ a: 1.1 });
+f();
+
+print("indirectArgumentsCallee");
+(function indirectArgumentsCallee(param) {
+    try {
+        funcp = arguments.callee;
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = funcp({ a: 1.1 });
+f();
+
+print("passignArgumentsToAnotherFunction_directArgumentsCallee");
+(function passignArgumentsToAnotherFunction_DirectArgumentsCallee(param) {
+    try {
+        funcp = calleeDirectly(arguments);
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = funcp({ a: 1.1 });
+f();
+
+print("passignArgumentsToAnotherFunction_indirectArgumentsCallee");
+(function passignArgumentsToAnotherFunction_indirectArgumentsCallee(param) {
+    try {
+        funcp = calleeIndirectly(arguments);
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = funcp({ a: 1.1 });
+f();
+
+print("arrow_directArgumentsCallee");
+(function arrow_directArgumentsCallee(param) {
+    try {
+        funcp = (_ => arguments.callee)();
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = funcp({ a: 1.1 });
+f();
+
+print("arrow_indirectArgumentsCallee");
+(function arrow_indirectArgumentsCallee(param) {
+    try {
+        funcp = (_ => arguments[callee()])();
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = funcp({ a: 1.1 });
+f();
+
+print("capture_directArgumentsCallee");
+(function capture_directArgumentsCallee(param) {
+    try {
+        argumentsp = arguments;
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = argumentsp.callee({ a: 1.1 });
+f();
+
+print("capture_indirectArgumentsCallee");
+(function capture_indirectArgumentsCallee(param) {
+    try {
+        argumentsp = arguments;
+    } catch (e) {
+    }
+    let f = () => {
+        return param;
+    };
+    return f;
+})();
+f = argumentsp[callee()]({ a: 1.1 });
+f();

