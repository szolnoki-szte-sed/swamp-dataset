--- lib/msf/core/post/linux/busy_box.rb ---
@@ -1,109 +1,118 @@
 # -*- coding: binary -*-
 
+require 'rex'
 
 module Msf
-class Post
-module Linux
-module BusyBox
-
-  include ::Msf::Post::Common
-  include ::Msf::Post::File
-
-  # Checks if the file exists in the target
-  #
-  # @param file_path [String] the target file path
-  # @return [Boolean] true if files exists, false otherwise
-  # @note Msf::Post::File#file? doesnt work because test -f is not available in busybox
-  def busy_box_file_exist?(file_path)
-    contents = read_file(file_path)
-    if contents.nil? || contents.empty?
-      return false
+  class Post
+    module Linux
+      module BusyBox
+        include ::Msf::Post::Common
+        include ::Msf::Post::File
+
+        #
+        # Checks if the file exists in the target
+        #
+        # @param file_path [String] the target file path
+        # @return [Boolean] true if files exists, false otherwise
+        # @note Msf::Post::File#file? doesnt work because test -f is not available in busybox
+        #
+        def busy_box_file_exist?(file_path)
+          contents = read_file(file_path)
+          if contents.nil? || contents.empty?
+            return false
+          end
+
+          true
+        end
+
+        #
+        # Checks if the directory is writable in the target
+        #
+        # @param dir_path [String] the target directory path
+        # @return [Boolean] true if target directory is writable, false otherwise
+        #
+        def busy_box_is_writable_dir?(dir_path)
+          res = false
+          rand_str = Rex::Text.rand_text_alpha(16)
+          file_path = "#{dir_path}/#{rand_str}"
+
+          cmd_exec("echo #{rand_str}XXX#{rand_str} > #{file_path}")
+          Rex.sleep(0.3)
+          rcv = read_file(file_path)
+
+          if rcv.include?("#{rand_str}XXX#{rand_str}")
+            res = true
+          end
+
+          cmd_exec("rm -f #{file_path}")
+          Rex.sleep(0.3)
+
+          res
+        end
+
+        #
+        # Checks some directories that usually are writable in devices running busybox
+        #
+        # @return [String] If the function finds a writable directory, it returns the path. Else it returns nil
+        #
+        def busy_box_writable_dir
+          dirs = %w[/etc/ /mnt/ /var/ /var/tmp/]
+
+          dirs.each do |d|
+            return d if busy_box_is_writable_dir?(d)
+          end
+
+          nil
+        end
+
+        #
+        # Writes data to a file
+        #
+        # @param file_path [String] the file path to write on the target
+        # @param data [String] the content to be written
+        # @param prepend [Boolean] if true, prepend the data to the target file. Otherwise, overwrite
+        #   the target file
+        # @return [Boolean] true if target file is writable and it was written. Otherwise, false.
+        # @note BusyBox commands are limited and Msf::Post::File#write_file doesn't work here, because
+        #   of it is necessary to implement an specific method.
+        #
+        def busy_box_write_file(file_path, data, prepend = false)
+          if prepend
+            dir = busy_box_writable_dir
+            return false unless dir
+
+            cmd_exec("cp -f #{file_path} #{dir}tmp")
+            Rex.sleep(0.3)
+          end
+
+          rand_str = Rex::Text.rand_text_alpha(16)
+          cmd_exec("echo #{rand_str} > #{file_path}")
+          Rex.sleep(0.3)
+
+          unless read_file(file_path).include?(rand_str)
+            return false
+          end
+
+          cmd_exec("echo \"\"> #{file_path}")
+          Rex.sleep(0.3)
+
+          lines = data.lines.map(&:chomp)
+          lines.each do |line|
+            cmd_exec("echo #{line.chomp} >> #{file_path}")
+            Rex.sleep(0.3)
+          end
+
+          if prepend
+            cmd_exec("cat #{dir}tmp >> #{file_path}")
+            Rex.sleep(0.3)
+
+            cmd_exec("rm -f #{dir}tmp")
+            Rex.sleep(0.3)
+          end
+
+          true
+        end
+      end
     end
-
-    true
-  end
-
-  # Checks if the directory is writable in the target
-  #
-  # @param dir_path [String] the target directory path
-  # @return [Boolean] true if target directory is writable, false otherwise
-  def busy_box_is_writable_dir?(dir_path)
-    res = false
-    rand_str = Rex::Text.rand_text_alpha(16)
-    file_path = "#{dir_path}/#{rand_str}"
-
-    cmd_exec("echo #{rand_str}XXX#{rand_str} > #{file_path}")
-    Rex::sleep(0.3)
-    rcv = read_file(file_path)
-
-    if rcv.include?("#{rand_str}XXX#{rand_str}")
-      res = true
-    end
-
-    cmd_exec("rm -f #{file_path}")
-    Rex::sleep(0.3)
-
-    res
-  end
-
-  # Checks some directories that usually are writable in devices running busybox
-  # @return [String] If the function finds a writable directory, it returns the path. Else it returns nil
-  def busy_box_writable_dir
-    dirs = %w(/etc/ /mnt/ /var/ /var/tmp/)
-
-    dirs.each do |d|
-      return d if busy_box_is_writable_dir?(d)
-    end
-
-    nil
-  end
-
-
-  # Writes data to a file
-  #
-  # @param file_path [String] the file path to write on the target
-  # @param data [String] the content to be written
-  # @param prepend [Boolean] if true, prepend the data to the target file. Otherwise, overwrite
-  #   the target file
-  # @return [Boolean] true if target file is writable and it was written. Otherwise, false.
-  # @note BusyBox commands are limited and Msf::Post::File#write_file doesn't work here, because
-  #   of it is necessary to implement an specific method.
-  def busy_box_write_file(file_path, data, prepend = false)
-    if prepend
-      dir = busy_box_writable_dir
-      return false unless dir
-      cmd_exec("cp -f #{file_path} #{dir}tmp")
-      Rex::sleep(0.3)
-    end
-
-    rand_str = Rex::Text.rand_text_alpha(16)
-    cmd_exec("echo #{rand_str} > #{file_path}")
-    Rex::sleep(0.3)
-
-    unless read_file(file_path).include?(rand_str)
-      return false
-    end
-
-    cmd_exec("echo \"\"> #{file_path}")
-    Rex::sleep(0.3)
-
-    lines = data.lines.map(&:chomp)
-    lines.each do |line|
-      cmd_exec("echo #{line.chomp} >> #{file_path}")
-      Rex::sleep(0.3)
-    end
-
-    if prepend
-      cmd_exec("cat #{dir}tmp >> #{file_path}")
-      Rex::sleep(0.3)
-
-      cmd_exec("rm -f #{dir}tmp")
-      Rex::sleep(0.3)
-    end
-
-    true
   end
-end # Busybox
-end # Linux
-end # Post
-end # Msf
+end

--- lib/msf/core/post/linux/compile.rb ---
@@ -1,88 +1,113 @@
 # -*- coding: binary -*-
-module Msf
-class Post
-module Linux
-module Compile
-  include ::Msf::Post::Common
-  include ::Msf::Post::File
-  include ::Msf::Post::Unix
-
-  def initialize(info = {})
-    super
-    register_options( [
-      OptEnum.new('COMPILE', [true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']]),
-      OptEnum.new('COMPILER', [true, 'Compiler to use on target', 'Auto', ['Auto', 'gcc', 'clang']]),
-    ], self.class)
-  end
-
-  def get_compiler
-    if has_gcc?
-      return 'gcc'
-    elsif has_clang?
-      return 'clang'
-    else
-      return nil
-    end
-  end
-
-  def live_compile?
-    return false unless %w{ Auto True }.include?(datastore['COMPILE'])
-
-    if datastore['COMPILER'] == 'gcc' && has_gcc?
-      vprint_good 'gcc is installed'
-      return true
-    elsif datastore['COMPILER'] == 'clang' && has_clang?
-      vprint_good 'clang is installed'
-      return true
-    elsif datastore['COMPILER'] == 'Auto' && get_compiler.present?
-      return true
-    end
 
-    unless datastore['COMPILE'] == 'Auto'
-      fail_with Module::Failure::BadConfig, "#{datastore['COMPILER']} is not installed. Set COMPILE False to upload a pre-compiled executable."
-    end
-
-    false
-  end
-
-  def upload_and_compile(path, data, compiler_args='')
-    write_file "#{path}.c", strip_comments(data)
-
-    compiler = datastore['COMPILER']
-    if datastore['COMPILER'] == 'Auto'
-      compiler = get_compiler
-      fail_with(Module::Failure::BadConfig, "Unable to find a compiler on the remote target.") unless compiler.present?
-    end
-
-    compiler_cmd = "#{compiler} -o '#{path}' '#{path}.c'"
-    if session.type == 'shell'
-      compiler_cmd = "PATH=\"$PATH:/usr/bin/\" #{compiler_cmd}"
-    end
-
-    unless compiler_args.to_s.blank?
-      compiler_cmd << " #{compiler_args}"
-    end
-
-    verification_token = Rex::Text.rand_text_alphanumeric(8)
-    success = cmd_exec("#{compiler_cmd} && echo #{verification_token}")&.include?(verification_token)
-
-    rm_f "#{path}.c"
-
-    unless success
-      message = "#{path}.c failed to compile."
-      # don't mention the COMPILE option if it was deregistered
-      message << ' Set COMPILE to False to upload a pre-compiled executable.' if options.include?('COMPILE')
-      fail_with Module::Failure::BadConfig, message
+module Msf
+  class Post
+    module Linux
+      module Compile
+        include ::Msf::Post::Common
+        include ::Msf::Post::Linux::System
+        include ::Msf::Post::File
+        include ::Msf::Post::Unix
+
+        def initialize(info = {})
+          super
+          register_options([
+            OptEnum.new('COMPILE', [true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']]),
+            OptEnum.new('COMPILER', [true, 'Compiler to use on target', 'Auto', ['Auto', 'gcc', 'clang']]),
+          ], self.class)
+        end
+
+        # Determines the available compiler on the target system.
+        #
+        # @return [String, nil] The name of the compiler ('gcc' or 'clang') if available, or nil if none are found.
+        def get_compiler
+          if has_gcc?
+            return 'gcc'
+          elsif has_clang?
+            return 'clang'
+          else
+            return nil
+          end
+        end
+
+        # Checks whether the target supports live compilation based on the module's configuration and available tools.
+        #
+        # @return [Boolean] True if compilation is supported and a compiler is available; otherwise, False.
+        # @raise [Module::Failure::BadConfig] If the specified compiler is not installed and compilation is required.
+        def live_compile?
+          return false unless %w[Auto True].include?(datastore['COMPILE'])
+
+          if datastore['COMPILER'] == 'gcc' && has_gcc?
+            vprint_good 'gcc is installed'
+            return true
+          elsif datastore['COMPILER'] == 'clang' && has_clang?
+            vprint_good 'clang is installed'
+            return true
+          elsif datastore['COMPILER'] == 'Auto' && get_compiler.present?
+            return true
+          end
+
+          unless datastore['COMPILE'] == 'Auto'
+            fail_with Module::Failure::BadConfig, "#{datastore['COMPILER']} is not installed. Set COMPILE False to upload a pre-compiled executable."
+          end
+
+          false
+        end
+
+        #
+        # Uploads C code to the target, compiles it, and handles verification of the compiled binary.
+        #
+        # @param path [String] The path where the compiled binary will be created.
+        # @param data [String] The C code to compile.
+        # @param compiler_args [String] Additional arguments for the compiler command.
+        # @raise [Module::Failure::BadConfig] If compilation fails or no compiler is found.
+        #
+        def upload_and_compile(path, data, compiler_args = '')
+          compiler = datastore['COMPILER']
+          if datastore['COMPILER'] == 'Auto'
+            compiler = get_compiler
+            fail_with(Module::Failure::BadConfig, 'Unable to find a compiler on the remote target.') if compiler.nil?
+          end
+
+          path = "#{path}.c" unless path.end_with?('.c')
+
+          # only upload the file if a compiler exists
+          write_file path.to_s, strip_comments(data)
+
+          compiler_cmd = "#{compiler} -o '#{path.sub(/\.c$/, '')}' '#{path}'"
+          if session.type == 'shell'
+            compiler_cmd = "PATH=\"$PATH:/usr/bin/\" #{compiler_cmd}"
+          end
+
+          unless compiler_args.to_s.blank?
+            compiler_cmd << " #{compiler_args}"
+          end
+
+          verification_token = Rex::Text.rand_text_alphanumeric(8)
+          success = cmd_exec("#{compiler_cmd} && echo #{verification_token}")&.include?(verification_token)
+
+          rm_f path.to_s
+
+          unless success
+            message = "#{path} failed to compile."
+            # don't mention the COMPILE option if it was deregistered
+            message << ' Set COMPILE to False to upload a pre-compiled executable.' if options.include?('COMPILE')
+            fail_with Module::Failure::BadConfig, message
+          end
+
+          chmod path
+        end
+
+        #
+        # Strips comments from C source code.
+        #
+        # @param c_code [String] The C source code.
+        # @return [String] The C code with comments removed.
+        #
+        def strip_comments(c_code)
+          c_code.gsub(%r{/\*.*?\*/}m, '').gsub(%r{^\s*//.*$}, '')
+        end
+      end
     end
-
-    chmod path
   end
-
-  def strip_comments(c_code)
-    c_code.gsub(%r{/\*.*?\*/}m, '').gsub(%r{^\s*//.*$}, '')
-  end
-
-end # Compile
-end # Linux
-end # Post
-end # Msf
+end

--- lib/msf/core/post/linux/kernel.rb ---
@@ -6,10 +6,13 @@ module Linux
       module Kernel
         include ::Msf::Post::Common
         include Msf::Post::File
+
         #
         # Returns uname output
         #
+        # @param opt [String] uname options, defaults to -a
         # @return [String]
+        # @raise [RuntimeError] If execution fails.
         #
         def uname(opts = '-a')
           cmd_exec("uname #{opts}").to_s.strip
@@ -79,9 +82,10 @@ def kernel_arch
         end
 
         #
-        # Returns the kernel boot config
+        # Returns the kernel boot config with comments removed
         #
         # @return [Array]
+        # @raise [RuntimeError] If execution fails.
         #
         def kernel_config
           release = kernel_release
@@ -98,6 +102,7 @@ def kernel_config
         # Returns the kernel modules
         #
         # @return [Array]
+        # @raise [RuntimeError] If execution fails.
         #
         def kernel_modules
           read_file('/proc/modules').to_s.scan(/^[^ ]+/)
@@ -109,6 +114,7 @@ def kernel_modules
         # Returns a list of CPU flags
         #
         # @return [Array]
+        # @raise [RuntimeError] If execution fails.
         #
         def cpu_flags
           cpuinfo = read_file('/proc/cpuinfo').to_s
@@ -124,6 +130,7 @@ def cpu_flags
         # Returns true if kernel and hardware supports Supervisor Mode Access Prevention (SMAP), false if not.
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def smap_enabled?
           cpu_flags.include? 'smap'
@@ -135,6 +142,7 @@ def smap_enabled?
         # Returns true if kernel and hardware supports Supervisor Mode Execution Protection (SMEP), false if not.
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def smep_enabled?
           cpu_flags.include? 'smep'
@@ -146,6 +154,7 @@ def smep_enabled?
         # Returns true if Kernel Address Isolation (KAISER) is enabled
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def kaiser_enabled?
           cpu_flags.include? 'kaiser'
@@ -157,6 +166,7 @@ def kaiser_enabled?
         # Returns true if Kernel Page-Table Isolation (KPTI) is enabled, false if not.
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def kpti_enabled?
           cpu_flags.include? 'pti'
@@ -168,6 +178,7 @@ def kpti_enabled?
         # Returns true if user namespaces are enabled, false if not.
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def userns_enabled?
           return false if read_file('/proc/sys/user/max_user_namespaces').to_s.strip.eql? '0'
@@ -182,6 +193,7 @@ def userns_enabled?
         # Returns true if Address Space Layout Randomization (ASLR) is enabled
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def aslr_enabled?
           aslr = read_file('/proc/sys/kernel/randomize_va_space').to_s.strip
@@ -194,6 +206,7 @@ def aslr_enabled?
         # Returns true if Exec-Shield is enabled
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def exec_shield_enabled?
           exec_shield = read_file('/proc/sys/kernel/exec-shield').to_s.strip
@@ -206,6 +219,7 @@ def exec_shield_enabled?
         # Returns true if unprivileged bpf is disabled
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def unprivileged_bpf_disabled?
           unprivileged_bpf_disabled = read_file('/proc/sys/kernel/unprivileged_bpf_disabled').to_s.strip
@@ -218,6 +232,7 @@ def unprivileged_bpf_disabled?
         # Returns true if kernel pointer restriction is enabled
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def kptr_restrict?
           read_file('/proc/sys/kernel/kptr_restrict').to_s.strip.eql? '1'
@@ -229,6 +244,7 @@ def kptr_restrict?
         # Returns true if dmesg restriction is enabled
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def dmesg_restrict?
           read_file('/proc/sys/kernel/dmesg_restrict').to_s.strip.eql? '1'
@@ -240,6 +256,7 @@ def dmesg_restrict?
         # Returns mmap minimum address
         #
         # @return [Integer]
+        # @raise [RuntimeError] If execution fails.
         #
         def mmap_min_addr
           mmap_min_addr = read_file('/proc/sys/vm/mmap_min_addr').to_s.strip
@@ -253,6 +270,9 @@ def mmap_min_addr
         #
         # Returns true if Linux Kernel Runtime Guard (LKRG) kernel module is installed
         #
+        # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
+        #
         def lkrg_installed?
           directory?('/proc/sys/lkrg')
         rescue StandardError
@@ -262,6 +282,9 @@ def lkrg_installed?
         #
         # Returns true if grsecurity is installed
         #
+        # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
+        #
         def grsec_installed?
           cmd_exec('test -c /dev/grsec && echo true').to_s.strip.include? 'true'
         rescue StandardError
@@ -271,6 +294,9 @@ def grsec_installed?
         #
         # Returns true if PaX is installed
         #
+        # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
+        #
         def pax_installed?
           read_file('/proc/self/status').to_s.include? 'PaX:'
         rescue StandardError
@@ -281,6 +307,7 @@ def pax_installed?
         # Returns true if SELinux is installed
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def selinux_installed?
           cmd_exec('id').to_s.include? 'context='
@@ -292,6 +319,7 @@ def selinux_installed?
         # Returns true if SELinux is in enforcing mode
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def selinux_enforcing?
           return false unless selinux_installed?
@@ -310,6 +338,7 @@ def selinux_enforcing?
         # Returns true if Yama is installed
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def yama_installed?
           ptrace_scope = read_file('/proc/sys/kernel/yama/ptrace_scope').to_s.strip
@@ -324,6 +353,7 @@ def yama_installed?
         # Returns true if Yama is enabled
         #
         # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
         #
         def yama_enabled?
           return false unless yama_installed?
@@ -332,7 +362,7 @@ def yama_enabled?
         rescue StandardError
           raise 'Could not determine Yama status'
         end
-      end # Kernel
-    end # Linux
-  end # Post
-end # Msf
+      end
+    end
+  end
+end

--- lib/msf/core/post/linux/packages.rb ---
@@ -0,0 +1,72 @@
+# -*- coding: binary -*-
+
+module Msf
+  class Post
+    module Linux
+      module Packages
+        include ::Msf::Post::Linux::System
+
+        #
+        # Determines the version of an installed package
+        #
+        # @param package The package name to check for
+        # @return [Rex::Version] nil if OS is not supported or package is not installed
+        #
+        def installed_package_version(package)
+          info = get_sysinfo
+
+          if ['debian', 'ubuntu'].include?(info[:distro])
+            package_version = cmd_exec("dpkg-query -f='${Version}' -W #{package}")
+            # The "no package" error is language based, but "dpkg-query:" starting is not
+            return nil if package_version.start_with?('dpkg-query:')
+
+            package_version = package_version.gsub('+', '.')
+            return Rex::Version.new(package_version)
+          elsif ['redhat', 'fedora', 'centos'].include?(info[:distro])
+            package_version = cmd_exec("rpm -q #{package}")
+            return nil unless package_version.start_with?(package)
+
+            # dnf-4.18.0-2.fc39.noarch
+            # remove package name at the beginning
+            package_version = package_version.split("#{package}-")[1]
+            # remove arch at the end
+            package_version = package_version.sub(/\.[^.]*$/, '')
+            return Rex::Version.new(package_version)
+          elsif ['solaris', 'oracle', 'freebsd'].include?(info[:distro])
+            package_version = cmd_exec("pkg info #{package}")
+            return nil unless package_version.include?('Version')
+
+            package_version = package_version.match(/Version\s+:\s+(.+)/)[1]
+            return Rex::Version.new(package_version)
+          elsif ['gentoo'].include?(info[:distro])
+            # https://wiki.gentoo.org/wiki/Equery
+            if command_exists?('equery')
+              package_version = cmd_exec("equery --quiet list #{package}")
+            # https://wiki.gentoo.org/wiki/Q_applets
+            elsif command_exists?('qlist')
+              package_version = cmd_exec("qlist -Iv #{package}")
+            else
+              vprint_error("installed_package_version couldn't find qlist and equery on gentoo")
+              return nil
+            end
+            return nil if package_version.strip.empty?
+
+            package_version = package_version.split('/')[1]
+            # make gcc-1.1 to 1.1
+            package_version = package_version.sub(/.*?-/, '')
+            return Rex::Version.new(package_version)
+          elsif ['arch'].include?(info[:distro])
+            package_version = cmd_exec("pacman -Qi #{package}")
+            return nil unless package_version.include?('Version')
+
+            package_version = package_version.match(/Version\s+:\s+(.+)/)[1]
+            return Rex::Version.new(package_version)
+          else
+            vprint_error("installed_package_version is being called on an unsupported OS: #{info[:distro]}")
+          end
+          nil
+        end
+      end
+    end
+  end
+end

--- lib/msf/core/post/linux/priv.rb ---
@@ -1,125 +1,198 @@
 # -*- coding: binary -*-
 
 module Msf
-class Post
-module Linux
-module Priv
-  include ::Msf::Post::Common
-
-  #
-  # Returns true if running as root, false if not.
-  # @return [Boolean]
-  #
-  def is_root?
-    if command_exists?('id')
-      user_id = cmd_exec('id -u')
-      clean_user_id = user_id.to_s.gsub(/[^\d]/, '')
-      if clean_user_id.empty?
-        raise "Could not determine UID: #{user_id.inspect}"
+  class Post
+    module Linux
+      module Priv
+        include ::Msf::Post::Common
+        include ::Msf::Post::File
+
+        #
+        # Returns true if running as root, false if not.
+        #
+        # @return [Boolean]
+        # @raise [RuntimeError] If execution fails.
+        #
+        def is_root?
+          if command_exists?('id')
+            user_id = cmd_exec('id -u')
+            clean_user_id = user_id.to_s.gsub(/[^\d]/, '')
+            if clean_user_id.empty?
+              raise "Could not determine UID: #{user_id.inspect}"
+            end
+
+            return (clean_user_id == '0')
+          end
+          user = whoami
+          data = cmd_exec('while read line; do echo $line; done </etc/passwd')
+          data.each_line do |line|
+            line = line.split(':')
+            return true if line[0] == user && line[3].to_i == 0
+          end
+          false
+        end
+
+        #
+        # Multiple functions to simulate native commands added
+        #
+
+        #
+        # Creates an empty file at the specified path using the touch command
+        #
+        # @param new_path_file [String] the path to the new file to be created
+        # @return [String] the output of the command
+        #
+        def touch_cmd(new_path_file)
+          cmd_exec("> #{new_path_file}")
+        end
+
+        #
+        # Copies the content of one file to another using a command execution
+        #
+        # @param origin_file [String] the path to the source file
+        # @param final_file [String] the path to the destination file
+        # @return [String] the output of the command
+        #
+        def cp_cmd(origin_file, final_file)
+          file_origin = read_file(origin_file)
+          cmd_exec("echo '#{file_origin}' > '#{final_file}'")
+        end
+
+        #
+        # Retrieves the binary name of a process given its PID
+        #
+        # @param pid [Integer] the process ID
+        # @return [String] the binary name of the process
+        #
+        def binary_of_pid(pid)
+          binary = read_file("/proc/#{pid}/cmdline")
+          if binary == '' # binary.empty?
+            binary = read_file("/proc/#{pid}/comm")
+          end
+          if binary[-1] == "\n"
+            binary = binary.split("\n")[0]
+          end
+          return binary
+        end
+
+        #
+        # Generates a sequence of numbers from `first` to `last` with a given `increment`
+        #
+        # @param first [Integer] the starting number of the sequence
+        # @param increment [Integer] the step increment between each number in the sequence
+        # @param last [Integer] the ending number of the sequence
+        # @return [Array<Integer>] an array containing the sequence of numbers
+        #
+        def seq(first, increment, last)
+          result = []
+          (first..last).step(increment) do |i|
+            result.insert(-1, i)
+          end
+          return result
+        end
+
+        #
+        # Returns the number of lines, words, and characters in a file
+        #
+        # @param file [String] the path to the file
+        # @return [Array<Integer, Integer, Integer, String>] an array containing the number of lines, words, characters, and the file name
+        #
+        def wc_cmd(file)
+          [nlines_file(file), nwords_file(file), nchars_file(file), file]
+        end
+
+        #
+        # Returns the number of characters in a file
+        #
+        # @param file [String] the path to the file
+        # @return [Integer] the number of characters in the file
+        #
+        def nchars_file(file)
+          nchars = 0
+          lines = read_file(file).split("\n")
+          nchars = lines.length
+          lines.each do |line|
+            line.gsub(/ /, ' ' => '')
+            nchars_line = line.length
+            nchars += nchars_line
+          end
+          nchars
+        end
+
+        #
+        # Returns the number of words in a file
+        #
+        # @param file [String] the path to the file
+        # @return [Integer] the number of words in the file
+        #
+        def nwords_file(file)
+          nwords = 0
+          lines = read_file(file).split("\n")
+          lines.each do |line|
+            words = line.split(' ')
+            nwords_line = words.length
+            nwords += nwords_line
+          end
+          return nwords
+        end
+
+        #
+        # Returns the number of lines in a file
+        #
+        # @param file [String] the path to the file
+        # @return [Integer] the number of lines in the file
+        #
+        def nlines_file(file)
+          lines = read_file(file).split("\n")
+          nlines = lines.length
+          return nlines
+        end
+
+        #
+        # Returns the first `n` lines of a file
+        #
+        # @param file [String] the path to the file
+        # @param nlines [Integer] the number of lines to return
+        # @return [Array<String>] an array containing the first `n` lines of the file
+        #
+        def head_cmd(file, nlines)
+          lines = read_file(file).split("\n")
+          result = lines[0..nlines - 1]
+          return result
+        end
+
+        #
+        # Returns the last `n` lines of a file
+        #
+        # @param file [String] the path to the file
+        # @param nlines [Integer] the number of lines to return
+        # @return [Array<String>] an array containing the last `n` lines of the file
+        #
+        def tail_cmd(file, nlines)
+          lines = read_file(file).split("\n")
+          result = lines[-1 * nlines..]
+          return result
+        end
+
+        #
+        # Searches for a specific string in a file and returns the lines that contain the string
+        #
+        # @param file [String] the path to the file
+        # @param string [String] the string to search for
+        # @return [Array<String>] an array containing the lines that include the specified string
+        #
+        def grep_cmd(file, string)
+          result = []
+          lines = read_file(file).split("\n")
+
+          lines.each do |line|
+            if line.include?(string)
+              result.insert(-1, line)
+            end
+          end
+          return result
+        end
       end
-      return (clean_user_id == '0')
     end
-    user = whoami
-    data = cmd_exec('while read line; do echo $line; done </etc/passwd')
-    data.each_line do |line|
-      line = line.split(':')
-      return true if line[0] == user && line[3].to_i == 0
-    end
-    false
-  end
-
-  #
-  # Multiple functions to simulate native commands added
-  #
-
-  def touch_cmd(new_path_file)
-    cmd_exec("> #{new_path_file}")
-  end
-
-  def cp_cmd(origin_file, final_file)
-    file_origin = read_file(origin_file)
-    cmd_exec("echo '#{file_origin}' > #{final_file}")
-  end
-
-  def binary_of_pid(pid)
-    binary = read_file("/proc/#{pid}/cmdline")
-    if binary == "" #binary.empty?
-      binary = read_file("/proc/#{pid}/comm")
-    end
-    if binary[-1] == "\n"
-      binary = binary.split("\n")[0]
-    end
-    return binary
-  end
-
-  def seq(first, increment, last)
-      result = []
-      (first..last).step(increment) do |i|
-        result.insert(-1, i)
-      end
-      return result
-  end
-
-  def wc_cmd(file)
-      [nlines_file(file), nwords_file(file), nchars_file(file), file]
-  end
-
-  def nchars_file(file)
-    nchars = 0
-    lines = read_file(file).split("\n")
-    nchars = lines.length()
-    lines.each do |line|
-      line.gsub(/[ ]/, ' ' => '')
-      nchars_line = line.length()
-      nchars = nchars + nchars_line
-    end
-    return nchars
   end
-
-  def nwords_file(file)
-    nwords = 0
-    lines = read_file(file).split("\n")
-    lines.each do |line|
-      words = line.split(" ")
-      nwords_line = words.length()
-      nwords = nwords + nwords_line
-    end
-    return nwords
-  end
-
-  def nlines_file(file)
-    lines = read_file(file).split("\n")
-    nlines = lines.length()
-    return nlines
-  end
-
-  def head_cmd(file, nlines)
-    lines = read_file(file).split("\n")
-    result = lines[0..nlines-1]
-    return result
-  end
-
-  def tail_cmd(file, nlines)
-    lines = read_file(file).split("\n")
-    result = lines[-1*(nlines)..-1]
-    return result
-  end
-
-  def grep_cmd(file, string)
-    result = []
-    lines = read_file(file).split("\n")
-
-    lines.each do |line|
-      if line.include?(string)
-        result.insert(-1, line)
-      end
-    end
-    return result
-  end
-
-
-
-end # Priv
-end # Linux
-end # Post
-end # Msf
+end

--- lib/msf/core/post/linux/process.rb ---
@@ -1,36 +1,42 @@
 # -*- coding: binary -*-
 
+require 'rex/post'
 
 module Msf
-class Post
-module Linux
+  class Post
+    module Linux
+      module Process
+        include Msf::Post::Process
 
-module Process
+        def initialize(info = {})
+          super(
+            update_info(
+              info,
+              'Compat' => {
+                'Meterpreter' => {
+                  'Commands' => %w[
+                    stdapi_sys_process_attach
+                    stdapi_sys_process_memory_read
+                  ]
+                }
+              }
+            )
+          )
+        end
 
-  include Msf::Post::Process
-
-  def initialize(info = {})
-    super(
-      update_info(
-        info,
-        'Compat' => {
-          'Meterpreter' => {
-            'Commands' => %w[
-              stdapi_sys_process_attach
-              stdapi_sys_process_memory_read
-            ]
-          }
-        }
-      )
-    )
-  end
-
-  def mem_read(base_address, length, pid: 0)
-    proc_id = session.sys.process.open(pid, PROCESS_READ)
-    data = proc_id.memory.read(base_address, length)
+        #
+        # Reads a specified length of memory from a given base address of a process
+        #
+        # @param base_address [Integer] the starting address to read from
+        # @param length [Integer] the number of bytes to read
+        # @param pid [Integer] the process ID (optional, default is 0)
+        # @return [String] the read memory content
+        #
+        def mem_read(base_address, length, pid: 0)
+          proc_id = session.sys.process.open(pid, PROCESS_READ)
+          proc_id.memory.read(base_address, length)
+        end
+      end
+    end
   end
-
-end # Process
-end # Linux
-end # Post
-end # Msf
+end

--- lib/msf/core/post/linux/system.rb ---
@@ -7,14 +7,14 @@ module System
         include ::Msf::Post::Common
         include ::Msf::Post::File
         include ::Msf::Post::Unix
+        include Msf::Auxiliary::Report
 
         #
         # Returns a Hash containing Distribution Name, Version and Kernel Information
         #
         def get_sysinfo
           system_data = {}
           etc_files = cmd_exec('ls /etc').split
-
           kernel_version = cmd_exec('uname -a')
           system_data[:kernel] = kernel_version
 
@@ -132,8 +132,10 @@ def get_sysinfo
         # Gathers all SUID files on the filesystem.
         # NOTE: This uses the Linux `find` command. It will most likely take a while to get all files.
         # Consider specifying a more narrow find path.
+        #
         # @param findpath The path on the system to start searching
         # @return [Array]
+        #
         def get_suid_files(findpath = '/')
           cmd_exec("find #{findpath} -perm -4000 -print -xdev").to_s.split("\n").delete_if { |i| i.include? 'Permission denied' }
         rescue StandardError
@@ -142,7 +144,9 @@ def get_suid_files(findpath = '/')
 
         #
         # Gets the $PATH environment variable
+        #
         # @return [String]
+        #
         def get_path
           cmd_exec('echo $PATH').to_s
         rescue StandardError
@@ -151,6 +155,7 @@ def get_path
 
         #
         # Gets basic information about the system's CPU.
+        #
         # @return [Hash]
         #
         def get_cpu_info
@@ -171,6 +176,7 @@ def get_cpu_info
 
         #
         # Gets the hostname of the system
+        #
         # @return [String]
         #
         def get_hostname
@@ -188,6 +194,7 @@ def get_hostname
 
         #
         # Gets the name of the current shell
+        #
         # @return [String]
         #
         def get_shell_name
@@ -202,6 +209,7 @@ def get_shell_name
 
         #
         # Gets the pid of the current shell
+        #
         # @return [String]
         #
         def get_shell_pid
@@ -210,6 +218,7 @@ def get_shell_pid
 
         #
         # Checks if the system has gcc installed
+        #
         # @return [Boolean]
         #
         def has_gcc?
@@ -220,6 +229,7 @@ def has_gcc?
 
         #
         # Checks if the system has clang installed
+        #
         # @return [Boolean]
         #
         def has_clang?
@@ -230,6 +240,7 @@ def has_clang?
 
         #
         # Checks if `file_path` is mounted on a noexec mount point
+        #
         # @return [Boolean]
         #
         def noexec?(file_path)
@@ -245,6 +256,7 @@ def noexec?(file_path)
 
         #
         # Checks if `file_path` is mounted on a nosuid mount point
+        #
         # @return [Boolean]
         #
         def nosuid?(file_path)
@@ -260,6 +272,7 @@ def nosuid?(file_path)
 
         #
         # Checks for protected hardlinks on the system
+        #
         # @return [Boolean]
         #
         def protected_hardlinks?
@@ -270,6 +283,7 @@ def protected_hardlinks?
 
         #
         # Checks for protected symlinks on the system
+        #
         # @return [Boolean]
         #
         def protected_symlinks?
@@ -280,18 +294,22 @@ def protected_symlinks?
 
         #
         # Gets the version of glibc
+        #
         # @return [String]
         #
         def glibc_version
           raise 'glibc is not installed' unless command_exists? 'ldd'
+          begin
 
-          cmd_exec('ldd --version').scan(/^ldd\s+\(.*\)\s+([\d.]+)/).flatten.first
-        rescue StandardError
-          raise 'Could not determine glibc version'
+            cmd_exec('ldd --version').scan(/^ldd\s+\(.*\)\s+([\d.]+)/).flatten.first
+          rescue StandardError
+            raise 'Could not determine glibc version'
+          end
         end
 
         #
         # Gets the mount point of `filepath`
+        #
         # @param [String] filepath The filepath to get the mount point
         # @return [String]
         #
@@ -303,6 +321,7 @@ def get_mount_path(filepath)
 
         #
         # Gets all the IP directions of the device
+        #
         # @return [Array]
         #
         def ips
@@ -323,6 +342,7 @@ def ips
 
         #
         # Gets all the interfaces of the device
+        #
         # @return [Array]
         #
         def interfaces
@@ -338,6 +358,7 @@ def interfaces
 
         #
         # Gets all the macs of the device
+        #
         # @return [Array]
         #
         def macs
@@ -354,9 +375,10 @@ def macs
           result
         end
 
-        # Parsing information based on: https://github.com/sensu-plugins/sensu-plugins-network-checks/blob/master/bin/check-netstat-tcp.rb
         #
+        # Parsing information based on: https://github.com/sensu-plugins/sensu-plugins-network-checks/blob/master/bin/check-netstat-tcp.rb
         # Gets all the listening tcp ports in the device
+        #
         # @return [Array]
         #
         def listen_tcp_ports
@@ -377,8 +399,8 @@ def listen_tcp_ports
         end
 
         # Parsing information based on: https://github.com/sensu-plugins/sensu-plugins-network-checks/blob/master/bin/check-netstat-tcp.rb
-        #
         # Gets all the listening udp ports in the device
+        #
         # @return [Array]
         #
         def listen_udp_ports
@@ -400,6 +422,7 @@ def listen_udp_ports
 
         #
         # Determine if system is a container
+        #
         # @return [String]
         #
         def get_container_type
@@ -421,6 +444,8 @@ def get_container_type
                 return 'Docker'
               when /lxc/i
                 return 'LXC'
+              else
+                return 'Unknown'
               end
             else
               # Check for the "container" environment variable
@@ -443,11 +468,7 @@ def get_container_type
           end
           container_type
         end
-        # System
       end
-      # Linux
     end
-    # Post
   end
-  # Msf
 end

--- spec/lib/msf/core/post/linux/busy_box_spec.rb ---
@@ -1,6 +1,6 @@
 # -*- coding: binary -*-
-require 'spec_helper'
 
+require 'spec_helper'
 
 RSpec.describe Msf::Post::Linux::BusyBox do
   subject do
@@ -9,15 +9,15 @@
     mod
   end
 
-  describe "#busy_box_file_exist?" do
-    describe "when file exists" do
+  describe '#busy_box_file_exist?' do
+    describe 'when file exists' do
       before :example do
         allow(subject).to receive(:read_file) do
           'test data'
         end
       end
 
-      it "returns true" do
+      it 'returns true' do
         expect(subject.busy_box_file_exist?('/etc/passwd')).to be_truthy
       end
     end
@@ -29,20 +29,21 @@
         end
       end
 
-      it "returns false" do
+      it 'returns false' do
         expect(subject.busy_box_file_exist?('/etc/nonexistent')).to be_falsey
       end
     end
   end
 
-  describe "#busy_box_is_writable_dir?" do
+  describe '#busy_box_is_writable_dir?' do
     before :example do
       allow(subject).to receive(:cmd_exec) do
         ''
       end
+      allow(Rex).to receive(:sleep)
     end
 
-    describe "when dir is writable" do
+    describe 'when dir is writable' do
       before :example do
         allow(subject).to receive(:read_file) do
           "#{'A' * 16}XXX#{'A' * 16}"
@@ -53,7 +54,7 @@
         end
       end
 
-      it "returns true" do
+      it 'returns true' do
         expect(subject.busy_box_is_writable_dir?('/tmp/')).to be_truthy
       end
     end
@@ -65,14 +66,13 @@
         end
       end
 
-      it "returns false" do
+      it 'returns false' do
         expect(subject.busy_box_is_writable_dir?('/etc/')).to be_falsey
       end
     end
   end
 
-
-  describe "#busy_box_writable_dir" do
+  describe '#busy_box_writable_dir' do
     before :example do
       allow(subject).to receive(:cmd_exec) do
         ''
@@ -86,12 +86,12 @@
         end
       end
 
-      it "returns nil" do
+      it 'returns nil' do
         expect(subject.busy_box_writable_dir).to be_nil
       end
     end
 
-    describe "when a writable directory exists" do
+    describe 'when a writable directory exists' do
       before :example do
         allow(subject).to receive(:read_file) do
           "#{'A' * 16}XXX#{'A' * 16}"
@@ -102,18 +102,18 @@
         end
       end
 
-      it "returns the writable dir path" do
+      it 'returns the writable dir path' do
         expect(subject.busy_box_writable_dir).to eq('/etc/')
       end
     end
   end
 
-
-  describe "#busy_box_write_file" do
+  describe '#busy_box_write_file' do
     before :example do
       allow(subject).to receive(:cmd_exec) do
         ''
       end
+      allow(Rex).to receive(:sleep)
     end
 
     describe "when the file isn't writable" do
@@ -123,12 +123,12 @@
         end
       end
 
-      it "returns false" do
+      it 'returns false' do
         expect(subject.busy_box_write_file('/etc/passwd', 'test')).to be_falsey
       end
     end
 
-    describe "when the file is writable" do
+    describe 'when the file is writable' do
       before :example do
         allow(subject).to receive(:read_file) do
           "#{'A' * 16}XXX#{'A' * 16}"
@@ -139,14 +139,14 @@
         end
       end
 
-      it "returns true" do
+      it 'returns true' do
         expect(subject.busy_box_write_file('/tmp/test', 'test')).to be_truthy
       end
     end
 
-    describe "when prepend is true" do
-      describe "when there is a writable dir" do
-        describe "when the target file is writable" do
+    describe 'when prepend is true' do
+      describe 'when there is a writable dir' do
+        describe 'when the target file is writable' do
           before :example do
             allow(subject).to receive(:busy_box_writable_dir) do
               '/tmp/'
@@ -161,7 +161,7 @@
             end
           end
 
-          it "returns true" do
+          it 'returns true' do
             expect(subject.busy_box_write_file('/tmp/test', 'test', true)).to be_truthy
           end
         end
@@ -173,12 +173,11 @@
             nil
           end
         end
-        
-        it "returns false" do
+
+        it 'returns false' do
           expect(subject.busy_box_write_file('/tmp/test', 'test', true)).to be_falsey
         end
       end
     end
   end
-
 end

--- spec/lib/msf/core/post/linux/compile_spec.rb ---
@@ -0,0 +1,156 @@
+require 'spec_helper'
+
+RSpec.describe Msf::Post::Linux::Compile do
+  subject do
+    mod = Msf::Exploit.allocate
+    mod.extend(Msf::PostMixin)
+    mod.extend described_class
+    mod.send(:initialize, {})
+    mod
+  end
+
+  before do
+    allow(Rex::Text).to receive(:rand_text_alphanumeric).with(8).and_return('fixedStr')
+  end
+
+  describe '#get_compiler' do
+    context 'when gcc is available' do
+      it 'returns gcc' do
+        allow(subject).to receive(:has_gcc?).and_return(true)
+        expect(subject.get_compiler).to eq('gcc')
+      end
+    end
+
+    context 'when clang is available' do
+      it 'returns clang' do
+        allow(subject).to receive(:has_gcc?).and_return(false)
+        allow(subject).to receive(:has_clang?).and_return(true)
+        expect(subject.get_compiler).to eq('clang')
+      end
+    end
+
+    context 'when no compiler is available' do
+      it 'returns nil' do
+        allow(subject).to receive(:has_gcc?).and_return(false)
+        allow(subject).to receive(:has_clang?).and_return(false)
+        expect(subject.get_compiler).to be_nil
+      end
+    end
+  end
+
+  describe '#live_compile?' do
+    context 'when COMPILE is not Auto or True' do
+      it 'returns false' do
+        allow(subject).to receive(:datastore).and_return({ 'COMPILE' => 'False' })
+        expect(subject.live_compile?).to be false
+      end
+    end
+
+    context 'when COMPILE is Auto or True' do
+      it 'returns true if gcc is specified and available' do
+        allow(subject).to receive(:datastore).and_return({ 'COMPILE' => 'Auto', 'COMPILER' => 'gcc' })
+        allow(subject).to receive(:has_gcc?).and_return(true)
+        expect(subject.live_compile?).to be true
+      end
+
+      it 'returns true if clang is specified and available' do
+        allow(subject).to receive(:datastore).and_return({ 'COMPILE' => 'Auto', 'COMPILER' => 'clang' })
+        allow(subject).to receive(:has_clang?).and_return(true)
+        expect(subject.live_compile?).to be true
+      end
+
+      it 'returns true if Auto is specified and a compiler is available' do
+        allow(subject).to receive(:datastore).and_return({ 'COMPILE' => 'Auto', 'COMPILER' => 'Auto' })
+        allow(subject).to receive(:get_compiler).and_return('gcc')
+        expect(subject.live_compile?).to be true
+      end
+
+      it 'raises an error if the specified compiler is not available' do
+        allow(subject).to receive(:datastore).and_return({ 'COMPILE' => 'True', 'COMPILER' => 'gcc' })
+        allow(subject).to receive(:has_gcc?).and_return(false)
+        expect { subject.live_compile? }.to raise_error(Msf::Exploit::Failed, 'gcc is not installed. Set COMPILE False to upload a pre-compiled executable.')
+      end
+    end
+  end
+
+  describe '#upload_and_compile' do
+    let(:origin) { '/path/to/source.c' }
+    let(:destination) { '/tmp/source.c' }
+    let(:compiled) { '/tmp/source' }
+    let(:flags) { '-static' }
+    let(:session) { double('Session', send: nil) }
+    let(:session_type_meterpreter) { 'meterpreter' }
+    let(:session_type_shell) { 'shell' }
+
+    before do
+      allow(subject).to receive(:get_compiler).and_return('gcc')
+      allow(subject).to receive(:rm_f).and_return('')
+      allow(subject).to receive(:chmod).and_return('')
+    end
+
+    it 'uploads the source file and compiles it on meterpreter with success' do
+      allow(subject).to receive_message_chain('session.type').and_return(session_type_meterpreter)
+      expect(subject).to receive(:session)
+      expect(subject).to receive(:write_file).with(destination, origin)
+      expect(subject).to receive(:cmd_exec).with("gcc -o '#{compiled}' '#{destination}' #{flags} && echo fixedStr").and_return('fixedStr')
+      expect(subject).to receive(:rm_f).with(destination)
+      expect(subject).to receive(:chmod).with(destination)
+
+      subject.upload_and_compile(compiled, origin, flags)
+    end
+
+    it 'uploads the source file and compiles it on shell with success' do
+      allow(subject).to receive_message_chain('session.type').and_return(session_type_shell)
+      expect(subject).to receive(:session)
+      expect(subject).to receive(:write_file).with(destination, origin)
+      expect(subject).to receive(:cmd_exec).with("PATH=\"$PATH:/usr/bin/\" gcc -o '#{compiled}' '#{destination}' #{flags} && echo fixedStr").and_return('fixedStr')
+      expect(subject).to receive(:rm_f).with(destination)
+      expect(subject).to receive(:chmod).with(destination)
+
+      subject.upload_and_compile(compiled, origin, flags)
+    end
+
+    it 'uploads the source file and compiles it on meterpreter but fails' do
+      allow(subject).to receive_message_chain('session.type').and_return(session_type_meterpreter)
+      expect(subject).to receive(:session)
+      expect(subject).to receive(:write_file).with(destination, origin)
+      # remove the expect line, so it will look like the compile failed
+      expect(subject).to receive(:cmd_exec).with("gcc -o '#{compiled}' '#{destination}' #{flags} && echo fixedStr").and_return('Compile error')
+      expect(subject).to receive(:rm_f).with(destination)
+
+      expect { subject.upload_and_compile(compiled, origin, flags) }.to raise_error(Msf::Exploit::Failed, '/tmp/source.c failed to compile. Set COMPILE to False to upload a pre-compiled executable.')
+    end
+
+    it 'raises an error if no compiler is available' do
+      allow(subject).to receive(:get_compiler).and_return(nil)
+      allow(subject).to receive_message_chain('session.type').and_return(session_type_shell)
+
+      expect { subject.upload_and_compile(compiled, origin, output) }.to raise_error(Msf::Exploit::Failed, 'Unable to find a compiler on the remote target.')
+    end
+  end
+
+  describe '#strip_comments' do
+    it 'removes comments from the source code' do
+      source_code = <<-CODE
+        // This is a single line comment
+        int main() {
+          /* This is a
+             multi-line comment */
+          printf("Hello, world!");
+          return 0;
+        }
+      CODE
+
+      expected_output = <<-CODE
+
+        int main() {
+        #{'  '}
+          printf("Hello, world!");
+          return 0;
+        }
+      CODE
+
+      expect(subject.strip_comments(source_code)).to eq(expected_output)
+    end
+  end
+end

--- spec/lib/msf/core/post/linux/kernel_spec.rb ---
@@ -0,0 +1,111 @@
+require 'spec_helper'
+
+RSpec.describe Msf::Post::Linux::Kernel do
+  subject do
+    mod = Msf::Module.new
+    mod.extend(Msf::Post::Linux::Kernel)
+    mod
+  end
+
+  describe '#uname' do
+    context 'it returns an ubuntu kernel' do
+      it 'returns the kernel information' do
+        allow(subject).to receive(:cmd_exec).and_return('Linux kali 6.11.2-amd64 #1 SMP PREEMPT_DYNAMIC Kali 6.11.2-1kali1 (2024-10-15) x86_64 GNU/Linux ')
+        expect(subject.uname).to eq('Linux kali 6.11.2-amd64 #1 SMP PREEMPT_DYNAMIC Kali 6.11.2-1kali1 (2024-10-15) x86_64 GNU/Linux')
+      end
+    end
+  end
+
+  describe '#kernel_release' do
+    context 'it returns an ubuntu kernel release' do
+      it 'returns 6.11.2-amd64' do
+        allow(subject).to receive(:cmd_exec).and_return('6.11.2-amd64 ')
+        expect(subject.kernel_release).to eq('6.11.2-amd64')
+      end
+    end
+  end
+
+  describe '#kernel_version' do
+    context 'it returns an ubuntu kernel version' do
+      it 'returns 6.11.2-amd64' do
+        allow(subject).to receive(:cmd_exec).and_return('#1 SMP PREEMPT_DYNAMIC Kali 6.11.2-1kali1 (2024-10-15) ')
+        expect(subject.kernel_version).to eq('#1 SMP PREEMPT_DYNAMIC Kali 6.11.2-1kali1 (2024-10-15)')
+      end
+    end
+  end
+
+  describe '#kernel_name' do
+    context 'it returns an ubuntu kernel name' do
+      it 'returns Linux' do
+        allow(subject).to receive(:cmd_exec).and_return('Linux ')
+        expect(subject.kernel_name).to eq('Linux')
+      end
+    end
+  end
+
+  describe '#kernel_hardware' do
+    context 'it returns an ubuntu kernel hardware' do
+      it 'returns x86_64' do
+        allow(subject).to receive(:cmd_exec).and_return('x86_64 ')
+        expect(subject.kernel_hardware).to eq('x86_64')
+      end
+    end
+  end
+
+  describe '#kernel_arch' do
+    context 'it returns an ubuntu kernel arch' do
+      it 'returns x64' do
+        allow(subject).to receive(:cmd_exec).and_return('x86_64 ')
+        expect(subject.kernel_arch).to eq('x64')
+      end
+      it 'returns aarch64' do
+        allow(subject).to receive(:cmd_exec).and_return('aarch64 ')
+        expect(subject.kernel_arch).to eq('aarch64')
+      end
+      it 'returns aarch64' do
+        allow(subject).to receive(:cmd_exec).and_return('arm ')
+        expect(subject.kernel_arch).to eq('armle')
+      end
+      it 'returns x86' do
+        allow(subject).to receive(:cmd_exec).and_return('i686 ')
+        expect(subject.kernel_arch).to eq('x86')
+      end
+      it 'returns ppc' do
+        allow(subject).to receive(:cmd_exec).and_return('ppc ')
+        expect(subject.kernel_arch).to eq('ppc')
+      end
+      it 'returns ppc64' do
+        allow(subject).to receive(:cmd_exec).and_return('ppc64 ')
+        expect(subject.kernel_arch).to eq('ppc64')
+      end
+      it 'returns ppc64le' do
+        allow(subject).to receive(:cmd_exec).and_return('ppc64le ')
+        expect(subject.kernel_arch).to eq('ppc64le')
+      end
+      it 'returns mips' do
+        allow(subject).to receive(:cmd_exec).and_return('mips ')
+        expect(subject.kernel_arch).to eq('mips')
+      end
+      it 'returns mips64' do
+        allow(subject).to receive(:cmd_exec).and_return('mips64 ')
+        expect(subject.kernel_arch).to eq('mips64')
+      end
+      it 'returns sparc' do
+        allow(subject).to receive(:cmd_exec).and_return('sparc ')
+        expect(subject.kernel_arch).to eq('sparc')
+      end
+      it 'returns riscv32le' do
+        allow(subject).to receive(:cmd_exec).and_return('riscv32 ')
+        expect(subject.kernel_arch).to eq('riscv32le')
+      end
+      it 'returns riscv64le' do
+        allow(subject).to receive(:cmd_exec).and_return('riscv64 ')
+        expect(subject.kernel_arch).to eq('riscv64le')
+      end
+      it 'returns loongarch64' do
+        allow(subject).to receive(:cmd_exec).and_return('loongarch64 ')
+        expect(subject.kernel_arch).to eq('loongarch64')
+      end
+    end
+  end
+end

--- spec/lib/msf/core/post/linux/packages_spec.rb ---
@@ -0,0 +1,178 @@
+require 'spec_helper'
+
+RSpec.describe Msf::Post::Linux::Packages do
+  subject do
+    mod = Msf::Module.new
+    mod.extend(Msf::Post::Linux::Packages)
+    mod
+  end
+
+  describe '#installed_package_version' do
+    context 'when the OS isnt supported' do
+      it 'returns nil' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'unsupported', version: '' })
+        expect(subject.installed_package_version('test')).to be_nil
+      end
+    end
+
+    # dockerfile for German locale Ubuntu
+    # FROM ubuntu:latest
+    #
+    # # Install locales package and set up German locale
+    # RUN apt-get update && apt-get install -y locales && \
+    #     locale-gen de_DE.UTF-8 && \
+    #     update-locale LANG=de_DE.UTF-8 && \
+    #     echo "export LANG=de_DE.UTF-8" >> /etc/profile && \
+    #     echo "export LANGUAGE=de_DE.UTF-8" >> /etc/profile && \
+    #     echo "export LC_ALL=de_DE.UTF-8" >> /etc/profile
+    #
+    # # Set environment variables
+    # ENV LANG=de_DE.UTF-8 \
+    #     LANGUAGE=de_DE.UTF-8 \
+    #     LC_ALL=de_DE.UTF-8
+    #
+    # CMD ["/bin/bash"]
+    context 'when the Ubuntu/Debian package isnt installed' do
+      it 'returns nil' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: 'Linux ubuntu22 5.15.0-25-generic #25-Ubuntu SMP Wed Mar 30 15:54:22 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux', distro: 'ubuntu', version: 'Ubuntu 22.04.5 LTS' })
+        allow(subject).to receive(:cmd_exec).and_return('dpkg-query: no packages found matching example')
+        expect(subject.installed_package_version('test')).to be_nil
+      end
+    end
+
+    context 'when the Ubuntu/Debian package is installed' do
+      it 'returns 3.5-5ubuntu2.1' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: 'Linux ubuntu22 5.15.0-25-generic #25-Ubuntu SMP Wed Mar 30 15:54:22 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux', distro: 'ubuntu', version: 'Ubuntu 22.04.5 LTS' })
+        allow(subject).to receive(:cmd_exec).and_return('3.5-5ubuntu2.1')
+        expect(subject.installed_package_version('test')).to eq(Rex::Version.new('3.5-5ubuntu2.1'))
+      end
+    end
+
+    context 'when the Ubuntu/Debian package is installed with a + in the version number' do
+      it 'returns 1.34.dfsg.pre.1ubuntu0.1.22.04.2' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: 'Linux ubuntu22 5.15.0-25-generic #25-Ubuntu SMP Wed Mar 30 15:54:22 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux', distro: 'ubuntu', version: 'Ubuntu 22.04.5 LTS' })
+        allow(subject).to receive(:cmd_exec).and_return('1.34+dfsg-1ubuntu0.1.22.04.2')
+        expect(subject.installed_package_version('test')).to eq(Rex::Version.new('1.34.dfsg.pre.1ubuntu0.1.22.04.2'))
+      end
+    end
+
+    context 'when the Redhat or Fedora package is installed' do
+      it 'returns 8.2.1-3.fc39' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'redhat', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return('curl-8.2.1-3.fc39.x86_64')
+        expect(subject.installed_package_version('curl')).to eq(Rex::Version.new('8.2.1-3.fc39'))
+      end
+    end
+
+    context 'when the Fedora package isnt installed' do
+      it 'returns nil' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'fedora', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return('package foobar is not installed')
+        expect(subject.installed_package_version('foobar')).to eq(nil)
+      end
+    end
+
+    # dockerfile for German locale Fedora
+    # FROM fedora:latest
+    #
+    # RUN dnf install -y glibc-langpack-de && \
+    #     echo "export LANG=de_DE.UTF-8" >> /etc/profile && \
+    #     echo "export LANGUAGE=de_DE.UTF-8" >> /etc/profile && \
+    #     echo "export LC_ALL=de_DE.UTF-8" >> /etc/profile
+    #
+    # ENV LANG=de_DE.UTF-8 \
+    #     LANGUAGE=de_DE.UTF-8 \
+    #     LC_ALL=de_DE.UTF-8
+    #
+    # CMD ["/bin/bash"]
+    context 'when the German language Fedora package isnt installed' do
+      it 'returns nil' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'fedora', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return('Das Paket foobar ist nicht installiert')
+        expect(subject.installed_package_version('foobar')).to eq(nil)
+      end
+    end
+
+    # freebsd 12.0
+    context 'when the FreeBSD package is installed' do
+      it 'returns 1.12.0' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'freebsd', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return("pkg-1.12.0\nName           : pkg\nVersion        : 1.12.0")
+        expect(subject.installed_package_version('test')).to eq(Rex::Version.new('1.12.0'))
+      end
+    end
+
+    context 'when the FreeBSD package isnt installed' do
+      it 'returns nil' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'freebsd', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return('pkg: No package(s) matching foobarbaz')
+        expect(subject.installed_package_version('foobarbaz')).to eq(nil)
+      end
+    end
+
+    # dockerfile for German locale gentoo
+    # FROM gentoo/stage3
+
+    # # Update system and install German locale support
+    # RUN emerge --sync && \
+    #     emerge --quiet --update --deep --newuse world && \
+    #     echo "de_DE.UTF-8 UTF-8" >> /etc/locale.gen && \
+    #     locale-gen && \
+    #     eselect locale set de_DE.UTF-8 && \
+    #     echo "export LANG=de_DE.UTF-8" >> /etc/profile && \
+    #     echo "export LANGUAGE=de_DE.UTF-8" >> /etc/profile && \
+    #     echo "export LC_ALL=de_DE.UTF-8" >> /etc/profile
+    #
+    # # Set environment variables
+    # ENV LANG=de_DE.UTF-8 \
+    #     LANGUAGE=de_DE.UTF-8 \
+    #     LC_ALL=de_DE.UTF-8
+    #
+    # CMD ["/bin/bash"]
+    context 'when the Gentoo package is installed and uses equery' do
+      it 'returns 4.3.2-r3' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'gentoo', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return('sys-devel/gcc-4.3.2-r3')
+        allow(subject).to receive(:command_exists?).with('equery').and_return(true)
+        expect(subject.installed_package_version('test')).to eq(Rex::Version.new('4.3.2-r3'))
+      end
+    end
+
+    context 'when the Gentoo package is installed and uses qlist' do
+      it 'returns 4.3.2-r3' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'gentoo', version: '' })
+        # equery and qlist output the same results for a found package
+        allow(subject).to receive(:cmd_exec).and_return('sys-devel/gcc-4.3.2-r3')
+        allow(subject).to receive(:command_exists?).with('equery').and_return(false)
+        allow(subject).to receive(:command_exists?).with('qlist').and_return(true)
+        expect(subject.installed_package_version('test')).to eq(Rex::Version.new('4.3.2-r3'))
+      end
+    end
+
+    context 'when the Gentoo package isnt installed and uses qlist' do
+      it 'returns nil' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'gentoo', version: '' })
+        allow(subject).to receive(:command_exists?).with('equery').and_return(false)
+        allow(subject).to receive(:command_exists?).with('qlist').and_return(true)
+        allow(subject).to receive(:cmd_exec).and_return('')
+        expect(subject.installed_package_version('test')).to eq(nil)
+      end
+    end
+
+    context 'when the Arch package is installed' do
+      it 'returns 8.12.1-1' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'arch', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return('Version         : 8.12.1-1')
+        expect(subject.installed_package_version('test')).to eq(Rex::Version.new('8.12.1-1'))
+      end
+    end
+
+    context 'when the Arch package isnt installed' do
+      it 'returns nil' do
+        allow(subject).to receive(:get_sysinfo).and_return({ kernel: '', distro: 'arch', version: '' })
+        allow(subject).to receive(:cmd_exec).and_return('error: package \'test\' was not found')
+        expect(subject.installed_package_version('test')).to eq(nil)
+      end
+    end
+  end
+end

--- spec/lib/msf/core/post/linux/priv_spec.rb ---
@@ -0,0 +1,142 @@
+require 'spec_helper'
+
+RSpec.describe Msf::Post::Linux::Priv do
+  subject do
+    mod = Msf::Module.new
+    mod.extend(Msf::Post::Linux::Priv)
+    mod
+  end
+
+  before do
+    allow(subject).to receive(:command_exists?).and_return(true)
+    allow(subject).to receive(:cmd_exec).and_return('')
+  end
+
+  describe '#is_root?' do
+    context 'when the id command exists' do
+      it 'returns true if the user ID is 0' do
+        allow(subject).to receive(:cmd_exec).with('id -u').and_return('0')
+        expect(subject.is_root?).to be true
+      end
+
+      it 'returns false if the user ID is not 0' do
+        allow(subject).to receive(:cmd_exec).with('id -u').and_return('1000')
+        expect(subject.is_root?).to be false
+      end
+
+      it 'raises an error if the user ID cannot be determined' do
+        allow(subject).to receive(:cmd_exec).with('id -u').and_return('abc')
+        expect { subject.is_root? }.to raise_error(RuntimeError, 'Could not determine UID: "abc"')
+      end
+    end
+  end
+
+  describe '#cp_cmd' do
+    it 'copies the content of one file to another' do
+      origin_file = '/path/to/origin'
+      final_file = '/path/to/destination'
+      file_content = 'file content'
+
+      allow(subject).to receive(:read_file).with(origin_file).and_return(file_content)
+      expect(subject).to receive(:cmd_exec).with("echo '#{file_content}' > '#{final_file}'")
+
+      subject.cp_cmd(origin_file, final_file)
+    end
+  end
+
+  describe '#binary_of_pid' do
+    it 'retrieves the binary name of a process given its PID' do
+      pid = 1234
+      cmdline_content = '/usr/bin/bash'
+      comm_content = 'bash'
+
+      allow(subject).to receive(:read_file).with("/proc/#{pid}/cmdline").and_return(cmdline_content)
+      expect(subject.binary_of_pid(pid)).to eq('/usr/bin/bash')
+
+      allow(subject).to receive(:read_file).with("/proc/#{pid}/cmdline").and_return('')
+      allow(subject).to receive(:read_file).with("/proc/#{pid}/comm").and_return(comm_content)
+      expect(subject.binary_of_pid(pid)).to eq('bash')
+    end
+  end
+
+  describe '#seq' do
+    it 'generates a sequence of numbers from first to last with a given increment' do
+      expect(subject.seq(1, 2, 10)).to eq([1, 3, 5, 7, 9])
+      expect(subject.seq(0, 5, 20)).to eq([0, 5, 10, 15, 20])
+    end
+  end
+
+  describe '#wc_cmd' do
+    it 'returns the number of lines, words, and characters in a file' do
+      file = '/path/to/file'
+      allow(subject).to receive(:nlines_file).with(file).and_return(10)
+      allow(subject).to receive(:nwords_file).with(file).and_return(20)
+      allow(subject).to receive(:nchars_file).with(file).and_return(100)
+
+      expect(subject.wc_cmd(file)).to eq([10, 20, 100, file])
+    end
+  end
+
+  describe '#nchars_file' do
+    it 'returns the number of characters in a file' do
+      file = '/path/to/file'
+      file_content = "Hello\nWorld"
+      allow(subject).to receive(:read_file).with(file).and_return(file_content)
+
+      # agrees with wc
+      # $ echo -n "Hello\nWorld" | wc -m
+      # 12
+      expect(subject.nchars_file(file)).to eq(12)
+    end
+  end
+
+  describe '#nwords_file' do
+    it 'returns the number of words in a file' do
+      file = '/path/to/file'
+      file_content = "Hello World\nThis is a test"
+      allow(subject).to receive(:read_file).with(file).and_return(file_content)
+
+      expect(subject.nwords_file(file)).to eq(6)
+    end
+  end
+
+  describe '#nlines_file' do
+    it 'returns the number of lines in a file' do
+      file = '/path/to/file'
+      file_content = "Hello\nWorld\nThis is a test"
+      allow(subject).to receive(:read_file).with(file).and_return(file_content)
+
+      expect(subject.nlines_file(file)).to eq(3)
+    end
+  end
+
+  describe '#head_cmd' do
+    it 'returns the first n lines of a file' do
+      file = '/path/to/file'
+      file_content = "Line 1\nLine 2\nLine 3\nLine 4\nLine 5"
+      allow(subject).to receive(:read_file).with(file).and_return(file_content)
+
+      expect(subject.head_cmd(file, 3)).to eq(['Line 1', 'Line 2', 'Line 3'])
+    end
+  end
+
+  describe '#tail_cmd' do
+    it 'returns the last n lines of a file' do
+      file = '/path/to/file'
+      file_content = "Line 1\nLine 2\nLine 3\nLine 4\nLine 5"
+      allow(subject).to receive(:read_file).with(file).and_return(file_content)
+
+      expect(subject.tail_cmd(file, 3)).to eq(['Line 3', 'Line 4', 'Line 5'])
+    end
+  end
+
+  describe '#grep_cmd' do
+    it 'searches for a specific string in a file and returns the lines that contain the string' do
+      file = '/path/to/file'
+      file_content = "Hello World\nThis is a test\nHello again"
+      allow(subject).to receive(:read_file).with(file).and_return(file_content)
+
+      expect(subject.grep_cmd(file, 'Hello')).to eq(['Hello World', 'Hello again'])
+    end
+  end
+end

--- spec/lib/msf/core/post/linux/process_spec.rb ---
@@ -0,0 +1,39 @@
+require 'spec_helper'
+
+RSpec.describe Msf::Post::Linux::Process do
+  subject do
+    mod = Msf::Exploit.allocate
+    mod.extend(Msf::PostMixin)
+    mod.extend described_class
+    mod.send(:initialize, {})
+    mod
+  end
+
+  describe '#mem_read' do
+    let(:base_address) { 0x1000 }
+    let(:length) { 64 }
+    let(:pid) { 1234 }
+    let(:process) { double('Process', send: nil) }
+    let(:memory) { double('Memory', send: nil) }
+    let(:memory_content) { 'memory content' }
+
+    before do
+      allow(subject).to receive_message_chain('session.sys.process.open').and_return(process)
+      allow(process).to receive(:memory).and_return(memory)
+    end
+
+    it 'reads memory from the specified base address and length' do
+      expect(subject).to receive(:session)
+      expect(memory).to receive(:read).with(base_address, length).and_return(memory_content)
+
+      expect(subject.mem_read(base_address, length, pid: pid)).to eq(memory_content)
+    end
+
+    it 'uses the default pid if not specified' do
+      expect(subject).to receive(:session)
+      expect(memory).to receive(:read).with(base_address, length).and_return(memory_content)
+
+      expect(subject.mem_read(base_address, length)).to eq(memory_content)
+    end
+  end
+end

--- spec/lib/msf/core/post/linux/system_spec.rb ---
@@ -0,0 +1,568 @@
+require 'spec_helper'
+
+RSpec.describe Msf::Post::Linux::System do
+  subject do
+    mod = Msf::Module.new
+    mod.extend(Msf::Post::Linux::System)
+    mod
+  end
+
+  describe '#get_sysinfo' do
+    context 'when the system is Debian' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('debian_version')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.15.0-20-generic (buildd@lgw01-amd64)')
+        allow(subject).to receive(:read_file).with('/etc/issue').and_return('Debian GNU/Linux 9 \\n \\l')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('debian')
+        expect(sysinfo[:version]).to eq('Debian GNU/Linux 9')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.15.0-20-generic (buildd@lgw01-amd64)')
+      end
+    end
+
+    context 'when the system is Ubuntu' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('debian_version')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.15.0-20-generic (buildd@lgw01-amd64) Ubuntu')
+        allow(subject).to receive(:read_file).with('/etc/issue').and_return('Ubuntu 18.04.1 LTS \\n \\l')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('ubuntu')
+        expect(sysinfo[:version]).to eq('Ubuntu 18.04.1 LTS')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.15.0-20-generic (buildd@lgw01-amd64) Ubuntu')
+      end
+    end
+
+    context 'when the system is Amazon or CentOS' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('system-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.14.88-88.76.amzn2.x86_64 (mockbuild@gobi-build-60008) (gcc version 7.3.1 20180303 (Red Hat 7.3.1-5) (GCC))')
+        allow(subject).to receive(:read_file).with('/etc/system-release').and_return('Amazon Linux 2')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('amazon')
+        expect(sysinfo[:version]).to eq('Amazon Linux 2')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.14.88-88.76.amzn2.x86_64 (mockbuild@gobi-build-60008) (gcc version 7.3.1 20180303 (Red Hat 7.3.1-5) (GCC))')
+      end
+    end
+
+    context 'when the system is Alpine' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('alpine-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.19.0-0-virt (buildozer@build-3-10-x86_64)')
+        allow(subject).to receive(:read_file).with('/etc/alpine-release').and_return('3.10.2')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('alpine')
+        expect(sysinfo[:version]).to eq('3.10.2')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.19.0-0-virt (buildozer@build-3-10-x86_64)')
+      end
+    end
+
+    context 'when the system is Fedora' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('fedora-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 5.3.7-301.fc31.x86_64 (mockbuild@bkernel01.phx2.fedoraproject.org)')
+        allow(subject).to receive(:read_file).with('/etc/fedora-release').and_return('Fedora release 31 (Thirty One)')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('fedora')
+        expect(sysinfo[:version]).to eq('Fedora release 31 (Thirty One)')
+        expect(sysinfo[:kernel]).to eq('Linux version 5.3.7-301.fc31.x86_64 (mockbuild@bkernel01.phx2.fedoraproject.org)')
+      end
+    end
+
+    context 'when the system is Oracle Linux' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('enterprise-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.14.35-1818.3.3.el7uek.x86_64 (mockbuild@x86-ol7-builder-02)')
+        allow(subject).to receive(:read_file).with('/etc/enterprise-release').and_return('Oracle Linux Server release 7.6')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('oracle')
+        expect(sysinfo[:version]).to eq('Oracle Linux Server release 7.6')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.14.35-1818.3.3.el7uek.x86_64 (mockbuild@x86-ol7-builder-02)')
+      end
+    end
+
+    context 'when the system is RedHat' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('redhat-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 3.10.0-957.21.3.el7.x86_64 (mockbuild@x86-01.bsys.centos.org)')
+        allow(subject).to receive(:read_file).with('/etc/redhat-release').and_return('Red Hat Enterprise Linux Server release 7.6 (Maipo)')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('redhat')
+        expect(sysinfo[:version]).to eq('Red Hat Enterprise Linux Server release 7.6 (Maipo)')
+        expect(sysinfo[:kernel]).to eq('Linux version 3.10.0-957.21.3.el7.x86_64 (mockbuild@x86-01.bsys.centos.org)')
+      end
+    end
+
+    context 'when the system is Arch' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('arch-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 5.3.7-arch1-1-ARCH (builduser@heftig-29959)')
+        allow(subject).to receive(:read_file).with('/etc/arch-release').and_return('Arch Linux')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('arch')
+        expect(sysinfo[:version]).to eq('Arch Linux')
+        expect(sysinfo[:kernel]).to eq('Linux version 5.3.7-arch1-1-ARCH (builduser@heftig-29959)')
+      end
+    end
+
+    context 'when the system is Slackware' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('slackware-version')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.4.14 (root@darkstar)')
+        allow(subject).to receive(:read_file).with('/etc/slackware-version').and_return('Slackware 14.2')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('slackware')
+        expect(sysinfo[:version]).to eq('Slackware 14.2')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.4.14 (root@darkstar)')
+      end
+    end
+
+    context 'when the system is Mandrake' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('mandrake-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 2.6.12-12mdk (nplanel@no.mandriva.com)')
+        allow(subject).to receive(:read_file).with('/etc/mandrake-release').and_return('Mandrake Linux release 10.2 (Limited Edition 2005)')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('mandrake')
+        expect(sysinfo[:version]).to eq('Mandrake Linux release 10.2 (Limited Edition 2005)')
+        expect(sysinfo[:kernel]).to eq('Linux version 2.6.12-12mdk (nplanel@no.mandriva.com)')
+      end
+    end
+
+    context 'when the system is SuSE' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('SuSE-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.12.14-lp151.28.36-default (geeko@buildhost)')
+        allow(subject).to receive(:read_file).with('/etc/SuSE-release').and_return('openSUSE Leap 15.1')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('suse')
+        expect(sysinfo[:version]).to eq('openSUSE Leap 15.1')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.12.14-lp151.28.36-default (geeko@buildhost)')
+      end
+    end
+
+    context 'when the system is OpenSUSE' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('SUSE-brand')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.12.14-lp151.28.36-default (geeko@buildhost)')
+        allow(subject).to receive(:read_file).with('/etc/SUSE-brand').and_return('VERSION = 15.1')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('suse')
+        expect(sysinfo[:version]).to eq('15.1')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.12.14-lp151.28.36-default (geeko@buildhost)')
+      end
+    end
+
+    context 'when the system is Gentoo' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('gentoo-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.19.57-gentoo (root@localhost)')
+        allow(subject).to receive(:read_file).with('/etc/gentoo-release').and_return('Gentoo Base System release 2.6')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('gentoo')
+        expect(sysinfo[:version]).to eq('Gentoo Base System release 2.6')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.19.57-gentoo (root@localhost)')
+      end
+    end
+
+    context 'when the system is Openwall' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('owl-release')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 2.6.32-431.el6.x86_64 (mockbuild@c6b8.bsys.dev.centos.org)')
+        allow(subject).to receive(:read_file).with('/etc/owl-release').and_return('Openwall GNU/*/Linux 3.1 (2014-09-26)')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('openwall')
+        expect(sysinfo[:version]).to eq('Openwall GNU/*/Linux 3.1 (2014-09-26)')
+        expect(sysinfo[:kernel]).to eq('Linux version 2.6.32-431.el6.x86_64 (mockbuild@c6b8.bsys.dev.centos.org)')
+      end
+    end
+
+    context 'when the system is Generic Linux' do
+      it 'returns the correct system information' do
+        allow(subject).to receive(:cmd_exec).with('ls /etc').and_return('issue')
+        allow(subject).to receive(:cmd_exec).with('uname -a').and_return('Linux version 4.19.0-0-virt (buildozer@build-3-10-x86_64)')
+        allow(subject).to receive(:read_file).with('/etc/issue').and_return('Generic Linux')
+        allow(subject).to receive(:report_host)
+
+        sysinfo = subject.get_sysinfo
+
+        expect(sysinfo[:distro]).to eq('linux')
+        expect(sysinfo[:version]).to eq('Generic Linux')
+        expect(sysinfo[:kernel]).to eq('Linux version 4.19.0-0-virt (buildozer@build-3-10-x86_64)')
+      end
+    end
+  end
+
+  describe '#get_suid_files' do
+    context 'when there are no permission denied errors' do
+      it 'returns the list of SUID files' do
+        suid_files = "/usr/bin/passwd\n/usr/bin/sudo\n"
+        allow(subject).to receive(:cmd_exec).with('find / -perm -4000 -print -xdev').and_return(suid_files)
+
+        result = subject.get_suid_files
+
+        expect(result).to eq(['/usr/bin/passwd', '/usr/bin/sudo'])
+      end
+    end
+
+    context 'when there are permission denied errors' do
+      it 'filters out the permission denied errors' do
+        suid_files = "/usr/bin/passwd\nfind: /root: Permission denied\n/usr/bin/sudo\n"
+        allow(subject).to receive(:cmd_exec).with('find / -perm -4000 -print -xdev').and_return(suid_files)
+
+        result = subject.get_suid_files
+
+        expect(result).to eq(['/usr/bin/passwd', '/usr/bin/sudo'])
+      end
+    end
+
+    context 'when an error occurs' do
+      it 'raises an error' do
+        allow(subject).to receive(:cmd_exec).with('find / -perm -4000 -print -xdev').and_raise(StandardError)
+
+        expect { subject.get_suid_files }.to raise_error('Could not retrieve all SUID files')
+      end
+    end
+  end
+
+  describe '#get_path' do
+    it 'returns the system path' do
+      allow(subject).to receive(:cmd_exec).with('echo $PATH').and_return('/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin')
+      expect(subject.get_path).to eq('/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin')
+    end
+
+    it 'raises an error if unable to determine path' do
+      allow(subject).to receive(:cmd_exec).with('echo $PATH').and_raise(StandardError)
+      expect { subject.get_path }.to raise_error('Unable to determine path')
+    end
+  end
+
+  describe '#get_cpu_info' do
+    it 'returns the CPU information' do
+      cpuinfo = "processor\t: 0\nvendor_id\t: GenuineIntel\ncpu MHz\t\t: 2400.000\nmodel name\t: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz\n"
+      allow(subject).to receive(:read_file).with('/proc/cpuinfo').and_return(cpuinfo)
+      expect(subject.get_cpu_info).to eq({ speed_mhz: 2400, product: 'Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz', vendor: 'GenuineIntel', cores: 1 })
+    end
+
+    it 'raises an error if unable to get CPU information' do
+      allow(subject).to receive(:read_file).with('/proc/cpuinfo').and_raise(StandardError)
+      expect { subject.get_cpu_info }.to raise_error('Could not get CPU information')
+    end
+  end
+
+  describe '#get_hostname' do
+    it 'returns the hostname using uname' do
+      allow(subject).to receive(:command_exists?).with('uname').and_return(true)
+      allow(subject).to receive(:cmd_exec).with('uname -n').and_return('test-hostname')
+      allow(subject).to receive(:report_host)
+      expect(subject.get_hostname).to eq('test-hostname')
+    end
+
+    it 'returns the hostname using /proc/sys/kernel/hostname' do
+      allow(subject).to receive(:command_exists?).with('uname').and_return(false)
+      allow(subject).to receive(:read_file).with('/proc/sys/kernel/hostname').and_return('test-hostname')
+      allow(subject).to receive(:report_host)
+      expect(subject.get_hostname).to eq('test-hostname')
+    end
+
+    it 'raises an error if unable to retrieve hostname' do
+      allow(subject).to receive(:cmd_exec).with('uname -n').and_raise(StandardError)
+      expect { subject.get_hostname }.to raise_error('Unable to retrieve hostname')
+    end
+  end
+
+  describe '#get_shell_name' do
+    it 'returns the shell name using ps' do
+      allow(subject).to receive(:command_exists?).with('ps').and_return(true)
+      allow(subject).to receive(:cmd_exec).with('ps -p $$').and_return("PID TTY          TIME CMD\n  1 ?        00:00:00 bash")
+      expect(subject.get_shell_name).to eq('bash')
+    end
+
+    it 'returns the shell name using echo $0' do
+      allow(subject).to receive(:command_exists?).with('ps').and_return(false)
+      allow(subject).to receive(:cmd_exec).with('echo $0').and_return('-bash')
+      expect(subject.get_shell_name).to eq('bash')
+    end
+
+    it 'raises an error if unable to gather shell name' do
+      allow(subject).to receive(:cmd_exec).with('ps -p $$').and_raise(StandardError)
+      expect { subject.get_shell_name }.to raise_error('Unable to gather shell name')
+    end
+  end
+
+  describe '#get_shell_pid' do
+    it 'returns the shell pid' do
+      allow(subject).to receive(:cmd_exec).with('echo $$').and_return('1234')
+      expect(subject.get_shell_pid).to eq('1234')
+    end
+  end
+
+  describe '#has_gcc?' do
+    it 'returns true if gcc is installed' do
+      allow(subject).to receive(:command_exists?).with('gcc').and_return(true)
+      expect(subject.has_gcc?).to be true
+    end
+
+    it 'raises an error if unable to check for gcc' do
+      allow(subject).to receive(:command_exists?).with('gcc').and_raise(StandardError)
+      expect { subject.has_gcc? }.to raise_error('Unable to check for gcc')
+    end
+  end
+
+  describe '#has_clang?' do
+    it 'returns true if clang is installed' do
+      allow(subject).to receive(:command_exists?).with('clang').and_return(true)
+      expect(subject.has_clang?).to be true
+    end
+
+    it 'raises an error if unable to check for clang' do
+      allow(subject).to receive(:command_exists?).with('clang').and_raise(StandardError)
+      expect { subject.has_clang? }.to raise_error('Unable to check for clang')
+    end
+  end
+
+  describe '#noexec?' do
+    it 'returns true if the file path is mounted on a noexec mount point' do
+      mount_content = "/dev/sda1 / ext4 rw,noexec 0 0\n"
+      allow(subject).to receive(:read_file).with('/proc/mounts').and_return(mount_content)
+      allow(subject).to receive(:get_mount_path).with('/path/to/file').and_return('/')
+      expect(subject.noexec?('/path/to/file')).to be true
+    end
+
+    it 'raises an error if unable to check for noexec volume' do
+      allow(subject).to receive(:read_file).with('/proc/mounts').and_raise(StandardError)
+      expect { subject.noexec?('/path/to/file') }.to raise_error('Unable to check for noexec volume')
+    end
+  end
+
+  describe '#nosuid?' do
+    it 'returns true if the file path is mounted on a nosuid mount point' do
+      mount_content = "/dev/sda1 / ext4 rw,nosuid 0 0\n"
+      allow(subject).to receive(:read_file).with('/proc/mounts').and_return(mount_content)
+      allow(subject).to receive(:get_mount_path).with('/path/to/file').and_return('/')
+      expect(subject.nosuid?('/path/to/file')).to be true
+    end
+
+    it 'raises an error if unable to check for nosuid volume' do
+      allow(subject).to receive(:read_file).with('/proc/mounts').and_raise(StandardError)
+      expect { subject.nosuid?('/path/to/file') }.to raise_error('Unable to check for nosuid volume')
+    end
+  end
+
+  describe '#protected_hardlinks?' do
+    it 'returns true if protected hardlinks are enabled' do
+      allow(subject).to receive(:read_file).with('/proc/sys/fs/protected_hardlinks').and_return('1')
+      expect(subject.protected_hardlinks?).to be true
+    end
+
+    it 'raises an error if unable to determine protected_hardlinks status' do
+      allow(subject).to receive(:read_file).with('/proc/sys/fs/protected_hardlinks').and_raise(StandardError)
+      expect { subject.protected_hardlinks? }.to raise_error('Could not determine protected_hardlinks status')
+    end
+  end
+
+  describe '#protected_symlinks?' do
+    it 'returns true if protected symlinks are enabled' do
+      allow(subject).to receive(:read_file).with('/proc/sys/fs/protected_symlinks').and_return('1')
+      expect(subject.protected_symlinks?).to be true
+    end
+
+    it 'raises an error if unable to determine protected_symlinks status' do
+      allow(subject).to receive(:read_file).with('/proc/sys/fs/protected_symlinks').and_raise(StandardError)
+      expect { subject.protected_symlinks? }.to raise_error('Could not determine protected_symlinks status')
+    end
+  end
+
+  describe '#glibc_version' do
+    it 'returns the glibc version' do
+      allow(subject).to receive(:command_exists?).with('ldd').and_return(true)
+      allow(subject).to receive(:cmd_exec).with('ldd --version').and_return('ldd (GNU libc) 2.27')
+      expect(subject.glibc_version).to eq('2.27')
+    end
+
+    it 'raises an error if glibc is not installed' do
+      allow(subject).to receive(:command_exists?).with('ldd').and_return(false)
+      expect { subject.glibc_version }.to raise_error('glibc is not installed')
+    end
+
+    it 'raises an error if unable to determine glibc version' do
+      allow(subject).to receive(:command_exists?).with('ldd').and_return(true)
+      allow(subject).to receive(:cmd_exec).with('ldd --version').and_raise(StandardError)
+      expect { subject.glibc_version }.to raise_error('Could not determine glibc version')
+    end
+  end
+
+  describe '#get_mount_path' do
+    it 'returns the mount path of the file' do
+      allow(subject).to receive(:cmd_exec).with('df "/path/to/file" | tail -1').and_return('/dev/sda1 101141520 52963696 42993928 56% /')
+      expect(subject.get_mount_path('/path/to/file')).to eq('/')
+    end
+
+    it 'raises an error if unable to get mount path' do
+      allow(subject).to receive(:cmd_exec).with('df "/path/to/file" | tail -1').and_raise(StandardError)
+      expect { subject.get_mount_path('/path/to/file') }.to raise_error('Unable to get mount path of /path/to/file')
+    end
+  end
+
+  describe '#ips' do
+    it 'returns all IP addresses of the device' do
+      # content from https://medium.com/@linuxadminhacks/find-the-names-of-the-network-interfaces-by-their-ips-4ef82326e49e
+      fib_trie_content = "Main:\n  +-- 0.0.0.0/0 3 0 5\n    +-- 192.168.1.0/24 2 0 2\n        +-- 192.168.1.0/30 2 0 2\n           |-- 192.168.1.3\n              /32 host LOCAL"
+      allow(subject).to receive(:read_file).with('/proc/net/fib_trie').and_return(fib_trie_content)
+      expect(subject.ips).to eq(['192.168.1.3'])
+    end
+  end
+
+  describe '#interfaces' do
+    it 'returns all interfaces of the device' do
+      interfaces_content = "/sys/class/net/eth0\n/sys/class/net/lo\n"
+      allow(subject).to receive(:cmd_exec).with('for fn in /sys/class/net/*; do echo $fn; done').and_return(interfaces_content)
+      expect(subject.interfaces).to eq(['eth0', 'lo'])
+    end
+  end
+
+  describe '#macs' do
+    it 'returns all MAC addresses of the device' do
+      macs_content = "/sys/class/net/eth0\n/sys/class/net/lo\n"
+      allow(subject).to receive(:cmd_exec).with('for fn in /sys/class/net/*; do echo $fn; done').and_return(macs_content)
+      allow(subject).to receive(:read_file).with('/sys/class/net/eth0/address').and_return('00:11:22:33:44:55')
+      allow(subject).to receive(:read_file).with('/sys/class/net/lo/address').and_return('00:00:00:00:00:00')
+      allow(subject).to receive(:report_host)
+      expect(subject.macs).to eq(['00:11:22:33:44:55', '00:00:00:00:00:00'])
+    end
+  end
+
+  describe '#listen_tcp_ports' do
+    it 'returns all listening TCP ports of the device' do
+      tcp_content = "  0: 0100007F:0016 00000000:0000 0A\n"
+      allow(subject).to receive(:read_file).with('/proc/net/tcp').and_return(tcp_content)
+      expect(subject.listen_tcp_ports).to eq([22])
+    end
+  end
+
+  describe '#listen_udp_ports' do
+    it 'returns all listening UDP ports of the device' do
+      udp_content = "  0: 0100007F:0035 00000000:0000 07\n"
+      allow(subject).to receive(:read_file).with('/proc/net/udp').and_return(udp_content)
+      expect(subject.listen_udp_ports).to eq([53])
+    end
+  end
+
+  describe '#get_container_type' do
+    it 'returns Docker if /.dockerenv exists' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(true)
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('Docker')
+    end
+
+    it 'returns Docker if /.dockerinit exists' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(false)
+      allow(subject).to receive(:file?).with('/.dockerinit').and_return(true)
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('Docker')
+    end
+
+    it 'returns Podman if /run/.containerenv exists' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(false)
+      allow(subject).to receive(:file?).with('/.dockerinit').and_return(false)
+      allow(subject).to receive(:file?).with('/run/.containerenv').and_return(true)
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('Podman')
+    end
+
+    it 'returns LXC if /dev/lxc exists' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(false)
+      allow(subject).to receive(:file?).with('/.dockerinit').and_return(false)
+      allow(subject).to receive(:file?).with('/run/.containerenv').and_return(false)
+      allow(subject).to receive(:directory?).with('/dev/lxc').and_return(true)
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('LXC')
+    end
+
+    it 'returns WSL if /proc/sys/kernel/osrelease contains WSL' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(false)
+      allow(subject).to receive(:file?).with('/.dockerinit').and_return(false)
+      allow(subject).to receive(:file?).with('/run/.containerenv').and_return(false)
+      allow(subject).to receive(:directory?).with('/dev/lxc').and_return(false)
+      allow(subject).to receive(:file?).with('/proc/sys/kernel/osrelease').and_return(true)
+      allow(subject).to receive(:read_file).with('/proc/sys/kernel/osrelease').and_return(['4.4.0-19041-Microsoft'])
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('WSL')
+    end
+
+    it 'returns Docker if /proc/1/cgroup contains docker' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(false)
+      allow(subject).to receive(:file?).with('/.dockerinit').and_return(false)
+      allow(subject).to receive(:file?).with('/run/.containerenv').and_return(false)
+      allow(subject).to receive(:directory?).with('/dev/lxc').and_return(false)
+      allow(subject).to receive(:file?).with('/proc/sys/kernel/osrelease').and_return(false)
+      allow(subject).to receive(:read_file).with('/proc/1/cgroup').and_return('1:name=systemd:/docker/1234567890abcdef')
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('Docker')
+    end
+
+    it 'returns LXC if /proc/1/cgroup contains lxc' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(false)
+      allow(subject).to receive(:file?).with('/.dockerinit').and_return(false)
+      allow(subject).to receive(:file?).with('/run/.containerenv').and_return(false)
+      allow(subject).to receive(:directory?).with('/dev/lxc').and_return(false)
+      allow(subject).to receive(:file?).with('/proc/sys/kernel/osrelease').and_return(false)
+      allow(subject).to receive(:read_file).with('/proc/1/cgroup').and_return('1:name=systemd:/lxc/1234567890abcdef')
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('LXC')
+    end
+
+    it 'returns Unknown if no container type is detected' do
+      allow(subject).to receive(:file?).with('/.dockerenv').and_return(false)
+      allow(subject).to receive(:file?).with('/.dockerinit').and_return(false)
+      allow(subject).to receive(:file?).with('/run/.containerenv').and_return(false)
+      allow(subject).to receive(:directory?).with('/dev/lxc').and_return(false)
+      allow(subject).to receive(:file?).with('/proc/sys/kernel/osrelease').and_return(false)
+      allow(subject).to receive(:read_file).with('/proc/1/cgroup').and_return('')
+      allow(subject).to receive(:get_env).with('container').and_return(nil)
+      allow(subject).to receive(:report_host)
+      expect(subject.get_container_type).to eq('Unknown')
+    end
+  end
+end

