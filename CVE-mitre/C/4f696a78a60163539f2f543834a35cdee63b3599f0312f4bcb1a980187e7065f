--- Dockerfile-MOZJS ---
@@ -23,6 +23,7 @@ ARG RUN_DEPS=" \
     libpq5 \
     libpython3.6 \
     libxslt1.1 \
+    libgdal26 \
     gdal-bin \
     libcgal13 \
     librabbitmq4 \
@@ -103,7 +104,7 @@ WORKDIR /zoo-project
 COPY . .
 
 RUN set -ex \
-    && apt-get update && apt-get install -y --no-install-recommends $BUILD_DEPS \
+    && apt-get update && apt-cache search libotb-dev && apt-get install -y --no-install-recommends $BUILD_DEPS \
     \
     && make -C ./thirds/cgic206 libcgic.a \
     \
@@ -118,7 +119,7 @@ RUN set -ex \
     && autoconf \
     && find /usr -name otbWrapperApplication.h \
     # Comment the line bellow if you don't want to use rabbitmq
-    && ./configure --with-rabbitmq=yes --with-python=/usr --with-pyvers=3.6 --with-js=/usr --with-mapserver=/usr --with-ms-version=7 --with-json=/usr --with-r=/usr --with-db-backend --prefix=/usr --with-otb=/usr/ --with-itk=/usr --with-otb-version=6.6 --with-itk-version=4.12 --with-saga=/usr --with-saga-version=7.2 --with-wx-config=/usr/bin/wx-config \
+    && ./configure --with-rabbitmq=yes --with-python=/usr --with-pyvers=3.6 --with-js=/usr --with-mapserver=/usr --with-ms-version=7 --with-json=/usr --with-r=/usr --with-db-backend --prefix=/usr --with-otb=/usr/ --with-itk=/usr --with-otb-version=7.0 --with-itk-version=4.12 --with-saga=/usr --with-saga-version=7.2 --with-wx-config=/usr/bin/wx-config \
     # Uncomment the line bellow if you don't want to use rabbitmq
     #&& ./configure --with-python=/usr --with-pyvers=3.6 --with-js=/usr --with-mapserver=/usr --with-ms-version=7 --with-json=/usr --with-r=/usr --prefix=/usr --with-otb=/usr/ --with-itk=/usr --with-otb-version=6.6 --with-itk-version=4.12 --with-saga=/usr --with-saga-version=7.2 --with-wx-config=/usr/bin/wx-config \
     && make -j4 \
@@ -379,7 +380,7 @@ RUN set -ex \
     && pip3 install --upgrade pip setuptools wheel \
     # see various issue reported about _2to3 invocation and setuptools < 58.0 \
     && python3 -m pip install --upgrade --no-cache-dir setuptools==57.5.0 \
-    && pip3 install GDAL==2.4.2 \
+    && pip3 install GDAL==3.0.4 \
     && pip3 install Cheetah3 redis spython \
     && sed "s:AllowOverride None:AllowOverride All:g" -i /etc/apache2/apache2.conf \
     \

--- zoo-project/HISTORY.txt ---
@@ -1,6 +1,13 @@
 Version 2.1.0-dev
+  * Store the zoofpm ip address in the status database to enable tracking
+  which zoofpm pod/container is used to run a process.
+  * Update GDAL based services to use the validateVRT for VRT used as
+  input file to ensure only the allowed paths are accessible.
+  * Add an isAllowedPath function to ensure the URL using file:// give
+  access only to the defined allowed paths, defined in the allowedPaths key
+  from the main section.
   * Update the skaffold.yaml file for easy deployment of the ZOO-Project
-  with DRU and CWL support on a local cluster
+  with DRU and CWL support on a local cluster in different flavors
   * Update the ZOO_DEBUG to use color for messages (if stderr is a tty)
   * Update variables naming, including the main configuration file name
   * Update ZOO_DEBUG function to use LOG_MESSAGE_FORMAT to format the

--- zoo-project/zoo-kernel/server_internal.h ---
@@ -29,6 +29,18 @@
 #ifndef IMPORTSERVICE
 #define IMPORTSERVICE "include" // default name of [include] block in main.cfg
 
+#include <libintl.h>
+#include <locale.h>
+
+/**
+ * ZOO-Kernel internal messages translation function
+ */
+#define _(String) dgettext ("zoo-kernel",String)
+/**
+ * ZOO-Services messages translation function
+ */
+#define _ss(String) dgettext ("zoo-services",String)
+
 #include "service.h"
 #include <openssl/sha.h>
 #include <openssl/md5.h>

--- zoo-project/zoo-kernel/service_internal.c ---
@@ -30,6 +30,8 @@
 #endif
 #include "service_internal.h"
 #include "service_callback.h"
+#include "request_parser.h"
+#include "caching.h"
 
 #ifdef WIN32
 // ref. https://docs.microsoft.com/en-us/windows/desktop/fileio/locking-and-unlocking-byte-ranges-in-files
@@ -342,15 +344,15 @@ char* _getStatusFile(maps* conf,char* pid){
       tmps1[flen]=0;
       fclose(f0);
       if(stat!=NULL){
-	unlockShm(lockid);
-	free(stat);
+        unlockShm(lockid);
+        free(stat);
       }
       return tmps1;
     }
     else{
       if(stat!=NULL){
-	unlockShm(lockid);
-	free(stat);
+        unlockShm(lockid);
+        free(stat);
       }
       return NULL;
     }
@@ -383,7 +385,7 @@ char* _getStatus(maps* conf,char* lid){
       setMapInMaps(conf,"lenv","lid",stat);
       lockid=acquireLock(conf);
       if(lockid<0)
-	return NULL;
+        return NULL;
     }
     fseek (f0, 0, SEEK_END);
     flen = ftell (f0);
@@ -397,11 +399,11 @@ char* _getStatus(maps* conf,char* lid){
       free(pcaStatusFile);
       if(stat!=NULL){
 #ifndef WIN32
-	removeShmLock(conf,1);
+        removeShmLock(conf,1);
 #else
-	unlockShm(lockid);
+        unlockShm(lockid);
 #endif
-	free(stat);
+        free(stat);
       }
       return fcontent;
     }
@@ -874,6 +876,53 @@ char* getInputValue( maps* inputs, const char* parameterName, size_t* numberOfBy
   return NULL;
 }
 
+/**
+ * Validate that the VRT contains only allowed path.
+ *
+ * @param pmsConf the maps pointing to the main configuration
+ * @param pccVRTName the name of the VRT file to validate
+ * @return true if the VRT is valid, false otherwise
+ */
+bool validateVRT(maps* pmsConf,const char* pccVRTName){
+  zStatStruct zStatus;
+  int iRes=zStat(pccVRTName, &zStatus);
+  if(zStatus.st_size>0){
+    char* pccVRTContent=(char*)malloc(zStatus.st_size*sizeof(char));
+    FILE* f=fopen(pccVRTName,"r");
+    if(f!=NULL){
+      fread(pccVRTContent,zStatus.st_size,1,f);
+      fclose(f);
+      xmlInitParser ();
+      xmlDocPtr doc = xmlReadMemory (pccVRTContent, zStatus.st_size, "validationFile.vrt.", NULL, XML_PARSE_RECOVER);
+      xmlXPathObjectPtr tmpsptr =
+        extractFromDoc (doc, "/*/*/*[local-name()='SourceFilename']");
+      xmlNodeSet *tmps = tmpsptr->nodesetval;
+      if(tmps!=NULL){
+        for (int i = 0; i < tmps->nodeNr; i++) {
+          xmlNodePtr node = tmps->nodeTab[i];
+          xmlChar *content = xmlNodeGetContent(node);
+          if(content!=NULL){
+            char* pccTmp=(char*)content;
+            if(strstr(pccTmp,"..")!=NULL || !isAllowedPath(pmsConf,pccTmp)){
+              xmlFree(content);
+              xmlXPathFreeObject (tmpsptr);
+              xmlFreeDoc (doc);
+              xmlCleanupParser ();
+              return false;
+            }
+            xmlFree(content);
+          }
+        }
+        xmlXPathFreeObject (tmpsptr);
+        xmlFreeDoc (doc);
+        xmlCleanupParser ();
+        return false;
+      }
+      xmlXPathFreeObject (tmpsptr);
+    }
+    return true;
+  }
+}
 
 /**
  * Read a file using the GDAL VSI API 

--- zoo-project/zoo-kernel/service_internal.h ---
@@ -127,6 +127,7 @@ extern "C" {
 
   
   ZOO_DLL_EXPORT char *readVSIFile(maps*,const char*);
+  ZOO_DLL_EXPORT bool validateVRT(maps*,const char*);
   ZOO_DLL_EXPORT int  setOutputValue( maps*, const char*, char*, size_t);
   ZOO_DLL_EXPORT char* getInputValue( maps*,const char*,size_t*);
 

--- zoo-project/zoo-kernel/sql/async_amqp.sql ---
@@ -36,22 +36,23 @@
 CREATE TABLE workers (
        id serial primary key,
        uuid text,
+       host varchar(17),
        pid int,
        status int,
        creation_time timestamp with time zone default now(),
        UNIQUE(uuid)
 );
 
 
-CREATE OR REPLACE FUNCTION checkAvailableExecutionSlot(schema text,uuid text, pid int) RETURNS boolean AS 
+CREATE OR REPLACE FUNCTION checkAvailableExecutionSlot(schema text,uuid text, host text, pid int) RETURNS boolean AS 
 $BODY$
 DECLARE
 	res int;
         cnt int;
 BEGIN
         EXECUTE 'SELECT count(*) from '||schema||'.workers where uuid = '''||uuid||'''' INTO cnt;
 	IF cnt = 0  THEN
-	   EXECUTE 'INSERT INTO '||schema||'.workers (uuid,pid,status) VALUES ('''||uuid||''','||pid||',1)';
+	   EXECUTE 'INSERT INTO '||schema||'.workers (uuid,host,pid,status) VALUES ('''||uuid||''','''||host||''','||pid||',1)';
 	   RETURN true;
 	ELSE
 	   RETURN false;

--- zoo-project/zoo-kernel/sqlapi.h ---
@@ -36,7 +36,7 @@
 #include "service.h"
 #include "service_internal.h"
 
-#define SQL_AVAILABLE_SLOT "SELECT %s.checkAvailableExecutionSlot('%s','%s',%d);"
+#define SQL_AVAILABLE_SLOT "SELECT %s.checkAvailableExecutionSlot('%s','%s','%s',%d);"
 
 #if defined(META_DB) || defined(USE_AMQP)
 extern "C" 

--- zoo-project/zoo-kernel/zoo_service_loader.c ---
@@ -122,6 +122,10 @@ extern "C" int crlex ();
 #ifdef USE_AMQP
 #include "service_internal_amqp.h"
 #include <sys/wait.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
 #endif
 
 #include <dirent.h>
@@ -5251,10 +5255,10 @@ int runRequest(map** inputs) {
  * @return 0 on sucess, other value on failure
  */
 int
-runAsyncRequest (maps** iconf, map ** lenv, map ** irequest_inputs,json_object *msg_obj)
+runAsyncRequest (maps** ppmsConf, map ** ppmLenv, map ** irequest_inputs,json_object *msg_obj)
 {
   register_signals(sig_handler);
-  maps* conf=*iconf;
+  maps* conf=*ppmsConf;
   map* request_inputs=*irequest_inputs;
   map* dsNb=getMapFromMaps(conf,"lenv","ds_nb");
   int metadb_id=0;
@@ -5264,14 +5268,22 @@ runAsyncRequest (maps** iconf, map ** lenv, map ** irequest_inputs,json_object *
 #endif
   int iSqlCon=init_sql(conf);
     //}
-  map *uusid=getMap(*lenv,"usid");
+  map *uusid=getMap(*ppmLenv,"usid");
   map *schema=getMapFromMaps(conf,"database","schema");
 
-  char* sqlQuery0=(char*)malloc(((2*strlen(schema->value))+
-                                 strlen(uusid->value)+strlen(SQL_AVAILABLE_SLOT)+129)*sizeof(char));
-  sprintf(sqlQuery0,SQL_AVAILABLE_SLOT,schema->value,schema->value,uusid->value,getpid());
-  OGRLayer *res=fetchSql(conf,iSqlCon-1,sqlQuery0);
-  free(sqlQuery0);
+  char acHost[256];
+  int hostname=gethostname(acHost, sizeof(acHost));
+  struct hostent *host_entry = gethostbyname(acHost);
+  char *pcIP = inet_ntoa(*((struct in_addr*) host_entry->h_addr_list[0]));
+  ZOO_DEBUG(pcIP);
+  ZOO_DEBUG(acHost);
+  char* pcaSqlQuery0=(char*)malloc(((2*strlen(schema->value))+
+                                strlen(pcIP)+strlen(uusid->value)+
+                                strlen(SQL_AVAILABLE_SLOT)+129)*sizeof(char));
+  sprintf(pcaSqlQuery0,SQL_AVAILABLE_SLOT,schema->value,schema->value,uusid->value,pcIP,getpid());
+  ZOO_DEBUG(pcaSqlQuery0);
+  OGRLayer *res=fetchSql(conf,iSqlCon-1,pcaSqlQuery0);
+  free(pcaSqlQuery0);
   if(res!=NULL){
     OGRFeature  *poFeature = NULL;
     const char *tmp1;
@@ -5298,7 +5310,7 @@ runAsyncRequest (maps** iconf, map ** lenv, map ** irequest_inputs,json_object *
             setMapInMaps(conf,"lenv","usid",uusid->value);
             setMapInMaps(conf,"lenv","uusid",uusid->value);
 
-            maps* lconf=dupMaps(iconf);
+            maps* lconf=dupMaps(ppmsConf);
             // Reset metapath
             addToMap(request_inputs,"metapath","");
             setMapInMaps(lconf,"lenv","metapath","");
@@ -5307,13 +5319,13 @@ runAsyncRequest (maps** iconf, map ** lenv, map ** irequest_inputs,json_object *
 
             // Define auth_env section in case we find fpm_user in the lenv
             // map coming from the message received
-            map* pmUserEnv=getMap(*lenv,"fpm_user");
+            map* pmUserEnv=getMap(*ppmLenv,"fpm_user");
             if(pmUserEnv!=NULL){
               setMapInMaps(lconf,"env","SERVICES_NAMESPACE",pmUserEnv->value);
               setMapInMaps(lconf,"zooServicesNamespace","namespace",pmUserEnv->value);
               maps* pmsaUserEnv=createMaps("auth_env");
               pmsaUserEnv->content=createMap("user",pmUserEnv->value);
-              pmUserEnv=getMap(*lenv,"fpm_cwd");
+              pmUserEnv=getMap(*ppmLenv,"fpm_cwd");
               if(pmUserEnv!=NULL){
                 addToMap(pmsaUserEnv->content,"cwd",pmUserEnv->value);
                 char *pcaTmpPath=(char*) malloc((strlen(pmUserEnv->value)+6)*sizeof(char));
@@ -5336,7 +5348,7 @@ runAsyncRequest (maps** iconf, map ** lenv, map ** irequest_inputs,json_object *
               initAllEnvironment(lconf,request_inputs,ntmp,"xrequest");
             }
             // Update every lenv map and add them to the main conf maps lenv section
-            map* pmTmp0=*lenv;
+            map* pmTmp0=*ppmLenv;
             while(pmTmp0!=NULL){
               setMapInMaps(lconf,"lenv",pmTmp0->name,pmTmp0->value);
               pmTmp0=pmTmp0->next;
@@ -5502,7 +5514,7 @@ runAsyncRequest (maps** iconf, map ** lenv, map ** irequest_inputs,json_object *
             dsNb=getMapFromMaps(conf,"lenv", "ds_nb");
             setMapInMaps(lconf, "lenv", "ds_nb",dsNb->value);
             map* usid = getMapFromMaps (lconf, "lenv", "uusid");
-            map* tmpm = getMap(*lenv, "osid");
+            map* tmpm = getMap(*ppmLenv, "osid");
             setMapInMaps(lconf, "lenv", "osid",tmpm->value);
             tmpm = getMapFromMaps (lconf, "lenv", "osid");
 
@@ -5586,7 +5598,7 @@ runAsyncRequest (maps** iconf, map ** lenv, map ** irequest_inputs,json_object *
             // Set Headers from lenv coming form the message
             // TODO: append current headers by fetching the renv from the
             // message?
-            map* pmCursor=*lenv;
+            map* pmCursor=*ppmLenv;
             while(pmCursor!=NULL){
               if(strncasecmp(pmCursor->name,"rb_headers_",11)==0){
                 setMapInMaps(lconf,"lenv",pmCursor->name,pmCursor->value);

--- zoo-project/zoo-services/gdal/contour/service.c ---
@@ -293,6 +293,12 @@ __declspec(dllexport)
 	setMapInMaps(conf,"lenv","message","Unable to open the file");
 #endif
     }
+    if(strstr(GDALGetDriverShortName(GDALGetDatasetDriver(hSrcDS)),"VRT")!=NULL){
+        if(!validateVRT(conf,pszSrcFilename)){
+          setMapInMaps(conf,"lenv","message",_("VRT file is not valid"));
+          return SERVICE_FAILED;
+        }
+    }
     hBand = GDALGetRasterBand( hSrcDS, nBandIn );
     if( hBand == NULL )
     {

--- zoo-project/zoo-services/gdal/dem/service.c ---
@@ -93,6 +93,7 @@
 #include "commonutils.h"
 #else
 #include "service.h"
+#include "service_internal.h"
 #endif
 
 CPL_CVSID("$Id$");
@@ -2613,6 +2614,12 @@ __declspec(dllexport)
         exit( 1 );
 #endif
     }
+    if(strstr(GDALGetDriverShortName(GDALGetDatasetDriver(hSrcDataset)),"VRT")!=NULL){
+        if(!validateVRT(conf,pszSrcFilename)){
+            setMapInMaps(conf,"lenv","message",_("VRT file is not valid"));
+            return NULL;
+        }
+    }
 
     nXSize = GDALGetRasterXSize(hSrcDataset);
     nYSize = GDALGetRasterYSize(hSrcDataset);

--- zoo-project/zoo-services/gdal/profile/service.c ---
@@ -67,6 +67,15 @@ int main(int argc,char** argv)
   free(pszFilename);
   if( hDataset != NULL )
     {
+
+		ZOO_DEBUG(GDALGetDriverShortName(GDALGetDatasetDriver(hDataset)));
+		if(strstr(GDALGetDriverShortName(GDALGetDatasetDriver(hDataset)),"VRT")!=NULL){
+			if(!validateVRT(conf,pszFilename)){
+				setMapInMaps(conf,"lenv","message",_("VRT file is not valid"));
+				return SERVICE_FAILED;
+			}
+		}
+
       GDALDriverH   hDriver;
       double        adfGeoTransform[6];
 

--- zoo-project/zoo-services/gdal/translate/service.c ---
@@ -35,6 +35,7 @@
 #include "vrtdataset.h"
 
 #include "service.h"
+#include "service_internal.h"
 
 CPL_CVSID("$Id$");
 
@@ -58,7 +59,7 @@ __declspec(dllexport)
     int			i;
     int			nRasterXSize, nRasterYSize;
     const char		*pszSource=NULL, *pszDest=NULL, *pszFormat = "GTiff";
-    GDALDriverH		hDriver;
+    GDALDriverH		hDriver, hInDriver;
     int			*panBandList = NULL, nBandCount = 0, bDefBands = TRUE;
     double		adfGeoTransform[6];
     GDALDataType	eOutputType = GDT_Unknown;
@@ -131,19 +132,19 @@ __declspec(dllexport)
       char *ext=new char[4];
       ext="tif";
       if(strncasecmp(pszFormat,"AAIGRID",7)==0)
-	ext="csv";
+        ext="csv";
       else 
-	if(strncasecmp(pszFormat,"PNG",3)==0)
-	  ext="png";
-	else
-	  if(strncasecmp(pszFormat,"GIF",3)==0)
-	    ext="gif";
-	  else
-	    if(strncasecmp(pszFormat,"JPEG",4)==0)
-	      ext="jpg";
-      sprintf((char*)pszDest,"%s/%s.%s",tempPath,tmpMap->value,ext);
-      fprintf(stderr,"DEBUG pszDest : %s\n",pszDest);
-    }
+        if(strncasecmp(pszFormat,"PNG",3)==0)
+          ext="png";
+        else
+          if(strncasecmp(pszFormat,"GIF",3)==0)
+            ext="gif";
+          else
+            if(strncasecmp(pszFormat,"JPEG",4)==0)
+              ext="jpg";
+            sprintf((char*)pszDest,"%s/%s.%s",tempPath,tmpMap->value,ext);
+            fprintf(stderr,"DEBUG pszDest : %s\n",pszDest);
+          }
 
     tmpMap=NULL;
     tmpMap=getMapFromMaps(inputs,"SrcWin","value");
@@ -152,11 +153,11 @@ __declspec(dllexport)
       char *t=strtok(tmp,",");
       int cnt=0;
       while(t!=NULL){
-	anSrcWin[cnt] = atoi(t);
-	t=strtok(NULL,",");
-	cnt++;
+        anSrcWin[cnt] = atoi(t);
+        t=strtok(NULL,",");
+        cnt++;
       }
-    }   
+    }
 
     tmpMap=NULL;
     tmpMap=getMapFromMaps(inputs,"ProjWin","value");
@@ -165,22 +166,22 @@ __declspec(dllexport)
       char *t=strtok(tmp,",");
       int cnt=0;
       while(t!=NULL){
-	switch(cnt){
-	case 0:
-	  dfULX = atof(t);
-	  break;
-	case 1:
-	  dfULY = atof(t);
-	  break;
-	case 2:
-	  dfLRX = atof(t);
-	  break;
-	case 3:
-	  dfLRY = atof(t);
-	  break;
-	}
-	t=strtok(NULL,",");
-	cnt++;
+        switch(cnt){
+        case 0:
+          dfULX = atof(t);
+          break;
+        case 1:
+          dfULY = atof(t);
+          break;
+        case 2:
+          dfLRX = atof(t);
+          break;
+        case 3:
+          dfLRY = atof(t);
+          break;
+        }
+        t=strtok(NULL,",");
+        cnt++;
       }
     }
 
@@ -191,82 +192,82 @@ __declspec(dllexport)
       map* length=getMapFromMaps(inputs,"GCP","length");
       int len=0;
       if(length){
-	len=atoi(length->value);
-	int i;
-	maps* currentMaps=getMaps(inputs,"GCP");
-	for(i=0;i<len;i++){
-	  char* endptr = NULL;
-	  /* -gcp pixel line easting northing [elev] */
-	  
-	  nGCPCount++;
-	  pasGCPs = (GDAL_GCP *) 
-	    realloc( pasGCPs, sizeof(GDAL_GCP) * nGCPCount );
-	  GDALInitGCPs( 1, pasGCPs + nGCPCount - 1 );
-
-	  map* currentMap=getMapArray(currentMaps->content,"value",i);
-
-	  char* tmpV=strdup(currentMap->value);
-	  char *res=strtok(tmpV,",");
-	  int j=0;
-	  while(res!=NULL){
-	    switch(j){
-	    case 0:
-	      pasGCPs[nGCPCount-1].dfGCPPixel = CPLAtofM(res);
-	      break;
-	    case 1:
-	      pasGCPs[nGCPCount-1].dfGCPLine = CPLAtofM(res);
-	      break;
-	    case 2:
-	      pasGCPs[nGCPCount-1].dfGCPX = CPLAtofM(res);
-	      break;
-	    case 3:
-	      pasGCPs[nGCPCount-1].dfGCPY = CPLAtofM(res);
-	      break;
-	    case 4:
-	      if(res!=NULL && (strtod(res, &endptr) != 0.0 || res[0] == '0'))
-		if (endptr && *endptr == 0)
-		  pasGCPs[nGCPCount-1].dfGCPZ = CPLAtofM(res);
-	      break;
-	    }
-	    res=strtok(NULL,",");
-	    j++;
-	  }
-	}
+        len=atoi(length->value);
+        int i;
+        maps* currentMaps=getMaps(inputs,"GCP");
+        for(i=0;i<len;i++){
+          char* endptr = NULL;
+          /* -gcp pixel line easting northing [elev] */
+
+          nGCPCount++;
+          pasGCPs = (GDAL_GCP *)
+            realloc( pasGCPs, sizeof(GDAL_GCP) * nGCPCount );
+          GDALInitGCPs( 1, pasGCPs + nGCPCount - 1 );
+
+          map* currentMap=getMapArray(currentMaps->content,"value",i);
+
+          char* tmpV=strdup(currentMap->value);
+          char *res=strtok(tmpV,",");
+          int j=0;
+          while(res!=NULL){
+            switch(j){
+            case 0:
+              pasGCPs[nGCPCount-1].dfGCPPixel = CPLAtofM(res);
+              break;
+            case 1:
+              pasGCPs[nGCPCount-1].dfGCPLine = CPLAtofM(res);
+              break;
+            case 2:
+              pasGCPs[nGCPCount-1].dfGCPX = CPLAtofM(res);
+              break;
+            case 3:
+              pasGCPs[nGCPCount-1].dfGCPY = CPLAtofM(res);
+              break;
+            case 4:
+              if(res!=NULL && (strtod(res, &endptr) != 0.0 || res[0] == '0'))
+          if (endptr && *endptr == 0)
+            pasGCPs[nGCPCount-1].dfGCPZ = CPLAtofM(res);
+              break;
+            }
+            res=strtok(NULL,",");
+            j++;
+          }
+        }
       }else{
-	char* endptr = NULL;
-	/* -gcp pixel line easting northing [elev] */
-	
-	nGCPCount++;
-	pasGCPs = (GDAL_GCP *) 
-	  realloc( pasGCPs, sizeof(GDAL_GCP) * nGCPCount );
-	GDALInitGCPs( 1, pasGCPs + nGCPCount - 1 );
-	
-	char* tmpV=strdup(tmpMap->value);
-	char *res=strtok(tmpV,",");
-	int j=0;
-	while(res!=NULL){
-	  switch(j){
-	  case 0:
-	    pasGCPs[nGCPCount-1].dfGCPPixel = CPLAtofM(res);
-	    break;
-	  case 1:
-	    pasGCPs[nGCPCount-1].dfGCPLine = CPLAtofM(res);
-	    break;
-	  case 2:
-	    pasGCPs[nGCPCount-1].dfGCPX = CPLAtofM(res);
-	    break;
-	  case 3:
-	    pasGCPs[nGCPCount-1].dfGCPY = CPLAtofM(res);
-	    break;
-	  case 4:
-	    if(res!=NULL && (CPLStrtod(res, &endptr) != 0.0 || res[0] == '0'))
-	      if (endptr && *endptr == 0)
-		pasGCPs[nGCPCount-1].dfGCPZ = CPLAtofM(res);
-	    break;
-	  }	    
-	  res=strtok(NULL,",");
-	  j++;
-	}
+        char* endptr = NULL;
+        /* -gcp pixel line easting northing [elev] */
+
+        nGCPCount++;
+        pasGCPs = (GDAL_GCP *)
+          realloc( pasGCPs, sizeof(GDAL_GCP) * nGCPCount );
+        GDALInitGCPs( 1, pasGCPs + nGCPCount - 1 );
+
+        char* tmpV=strdup(tmpMap->value);
+        char *res=strtok(tmpV,",");
+        int j=0;
+        while(res!=NULL){
+          switch(j){
+          case 0:
+            pasGCPs[nGCPCount-1].dfGCPPixel = CPLAtofM(res);
+            break;
+          case 1:
+            pasGCPs[nGCPCount-1].dfGCPLine = CPLAtofM(res);
+            break;
+          case 2:
+            pasGCPs[nGCPCount-1].dfGCPX = CPLAtofM(res);
+            break;
+          case 3:
+            pasGCPs[nGCPCount-1].dfGCPY = CPLAtofM(res);
+            break;
+          case 4:
+            if(res!=NULL && (CPLStrtod(res, &endptr) != 0.0 || res[0] == '0'))
+              if (endptr && *endptr == 0)
+          pasGCPs[nGCPCount-1].dfGCPZ = CPLAtofM(res);
+            break;
+          }
+          res=strtok(NULL,",");
+          j++;
+        }
       }
     }
 
@@ -275,62 +276,59 @@ __declspec(dllexport)
     tmpMap=getMapFromMaps(inputs,"SRS","value");
     if(tmpMap!=NULL){
       OGRSpatialReference oOutputSRS;
-      if( oOutputSRS.SetFromUserInput( tmpMap->value ) != OGRERR_NONE )
-	{
-	  char *msg=(char*)CPLMalloc(100*sizeof(char));
-	  sprintf( msg, "Failed to process SRS definition: %s\n", 
-		   tmpMap->value );
-	  setMapInMaps(conf,"lenv","message",msg);
-	  /**
-	   * Avoiding GDALDestroyDriverManager() call
-	   */
-	  return SERVICE_FAILED;
-	}
+      if( oOutputSRS.SetFromUserInput( tmpMap->value ) != OGRERR_NONE ) {
+        char *msg=(char*)CPLMalloc(100*sizeof(char));
+        sprintf( msg, "Failed to process SRS definition: %s\n",
+          tmpMap->value );
+        setMapInMaps(conf,"lenv","message",msg);
+        /**
+        * Avoiding GDALDestroyDriverManager() call
+        */
+        return SERVICE_FAILED;
+      }
       oOutputSRS.exportToWkt( &pszOutputSRS );
     }
     tmpMap=NULL;
     tmpMap=getMapFromMaps(inputs,"Type","value");
     if(tmpMap!=NULL){
       int	iType;
       
-      for( iType = 1; iType < GDT_TypeCount; iType++ )
-	{
-	  if( GDALGetDataTypeName((GDALDataType)iType) != NULL
-	      && EQUAL(GDALGetDataTypeName((GDALDataType)iType),
-		       tmpMap->value) )
-	    {
-	      eOutputType = (GDALDataType) iType;
-	    }
-	}
+      for( iType = 1; iType < GDT_TypeCount; iType++ ) {
+        if( GDALGetDataTypeName((GDALDataType)iType) != NULL
+            && EQUAL(GDALGetDataTypeName((GDALDataType)iType),
+              tmpMap->value) )
+          {
+            eOutputType = (GDALDataType) iType;
+          }
+      }
       
-      if( eOutputType == GDT_Unknown )
-	{
-	  printf( "Unknown output pixel type: %s\n", tmpMap->value );
-	  /**
-	   * Avoiding GDALDestroyDriverManager() call
-	   */
-	  exit( 2 );
-	}
+      if( eOutputType == GDT_Unknown ) {
+        printf( "Unknown output pixel type: %s\n", tmpMap->value );
+        /**
+        * Avoiding GDALDestroyDriverManager() call
+        */
+        exit( 2 );
+      }
     }
 
     fprintf(stderr,"DEBUG pszDest : %s %d\n",pszDest,__LINE__);
     if( pszDest == NULL ){
-	fprintf(stderr,"exit line 416");
-	fflush(stderr);
-	/**
-	 * Avoiding GDALDestroyDriverManager() call
-	 */
+        fprintf(stderr,"exit line 416");
+        fflush(stderr);
+        /**
+        * Avoiding GDALDestroyDriverManager() call
+        */
         exit( 10 );
       }
 
     fprintf(stderr,"DEBUG pszDest : %s %d\n",pszDest,__LINE__);
     if ( strcmp(pszSource, pszDest) == 0)
       {
         fprintf(stderr, "Source and destination datasets must be different.\n");
-	fflush(stderr);
-	/**
-	 * Avoiding GDALDestroyDriverManager() call
-	 */
+        fflush(stderr);
+        /**
+        * Avoiding GDALDestroyDriverManager() call
+        */
         exit( 1 );
       }
 
@@ -351,6 +349,13 @@ __declspec(dllexport)
       return SERVICE_FAILED;
     }
 
+    if(strstr(GDALGetDriverShortName(GDALGetDatasetDriver(hDataset)),"VRT")!=NULL){
+      if(!validateVRT(conf,pszSource)){
+        setMapInMaps(conf,"lenv","message",_("VRT file is not valid"));
+        return SERVICE_FAILED;
+      }
+    }
+
     fprintf(stderr,"DEBUG pszDest : %s %d\n",pszDest,__LINE__);
     /* ----------------------------------------------------------------- */
     /*      Handle subdatasets.                                          */

--- zoo-project/zoo-services/gdal/warp/service.c ---
@@ -34,6 +34,7 @@
 #include "ogr_api.h"
 #include <vector>
 #include "service.h"
+#include "service_internal.h"
 
 CPL_CVSID("$Id: gdalwarp.cpp 24214 2012-04-08 20:17:17Z etourigny $");
 
@@ -821,6 +822,12 @@ int Gdal_Warp( maps*& conf,maps*& inputs,maps*& outputs )
 		  setMapInMaps(conf,"lenv","message","Cannot compute bounding box of cutline.");
 		  return GDALExit(1);
                 }
+                if(strstr(GDALGetDriverShortName(GDALGetDatasetDriver(hDataset)),"VRT")!=NULL){
+                    if(!validateVRT(conf,pszSource)){
+                        setMapInMaps(conf,"lenv","message",_("VRT file is not valid"));
+                        return SERVICE_FAILED;
+                    }
+                }
 
                 OGRSpatialReferenceH  hRasterSRS = NULL;
                 const char *pszProjection = NULL;
@@ -1478,6 +1485,12 @@ GDALWarpCreateOutput( maps*& conf,char **papszSrcFiles, const char *pszFilename,
         hSrcDS = GDALOpen( papszSrcFiles[iSrc], GA_ReadOnly );
         if( hSrcDS == NULL )
             GDALExit( 1 );
+        if(strstr(GDALGetDriverShortName(GDALGetDatasetDriver(hSrcDS)),"VRT")!=NULL){
+            if(!validateVRT(conf,papszSrcFiles[iSrc])){
+                setMapInMaps(conf,"lenv","message",_("VRT file is not valid"));
+                return NULL;
+            }
+        }
 
 /* -------------------------------------------------------------------- */
 /*      Check that there's at least one raster band                     */

