--- LICENSE.txt ---
@@ -1,7 +1,9 @@
 ﻿
-ShowDoc遵循Apache2开源协议发布，并提供免费使用。
-版权所有Copyright © 2015 by star7th (http://blog.star7th.com/)
-All rights reserved。
+ShowDoc遵循Apache2开源协议发布。
+ShowDoc在遵循Apache2开源协议之上有一条额外版权声明：
+showdoc官方(https://www.showdoc.com.cn/)以及作者star7th ( https://github.com/star7th )拥有程序的版权和相应权利，
+在保留程序UI界面上的版权信息和链接的前提下，可免费使用或者二次开发
+如需更改版权信息或版权链接，需取得官方同意授权。
 
 Apache Licence是著名的非盈利开源组织Apache采用的协议。
 该协议和BSD类似，鼓励代码共享和尊重原作者的著作权，
@@ -29,3 +31,9 @@ CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.
+
+Showdoc has an additional copyright notice on compliance with the Apache2 Open Source License:
+Showdoc official（ https://www.showdoc.com.cn/ ）And author star7th（ https://github.com/star7th ）Have the copyright and corresponding rights of the program,
+On the premise of retaining the copyright information and links on the program UI interface, it can be used for free or secondary development
+If you need to change copyright information or copyright links, you need to obtain official consent and authorization.
+

--- README.md ---
@@ -43,7 +43,7 @@ Responsive webpage design can share the project documents to computer or mobile
 - #### Permission Manage
 
   - Public and Private Project
-  
+
     Projects on ShowDoc are divided into two categories including Public Project and Private Project. The Public Project can be visited by anyone, the Private Project need to login. The password is set by project owner.
 
   - Project Transfer
@@ -81,9 +81,7 @@ Responsive webpage design can share the project documents to computer or mobile
 ### About the copyright
 
 ShowDoc is issued complying with Apache2 Open Source License, and it is free.
-
-Copyright © star7th
-
-E-mail: xing7th#gmail.com (change # into @)
-
-All rights reserved.
+Showdoc has an additional copyright notice on compliance with the Apache2 Open Source License:
+[Showdoc official](https://www.showdoc.com.cn/ 'Showdoc official') And author [star7th](https://github.com/star7th 'star7th') Have the copyright and corresponding rights of the program,
+On the premise of retaining the copyright information and links on the program UI interface, it can be used for free or secondary development
+If you need to change copyright information or copyright links, you need to obtain official consent and authorization.

--- composer.json ---
@@ -18,7 +18,9 @@
         "php": ">=5.3.0",
         "qcloud/cos-sdk-v5": "1.*",
         "league/oauth2-client": "^2.6",
-        "jasig/phpcas": "^1.3"
+        "jasig/phpcas": "^1.3",
+        "aws/aws-sdk-php": "^3.208",
+        "gregwar/captcha": "1.*"
     },
     "config": {
         "vendor-dir": "./server/vendor"

--- composer.lock ---
@@ -4,8 +4,224 @@
         "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
         "This file is @generated automatically"
     ],
-    "content-hash": "05ae90d0fcc983a02874f65e1b52b81e",
+    "content-hash": "1c994b203fb6b15841c05b2218321d4f",
     "packages": [
+        {
+            "name": "aws/aws-crt-php",
+            "version": "v1.0.2",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/awslabs/aws-crt-php.git",
+                "reference": "3942776a8c99209908ee0b287746263725685732"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/awslabs/aws-crt-php/zipball/3942776a8c99209908ee0b287746263725685732",
+                "reference": "3942776a8c99209908ee0b287746263725685732",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "php": ">=5.5"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "^4.8.35|^5.4.3"
+            },
+            "type": "library",
+            "autoload": {
+                "classmap": [
+                    "src/"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "Apache-2.0"
+            ],
+            "authors": [
+                {
+                    "name": "AWS SDK Common Runtime Team",
+                    "email": "aws-sdk-common-runtime@amazon.com"
+                }
+            ],
+            "description": "AWS Common Runtime for PHP",
+            "homepage": "http://aws.amazon.com/sdkforphp",
+            "keywords": [
+                "amazon",
+                "aws",
+                "crt",
+                "sdk"
+            ],
+            "support": {
+                "issues": "https://github.com/awslabs/aws-crt-php/issues",
+                "source": "https://github.com/awslabs/aws-crt-php/tree/v1.0.2"
+            },
+            "time": "2021-09-03T22:57:30+00:00"
+        },
+        {
+            "name": "aws/aws-sdk-php",
+            "version": "3.208.7",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/aws/aws-sdk-php.git",
+                "reference": "41a800dd7cf5c4ac0ef9bf8db01e838ab6a3698c"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/aws/aws-sdk-php/zipball/41a800dd7cf5c4ac0ef9bf8db01e838ab6a3698c",
+                "reference": "41a800dd7cf5c4ac0ef9bf8db01e838ab6a3698c",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "aws/aws-crt-php": "^1.0.2",
+                "ext-json": "*",
+                "ext-pcre": "*",
+                "ext-simplexml": "*",
+                "guzzlehttp/guzzle": "^5.3.3|^6.2.1|^7.0",
+                "guzzlehttp/promises": "^1.4.0",
+                "guzzlehttp/psr7": "^1.7.0|^2.0",
+                "mtdowling/jmespath.php": "^2.6",
+                "php": ">=5.5"
+            },
+            "require-dev": {
+                "andrewsville/php-token-reflection": "^1.4",
+                "aws/aws-php-sns-message-validator": "~1.0",
+                "behat/behat": "~3.0",
+                "doctrine/cache": "~1.4",
+                "ext-dom": "*",
+                "ext-openssl": "*",
+                "ext-pcntl": "*",
+                "ext-sockets": "*",
+                "nette/neon": "^2.3",
+                "paragonie/random_compat": ">= 2",
+                "phpunit/phpunit": "^4.8.35|^5.4.3",
+                "psr/cache": "^1.0",
+                "psr/simple-cache": "^1.0",
+                "sebastian/comparator": "^1.2.3"
+            },
+            "suggest": {
+                "aws/aws-php-sns-message-validator": "To validate incoming SNS notifications",
+                "doctrine/cache": "To use the DoctrineCacheAdapter",
+                "ext-curl": "To send requests using cURL",
+                "ext-openssl": "Allows working with CloudFront private distributions and verifying received SNS messages",
+                "ext-sockets": "To use client-side monitoring"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.0-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Aws\\": "src/"
+                },
+                "files": [
+                    "src/functions.php"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "Apache-2.0"
+            ],
+            "authors": [
+                {
+                    "name": "Amazon Web Services",
+                    "homepage": "http://aws.amazon.com"
+                }
+            ],
+            "description": "AWS SDK for PHP - Use Amazon Web Services in your PHP project",
+            "homepage": "http://aws.amazon.com/sdkforphp",
+            "keywords": [
+                "amazon",
+                "aws",
+                "cloud",
+                "dynamodb",
+                "ec2",
+                "glacier",
+                "s3",
+                "sdk"
+            ],
+            "support": {
+                "forum": "https://forums.aws.amazon.com/forum.jspa?forumID=80",
+                "issues": "https://github.com/aws/aws-sdk-php/issues",
+                "source": "https://github.com/aws/aws-sdk-php/tree/3.208.7"
+            },
+            "time": "2021-12-21T19:16:39+00:00"
+        },
+        {
+            "name": "gregwar/captcha",
+            "version": "v1.1.9",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/Gregwar/Captcha.git",
+                "reference": "4bb668e6b40e3205a020ca5ee4ca8cff8b8780c5"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/Gregwar/Captcha/zipball/4bb668e6b40e3205a020ca5ee4ca8cff8b8780c5",
+                "reference": "4bb668e6b40e3205a020ca5ee4ca8cff8b8780c5",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "ext-gd": "*",
+                "ext-mbstring": "*",
+                "php": ">=5.3.0",
+                "symfony/finder": "*"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "^6.4"
+            },
+            "type": "captcha",
+            "autoload": {
+                "psr-4": {
+                    "Gregwar\\": "src/Gregwar"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Grégoire Passault",
+                    "email": "g.passault@gmail.com",
+                    "homepage": "http://www.gregwar.com/"
+                },
+                {
+                    "name": "Jeremy Livingston",
+                    "email": "jeremy.j.livingston@gmail.com"
+                }
+            ],
+            "description": "Captcha generator",
+            "homepage": "https://github.com/Gregwar/Captcha",
+            "keywords": [
+                "bot",
+                "captcha",
+                "spam"
+            ],
+            "support": {
+                "issues": "https://github.com/Gregwar/Captcha/issues",
+                "source": "https://github.com/Gregwar/Captcha/tree/master"
+            },
+            "time": "2020-03-24T14:39:05+00:00"
+        },
         {
             "name": "guzzle/guzzle",
             "version": "v3.9.3",
@@ -500,6 +716,73 @@
             },
             "time": "2020-10-28T02:03:40+00:00"
         },
+        {
+            "name": "mtdowling/jmespath.php",
+            "version": "2.6.1",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/jmespath/jmespath.php.git",
+                "reference": "9b87907a81b87bc76d19a7fb2d61e61486ee9edb"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/jmespath/jmespath.php/zipball/9b87907a81b87bc76d19a7fb2d61e61486ee9edb",
+                "reference": "9b87907a81b87bc76d19a7fb2d61e61486ee9edb",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "php": "^5.4 || ^7.0 || ^8.0",
+                "symfony/polyfill-mbstring": "^1.17"
+            },
+            "require-dev": {
+                "composer/xdebug-handler": "^1.4 || ^2.0",
+                "phpunit/phpunit": "^4.8.36 || ^7.5.15"
+            },
+            "bin": [
+                "bin/jp.php"
+            ],
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "2.6-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "JmesPath\\": "src/"
+                },
+                "files": [
+                    "src/JmesPath.php"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Michael Dowling",
+                    "email": "mtdowling@gmail.com",
+                    "homepage": "https://github.com/mtdowling"
+                }
+            ],
+            "description": "Declaratively specify how to extract elements from a JSON document",
+            "keywords": [
+                "json",
+                "jsonpath"
+            ],
+            "support": {
+                "issues": "https://github.com/jmespath/jmespath.php/issues",
+                "source": "https://github.com/jmespath/jmespath.php/tree/2.6.1"
+            },
+            "time": "2021-06-14T00:11:39+00:00"
+        },
         {
             "name": "paragonie/random_compat",
             "version": "v9.99.100",
@@ -829,6 +1112,79 @@
             },
             "time": "2019-03-08T08:55:37+00:00"
         },
+        {
+            "name": "symfony/deprecation-contracts",
+            "version": "v2.5.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/symfony/deprecation-contracts.git",
+                "reference": "6f981ee24cf69ee7ce9736146d1c57c2780598a8"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/symfony/deprecation-contracts/zipball/6f981ee24cf69ee7ce9736146d1c57c2780598a8",
+                "reference": "6f981ee24cf69ee7ce9736146d1c57c2780598a8",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "php": ">=7.1"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-main": "2.5-dev"
+                },
+                "thanks": {
+                    "name": "symfony/contracts",
+                    "url": "https://github.com/symfony/contracts"
+                }
+            },
+            "autoload": {
+                "files": [
+                    "function.php"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Nicolas Grekas",
+                    "email": "p@tchwork.com"
+                },
+                {
+                    "name": "Symfony Community",
+                    "homepage": "https://symfony.com/contributors"
+                }
+            ],
+            "description": "A generic function and convention to trigger deprecation notices",
+            "homepage": "https://symfony.com",
+            "support": {
+                "source": "https://github.com/symfony/deprecation-contracts/tree/v2.5.0"
+            },
+            "funding": [
+                {
+                    "url": "https://symfony.com/sponsor",
+                    "type": "custom"
+                },
+                {
+                    "url": "https://github.com/fabpot",
+                    "type": "github"
+                },
+                {
+                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
+                    "type": "tidelift"
+                }
+            ],
+            "time": "2021-07-12T14:48:14+00:00"
+        },
         {
             "name": "symfony/event-dispatcher",
             "version": "v2.8.52",
@@ -891,6 +1247,250 @@
                 "source": "https://github.com/symfony/event-dispatcher/tree/v2.8.50"
             },
             "time": "2018-11-21T14:20:20+00:00"
+        },
+        {
+            "name": "symfony/finder",
+            "version": "v5.4.2",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/symfony/finder.git",
+                "reference": "e77046c252be48c48a40816187ed527703c8f76c"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/symfony/finder/zipball/e77046c252be48c48a40816187ed527703c8f76c",
+                "reference": "e77046c252be48c48a40816187ed527703c8f76c",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "php": ">=7.2.5",
+                "symfony/deprecation-contracts": "^2.1|^3",
+                "symfony/polyfill-php80": "^1.16"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "Symfony\\Component\\Finder\\": ""
+                },
+                "exclude-from-classmap": [
+                    "/Tests/"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Fabien Potencier",
+                    "email": "fabien@symfony.com"
+                },
+                {
+                    "name": "Symfony Community",
+                    "homepage": "https://symfony.com/contributors"
+                }
+            ],
+            "description": "Finds files and directories via an intuitive fluent interface",
+            "homepage": "https://symfony.com",
+            "support": {
+                "source": "https://github.com/symfony/finder/tree/v5.4.2"
+            },
+            "funding": [
+                {
+                    "url": "https://symfony.com/sponsor",
+                    "type": "custom"
+                },
+                {
+                    "url": "https://github.com/fabpot",
+                    "type": "github"
+                },
+                {
+                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
+                    "type": "tidelift"
+                }
+            ],
+            "time": "2021-12-15T11:06:13+00:00"
+        },
+        {
+            "name": "symfony/polyfill-mbstring",
+            "version": "v1.23.1",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/symfony/polyfill-mbstring.git",
+                "reference": "9174a3d80210dca8daa7f31fec659150bbeabfc6"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/9174a3d80210dca8daa7f31fec659150bbeabfc6",
+                "reference": "9174a3d80210dca8daa7f31fec659150bbeabfc6",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "php": ">=7.1"
+            },
+            "suggest": {
+                "ext-mbstring": "For best performance"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-main": "1.23-dev"
+                },
+                "thanks": {
+                    "name": "symfony/polyfill",
+                    "url": "https://github.com/symfony/polyfill"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Symfony\\Polyfill\\Mbstring\\": ""
+                },
+                "files": [
+                    "bootstrap.php"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Nicolas Grekas",
+                    "email": "p@tchwork.com"
+                },
+                {
+                    "name": "Symfony Community",
+                    "homepage": "https://symfony.com/contributors"
+                }
+            ],
+            "description": "Symfony polyfill for the Mbstring extension",
+            "homepage": "https://symfony.com",
+            "keywords": [
+                "compatibility",
+                "mbstring",
+                "polyfill",
+                "portable",
+                "shim"
+            ],
+            "support": {
+                "source": "https://github.com/symfony/polyfill-mbstring/tree/v1.23.1"
+            },
+            "funding": [
+                {
+                    "url": "https://symfony.com/sponsor",
+                    "type": "custom"
+                },
+                {
+                    "url": "https://github.com/fabpot",
+                    "type": "github"
+                },
+                {
+                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
+                    "type": "tidelift"
+                }
+            ],
+            "time": "2021-05-27T12:26:48+00:00"
+        },
+        {
+            "name": "symfony/polyfill-php80",
+            "version": "v1.23.1",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/symfony/polyfill-php80.git",
+                "reference": "1100343ed1a92e3a38f9ae122fc0eb21602547be"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/symfony/polyfill-php80/zipball/1100343ed1a92e3a38f9ae122fc0eb21602547be",
+                "reference": "1100343ed1a92e3a38f9ae122fc0eb21602547be",
+                "shasum": "",
+                "mirrors": [
+                    {
+                        "url": "https://mirrors.aliyun.com/composer/dists/%package%/%reference%.%type%",
+                        "preferred": true
+                    }
+                ]
+            },
+            "require": {
+                "php": ">=7.1"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-main": "1.23-dev"
+                },
+                "thanks": {
+                    "name": "symfony/polyfill",
+                    "url": "https://github.com/symfony/polyfill"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Symfony\\Polyfill\\Php80\\": ""
+                },
+                "files": [
+                    "bootstrap.php"
+                ],
+                "classmap": [
+                    "Resources/stubs"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Ion Bazan",
+                    "email": "ion.bazan@gmail.com"
+                },
+                {
+                    "name": "Nicolas Grekas",
+                    "email": "p@tchwork.com"
+                },
+                {
+                    "name": "Symfony Community",
+                    "homepage": "https://symfony.com/contributors"
+                }
+            ],
+            "description": "Symfony polyfill backporting some PHP 8.0+ features to lower PHP versions",
+            "homepage": "https://symfony.com",
+            "keywords": [
+                "compatibility",
+                "polyfill",
+                "portable",
+                "shim"
+            ],
+            "support": {
+                "source": "https://github.com/symfony/polyfill-php80/tree/v1.23.1"
+            },
+            "funding": [
+                {
+                    "url": "https://symfony.com/sponsor",
+                    "type": "custom"
+                },
+                {
+                    "url": "https://github.com/fabpot",
+                    "type": "github"
+                },
+                {
+                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
+                    "type": "tidelift"
+                }
+            ],
+            "time": "2021-07-28T13:41:28+00:00"
         }
     ],
     "packages-dev": [],

--- server/Application/Api/Controller/AdminSettingController.class.php ---
@@ -188,7 +188,7 @@ public function getLoginSecretKey(){
         $this->checkAdmin();
         $login_secret_key = D("Options")->get("login_secret_key") ;
         if(!$login_secret_key){
-            $login_secret_key = bin2hex( random_bytes( 16 ) );
+            $login_secret_key = get_rand_str();
             D("Options")->set("login_secret_key",$login_secret_key) ;
         }
         $this->sendResult(array("login_secret_key"=>$login_secret_key));
@@ -198,7 +198,7 @@ public function getLoginSecretKey(){
     public function resetLoginSecretKey(){
         $login_user = $this->checkLogin();
         $this->checkAdmin();
-        $login_secret_key = bin2hex( random_bytes( 16 ) );
+        $login_secret_key = get_rand_str();
         D("Options")->set("login_secret_key",$login_secret_key) ;
         $this->sendResult(array("login_secret_key"=>$login_secret_key));
 

--- server/Application/Api/Controller/CommonController.class.php ---
@@ -1,6 +1,7 @@
 <?php
 namespace Api\Controller;
 use Think\Controller;
+use Gregwar\Captcha\CaptchaBuilder as CaptchaBuilder;
 class CommonController extends BaseController {
 
 
@@ -16,6 +17,14 @@ public function qrcode(){
 
     //生成验证码
     public function verify(){
+
+    if(version_compare(PHP_VERSION,COMPOSER_PHP_VERSION,'>')){
+      $builder = new CaptchaBuilder();
+      $builder->build();
+      session('v_code', strtolower($builder->getPhrase()) ) ; //转成小写后存入session
+      header('Content-type: image/PNG');
+      $builder->output();
+    }else{
       //生成验证码图片
       Header("Content-type: image/PNG");
       $im = imagecreate(44,18); // 画一张指定宽高的图片
@@ -41,6 +50,9 @@ public function verify(){
       ImageDestroy($im);
     }
 
+
+    }
+
     public function createCaptcha(){
         $captcha = rand(1000, 9999) ;
         $data = array(
@@ -56,25 +68,33 @@ public function showCaptcha(){
       $captcha_id = I("captcha_id/d");
       $captcha = D("Captcha")->where("captcha_id = '$captcha_id' ")->find();
 
-      $numArray  = array_map('intval', str_split($captcha['captcha']));
-      //生成验证码图片
-      Header("Content-type: image/PNG");
-      $im = imagecreate(44,18); // 画一张指定宽高的图片
-      $back = ImageColorAllocate($im, 245,245,245); // 定义背景颜色
-      imagefill($im,0,0,$back); //把背景颜色填充到刚刚画出来的图片中
-      srand((double)microtime()*1000000);
-      //生成4位数字
-      for($i=0;$i<4;$i++){
-        $font = ImageColorAllocate($im, rand(100,255),rand(0,100),rand(100,255)); // 生成随机颜色
-        imagestring($im, 5, 2+$i*10, 1, $numArray[$i], $font);
-      }
-      for($i=0;$i<200;$i++) //加入干扰象素
-      {
-        $randcolor = ImageColorallocate($im,rand(0,255),rand(0,255),rand(0,255));
-        imagesetpixel($im, rand()%70 , rand()%30 , $randcolor); // 画像素点函数
+      if(version_compare(PHP_VERSION,COMPOSER_PHP_VERSION,'>')){
+        $builder = new CaptchaBuilder($captcha['captcha']);
+        $builder->build();
+        header('Content-type: image/PNG');
+        $builder->output();
+      }else{
+        $numArray  = array_map('intval', str_split($captcha['captcha']));
+        //生成验证码图片
+        Header("Content-type: image/PNG");
+        $im = imagecreate(44,18); // 画一张指定宽高的图片
+        $back = ImageColorAllocate($im, 245,245,245); // 定义背景颜色
+        imagefill($im,0,0,$back); //把背景颜色填充到刚刚画出来的图片中
+        srand((double)microtime()*1000000);
+        //生成4位数字
+        for($i=0;$i<4;$i++){
+          $font = ImageColorAllocate($im, rand(100,255),rand(0,100),rand(100,255)); // 生成随机颜色
+          imagestring($im, 5, 2+$i*10, 1, $numArray[$i], $font);
+        }
+        for($i=0;$i<200;$i++) //加入干扰象素
+        {
+          $randcolor = ImageColorallocate($im,rand(0,255),rand(0,255),rand(0,255));
+          imagesetpixel($im, rand()%70 , rand()%30 , $randcolor); // 画像素点函数
+        }
+        ImagePNG($im);
+        ImageDestroy($im);
       }
-      ImagePNG($im);
-      ImageDestroy($im);
+
 
     }
 

--- server/Application/Api/Model/AttachmentModel.class.php ---
@@ -1,6 +1,8 @@
 <?php
 namespace Api\Model;
 use Api\Model\BaseModel;
+use Aws\S3\S3Client;
+
 /**
  * 
  * @author star7th      
@@ -44,6 +46,7 @@ public function deleteFile($file_id){
 		if (file_exists($file_path)) {
 			@unlink($file_path);
 		}
+		$this->deleteOss($real_url);
 		D("UploadFile")->where(" file_id = '$file_id' ")->delete();
 		D("FilePage")->where(" file_id = '$file_id' ")->delete();
 		return true ;
@@ -126,80 +129,176 @@ public function upload($_files , $file_key , $uid , $item_id = 0  , $page_id = 0
 		return false;
 	}
 
-  //上传到oss。参数$uploadFile是文件上传流，如$_FILES['file'] .也可以自己拼凑
+  	//上传到oss。参数$uploadFile是文件上传流，如$_FILES['file'] .也可以自己拼凑
 	public function uploadOss($uploadFile){
 		$oss_setting_json = D("Options")->get("oss_setting") ;
 		$oss_setting = json_decode($oss_setting_json,1);
-		if ($oss_setting && $oss_setting['oss_type'] && $oss_setting['oss_type'] == 'aliyun') {
-				$config = array(
-						"key" => $oss_setting['key'],
-						"secret"=> $oss_setting['secret'],
-						"endpoint"=> $oss_setting['endpoint'],
-						"bucket"=> $oss_setting['bucket'],
-				);
-				// $oss = new_oss($config['key'] , $config['secret'] , $config['endpoint'] );
-				include_once VENDOR_PATH .'Alioss/autoload.php';
-				$oss = new \OSS\OssClient($config['key'] ,  $config['secret'] , $config['endpoint'] , false );
-				$ext = strrchr($uploadFile['name'], '.'); //获取扩展名
-				$oss_path = "showdoc_".time().rand().$ext;
-				$res = $oss->uploadFile($config['bucket'],$oss_path,$uploadFile['tmp_name']);
-				if ($res && $res['info'] && $res['info']['url']) {
-						if ($oss_setting['domain']) {
-								return $oss_setting['protocol'] . '://'.$oss_setting['domain']."/".$oss_path ;
-						}else{
-								return $res['info']['url'] ;
-						}
-						
-				}
+
+		if ($oss_setting && $oss_setting['oss_type'] && ( $oss_setting['oss_type'] == 's3_storage' || $oss_setting['oss_type'] == 'aliyun') ) {
+
+			return $this->uploadS3($uploadFile , $oss_setting);
+
 		}
 
 		if ($oss_setting && $oss_setting['oss_type'] && $oss_setting['oss_type'] == 'qiniu') {
-				$config = array(
-										'rootPath' => './',
-										'saveName' => array('uniqid', ''),
-										'driver' => 'Qiniu',
-										'driverConfig' => array(
-														'accessKey' => $oss_setting['key'],
-														'secrectKey' => $oss_setting['secret'], 
-														'protocol'=>$oss_setting['protocol'],
-														'domain' => $oss_setting['domain'],
-														'bucket' => $oss_setting['bucket'], 
-												)
-					);
-					//上传到七牛
-					$Upload = new \Think\Upload($config);
-					$info = $Upload->uploadOne($uploadFile);
-					if ($info && $info['url']) {
-							return $info['url'] ;
-					}
 
+			$oss_setting['endpoint'] = $this->getQiuniuEndpointByKey($oss_setting['key'] , $oss_setting['bucket']);
+			return $this->uploadS3($uploadFile , $oss_setting); 
+
+		}
+		// 腾讯云
+		if ($oss_setting && $oss_setting['oss_type'] && $oss_setting['oss_type'] == 'qcloud') {
+			// 腾讯云，一开始让用户填写region而没填写endpoint，所以要自己拼接
+			$oss_setting['endpoint'] = "https://cos.{$oss_setting['region']}.myqcloud.com";
+			// 腾讯云的SecretId相当于s3的key， secretKey相当于s3的secret
+			$oss_setting['key'] = $oss_setting['secretId']  ;
+			$oss_setting['secret'] = $oss_setting['secretKey']  ;
+			return $this->uploadS3($uploadFile , $oss_setting); 
+		}
+
+
+		return false ;
+	}
+
+	// 通过s3协议上传
+	// 注意传进来的oss_setting数组需要先转换成合法格式
+	public function uploadS3($uploadFile , $oss_setting){
+
+		$ext = strrchr($uploadFile['name'], '.'); //获取扩展名
+		$oss_path = "showdoc_".get_rand_str().$ext;
+
+		// 如果不包含协议头，自己给它补充
+		if(!strstr($oss_setting['endpoint'] , '://')){
+			$oss_setting['endpoint'] = 'https://'.$oss_setting['endpoint'] ;
+		}
+		$s3 = new S3Client([
+			'version' => 'latest',
+			'region'  => 'us-east-1',
+			'endpoint' => $oss_setting['endpoint'] ,
+			'use_virtual_hosted_style_endpoint' => true,
+			'credentials' => [
+					'key'    => $oss_setting['key'],
+					'secret' => $oss_setting['secret'],
+				],
+		]);
+	
+		// Send a PutObject request and get the result object.
+		$resObj = $s3->putObject([
+			'Bucket' => $oss_setting['bucket'],
+			'Key'    => $oss_path,
+			'Body'   => fopen($uploadFile['tmp_name'], 'rb')
+		]);
+		$res = (array)$resObj ;
+		$resultdata = current($res) ;// 获取数组的第一个值
+		// var_dump( $resultdata) ;exit();
+		if ($res && $resultdata && $resultdata['ObjectURL']) {
+			if ($oss_setting['domain']) {
+					return $oss_setting['protocol'] . '://'.$oss_setting['domain']."/".$oss_path ;
+			}else{
+					return $resultdata['ObjectURL'];
+			}
+			
+		}else{
+			// var_dump($resObj) ;exit();
+		}
+	}
+
+  	//从oss中删除
+	public function deleteOss($file_url){
+		$oss_setting_json = D("Options")->get("oss_setting") ;
+		$oss_setting = json_decode($oss_setting_json,1);
+		if ($oss_setting && $oss_setting['oss_type'] && ( $oss_setting['oss_type'] == 's3_storage' || $oss_setting['oss_type'] == 'aliyun') ) {
+			return $this->deleteS3($file_url , $oss_setting);
+		}
+
+		if ($oss_setting && $oss_setting['oss_type'] && $oss_setting['oss_type'] == 'qiniu') {
+			$oss_setting['endpoint'] = $this->getQiuniuEndpointByKey($oss_setting['key'] , $oss_setting['bucket']);
+			return $this->deleteS3($file_url , $oss_setting); 
 		}
 		//var_dump($config);
 		// 腾讯云
 		if ($oss_setting && $oss_setting['oss_type'] && $oss_setting['oss_type'] == 'qcloud') {
-			$cosClient = new \Qcloud\Cos\Client(array('region' => $oss_setting['region'],
-			'credentials'=> array(
-					'secretId'    => $oss_setting['secretId'],
-					'secretKey' => $oss_setting['secretKey']
-				)));
-				$ext = strrchr($uploadFile['name'], '.'); //获取扩展名
-				$oss_path = "showdoc_".time().rand().rand().$ext;
-				$result = $cosClient->putObject(array(
-					'Bucket' => $oss_setting['bucket'],
-					'Key' => $oss_path ,
-					'Body' => fopen($uploadFile['tmp_name'], 'rb')));
-				if ($result && $result['ObjectURL']) {
-						if ($oss_setting['domain']) {
-								return $oss_setting['protocol'] . '://'.$oss_setting['domain']."/".$oss_path ;
-						}else{
-								return $result['ObjectURL'] ;
-						}
-						
-				}
+
+			// 腾讯云，一开始让用户填写region而没填写endpoint，所以要自己拼接
+			$oss_setting['endpoint'] = "https://cos.{$oss_setting['region']}.myqcloud.com";
+			// 腾讯云的SecretId相当于s3的key， secretKey相当于s3的secret
+			$oss_setting['key'] = $oss_setting['secretId']  ;
+			$oss_setting['secret'] = $oss_setting['secretKey']  ;
+			return $this->deleteS3($file_url , $oss_setting); 
+
 		}
 
 
 		return false ;
 	}
 
+	// 通过s3协议删除
+	// 注意传进来的oss_setting数组需要先转换成合法格式
+	public function deleteS3($file_url , $oss_setting){
+
+		$array = parse_url($file_url) ;
+		$file = $array['path'] ;  // 得到的是url中的路径，例如/path_.txt
+		$file = substr($file, 1); // 要把路径前的/去掉，才是得到文件名path_.txt
+		// 如果不包含协议头，自己给它补充
+		if(!strstr($oss_setting['endpoint'] , '://')){
+			$oss_setting['endpoint'] = 'https://'.$oss_setting['endpoint'] ;
+		}
+		$s3 = new S3Client([
+			'version' => 'latest',
+			'region'  => 'us-east-1',
+			'endpoint' => $oss_setting['endpoint'] ,
+			'use_virtual_hosted_style_endpoint' => true,
+			'credentials' => [
+					'key'    => $oss_setting['key'],
+					'secret' => $oss_setting['secret'],
+				],
+		]);
+	
+		// Send a PutObject request and get the result object.
+		$resObj = $s3->deleteObject([
+			'Bucket' => $oss_setting['bucket'],
+			'Key'    => $file,
+		]);
+		$res = (array)$resObj ;
+		$resultdata = current($res) ;// 获取数组的第一个值
+		// var_dump( $resultdata) ;exit();
+	}
+
+	// 由于历史原因，当初没有让用户填写七牛云的region。而且即使填写了，也不能直接获取到七牛云s3兼容协议上传的endpoint
+	// 所以，需要自己调接口查询然后拼凑。七牛这个坑货。
+	public function getQiuniuEndpointByKey($key,$bucket){
+
+		$query_url = "https://api.qiniu.com/v2/query?ak={$key}&bucket={$bucket}";
+		$res = http_post($query_url,array());
+
+		$array = json_decode($res,true) ;
+		// var_dump($array);exit();
+		if($array && $array['region'] ){
+			switch ($array['region']) {
+				case 'z0':
+					return 'https://s3-cn-east-1.qiniucs.com';
+					break;
+				case 'z1':
+					return 'https://s3-cn-north-1.qiniucs.com';
+					break;
+				case 'z2':
+					return 'https://s3-cn-south-1.qiniucs.com';
+					break;
+				case 'na0':
+					return 'https://s3-us-north-1.qiniucs.com';
+					break;
+				case 'as0':
+					return 'https://s3-ap-southeast-1.qiniucs.com';
+					break;
+				default:
+					return false;
+					break;
+			}
+
+		}
+
+	}
+
+
+
 }
\ No newline at end of file

--- server/Application/Api/Model/PageModel.class.php ---
@@ -226,6 +226,12 @@ public function runapiToMd($content){
  
  }
 
+    // 如果有query参数组，则把url中的参数去掉
+    $query = $content['request']['query'] ;
+    if ($query && is_array($query) && $query[0] && $query[0]['name']){
+        $words = explode('?',$content['info']['url']);
+        $content['info']['url']  = $words[0] ;
+    }
 
 $new_content .= "
   

--- server/index.php ---
@@ -10,9 +10,9 @@
 
 // cookie安全，给PHPSESSID加上Strict
 if (PHP_VERSION_ID >= 70300) {
-    session_set_cookie_params([
+    session_set_cookie_params(array(
         'samesite' => 'Strict'
-    ]);
+    ));
 } else { 
     session_set_cookie_params(
         NULL,

--- server/vendor/aws/aws-crt-php/.clang-format ---
@@ -0,0 +1,58 @@
+---
+Language:        Cpp
+# BasedOnStyle:  Mozilla
+AlignAfterOpenBracket: AlwaysBreak
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlines: Right
+AlignOperands:   true
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: false
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: Inline
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: false
+BinPackArguments: false
+BinPackParameters: false
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Attach
+BreakBeforeTernaryOperators: true
+BreakStringLiterals: true
+ColumnLimit:     120
+ContinuationIndentWidth: 4
+DerivePointerAlignment: false
+IncludeBlocks:   Preserve
+IndentCaseLabels: true
+IndentPPDirectives: AfterHash
+IndentWidth:     4
+IndentWrappedFunctionNames: true
+KeepEmptyLinesAtTheStartOfBlocks: true
+MacroBlockBegin: ''
+MacroBlockEnd:   ''
+MaxEmptyLinesToKeep: 1
+PenaltyBreakAssignment: 2
+PenaltyBreakBeforeFirstCallParameter: 19
+PenaltyBreakComment: 300
+PenaltyBreakFirstLessLess: 120
+PenaltyBreakString: 1000
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 100000
+PointerAlignment: Right
+ReflowComments:  true
+SortIncludes:    true
+SpaceAfterCStyleCast: false
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeParens: ControlStatements
+SpaceInEmptyParentheses: false
+SpacesInContainerLiterals: true
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+Standard:        Cpp11
+TabWidth:        4
+UseTab:          Never
+...
+

--- server/vendor/aws/aws-crt-php/.clang-format-ignore ---
@@ -0,0 +1,4 @@
+# ignore generated files
+ext/api.h
+ext/*_arginfo.h
+src/api.h

--- server/vendor/aws/aws-crt-php/.github/ISSUE_TEMPLATE/---bug-report.md ---
@@ -0,0 +1,36 @@
+---
+name: "\U0001F41B Bug report"
+about: Create a report to help us improve
+title: ''
+labels: bug, needs-triage
+assignees: ''
+
+---
+
+Confirm by changing [ ] to [x] below to ensure that it's a bug:
+- [ ] I've gone though [Developer Guide](https://docs.aws.amazon.com/sdk-for-cpp/v1/developer-guide/welcome.html) and [API reference](http://sdk.amazonaws.com/cpp/api/LATEST/index.html)
+- [ ] I've searched for [previous similar issues](https://github.com/aws/aws-sdk-cpp/issues) and didn't find any solution
+  
+**Describe the bug**
+A clear and concise description of what the bug is.
+
+**SDK version number**
+
+**Platform/OS/Hardware/Device**
+What are you running the sdk on?
+
+**To Reproduce (observed behavior)**
+Steps to reproduce the behavior (please share code)
+
+**Expected behavior**
+A clear and concise description of what you expected to happen.
+
+**Logs/output**
+If applicable, add logs or error output.
+
+*REMEMBER TO SANITIZE YOUR PERSONAL INFO*
+
+
+
+**Additional context**
+Add any other context about the problem here.

--- server/vendor/aws/aws-crt-php/.github/ISSUE_TEMPLATE/---feature-request.md ---
@@ -0,0 +1,20 @@
+---
+name: "\U0001F680 Feature request"
+about: Suggest an idea for this project
+title: ''
+labels: feature-request, needs-triage
+assignees: ''
+
+---
+
+**Is your feature request related to a problem? Please describe.**
+A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
+
+**Describe the solution you'd like**
+A clear and concise description of what you want to happen.
+
+**Describe alternatives you've considered**
+A clear and concise description of any alternative solutions or features you've considered.
+
+**Additional context**
+Add any other context or screenshots about the feature request here.
\ No newline at end of file

--- server/vendor/aws/aws-crt-php/.github/ISSUE_TEMPLATE/---questions-help.md ---
@@ -0,0 +1,23 @@
+---
+name: "\U0001F4AC Questions / Help"
+about: If you have questions, please check AWS Forums or StackOverflow
+title: ''
+labels: guidance, needs-triage
+assignees: ''
+
+---
+
+Confirm by changing [ ] to [x] below:
+- [ ] I've searched for [previous similar issues](https://github.com/awslabs/aws-crt-php/issues) and didn't find any solution
+
+**Platform/OS/Hardware/Device**
+What are you running the sdk on?
+
+**Describe the question**
+
+
+**Logs/output**
+If applicable, add logs or error output.
+
+*REMEMBER TO SANITIZE YOUR PERSONAL INFO*
+

--- server/vendor/aws/aws-crt-php/.github/PULL_REQUEST_TEMPLATE.md ---
@@ -0,0 +1,6 @@
+*Issue #, if available:*
+
+*Description of changes:*
+
+
+By submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.

--- server/vendor/aws/aws-crt-php/.github/workflows/ci.yml ---
@@ -0,0 +1,145 @@
+name: CI
+
+on:
+  push:
+    branches:
+      - '*'
+      - '!main'
+
+env:
+  BUILDER_VERSION: v0.8.18
+  BUILDER_SOURCE: releases
+  BUILDER_HOST: https://d19elf31gohf1l.cloudfront.net
+  PACKAGE_NAME: aws-crt-php
+  LINUX_BASE_IMAGE: ubuntu-16-x64
+  RUN: ${{ github.run_id }}-${{ github.run_number }}
+
+jobs:
+  php-5_5-linux-x64:
+    name: php-linux-x64 (5.5)
+    runs-on: ubuntu-latest
+    steps:
+    - name: Setup PHP with Xdebug
+      uses: shivammathur/setup-php@v2
+      with:
+        coverage: xdebug
+        php-version: 5.5
+        ini-values: xdebug.overload_var_dump=0, memory_limit=4G, phar.readonly=false
+
+    - name: Checkout
+      uses: actions/checkout@v2
+      with:
+        submodules: recursive
+
+    - name: Install ancient PHPUnit
+      run: composer require --dev --ignore-platform-reqs phpunit/phpunit "4.8.36"
+
+    - name: Install depedencies
+      run: composer update --no-interaction
+
+    - name: Build for PHP 5.5
+      env:
+        CC: clang
+        CXX: clang++
+      run: |
+        phpize
+        ./configure
+        make
+
+  php-linux-x64:
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        version:
+          - "5.6"
+          - "7.0"
+          - "7.1"
+          - "7.2"
+          - "7.3"
+          - "7.4"
+          - "8.0"
+    steps:
+    - name: Setup PHP with Xdebug
+      uses: shivammathur/setup-php@v2
+      with:
+        coverage: xdebug
+        php-version: ${{matrix.version}}
+        ini-values: xdebug.overload_var_dump=0, memory_limit=4G, phar.readonly=false
+
+    - name: Checkout
+      uses: actions/checkout@v2
+      with:
+        submodules: recursive
+
+    - name: Install depedencies
+      run: composer update --no-interaction
+
+    - name: Run tests
+      env:
+        CC: clang
+        CXX: clang++
+      run: |
+        phpize
+        ./configure
+        make
+        make test
+
+
+  #   linux-arm:
+  #     name: ARM (${{ matrix.arch }})
+  #     runs-on: ubuntu-latest
+  #     strategy:
+  #       matrix:
+  #         arch: [armv6, armv7, arm64]
+  #     steps:
+  #     - name: Build ${{ env.PACKAGE_NAME }}
+  #       run: |
+  #         python3 -c "from urllib.request import urlretrieve; urlretrieve('${{ env.BUILDER_HOST }}/${{ env.BUILDER_SOURCE }}/${{ env.BUILDER_VERSION }}/builder.pyz?run=${{ env.RUN }}', 'builder')"
+  #         chmod a+x builder
+  #         ./builder build -p ${{ env.PACKAGE_NAME }} --target=linux-${{ matrix.arch }} --spec=downstream
+
+  # windows-vc16:
+  #   runs-on: windows-latest
+  #   strategy:
+  #     matrix:
+  #       arch: [x64]
+  #   steps:
+  #   - uses: ilammy/msvc-dev-cmd@v1
+  #     with:
+  #       arch: ${{ matrix.arch }}
+  #       uwp: false
+  #       spectre: true
+  #   - name: Build ${{ env.PACKAGE_NAME }} + consumers
+  #     run: |
+  #       python -c "from urllib.request import urlretrieve; urlretrieve('${{ env.BUILDER_HOST }}/${{ env.BUILDER_SOURCE }}/${{ env.BUILDER_VERSION }}/builder.pyz?run=${{ env.RUN }}', 'builder.pyz')"
+  #       python builder.pyz build -p ${{ env.PACKAGE_NAME }} --spec=downstream
+
+  # windows-vc14:
+  #   runs-on: windows-latest
+  #   strategy:
+  #     matrix:
+  #       arch: [x86, x64]
+  #   steps:
+  #   - uses: ilammy/msvc-dev-cmd@v1
+  #     with:
+  #       toolset: 14.0
+  #       arch: ${{ matrix.arch }}
+  #       uwp: false
+  #       spectre: true
+  #   - name: Build ${{ env.PACKAGE_NAME }} + consumers
+  #     run: |
+  #       python -c "from urllib.request import urlretrieve; urlretrieve('${{ env.BUILDER_HOST }}/${{ env.BUILDER_SOURCE }}/${{ env.BUILDER_VERSION }}/builder.pyz?run=${{ env.RUN }}', 'builder.pyz')"
+  #       python builder.pyz build -p ${{ env.PACKAGE_NAME }} downstream
+
+  macos:
+    runs-on: macos-${{ matrix.version }}
+    strategy:
+      matrix:
+        version: [10.15]
+    steps:
+      - name: Build PHP 8 extension and test
+        run: |
+          python3 -c "from urllib.request import urlretrieve; urlretrieve('${{ env.BUILDER_HOST }}/${{ env.BUILDER_SOURCE }}/${{ env.BUILDER_VERSION }}/builder.pyz?run=${{ env.RUN }}', 'builder')"
+          chmod a+x builder
+          ./builder build -p ${{ env.PACKAGE_NAME }} --spec=downstream

--- server/vendor/aws/aws-crt-php/.github/workflows/lint.yml ---
@@ -0,0 +1,29 @@
+name: Lint
+
+on: [push]
+
+jobs:
+  clang-format:
+
+    runs-on: ubuntu-latest
+
+    steps:
+    - name: Checkout Sources
+      uses: actions/checkout@v1
+
+    - name: clang-format lint
+      uses: DoozyX/clang-format-lint-action@v0.3.1
+      with:
+        # List of extensions to check
+        extensions: c
+
+  check-submodules:
+    runs-on: ubuntu-latest
+    steps:
+    - name: Checkout Source
+      uses: actions/checkout@v2
+      with:
+        submodules: true
+        fetch-depth: 0
+    - name: Check Submodules
+      uses: awslabs/aws-crt-builder/.github/actions/check-submodules@main

--- server/vendor/aws/aws-crt-php/.github/workflows/stale_issue.yml ---
@@ -0,0 +1,46 @@
+name: "Close stale issues"
+
+# Controls when the action will run.
+on:
+  schedule:
+    - cron: "0 0 * * *"
+
+jobs:
+  cleanup:
+    runs-on: ubuntu-latest
+    name: Stale issue job
+    steps:
+    - uses: aws-actions/stale-issue-cleanup@v3
+      with:
+        # Setting messages to an empty string will cause the automation to skip
+        # that category
+        ancient-issue-message: Greetings! Sorry to say but this is a very old issue that is probably not getting as much attention as it deservers. We encourage you to check if this is still an issue in the latest release and if you find that this is still a problem, please feel free to open a new one.
+        stale-issue-message: Greetings! It looks like this issue hasn’t been active in longer than a week. We encourage you to check if this is still an issue in the latest release. Because it has been longer than a week since the last update on this, and in the absence of more information, we will be closing this issue soon. If you find that this is still a problem, please feel free to provide a comment or add an upvote to prevent automatic closure, or if the issue is already closed, please feel free to open a new one.
+        stale-pr-message: Greetings! It looks like this PR hasn’t been active in longer than a week, add a comment or an upvote to prevent automatic closure, or if the issue is already closed, please feel free to open a new one.
+
+        # These labels are required
+        stale-issue-label: closing-soon
+        exempt-issue-label: automation-exempt
+        stale-pr-label: closing-soon
+        exempt-pr-label: pr/needs-review
+        response-requested-label: response-requested
+
+        # Don't set closed-for-staleness label to skip closing very old issues
+        # regardless of label
+        closed-for-staleness-label: closed-for-staleness
+
+        # Issue timing
+        days-before-stale: 7
+        days-before-close: 4
+        days-before-ancient: 365
+
+        # If you don't want to mark a issue as being ancient based on a
+        # threshold of "upvotes", you can set this here. An "upvote" is
+        # the total number of +1, heart, hooray, and rocket reactions
+        # on an issue.
+        minimum-upvotes-to-exempt: 1
+
+        repo-token: ${{ secrets.GITHUB_TOKEN }}
+        loglevel: DEBUG
+        # Set dry-run to true to not perform label or close actions.
+        dry-run: false

--- server/vendor/aws/aws-crt-php/.gitignore ---
@@ -0,0 +1,210 @@
+
+# Created by https://www.toptal.com/developers/gitignore/api/autotools,cmake,phpstorm
+# Edit at https://www.toptal.com/developers/gitignore?templates=autotools,cmake,phpstorm
+
+### Autotools ###
+# http://www.gnu.org/software/automake
+
+Makefile.in
+/ar-lib
+/mdate-sh
+/py-compile
+/test-driver
+/ylwrap
+.deps/
+
+# http://www.gnu.org/software/autoconf
+
+autom4te.cache
+/autoscan.log
+/autoscan-*.log
+/aclocal.m4
+/compile
+/config.guess
+/config.h.in
+/config.log
+/config.status
+/config.sub
+/configure
+/configure.scan
+/depcomp
+/install-sh
+/missing
+/stamp-h1
+
+# https://www.gnu.org/software/libtool/
+
+/ltmain.sh
+
+# http://www.gnu.org/software/texinfo
+
+/texinfo.tex
+
+# http://www.gnu.org/software/m4/
+
+m4/libtool.m4
+m4/ltoptions.m4
+m4/ltsugar.m4
+m4/ltversion.m4
+m4/lt~obsolete.m4
+
+# Generated Makefile
+# (meta build system like autotools,
+# can automatically generate from config.status script
+# (which is called by configure script))
+Makefile
+
+### Autotools Patch ###
+
+### CMake ###
+CMakeLists.txt.user
+CMakeCache.txt
+CMakeFiles
+CMakeScripts
+Testing
+cmake_install.cmake
+install_manifest.txt
+compile_commands.json
+CTestTestfile.cmake
+_deps
+
+### CMake Patch ###
+# External projects
+*-prefix/
+
+### PhpStorm ###
+# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider
+# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839
+
+# User-specific stuff
+.idea/**/workspace.xml
+.idea/**/tasks.xml
+.idea/**/usage.statistics.xml
+.idea/**/dictionaries
+.idea/**/shelf
+.idea/
+# Generated files
+.idea/**/contentModel.xml
+
+# Sensitive or high-churn files
+.idea/**/dataSources/
+.idea/**/dataSources.ids
+.idea/**/dataSources.local.xml
+.idea/**/sqlDataSources.xml
+.idea/**/dynamic.xml
+.idea/**/uiDesigner.xml
+.idea/**/dbnavigator.xml
+
+# Gradle
+.idea/**/gradle.xml
+.idea/**/libraries
+
+# Gradle and Maven with auto-import
+# When using Gradle or Maven with auto-import, you should exclude module files,
+# since they will be recreated, and may cause churn.  Uncomment if using
+# auto-import.
+# .idea/artifacts
+# .idea/compiler.xml
+# .idea/jarRepositories.xml
+# .idea/modules.xml
+# .idea/*.iml
+# .idea/modules
+# *.iml
+# *.ipr
+
+# CMake
+cmake-build-*/
+
+# Mongo Explorer plugin
+.idea/**/mongoSettings.xml
+
+# File-based project format
+*.iws
+
+# IntelliJ
+out/
+
+# mpeltonen/sbt-idea plugin
+.idea_modules/
+
+# JIRA plugin
+atlassian-ide-plugin.xml
+
+# Cursive Clojure plugin
+.idea/replstate.xml
+
+# Crashlytics plugin (for Android Studio and IntelliJ)
+com_crashlytics_export_strings.xml
+crashlytics.properties
+crashlytics-build.properties
+fabric.properties
+
+# Editor-based Rest Client
+.idea/httpRequests
+
+# Android studio 3.1+ serialized cache file
+.idea/caches/build_file_checksums.ser
+
+### PhpStorm Patch ###
+# Comment Reason: https://github.com/joeblau/gitignore.io/issues/186#issuecomment-215987721
+
+# *.iml
+# modules.xml
+# .idea/misc.xml
+# *.ipr
+
+# Sonarlint plugin
+# https://plugins.jetbrains.com/plugin/7973-sonarlint
+.idea/**/sonarlint/
+
+# SonarQube Plugin
+# https://plugins.jetbrains.com/plugin/7238-sonarqube-community-plugin
+.idea/**/sonarIssues.xml
+
+# Markdown Navigator plugin
+# https://plugins.jetbrains.com/plugin/7896-markdown-navigator-enhanced
+.idea/**/markdown-navigator.xml
+.idea/**/markdown-navigator-enh.xml
+.idea/**/markdown-navigator/
+
+# Cache file creation bug
+# See https://youtrack.jetbrains.com/issue/JBR-2257
+.idea/$CACHE_FILE$
+
+# CodeStream plugin
+# https://plugins.jetbrains.com/plugin/12206-codestream
+.idea/codestream.xml
+
+# End of https://www.toptal.com/developers/gitignore/api/autotools,cmake,phpstorm
+
+.deps
+.libs/
+build/
+configure.in
+configure.ac
+mkinstalldirs
+run-tests.php
+Makefile.global
+acinclude.m4
+libtool
+modules/
+*.lo
+config.h
+config.nice
+*.la
+Makefile*
+!Makefile.am
+!Makefile.frag
+!Makefile.frag.w32
+/vendor/
+.idea/
+.DS_Store
+composer.lock
+PHP-Parser*/
+src/*.so
+src/*.dylib
+src/*.dll
+
+# ignoring output of package.xml as it needs to be generated from ./prepare_release.sh in each publishing
+package.xml
+*.tgz

--- server/vendor/aws/aws-crt-php/.gitmodules ---
@@ -0,0 +1,3 @@
+[submodule "crt/aws-crt-ffi"]
+	path = crt/aws-crt-ffi
+	url = https://github.com/awslabs/aws-crt-ffi.git

--- server/vendor/aws/aws-crt-php/CODE_OF_CONDUCT.md ---
@@ -0,0 +1,4 @@
+## Code of Conduct
+This project has adopted the [Amazon Open Source Code of Conduct](https://aws.github.io/code-of-conduct).
+For more information see the [Code of Conduct FAQ](https://aws.github.io/code-of-conduct-faq) or contact
+opensource-codeofconduct@amazon.com with any additional questions or comments.

--- server/vendor/aws/aws-crt-php/CONTRIBUTING.md ---
@@ -0,0 +1,61 @@
+# Contributing Guidelines
+
+Thank you for your interest in contributing to our project. Whether it's a bug report, new feature, correction, or additional
+documentation, we greatly value feedback and contributions from our community.
+
+Please read through this document before submitting any issues or pull requests to ensure we have all the necessary
+information to effectively respond to your bug report or contribution.
+
+
+## Reporting Bugs/Feature Requests
+
+We welcome you to use the GitHub issue tracker to report bugs or suggest features.
+
+When filing an issue, please check existing open, or recently closed, issues to make sure somebody else hasn't already
+reported the issue. Please try to include as much information as you can. Details like these are incredibly useful:
+
+* A reproducible test case or series of steps
+* The version of our code being used
+* Any modifications you've made relevant to the bug
+* Anything unusual about your environment or deployment
+
+
+## Contributing via Pull Requests
+Contributions via pull requests are much appreciated. Before sending us a pull request, please ensure that:
+
+1. You are working against the latest source on the *master* branch.
+2. You check existing open, and recently merged, pull requests to make sure someone else hasn't addressed the problem already.
+3. You open an issue to discuss any significant work - we would hate for your time to be wasted.
+
+To send us a pull request, please:
+
+1. Fork the repository.
+2. Modify the source; please focus on the specific change you are contributing. If you also reformat all the code, it will be hard for us to focus on your change.
+3. Ensure local tests pass.
+4. Commit to your fork using clear commit messages.
+5. Send us a pull request, answering any default questions in the pull request interface.
+6. Pay attention to any automated CI failures reported in the pull request, and stay involved in the conversation.
+
+GitHub provides additional document on [forking a repository](https://help.github.com/articles/fork-a-repo/) and
+[creating a pull request](https://help.github.com/articles/creating-a-pull-request/).
+
+
+## Finding contributions to work on
+Looking at the existing issues is a great way to find something to contribute on. As our projects, by default, use the default GitHub issue labels (enhancement/bug/duplicate/help wanted/invalid/question/wontfix), looking at any 'help wanted' issues is a great place to start.
+
+
+## Code of Conduct
+This project has adopted the [Amazon Open Source Code of Conduct](https://aws.github.io/code-of-conduct).
+For more information see the [Code of Conduct FAQ](https://aws.github.io/code-of-conduct-faq) or contact
+opensource-codeofconduct@amazon.com with any additional questions or comments.
+
+
+## Security issue notifications
+If you discover a potential security issue in this project we ask that you notify AWS/Amazon Security via our [vulnerability reporting page](http://aws.amazon.com/security/vulnerability-reporting/). Please do **not** create a public github issue.
+
+
+## Licensing
+
+See the [LICENSE](LICENSE) file for our project's licensing. We will ask you to confirm the licensing of your contribution.
+
+We may ask you to sign a [Contributor License Agreement (CLA)](http://en.wikipedia.org/wiki/Contributor_License_Agreement) for larger changes.

--- server/vendor/aws/aws-crt-php/LICENSE ---
@@ -0,0 +1,175 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.

--- server/vendor/aws/aws-crt-php/Makefile.frag ---
@@ -0,0 +1,72 @@
+
+INT_DIR=build/install
+GENERATE_STUBS=$(shell expr `php --version | head -1 | cut -f 2 -d' '` \>= 7.1)
+
+CMAKE = cmake3
+ifeq (, $(shell which cmake3))
+	CMAKE = cmake
+endif
+
+# default to using system OpenSSL, if disabled aws-lc will be used
+USE_OPENSSL ?= ON
+ifneq (OFF,$(USE_OPENSSL))
+	CMAKE_USE_OPENSSL=-DUSE_OPENSSL=ON
+	# if a path was provided, add it to CMAKE_PREFIX_PATH
+	ifneq (ON,$(USE_OPENSSL))
+    	CMAKE_PREFIX_PATH=-DCMAKE_PREFIX_PATH=$(USE_OPENSSL)
+	endif
+endif
+
+CMAKE_CONFIGURE = $(CMAKE) \
+    -DCMAKE_INSTALL_PREFIX=$(INT_DIR) \
+    -DBUILD_TESTING=OFF \
+    -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE) \
+    $(CMAKE_USE_OPENSSL) \
+    $(CMAKE_PREFIX_PATH)
+CMAKE_BUILD = CMAKE_BUILD_PARALLEL_LEVEL='' $(CMAKE) --build
+CMAKE_BUILD_TYPE ?= RelWithDebInfo
+CMAKE_TARGET = --config $(CMAKE_BUILD_TYPE) --target install
+
+all: extension 
+.PHONY: all extension 
+
+# configure for static aws-crt-ffi.a
+build/aws-crt-ffi-static/CMakeCache.txt:
+	$(CMAKE_CONFIGURE) -Hcrt/aws-crt-ffi -Bbuild/aws-crt-ffi-static -DBUILD_SHARED_LIBS=OFF
+
+# build static libaws-crt-ffi.a
+build/aws-crt-ffi-static/libaws-crt-ffi.a: build/aws-crt-ffi-static/CMakeCache.txt
+	$(CMAKE_BUILD) build/aws-crt-ffi-static $(CMAKE_TARGET)
+
+# PHP extension target
+extension: ext/awscrt.lo
+
+# Force the crt object target to depend on the CRT static library
+ext/awscrt.lo: ext/awscrt.c
+
+ext/awscrt.c: build/aws-crt-ffi-static/libaws-crt-ffi.a ext/api.h ext/awscrt_arginfo.h
+
+ext/awscrt_arginfo.h: ext/awscrt.stub.php gen_stub.php
+ifeq ($(GENERATE_STUBS),1)
+	# generate awscrt_arginfo.h
+	php gen_stub.php --minimal-arginfo ext/awscrt.stub.php
+endif
+
+# transform/install api.h from FFI lib
+src/api.h: crt/aws-crt-ffi/src/api.h
+	php gen_api.php crt/aws-crt-ffi/src/api.h > src/api.h
+
+# install api.h to ext/ as well
+ext/api.h : src/api.h
+	cp -v src/api.h ext/api.h
+
+ext/php_aws_crt.h: ext/awscrt_arginfo.h ext/api.h
+
+vendor/bin/phpunit:
+	composer update
+
+test-extension: vendor/bin/phpunit extension
+	composer run test-extension
+
+# Use PHPUnit to run tests
+test: test-extension

--- server/vendor/aws/aws-crt-php/Makefile.frag.w32 ---
@@ -0,0 +1,35 @@
+
+CMAKE=cmake.exe
+COMPOSER_PHAR=C:\ProgramData\ComposerSetup\bin\composer.phar
+PHP_BINARY=$(PHP_PREFIX)\php.exe
+
+CMAKE_CONFIGURE = $(CMAKE) -DCMAKE_INSTALL_PREFIX=$(AWSCRT_DIR)\build\install -DCMAKE_PREFIX_PATH=$(AWSCRT_DIR)\build\install -DBUILD_TESTING=OFF -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE)
+CMAKE_BUILD = $(CMAKE) --build
+CMAKE_BUILD_TYPE = Release
+CMAKE_TARGET = --config $(CMAKE_BUILD_TYPE) --target install
+
+# configure for static aws-crt-ffi.lib
+$(AWSCRT_DIR)\build\CMakeCache.txt:
+	$(CMAKE_CONFIGURE) -H$(AWSCRT_DIR)\crt\aws-crt-ffi -B$(AWSCRT_DIR)\build -DBUILD_SHARED_LIBS=OFF
+
+# build static libaws-crt-ffi.lib
+$(AWSCRT_DIR)\build\libaws-crt-ffi.lib: $(AWSCRT_DIR)\build\CMakeCache.txt
+	$(CMAKE_BUILD) $(AWSCRT_DIR)\build $(CMAKE_TARGET)
+
+# Force the awscrt extension DLL target to depend on the extension src
+$(BUILD_DIR)\php_awscrt.dll: $(AWSCRT_DIR)\ext\awscrt.c
+
+$(AWSCRT_DIR)\ext\awscrt.c: $(AWSCRT_DIR)\build\libaws-crt-ffi.lib $(AWSCRT_DIR)\ext\api.h $(AWSCRT_DIR)\ext\awscrt_arginfo.h
+
+# transform\install api.h from FFI lib
+$(AWSCRT_DIR)\src\api.h: $(AWSCRT_DIR)\crt\aws-crt-ffi\src\api.h
+	php $(AWSCRT_DIR)\gen_api.php $(AWSCRT_DIR)\crt\aws-crt-ffi\src\api.h > $(AWSCRT_DIR)\src\api.h
+
+# install api.h to ext/ as well
+$(AWSCRT_DIR)\ext\api.h : $(AWSCRT_DIR)\src\api.h
+	copy $(AWSCRT_DIR)\src\api.h $(AWSCRT_DIR)\ext\api.h
+
+# Use PHPUnit to run tests
+test-awscrt: install $(AWSCRT_DIR)\src\api.h $(BUILD_DIR)\php_awscrt.dll
+	$(PHP_BINARY) -c $(AWSCRT_DIR)\php-win.ini $(COMPOSER_PHAR) --working-dir=$(AWSCRT_DIR) update
+	$(PHP_BINARY) -c $(AWSCRT_DIR)\php-win.ini $(COMPOSER_PHAR) --working-dir=$(AWSCRT_DIR) run test-win

--- server/vendor/aws/aws-crt-php/NOTICE ---
@@ -0,0 +1 @@
+Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

--- server/vendor/aws/aws-crt-php/README.md ---
@@ -0,0 +1,80 @@
+# AWS Common Runtime PHP bindings
+
+## Requirements
+* PHP 5.5+ on UNIX platforms, 7.2+ on Windows
+* CMake 3.x
+* GCC 4.4+, clang 3.8+ on UNIX, Visual Studio 2017 build tools on Windows
+* Tests require [Composer](https://getcomposer.org)
+
+## Building on UNIX
+```sh
+$ git clone --recursive https://github.com/awslabs/aws-crt-php.git
+$ cd aws-crt-php
+$ phpize
+$ ./configure
+$ make && make test
+```
+
+## Building on Windows
+* First, ensure that you are able to build PHP on windows via the PHP SDK (this example assumes installation of the SDK to C:\php-sdk and that you've checked out the PHP source to php-src within the build directory). The following resources are helpful to get PHP building on windows:
+    * https://github.com/microsoft/php-sdk-binary-tools
+    * https://medium.com/@erinus/how-to-build-php-on-windows-a7ad0a87862a
+    * https://medium.com/@erinus/how-to-build-php-extension-on-windows-d1667290f809
+
+```bat
+""" From VS2017 Command Prompt
+> C:\php-sdk\phpsdk-vc15-x64.bat
+
+C:\php-sdk\
+$ phpsdk_buildtree php-<version>
+
+C:\php-sdk\php-<version>\vc15\x64\
+$ git clone https://github.com/php/php-src.git && cd php-src
+
+""" This only has to be done once, the first time you set this all up
+C:\php-sdk\php-<version>\vc15\x64\php-src
+$ phpsdk_deps --update --branch <php-major.minor-version>
+
+C:\php-sdk\php-<version>\vc15\x64\php-src
+$ git clone --recursive https://github.com/awslabs/aws-crt-php.git ..\pecl\awscrt
+
+C:\php-sdk\php-<version>\vc15\x64\php-src
+$ buildconf
+
+C:\php-sdk\php-<version>\vc15\x64\php-src
+$ configure --enable-cli --with-openssl --enable-awscrt=shared
+
+C:\php-sdk\php-<version>\vc15\x64\php-src
+$ nmake
+
+C:\php-sdk\php-<version>\vc15\x64\php-src
+$ nmake test-awscrt
+```
+
+## Debugging
+Using [PHPBrew](https://github.com/phpbrew/phpbrew) to build/manage multiple versions of PHP is helpful.
+
+Note: You must use a debug build of PHP to debug native extensions. 
+See the [PHP Internals Book](https://www.phpinternalsbook.com/php7/build_system/building_php.html) for more info
+
+```shell
+# PHP 8 example
+$ phpbrew install --stdout -j 8 8.0 +default -- CFLAGS=-Wno-error --disable-cgi --enable-debug
+# PHP 5.5 example
+$ phpbrew install --stdout -j 8 5.5 +default -openssl -mbstring -- CFLAGS="-w -Wno-error" --enable-debug --with-zlib=/usr/local/opt/zlib
+$ phpbrew switch php-8.0.6 # or whatever version is current, it'll be at the end of the build output
+$ phpize
+$ ./configure
+$ make CMAKE_BUILD_TYPE=Debug
+```
+
+Ensure that the php you launch from your debugger is the result of `which php`, not just
+the system default php.
+
+## Security
+
+See [CONTRIBUTING](CONTRIBUTING.md#security-issue-notifications) for more information.
+
+## License
+
+This project is licensed under the Apache-2.0 License.

--- server/vendor/aws/aws-crt-php/builder.json ---
@@ -0,0 +1,37 @@
+{
+    "name": "aws-crt-php",
+    "hosts": {
+        "ubuntu": {
+            "pkg_setup": [
+                "add-apt-repository -y ppa:ondrej/php"
+            ],
+            "packages": [
+                "autotools-dev",
+                "autoconf",
+                "libtool",
+                "clang",
+                "php5.6-dev"
+            ]
+        },
+        "al2": {
+            "packages": [
+                "autoconf",
+                "automake",
+                "libtool",
+                "clang",
+                "php-devel"
+            ]
+        }
+    },
+    "build_steps": [
+        ["phpize"],
+        ["./configure"],
+        ["make"]
+    ],
+    "test_env": {
+        "NO_INTERACTION": "1"
+    },
+    "test_steps": [
+        ["./run_tests"]
+    ]
+}

--- server/vendor/aws/aws-crt-php/composer.json ---
@@ -0,0 +1,34 @@
+{
+    "name": "aws/aws-crt-php",
+    "homepage": "http://aws.amazon.com/sdkforphp",
+    "description": "AWS Common Runtime for PHP",
+    "keywords": ["aws","amazon","sdk","crt"],
+    "type": "library",
+    "authors": [
+        {
+            "name": "AWS SDK Common Runtime Team",
+            "email": "aws-sdk-common-runtime@amazon.com"
+        }
+    ],
+    "config": {
+        "platform": {"php": "5.6"}
+    },
+    "minimum-stability": "alpha",
+    "require": {
+        "php": ">=5.5"
+    },
+    "require-dev": {
+        "phpunit/phpunit":"^4.8.35|^5.4.3"
+    },
+    "autoload": {
+        "classmap": [
+            "src/"
+        ]
+    },
+    "scripts": {
+        "test": "./run_tests",
+        "test-extension": "@test",
+        "test-win": "run_tests"
+    },
+    "license": "Apache-2.0"
+}

--- server/vendor/aws/aws-crt-php/config.m4 ---
@@ -0,0 +1,30 @@
+dnl
+dnl * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+dnl * SPDX-License-Identifier: Apache-2.0.
+dnl
+
+PHP_ARG_WITH(awscrt, for AWS Common Runtime support,
+    [  --with-awscrt         Include awscrt support])
+
+if test "$PHP_AWSCRT" != "no"; then
+    # force lib paths to be absolute, or PHP will mangle them
+    cwd=`pwd`
+    # Enable s2n and libcrypto for non-darwin UNIX
+    if uname -a | grep -i darwin > /dev/null 2>&1; then
+        platform_tls_libs=""
+    else
+        platform_tls_libs="-ls2n -lcrypto"
+    fi
+    CRT_LIBPATHS="-L${cwd}/build/install/lib -L${cwd}/build/install/lib64"
+    CRT_LIBS="-laws-crt-ffi -laws-c-auth -laws-c-http -laws-c-io -laws-c-cal -laws-c-compression -laws-checksums -laws-c-common ${platform_tls_libs}"
+    PHP_ADD_INCLUDE(${cwd}/build/install/include)
+    PHP_EVAL_LIBLINE([$CRT_LIBPATHS $CRT_LIBS], AWSCRT_SHARED_LIBADD)
+
+    # Shoves the linker line into the Makefile
+    PHP_SUBST(AWSCRT_SHARED_LIBADD)
+
+    # Sources for the PHP extension itself
+    AWSCRT_SOURCES=ext/awscrt.c
+    PHP_NEW_EXTENSION(awscrt, $AWSCRT_SOURCES, $ext_shared)
+    PHP_ADD_MAKEFILE_FRAGMENT
+fi

--- server/vendor/aws/aws-crt-php/config.w32 ---
@@ -0,0 +1,13 @@
+// vim:ft=javascript
+
+ARG_ENABLE("awscrt", "Include AWS Common Runtime support", "yes");
+
+if (PHP_AWSCRT != "no") {
+    ADD_MAKEFILE_FRAGMENT();
+    DEFINE('CFLAGS_AWSCRT', '/I ' + configure_module_dirname + '\\build\\install\\include');
+    DEFINE('LIBS_AWSCRT', '/LIBPATH:' + configure_module_dirname + '\\build\\install\\lib ' + 
+        'aws-crt-ffi.lib aws-c-auth.lib aws-c-http.lib aws-c-io.lib aws-c-cal.lib aws-c-compression.lib aws-c-common.lib ' +
+        'ncrypt.lib Secur32.lib Crypt32.lib Shlwapi.lib');
+    DEFINE('AWSCRT_DIR', configure_module_dirname);
+    EXTENSION("awscrt", "ext\\awscrt.c", PHP_AWSCRT_SHARED);
+}

--- server/vendor/aws/aws-crt-php/ext/.gitignore ---
@@ -0,0 +1,2 @@
+*.so
+api.h

--- server/vendor/aws/aws-crt-php/ext/awscrt.c ---
@@ -0,0 +1,17 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+/* This is a unity-build style source file, as PHP's build system is simplest with 1 source file per extension */
+
+#include "credentials.c"
+#include "crt.c"
+#include "event_loop.c"
+#include "http.c"
+#include "signing.c"
+#include "stream.c"
+// #include "hash.c"
+#include "crc.c"
+#include "logging.c"
+#include "php_util.c"

--- server/vendor/aws/aws-crt-php/ext/awscrt.stub.php ---
@@ -0,0 +1,88 @@
+<?php
+
+/**
+ * @generate-class-entries
+ * @generate-function-entries
+*/
+
+function aws_crt_last_error(): int {}
+function aws_crt_error_name(int $error_code): string {}
+function aws_crt_error_str(int $error_code): string {}
+function aws_crt_error_debug_str(int $error_code): string {}
+
+function aws_crt_log_to_stdout(): void {}
+function aws_crt_log_to_stderr(): void {}
+function aws_crt_log_to_file(string $filename): void {}
+function aws_crt_log_to_stream(object $stream): void {}
+function aws_crt_log_stop(): void {}
+function aws_crt_log_set_level(int $level): void {}
+function aws_crt_log_message(string $message): void {}
+
+function aws_crt_event_loop_group_options_new(): int {}
+function aws_crt_event_loop_group_options_release(int $elg_options): void {}
+function aws_crt_event_loop_group_options_set_max_threads(int $elg_options, int $max_threads): void {}
+function aws_crt_event_loop_group_new(object $options): object {}
+function aws_crt_event_loop_group_release(object $event_loop_group): void {}
+
+function aws_crt_input_stream_options_new(): object {}
+function aws_crt_input_stream_options_release(object $options): void {}
+function aws_crt_input_stream_options_set_user_data(object $options, object $user_data): void {}
+function aws_crt_input_stream_new(object $options): object {}
+function aws_crt_input_stream_release(int $stream): void {}
+function aws_crt_input_stream_seek(int $stream, int $offset, int $basis): int {}
+function aws_crt_input_stream_read(int $stream, int $length): string {}
+function aws_crt_input_stream_eof(int $stream): bool {}
+function aws_crt_input_stream_get_length(int $stream): int {}
+
+function aws_crt_http_message_new_from_blob(string $blob): int {}
+function aws_crt_http_message_to_blob(int $message): string {}
+function aws_crt_http_message_release(int $message): void {}
+
+function aws_crt_credentials_options_new(): object {}
+function aws_crt_credentials_options_release(object $options): void {}
+function aws_crt_credentials_options_set_access_key_id(object $options, string $access_key_id): void {}
+function aws_crt_credentials_options_set_secret_access_key(object $options, string $secret_access_key): void {}
+function aws_crt_credentials_options_set_session_token(object $options, string $session_token): void {}
+function aws_crt_credentials_options_set_expiration_timepoint_seconds(object $options, int $expiration_timepoint_seconds): void {}
+
+function aws_crt_credentials_new(object $options): object {}
+function aws_crt_credentials_release(object $credentials): void {}
+
+function aws_crt_credentials_provider_release(int $credentials): void {}
+
+function aws_crt_credentials_provider_static_options_new(): object {}
+function aws_crt_credentials_provider_static_options_release(object $options): void {}
+function aws_crt_credentials_provider_static_options_set_access_key_id(object $options, string $access_key_id): void {}
+function aws_crt_credentials_provider_static_options_set_secret_access_key(object $options, string $secret_access_key): void {}
+function aws_crt_credentials_provider_static_options_set_session_token(object $options, string $session_token): void {}
+function aws_crt_credentials_provider_static_new(object $options): object {}
+
+function aws_crt_signing_config_aws_new(): int {}
+function aws_crt_signing_config_aws_release(int $config): void {}
+function aws_crt_signing_config_aws_set_algorithm(int $config, int $algorithm): void {}
+function aws_crt_signing_config_aws_set_signature_type(int $config, int $signature_type): void {}
+function aws_crt_signing_config_aws_set_credentials_provider(int $config, int $credentials_provider): void {}
+function aws_crt_signing_config_aws_set_region(int $config, string $region): void {}
+function aws_crt_signing_config_aws_set_service(int $config, string $service): void {}
+function aws_crt_signing_config_aws_set_use_double_uri_encode(int $config, bool $use_double_uri_encode): void {}
+function aws_crt_signing_config_aws_set_should_normalize_uri_path(int $config, bool $should_normalize_uri_path): void {}
+function aws_crt_signing_config_aws_set_omit_session_token(int $config, bool $omit_session_token): void {}
+function aws_crt_signing_config_aws_set_signed_body_value(int $config, string $signed_body_value): void {}
+function aws_crt_signing_config_aws_set_signed_body_header_type(int $config, int $signed_body_header_type): void {}
+function aws_crt_signing_config_aws_set_expiration_in_seconds(int $config, int $expiration_in_seconds): void {}
+function aws_crt_signing_config_aws_set_date(int $config, int $timestamp): void {}
+function aws_crt_signing_config_aws_set_should_sign_header_fn(int $config, object $should_sign_header): void {}
+
+function aws_crt_signable_new_from_http_request(int $http_message): int {}
+function aws_crt_signable_new_from_chunk(int $input_stream, string $previous_signature): int {}
+function aws_crt_signable_new_from_canonical_request(string $request): int {}
+function aws_crt_signable_release(int $signable): void {}
+
+function aws_crt_signing_result_release(int $signing_result): void {}
+function aws_crt_signing_result_apply_to_http_request(object $signing_result, object $http_request): void {}
+
+function aws_crt_sign_request_aws(int $signable, int $signing_config, object $on_complete, object $user_data): int {}
+function aws_crt_test_verify_sigv4a_signing(int $signable, int $signing_config, string $expected_canonical_request, string $signature, string $ecc_key_pub_x, string $ecc_key_pub_y): bool {}
+
+function aws_crt_crc32(string $input, int $prev): int {}
+function aws_crt_crc32c(string $input, int $prev): int {}

--- server/vendor/aws/aws-crt-php/ext/awscrt_arginfo.h ---
@@ -0,0 +1,413 @@
+/* This is a generated file, edit the .stub.php file instead.
+ * Stub hash: 344f9d59b85697b80bb6808ac7d5eb7c1d07c03f */
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_last_error, 0, 0, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_error_name, 0, 0, 1)
+	ZEND_ARG_INFO(0, error_code)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_error_str arginfo_aws_crt_error_name
+
+#define arginfo_aws_crt_error_debug_str arginfo_aws_crt_error_name
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_log_to_stdout, 0, 0, 0)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_log_to_stderr arginfo_aws_crt_log_to_stdout
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_log_to_file, 0, 0, 1)
+	ZEND_ARG_INFO(0, filename)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_log_to_stream, 0, 0, 1)
+	ZEND_ARG_INFO(0, stream)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_log_stop arginfo_aws_crt_log_to_stdout
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_log_set_level, 0, 0, 1)
+	ZEND_ARG_INFO(0, level)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_log_message, 0, 0, 1)
+	ZEND_ARG_INFO(0, message)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_event_loop_group_options_new arginfo_aws_crt_last_error
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_event_loop_group_options_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, elg_options)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_event_loop_group_options_set_max_threads, 0, 0, 2)
+	ZEND_ARG_INFO(0, elg_options)
+	ZEND_ARG_INFO(0, max_threads)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_event_loop_group_new, 0, 0, 1)
+	ZEND_ARG_INFO(0, options)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_event_loop_group_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, event_loop_group)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_options_new, 0, 0, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_options_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, options)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_options_set_user_data, 0, 0, 2)
+	ZEND_ARG_INFO(0, options)
+	ZEND_ARG_INFO(0, user_data)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_input_stream_new arginfo_aws_crt_event_loop_group_new
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, stream)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_seek, 0, 0, 3)
+	ZEND_ARG_INFO(0, stream)
+	ZEND_ARG_INFO(0, offset)
+	ZEND_ARG_INFO(0, basis)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_read, 0, 0, 2)
+	ZEND_ARG_INFO(0, stream)
+	ZEND_ARG_INFO(0, length)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_eof, 0, 0, 1)
+	ZEND_ARG_INFO(0, stream)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_input_stream_get_length, 0, 0, 1)
+	ZEND_ARG_INFO(0, stream)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_http_message_new_from_blob, 0, 0, 1)
+	ZEND_ARG_INFO(0, blob)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_http_message_to_blob, 0, 0, 1)
+	ZEND_ARG_INFO(0, message)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_http_message_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, message)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_credentials_options_new arginfo_aws_crt_input_stream_options_new
+
+#define arginfo_aws_crt_credentials_options_release arginfo_aws_crt_input_stream_options_release
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_credentials_options_set_access_key_id, 0, 0, 2)
+	ZEND_ARG_INFO(0, options)
+	ZEND_ARG_INFO(0, access_key_id)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_credentials_options_set_secret_access_key, 0, 0, 2)
+	ZEND_ARG_INFO(0, options)
+	ZEND_ARG_INFO(0, secret_access_key)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_credentials_options_set_session_token, 0, 0, 2)
+	ZEND_ARG_INFO(0, options)
+	ZEND_ARG_INFO(0, session_token)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_credentials_options_set_expiration_timepoint_seconds, 0, 0, 2)
+	ZEND_ARG_INFO(0, options)
+	ZEND_ARG_INFO(0, expiration_timepoint_seconds)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_credentials_new arginfo_aws_crt_event_loop_group_new
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_credentials_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, credentials)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_credentials_provider_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, credentials)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_credentials_provider_static_options_new arginfo_aws_crt_input_stream_options_new
+
+#define arginfo_aws_crt_credentials_provider_static_options_release arginfo_aws_crt_input_stream_options_release
+
+#define arginfo_aws_crt_credentials_provider_static_options_set_access_key_id arginfo_aws_crt_credentials_options_set_access_key_id
+
+#define arginfo_aws_crt_credentials_provider_static_options_set_secret_access_key arginfo_aws_crt_credentials_options_set_secret_access_key
+
+#define arginfo_aws_crt_credentials_provider_static_options_set_session_token arginfo_aws_crt_credentials_options_set_session_token
+
+#define arginfo_aws_crt_credentials_provider_static_new arginfo_aws_crt_event_loop_group_new
+
+#define arginfo_aws_crt_signing_config_aws_new arginfo_aws_crt_last_error
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, config)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_algorithm, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, algorithm)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_signature_type, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, signature_type)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_credentials_provider, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, credentials_provider)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_region, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, region)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_service, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, service)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_use_double_uri_encode, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, use_double_uri_encode)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_should_normalize_uri_path, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, should_normalize_uri_path)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_omit_session_token, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, omit_session_token)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_signed_body_value, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, signed_body_value)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_signed_body_header_type, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, signed_body_header_type)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_expiration_in_seconds, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, expiration_in_seconds)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_date, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, timestamp)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_config_aws_set_should_sign_header_fn, 0, 0, 2)
+	ZEND_ARG_INFO(0, config)
+	ZEND_ARG_INFO(0, should_sign_header)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signable_new_from_http_request, 0, 0, 1)
+	ZEND_ARG_INFO(0, http_message)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signable_new_from_chunk, 0, 0, 2)
+	ZEND_ARG_INFO(0, input_stream)
+	ZEND_ARG_INFO(0, previous_signature)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signable_new_from_canonical_request, 0, 0, 1)
+	ZEND_ARG_INFO(0, request)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signable_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, signable)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_result_release, 0, 0, 1)
+	ZEND_ARG_INFO(0, signing_result)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_signing_result_apply_to_http_request, 0, 0, 2)
+	ZEND_ARG_INFO(0, signing_result)
+	ZEND_ARG_INFO(0, http_request)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_sign_request_aws, 0, 0, 4)
+	ZEND_ARG_INFO(0, signable)
+	ZEND_ARG_INFO(0, signing_config)
+	ZEND_ARG_INFO(0, on_complete)
+	ZEND_ARG_INFO(0, user_data)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_test_verify_sigv4a_signing, 0, 0, 6)
+	ZEND_ARG_INFO(0, signable)
+	ZEND_ARG_INFO(0, signing_config)
+	ZEND_ARG_INFO(0, expected_canonical_request)
+	ZEND_ARG_INFO(0, signature)
+	ZEND_ARG_INFO(0, ecc_key_pub_x)
+	ZEND_ARG_INFO(0, ecc_key_pub_y)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_aws_crt_crc32, 0, 0, 2)
+	ZEND_ARG_INFO(0, input)
+	ZEND_ARG_INFO(0, prev)
+ZEND_END_ARG_INFO()
+
+#define arginfo_aws_crt_crc32c arginfo_aws_crt_crc32
+
+
+ZEND_FUNCTION(aws_crt_last_error);
+ZEND_FUNCTION(aws_crt_error_name);
+ZEND_FUNCTION(aws_crt_error_str);
+ZEND_FUNCTION(aws_crt_error_debug_str);
+ZEND_FUNCTION(aws_crt_log_to_stdout);
+ZEND_FUNCTION(aws_crt_log_to_stderr);
+ZEND_FUNCTION(aws_crt_log_to_file);
+ZEND_FUNCTION(aws_crt_log_to_stream);
+ZEND_FUNCTION(aws_crt_log_stop);
+ZEND_FUNCTION(aws_crt_log_set_level);
+ZEND_FUNCTION(aws_crt_log_message);
+ZEND_FUNCTION(aws_crt_event_loop_group_options_new);
+ZEND_FUNCTION(aws_crt_event_loop_group_options_release);
+ZEND_FUNCTION(aws_crt_event_loop_group_options_set_max_threads);
+ZEND_FUNCTION(aws_crt_event_loop_group_new);
+ZEND_FUNCTION(aws_crt_event_loop_group_release);
+ZEND_FUNCTION(aws_crt_input_stream_options_new);
+ZEND_FUNCTION(aws_crt_input_stream_options_release);
+ZEND_FUNCTION(aws_crt_input_stream_options_set_user_data);
+ZEND_FUNCTION(aws_crt_input_stream_new);
+ZEND_FUNCTION(aws_crt_input_stream_release);
+ZEND_FUNCTION(aws_crt_input_stream_seek);
+ZEND_FUNCTION(aws_crt_input_stream_read);
+ZEND_FUNCTION(aws_crt_input_stream_eof);
+ZEND_FUNCTION(aws_crt_input_stream_get_length);
+ZEND_FUNCTION(aws_crt_http_message_new_from_blob);
+ZEND_FUNCTION(aws_crt_http_message_to_blob);
+ZEND_FUNCTION(aws_crt_http_message_release);
+ZEND_FUNCTION(aws_crt_credentials_options_new);
+ZEND_FUNCTION(aws_crt_credentials_options_release);
+ZEND_FUNCTION(aws_crt_credentials_options_set_access_key_id);
+ZEND_FUNCTION(aws_crt_credentials_options_set_secret_access_key);
+ZEND_FUNCTION(aws_crt_credentials_options_set_session_token);
+ZEND_FUNCTION(aws_crt_credentials_options_set_expiration_timepoint_seconds);
+ZEND_FUNCTION(aws_crt_credentials_new);
+ZEND_FUNCTION(aws_crt_credentials_release);
+ZEND_FUNCTION(aws_crt_credentials_provider_release);
+ZEND_FUNCTION(aws_crt_credentials_provider_static_options_new);
+ZEND_FUNCTION(aws_crt_credentials_provider_static_options_release);
+ZEND_FUNCTION(aws_crt_credentials_provider_static_options_set_access_key_id);
+ZEND_FUNCTION(aws_crt_credentials_provider_static_options_set_secret_access_key);
+ZEND_FUNCTION(aws_crt_credentials_provider_static_options_set_session_token);
+ZEND_FUNCTION(aws_crt_credentials_provider_static_new);
+ZEND_FUNCTION(aws_crt_signing_config_aws_new);
+ZEND_FUNCTION(aws_crt_signing_config_aws_release);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_algorithm);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_signature_type);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_credentials_provider);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_region);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_service);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_use_double_uri_encode);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_should_normalize_uri_path);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_omit_session_token);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_signed_body_value);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_signed_body_header_type);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_expiration_in_seconds);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_date);
+ZEND_FUNCTION(aws_crt_signing_config_aws_set_should_sign_header_fn);
+ZEND_FUNCTION(aws_crt_signable_new_from_http_request);
+ZEND_FUNCTION(aws_crt_signable_new_from_chunk);
+ZEND_FUNCTION(aws_crt_signable_new_from_canonical_request);
+ZEND_FUNCTION(aws_crt_signable_release);
+ZEND_FUNCTION(aws_crt_signing_result_release);
+ZEND_FUNCTION(aws_crt_signing_result_apply_to_http_request);
+ZEND_FUNCTION(aws_crt_sign_request_aws);
+ZEND_FUNCTION(aws_crt_test_verify_sigv4a_signing);
+ZEND_FUNCTION(aws_crt_crc32);
+ZEND_FUNCTION(aws_crt_crc32c);
+
+
+static const zend_function_entry ext_functions[] = {
+	ZEND_FE(aws_crt_last_error, arginfo_aws_crt_last_error)
+	ZEND_FE(aws_crt_error_name, arginfo_aws_crt_error_name)
+	ZEND_FE(aws_crt_error_str, arginfo_aws_crt_error_str)
+	ZEND_FE(aws_crt_error_debug_str, arginfo_aws_crt_error_debug_str)
+	ZEND_FE(aws_crt_log_to_stdout, arginfo_aws_crt_log_to_stdout)
+	ZEND_FE(aws_crt_log_to_stderr, arginfo_aws_crt_log_to_stderr)
+	ZEND_FE(aws_crt_log_to_file, arginfo_aws_crt_log_to_file)
+	ZEND_FE(aws_crt_log_to_stream, arginfo_aws_crt_log_to_stream)
+	ZEND_FE(aws_crt_log_stop, arginfo_aws_crt_log_stop)
+	ZEND_FE(aws_crt_log_set_level, arginfo_aws_crt_log_set_level)
+	ZEND_FE(aws_crt_log_message, arginfo_aws_crt_log_message)
+	ZEND_FE(aws_crt_event_loop_group_options_new, arginfo_aws_crt_event_loop_group_options_new)
+	ZEND_FE(aws_crt_event_loop_group_options_release, arginfo_aws_crt_event_loop_group_options_release)
+	ZEND_FE(aws_crt_event_loop_group_options_set_max_threads, arginfo_aws_crt_event_loop_group_options_set_max_threads)
+	ZEND_FE(aws_crt_event_loop_group_new, arginfo_aws_crt_event_loop_group_new)
+	ZEND_FE(aws_crt_event_loop_group_release, arginfo_aws_crt_event_loop_group_release)
+	ZEND_FE(aws_crt_input_stream_options_new, arginfo_aws_crt_input_stream_options_new)
+	ZEND_FE(aws_crt_input_stream_options_release, arginfo_aws_crt_input_stream_options_release)
+	ZEND_FE(aws_crt_input_stream_options_set_user_data, arginfo_aws_crt_input_stream_options_set_user_data)
+	ZEND_FE(aws_crt_input_stream_new, arginfo_aws_crt_input_stream_new)
+	ZEND_FE(aws_crt_input_stream_release, arginfo_aws_crt_input_stream_release)
+	ZEND_FE(aws_crt_input_stream_seek, arginfo_aws_crt_input_stream_seek)
+	ZEND_FE(aws_crt_input_stream_read, arginfo_aws_crt_input_stream_read)
+	ZEND_FE(aws_crt_input_stream_eof, arginfo_aws_crt_input_stream_eof)
+	ZEND_FE(aws_crt_input_stream_get_length, arginfo_aws_crt_input_stream_get_length)
+	ZEND_FE(aws_crt_http_message_new_from_blob, arginfo_aws_crt_http_message_new_from_blob)
+	ZEND_FE(aws_crt_http_message_to_blob, arginfo_aws_crt_http_message_to_blob)
+	ZEND_FE(aws_crt_http_message_release, arginfo_aws_crt_http_message_release)
+	ZEND_FE(aws_crt_credentials_options_new, arginfo_aws_crt_credentials_options_new)
+	ZEND_FE(aws_crt_credentials_options_release, arginfo_aws_crt_credentials_options_release)
+	ZEND_FE(aws_crt_credentials_options_set_access_key_id, arginfo_aws_crt_credentials_options_set_access_key_id)
+	ZEND_FE(aws_crt_credentials_options_set_secret_access_key, arginfo_aws_crt_credentials_options_set_secret_access_key)
+	ZEND_FE(aws_crt_credentials_options_set_session_token, arginfo_aws_crt_credentials_options_set_session_token)
+	ZEND_FE(aws_crt_credentials_options_set_expiration_timepoint_seconds, arginfo_aws_crt_credentials_options_set_expiration_timepoint_seconds)
+	ZEND_FE(aws_crt_credentials_new, arginfo_aws_crt_credentials_new)
+	ZEND_FE(aws_crt_credentials_release, arginfo_aws_crt_credentials_release)
+	ZEND_FE(aws_crt_credentials_provider_release, arginfo_aws_crt_credentials_provider_release)
+	ZEND_FE(aws_crt_credentials_provider_static_options_new, arginfo_aws_crt_credentials_provider_static_options_new)
+	ZEND_FE(aws_crt_credentials_provider_static_options_release, arginfo_aws_crt_credentials_provider_static_options_release)
+	ZEND_FE(aws_crt_credentials_provider_static_options_set_access_key_id, arginfo_aws_crt_credentials_provider_static_options_set_access_key_id)
+	ZEND_FE(aws_crt_credentials_provider_static_options_set_secret_access_key, arginfo_aws_crt_credentials_provider_static_options_set_secret_access_key)
+	ZEND_FE(aws_crt_credentials_provider_static_options_set_session_token, arginfo_aws_crt_credentials_provider_static_options_set_session_token)
+	ZEND_FE(aws_crt_credentials_provider_static_new, arginfo_aws_crt_credentials_provider_static_new)
+	ZEND_FE(aws_crt_signing_config_aws_new, arginfo_aws_crt_signing_config_aws_new)
+	ZEND_FE(aws_crt_signing_config_aws_release, arginfo_aws_crt_signing_config_aws_release)
+	ZEND_FE(aws_crt_signing_config_aws_set_algorithm, arginfo_aws_crt_signing_config_aws_set_algorithm)
+	ZEND_FE(aws_crt_signing_config_aws_set_signature_type, arginfo_aws_crt_signing_config_aws_set_signature_type)
+	ZEND_FE(aws_crt_signing_config_aws_set_credentials_provider, arginfo_aws_crt_signing_config_aws_set_credentials_provider)
+	ZEND_FE(aws_crt_signing_config_aws_set_region, arginfo_aws_crt_signing_config_aws_set_region)
+	ZEND_FE(aws_crt_signing_config_aws_set_service, arginfo_aws_crt_signing_config_aws_set_service)
+	ZEND_FE(aws_crt_signing_config_aws_set_use_double_uri_encode, arginfo_aws_crt_signing_config_aws_set_use_double_uri_encode)
+	ZEND_FE(aws_crt_signing_config_aws_set_should_normalize_uri_path, arginfo_aws_crt_signing_config_aws_set_should_normalize_uri_path)
+	ZEND_FE(aws_crt_signing_config_aws_set_omit_session_token, arginfo_aws_crt_signing_config_aws_set_omit_session_token)
+	ZEND_FE(aws_crt_signing_config_aws_set_signed_body_value, arginfo_aws_crt_signing_config_aws_set_signed_body_value)
+	ZEND_FE(aws_crt_signing_config_aws_set_signed_body_header_type, arginfo_aws_crt_signing_config_aws_set_signed_body_header_type)
+	ZEND_FE(aws_crt_signing_config_aws_set_expiration_in_seconds, arginfo_aws_crt_signing_config_aws_set_expiration_in_seconds)
+	ZEND_FE(aws_crt_signing_config_aws_set_date, arginfo_aws_crt_signing_config_aws_set_date)
+	ZEND_FE(aws_crt_signing_config_aws_set_should_sign_header_fn, arginfo_aws_crt_signing_config_aws_set_should_sign_header_fn)
+	ZEND_FE(aws_crt_signable_new_from_http_request, arginfo_aws_crt_signable_new_from_http_request)
+	ZEND_FE(aws_crt_signable_new_from_chunk, arginfo_aws_crt_signable_new_from_chunk)
+	ZEND_FE(aws_crt_signable_new_from_canonical_request, arginfo_aws_crt_signable_new_from_canonical_request)
+	ZEND_FE(aws_crt_signable_release, arginfo_aws_crt_signable_release)
+	ZEND_FE(aws_crt_signing_result_release, arginfo_aws_crt_signing_result_release)
+	ZEND_FE(aws_crt_signing_result_apply_to_http_request, arginfo_aws_crt_signing_result_apply_to_http_request)
+	ZEND_FE(aws_crt_sign_request_aws, arginfo_aws_crt_sign_request_aws)
+	ZEND_FE(aws_crt_test_verify_sigv4a_signing, arginfo_aws_crt_test_verify_sigv4a_signing)
+	ZEND_FE(aws_crt_crc32, arginfo_aws_crt_crc32)
+	ZEND_FE(aws_crt_crc32c, arginfo_aws_crt_crc32c)
+	ZEND_FE_END
+};

--- server/vendor/aws/aws-crt-php/ext/crc.c ---
@@ -0,0 +1,32 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+PHP_FUNCTION(aws_crt_crc32) {
+    zend_ulong prev = 0;
+    const char *input = NULL;
+    size_t len = 0;
+
+    aws_php_parse_parameters("sl", &input, &len, &prev);
+
+    if (prev > UINT32_MAX) {
+        aws_php_throw_exception("previous crc cannot be larger than UINT32_MAX");
+    }
+    RETURN_LONG((zend_ulong)aws_crt_crc32((const uint8_t *)input, len, prev));
+}
+
+PHP_FUNCTION(aws_crt_crc32c) {
+    zend_ulong prev = 0;
+    const char *input = NULL;
+    size_t len = 0;
+
+    aws_php_parse_parameters("sl", &input, &len, &prev);
+
+    if (prev > UINT32_MAX) {
+        aws_php_throw_exception("previous crc cannot be larger than UINT32_MAX");
+    }
+    RETURN_LONG((zend_ulong)aws_crt_crc32c((const uint8_t *)input, len, prev));
+}

--- server/vendor/aws/aws-crt-php/ext/credentials.c ---
@@ -0,0 +1,154 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+PHP_FUNCTION(aws_crt_credentials_options_new) {
+    aws_crt_credentials_options *options = aws_crt_credentials_options_new();
+    RETURN_LONG((zend_ulong)options);
+}
+
+PHP_FUNCTION(aws_crt_credentials_options_release) {
+    zend_ulong php_options = 0;
+
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_credentials_options *options = (void *)php_options;
+    aws_crt_credentials_options_release(options);
+}
+
+PHP_FUNCTION(aws_crt_credentials_options_set_access_key_id) {
+    zend_ulong php_options = 0;
+    const char *access_key_id = NULL;
+    size_t access_key_id_len = 0;
+
+    aws_php_parse_parameters("ls", &php_options, &access_key_id, &access_key_id_len);
+
+    aws_crt_credentials_options *options = (void *)php_options;
+    aws_crt_credentials_options_set_access_key_id(options, (uint8_t *)access_key_id, access_key_id_len);
+}
+
+PHP_FUNCTION(aws_crt_credentials_options_set_secret_access_key) {
+    zend_ulong php_options = 0;
+    const char *secret_access_key = NULL;
+    size_t secret_access_key_len = 0;
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS(), "ls", &php_options, &secret_access_key, &secret_access_key_len) ==
+        FAILURE) {
+        RETURN_NULL();
+    }
+
+    aws_crt_credentials_options *options = (void *)php_options;
+    aws_crt_credentials_options_set_secret_access_key(options, (uint8_t *)secret_access_key, secret_access_key_len);
+}
+
+PHP_FUNCTION(aws_crt_credentials_options_set_session_token) {
+    zend_ulong php_options = 0;
+    const char *session_token = NULL;
+    size_t session_token_len = 0;
+
+    aws_php_parse_parameters("ls", &php_options, &session_token, &session_token_len);
+
+    aws_crt_credentials_options *options = (void *)php_options;
+    aws_crt_credentials_options_set_session_token(options, (uint8_t *)session_token, session_token_len);
+}
+
+PHP_FUNCTION(aws_crt_credentials_options_set_expiration_timepoint_seconds) {
+    zend_ulong php_options = 0;
+    zend_ulong expiration_timepoint_seconds = 0;
+    aws_php_parse_parameters("ll", &php_options, &expiration_timepoint_seconds);
+
+    aws_crt_credentials_options *options = (void *)php_options;
+    aws_crt_credentials_options_set_expiration_timepoint_seconds(options, expiration_timepoint_seconds);
+}
+
+PHP_FUNCTION(aws_crt_credentials_new) {
+    zend_ulong php_options = 0;
+
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_credentials_options *options = (void *)php_options;
+    aws_crt_credentials *credentials = aws_crt_credentials_new(options);
+    RETURN_LONG((zend_ulong)credentials);
+}
+
+PHP_FUNCTION(aws_crt_credentials_release) {
+    zend_ulong php_credentials = 0;
+
+    aws_php_parse_parameters("l", &php_credentials);
+
+    aws_crt_credentials *credentials = (void *)php_credentials;
+    aws_crt_credentials_release(credentials);
+}
+
+PHP_FUNCTION(aws_crt_credentials_provider_release) {
+    zend_ulong php_creds_provider = 0;
+
+    aws_php_parse_parameters("l", &php_creds_provider);
+
+    aws_crt_credentials_provider *provider = (void *)php_creds_provider;
+    aws_crt_credentials_provider_release(provider);
+}
+
+PHP_FUNCTION(aws_crt_credentials_provider_static_options_new) {
+    aws_crt_credentials_provider_static_options *options = aws_crt_credentials_provider_static_options_new();
+    RETURN_LONG((zend_ulong)options);
+}
+
+PHP_FUNCTION(aws_crt_credentials_provider_static_options_release) {
+    zend_ulong php_options = 0;
+
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_credentials_provider_static_options *options = (void *)php_options;
+    aws_crt_credentials_provider_static_options_release(options);
+}
+
+PHP_FUNCTION(aws_crt_credentials_provider_static_options_set_access_key_id) {
+    zend_ulong php_options = 0;
+    const char *access_key_id = NULL;
+    size_t access_key_id_len = 0;
+
+    aws_php_parse_parameters("ls", &php_options, &access_key_id, &access_key_id_len);
+
+    aws_crt_credentials_provider_static_options *options = (void *)php_options;
+    aws_crt_credentials_provider_static_options_set_access_key_id(options, (uint8_t *)access_key_id, access_key_id_len);
+}
+
+PHP_FUNCTION(aws_crt_credentials_provider_static_options_set_secret_access_key) {
+    zend_ulong php_options = 0;
+    const char *secret_access_key = NULL;
+    size_t secret_access_key_len = 0;
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS(), "ls", &php_options, &secret_access_key, &secret_access_key_len) ==
+        FAILURE) {
+        RETURN_NULL();
+    }
+
+    aws_crt_credentials_provider_static_options *options = (void *)php_options;
+    aws_crt_credentials_provider_static_options_set_secret_access_key(
+        options, (uint8_t *)secret_access_key, secret_access_key_len);
+}
+
+PHP_FUNCTION(aws_crt_credentials_provider_static_options_set_session_token) {
+    zend_ulong php_options = 0;
+    const char *session_token = NULL;
+    size_t session_token_len = 0;
+
+    aws_php_parse_parameters("ls", &php_options, &session_token, &session_token_len);
+
+    aws_crt_credentials_provider_static_options *options = (void *)php_options;
+    aws_crt_credentials_provider_static_options_set_session_token(options, (uint8_t *)session_token, session_token_len);
+}
+
+PHP_FUNCTION(aws_crt_credentials_provider_static_new) {
+    zend_ulong php_options = 0;
+
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_credentials_provider_static_options *options = (void *)php_options;
+    aws_crt_credentials_provider *provider = aws_crt_credentials_provider_static_new(options);
+    RETURN_LONG((zend_ulong)provider);
+}

--- server/vendor/aws/aws-crt-php/ext/crt.c ---
@@ -0,0 +1,314 @@
+
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+/* Helpful references for this extension:
+ * zend_parse_parameters and friends -
+ * https://git.php.net/?p=php-src.git;a=blob;f=docs/parameter-parsing-api.md;h=c962fc6ee58cc756aaac9e65759b7d5ea5c18fc4;hb=HEAD
+ * https://git.php.net/?p=php-src.git;a=blob;f=docs/self-contained-extensions.md;h=47f4c636baca8ca195118e2cc234ac7fd2842c1b;hb=HEAD
+ * Threads:
+ * http://blog.jpauli.tech/2017-01-12-threads-and-php-html/
+ * Examples:
+ * Curl extension: https://github.com/php/php-src/blob/PHP-5.6/ext/curl/interface.c
+ * libuv extension: https://github.com/amphp/ext-uv/blob/master/php_uv.c
+ */
+
+zval aws_php_invoke_callback(zval *callback, const char *arg_types, ...) {
+
+    char *error = NULL;
+    zend_fcall_info fci = {0};
+    zend_fcall_info_cache fcc = empty_fcall_info_cache;
+    if (zend_fcall_info_init(callback, IS_CALLABLE_CHECK_SYNTAX_ONLY, &fci, &fcc, NULL, &error) == FAILURE) {
+        aws_php_throw_exception("Unable to initialize callback from callable via zend_fcall_info_init: %s", error);
+    }
+
+    /* Allocate the stack frame of zval arguments and fill them in */
+    const size_t num_args = strlen(arg_types);
+    zval *stack = alloca(sizeof(zval) * num_args);
+    int arg_idx = 0;
+    va_list va;
+    va_start(va, arg_types);
+    while (arg_idx < num_args) {
+        const char arg_type = arg_types[arg_idx];
+        switch (arg_type) {
+            /* zval types */
+            case 'a':
+            case 'A':
+            case 'n':
+            case 'o':
+            case 'r':
+            case 'z': {
+                zval *zval_val = va_arg(va, zval *);
+                ZVAL_ZVAL(&stack[arg_idx], zval_val, 0, 0);
+                break;
+            }
+            /* buffers/strings (char *, size_t) */
+            case 'p':
+            case 's': {
+                const char *buf = va_arg(va, const char *);
+                const size_t len = va_arg(va, size_t);
+                aws_php_zval_stringl(&stack[arg_idx], buf, len);
+                break;
+            }
+            /* other primitives */
+            case 'b': {
+                zend_bool bool_val = va_arg(va, int);
+                ZVAL_BOOL(&stack[arg_idx], bool_val);
+                break;
+            }
+            case 'd': {
+                double double_val = va_arg(va, double);
+                ZVAL_DOUBLE(&stack[arg_idx], double_val);
+                break;
+            }
+            case 'l': {
+                zend_ulong long_val = va_arg(va, zend_ulong);
+                ZVAL_LONG(&stack[arg_idx], long_val);
+                break;
+            }
+            /* strings (zend_string), not supported in PHP 5.6, therefore not supported */
+            case 'P':
+            case 'S':
+            /* unsupported */
+            case 'C':
+            case 'f':
+            case 'h':
+            case 'H':
+            case 'O':
+                aws_php_throw_exception("Unsupported argument type to aws_php_invoke_callback: %c", arg_type);
+                break;
+            default:
+                aws_php_throw_exception("Unsupported argument type to aws_php_invoke_callback: %c", arg_type);
+                break;
+        }
+        ++arg_idx;
+    }
+    va_end(va);
+
+    /* set up the stack for the call */
+#if AWS_PHP_AT_LEAST_7
+    zend_fcall_info_argp(&fci, num_args, stack);
+#else
+    /* PHP5.6 may mutate the arguments due to coercion */
+    zval **arg_ptrs = alloca(sizeof(zval *) * num_args);
+    zval ***args = alloca(sizeof(zval **) * num_args);
+    for (int arg_idx = 0; arg_idx < num_args; ++arg_idx) {
+        arg_ptrs[arg_idx] = &stack[arg_idx];
+        args[arg_idx] = &arg_ptrs[arg_idx];
+    }
+    fci.param_count = num_args;
+    fci.params = args;
+#endif
+
+    zval retval;
+    /* PHP5 allocates its own return value, 7+ uses an existing one we provide */
+#if !AWS_PHP_AT_LEAST_7
+    zval *retval5 = NULL;
+    fci.retval_ptr_ptr = &retval5;
+#else
+    fci.retval = &retval;
+#endif
+
+    if (zend_call_function(&fci, &fcc) == FAILURE) {
+        aws_php_throw_exception("zend_call_function failed in aws_php_invoke_callback");
+    }
+
+#if !AWS_PHP_AT_LEAST_7
+    /* initialize the local retval from the retval in retval_ptr_ptr above */
+    if (retval5) {
+        ZVAL_ZVAL(&retval, retval5, 1, 1);
+    }
+#endif
+
+    /* Clean up arguments */
+#if AWS_PHP_AT_LEAST_7
+    zend_fcall_info_args_clear(&fci, 1);
+#endif
+
+    return retval;
+}
+
+void aws_php_zval_stringl(zval *val, const char *str, size_t len) {
+    AWS_FATAL_ASSERT(val != NULL);
+#if AWS_PHP_AT_LEAST_7
+    ZVAL_STRINGL(val, str, len);
+#else
+    ZVAL_STRINGL(val, str, len, 1);
+#endif
+}
+
+aws_php_thread_queue s_aws_php_main_thread_queue;
+
+bool aws_php_is_main_thread(void) {
+    return s_aws_php_main_thread_queue.thread_id == aws_thread_current_thread_id();
+}
+
+void aws_php_thread_queue_init(aws_php_thread_queue *queue) {
+    aws_mutex_init(&queue->mutex);
+    memset(queue->queue, 0, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);
+    queue->write_slot = 0;
+    queue->thread_id = aws_thread_current_thread_id();
+}
+
+void aws_php_thread_queue_clean_up(aws_php_thread_queue *queue) {
+    assert(queue->write_slot == 0 && "aws_php_thread_queue cannot be cleaned up while queue is not empty");
+    aws_mutex_clean_up(&queue->mutex);
+}
+
+void aws_php_thread_queue_push(aws_php_thread_queue *queue, aws_php_task task) {
+    aws_mutex_lock(&queue->mutex);
+    assert(queue->write_slot < AWS_PHP_THREAD_QUEUE_MAX_DEPTH && "thread queue is full");
+    queue->queue[queue->write_slot++] = task;
+    aws_mutex_unlock(&queue->mutex);
+}
+
+bool aws_php_thread_queue_drain(aws_php_thread_queue *queue) {
+    assert(
+        queue->thread_id == aws_thread_current_thread_id() &&
+        "thread queue cannot be drained from a thread other than its home");
+    aws_php_task drain_queue[AWS_PHP_THREAD_QUEUE_MAX_DEPTH];
+    aws_mutex_lock(&queue->mutex);
+    /* copy any queued tasks into the drain queue, then reset the queue */
+    memcpy(drain_queue, queue->queue, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);
+    memset(queue->queue, 0, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);
+    queue->write_slot = 0;
+    aws_mutex_unlock(&queue->mutex);
+
+    bool did_work = false;
+    for (int idx = 0; idx < AWS_PHP_THREAD_QUEUE_MAX_DEPTH; ++idx) {
+        aws_php_task *task = &drain_queue[idx];
+        if (!task->callback) {
+            break;
+        }
+        did_work = true;
+        task->callback(task->data);
+        if (task->dtor) {
+            task->dtor(task->data);
+        }
+    }
+
+    return did_work;
+}
+
+/* called on main thread after delivery */
+static void s_thread_queue_complete_promise(void *data) {
+    struct aws_promise *promise = data;
+    aws_promise_complete(promise, NULL, NULL);
+}
+
+/* called from worker thread to wait for the main thread to execute any queued work in PHP */
+void aws_php_thread_queue_yield(aws_php_thread_queue *queue) {
+    /* If on the main thread, then just drain the queue */
+    if (aws_php_is_main_thread()) {
+        aws_php_thread_queue_drain(queue);
+    } else {
+        /* push a task onto the end of the queue, we will return once this task completes our promise */
+        struct aws_promise *queue_drained = aws_promise_new(aws_crt_default_allocator());
+        aws_php_task queue_drained_task = {
+            .callback = s_thread_queue_complete_promise,
+            .data = queue_drained,
+        };
+        aws_php_thread_queue_push(queue, queue_drained_task);
+        aws_promise_wait(queue_drained);
+        aws_promise_release(queue_drained);
+    }
+}
+
+/* called from PHP thread to wait on async queued jobs, one of which should complete the promise */
+void aws_php_thread_queue_wait(aws_php_thread_queue *queue, struct aws_promise *promise) {
+    while (!aws_promise_is_complete(promise)) {
+        aws_php_thread_queue_drain(queue);
+    }
+}
+
+ZEND_DECLARE_MODULE_GLOBALS(awscrt);
+
+PHP_INI_BEGIN()
+STD_PHP_INI_ENTRY(
+    "awscrt.log_level",
+    "",
+    PHP_INI_ALL,
+    OnUpdateLongGEZero,
+    log_level,
+    zend_awscrt_globals,
+    awscrt_globals)
+PHP_INI_END()
+
+static PHP_MINIT_FUNCTION(awscrt) {
+    REGISTER_INI_ENTRIES();
+
+    /* prevent s2n from initializing/de-initializing OpenSSL/libcrypto */
+    aws_crt_crypto_share();
+    aws_crt_init();
+    aws_php_thread_queue_init(&s_aws_php_main_thread_queue);
+    return SUCCESS;
+}
+
+static PHP_MSHUTDOWN_FUNCTION(awscrt) {
+    UNREGISTER_INI_ENTRIES();
+    aws_php_thread_queue_clean_up(&s_aws_php_main_thread_queue);
+    aws_crt_thread_join_all(0);
+    aws_crt_clean_up();
+    return SUCCESS;
+}
+
+static PHP_GINIT_FUNCTION(awscrt) {
+#if defined(COMPILE_DL_ASTKIT) && defined(ZTS)
+    ZEND_TSRMLS_CACHE_UPDATE();
+#endif
+    awscrt_globals->log_level = 0;
+}
+
+zend_module_entry awscrt_module_entry = {
+    STANDARD_MODULE_HEADER,
+    "awscrt",
+    ext_functions, /* functions */
+    PHP_MINIT(awscrt),
+    PHP_MSHUTDOWN(awscrt),
+    NULL, /* RINIT */
+    NULL, /* RSHUTDOWN */
+    NULL, /* MINFO */
+    NO_VERSION_YET,
+    PHP_MODULE_GLOBALS(awscrt),
+    PHP_GINIT(awscrt),
+    NULL, /* GSHUTDOWN */
+    NULL, /* RPOSTSHUTDOWN */
+    STANDARD_MODULE_PROPERTIES_EX,
+};
+
+#ifdef COMPILE_DL_AWSCRT
+ZEND_GET_MODULE(awscrt)
+#endif
+
+/* aws_crt_last_error() */
+PHP_FUNCTION(aws_crt_last_error) {
+    RETURN_LONG(aws_crt_last_error());
+}
+
+/* aws_crt_error_str(int error_code) */
+PHP_FUNCTION(aws_crt_error_str) {
+    zend_ulong error_code = 0;
+    aws_php_parse_parameters("l", &error_code);
+
+    XRETURN_STRING(aws_crt_error_str(error_code));
+}
+
+/* aws_crt_error_name(int error_code) */
+PHP_FUNCTION(aws_crt_error_name) {
+    zend_ulong error_code = 0;
+    aws_php_parse_parameters("l", &error_code);
+
+    XRETURN_STRING(aws_crt_error_name(error_code));
+}
+
+/* aws_crt_error_debug_str(int error_code) */
+PHP_FUNCTION(aws_crt_error_debug_str) {
+    zend_ulong error_code = 0;
+    aws_php_parse_parameters("l", &error_code);
+
+    XRETURN_STRING(aws_crt_error_debug_str(error_code));
+}

--- server/vendor/aws/aws-crt-php/ext/event_loop.c ---
@@ -0,0 +1,48 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+PHP_FUNCTION(aws_crt_event_loop_group_options_new) {
+    aws_php_parse_parameters_none();
+    aws_crt_event_loop_group_options *options = aws_crt_event_loop_group_options_new();
+    RETURN_LONG((zend_ulong)options);
+}
+
+PHP_FUNCTION(aws_crt_event_loop_group_options_release) {
+    zend_ulong php_options = 0;
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_event_loop_group_options *options = (void *)php_options;
+    aws_crt_event_loop_group_options_release(options);
+}
+
+PHP_FUNCTION(aws_crt_event_loop_group_options_set_max_threads) {
+    zend_ulong php_options = 0;
+    zend_ulong num_threads = 0;
+    aws_php_parse_parameters("ll", &php_options, &num_threads);
+
+    aws_crt_event_loop_group_options *options = (void *)php_options;
+    aws_crt_event_loop_group_options_set_max_threads(options, num_threads);
+}
+
+PHP_FUNCTION(aws_crt_event_loop_group_new) {
+    zend_ulong php_options = 0;
+
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_event_loop_group_options *options = (void *)php_options;
+    aws_crt_event_loop_group *elg = aws_crt_event_loop_group_new(options);
+    RETURN_LONG((zend_ulong)elg);
+}
+
+PHP_FUNCTION(aws_crt_event_loop_group_release) {
+    zend_ulong php_elg = 0;
+
+    aws_php_parse_parameters("l", &php_elg);
+
+    aws_crt_event_loop_group *elg = (void *)php_elg;
+    aws_crt_event_loop_group_release(elg);
+}

--- server/vendor/aws/aws-crt-php/ext/http.c ---
@@ -0,0 +1,36 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+PHP_FUNCTION(aws_crt_http_message_new_from_blob) {
+    const char *blob = NULL;
+    size_t blob_len = 0;
+
+    aws_php_parse_parameters("s", &blob, &blob_len);
+
+    aws_crt_http_message *message = aws_crt_http_message_new_from_blob((uint8_t *)blob, blob_len);
+    RETURN_LONG((zend_ulong)message);
+}
+
+PHP_FUNCTION(aws_crt_http_message_to_blob) {
+    zend_ulong php_msg = 0;
+
+    aws_php_parse_parameters("l", &php_msg);
+
+    aws_crt_http_message *message = (void *)php_msg;
+    aws_crt_buf blob;
+    aws_crt_http_message_to_blob(message, &blob);
+    XRETURN_STRINGL((const char *)blob.blob, blob.length);
+}
+
+PHP_FUNCTION(aws_crt_http_message_release) {
+    zend_ulong php_msg = 0;
+
+    aws_php_parse_parameters("l", &php_msg);
+
+    aws_crt_http_message *message = (void *)php_msg;
+    aws_crt_http_message_release(message);
+}

--- server/vendor/aws/aws-crt-php/ext/logging.c ---
@@ -0,0 +1,65 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+PHP_FUNCTION(aws_crt_log_to_stdout) {
+    aws_php_parse_parameters_none();
+    aws_crt_log_to_stdout();
+}
+
+PHP_FUNCTION(aws_crt_log_to_stderr) {
+    aws_php_parse_parameters_none();
+    aws_crt_log_to_stderr();
+}
+
+PHP_FUNCTION(aws_crt_log_to_file) {
+    const char *filename = NULL;
+    size_t filename_len = 0;
+    /* read the filename as a path, which guarantees no NUL bytes */
+    aws_php_parse_parameters("p", &filename, &filename_len);
+    aws_crt_log_to_file(filename);
+}
+
+static void php_crt_log(const char *message, size_t len, void *user_data) {
+    php_stream *stream = user_data;
+    php_stream_write(stream, message, len);
+    php_stream_flush(stream);
+}
+
+PHP_FUNCTION(aws_crt_log_to_stream) {
+    zval *php_log_stream = NULL;
+    aws_php_parse_parameters("r", &php_log_stream);
+
+    if (php_log_stream) {
+        php_stream *stream = NULL;
+        Z_ADDREF(*php_log_stream);
+        AWS_PHP_STREAM_FROM_ZVAL(stream, php_log_stream);
+        aws_crt_log_to_callback((aws_crt_log_callback *)php_crt_log, stream);
+    } else {
+        aws_crt_log_to_callback(NULL, NULL);
+    }
+}
+
+PHP_FUNCTION(aws_crt_log_set_level) {
+    zend_ulong log_level = 0;
+    aws_php_parse_parameters("l", &log_level);
+    aws_crt_log_set_level((aws_crt_log_level)log_level);
+}
+
+PHP_FUNCTION(aws_crt_log_stop) {
+    aws_php_parse_parameters_none();
+    aws_crt_log_stop();
+}
+
+PHP_FUNCTION(aws_crt_log_message) {
+    zend_ulong log_level = 0;
+    const char *message = NULL;
+    size_t message_len = 0;
+
+    aws_php_parse_parameters("ls", &log_level, &message, &message_len);
+
+    aws_crt_log_message((aws_crt_log_level)log_level, (const uint8_t *)message, message_len);
+}

--- server/vendor/aws/aws-crt-php/ext/php_aws_crt.h ---
@@ -0,0 +1,171 @@
+
+#ifndef PHP_AWS_CRT_H
+#define PHP_AWS_CRT_H
+
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#ifdef HAVE_CONFIG_H
+#    include "config.h"
+#endif
+
+#include "php.h"
+
+#include "Zend/zend_extensions.h" /* for ZEND_EXTENSION_API_NO */
+
+#include <aws/common/common.h>
+#include <aws/common/mutex.h>
+#include <aws/common/promise.h>
+#include <aws/common/thread.h>
+
+/* ZEND_EXTENSION_API_NO from each branch of the PHP source */
+#define AWS_PHP_EXTENSION_API_5_5 220121212
+#define AWS_PHP_EXTENSION_API_5_6 220131226
+#define AWS_PHP_EXTENSION_API_7_0 320151012
+#define AWS_PHP_EXTENSION_API_7_1 320160303
+#define AWS_PHP_EXTENSION_API_7_2 320170718
+#define AWS_PHP_EXTENSION_API_7_3 320180731
+#define AWS_PHP_EXTENSION_API_7_4 320190902
+#define AWS_PHP_EXTENSION_API_8_0 420200930
+
+#if ZEND_EXTENSION_API_NO < AWS_PHP_EXTENSION_API_5_5
+#    error "PHP >= 5.5 is required"
+#endif
+
+#define AWS_PHP_AT_LEAST_7 (ZEND_EXTENSION_API_NO >= AWS_PHP_EXTENSION_API_7_0)
+#define AWS_PHP_AT_LEAST_7_2 (ZEND_EXTENSION_API_NO >= AWS_PHP_EXTENSION_API_7_2)
+
+ZEND_BEGIN_MODULE_GLOBALS(awscrt)
+long log_level;
+ZEND_END_MODULE_GLOBALS(awscrt)
+
+ZEND_EXTERN_MODULE_GLOBALS(awscrt)
+
+#define AWSCRT_GLOBAL(v) ZEND_MODULE_GLOBALS_ACCESSOR(awscrt, v)
+
+#if AWS_PHP_AT_LEAST_7
+/* PHP 7 takes a zval*, PHP5 takes a zval** */
+#    define AWS_PHP_STREAM_FROM_ZVAL(s, z) php_stream_from_zval(s, z)
+#define XRETURN_STRINGL RETURN_STRINGL
+#define XRETURN_STRING RETURN_STRING
+#define XRETVAL_STRINGL RETVAL_STRINGL
+#define XRETVAL_STRING RETVAL_STRING
+#else /* PHP 5.5-5.6 */
+#    define AWS_PHP_STREAM_FROM_ZVAL(s, z) php_stream_from_zval(s, &z)
+#define XRETURN_STRINGL(s, l) RETURN_STRINGL(s, l, 1)
+#define XRETURN_STRING(s) RETURN_STRING(s, 1)
+#define XRETVAL_STRINGL(s, l) RETVAL_STRINGL(s, l, 1)
+#define XRETVAL_STRING(s) RETVAL_STRING(s, 1)
+#endif /* PHP 5.x */
+
+#include "api.h"
+#include "awscrt_arginfo.h"
+
+/* Utility macros borrowed from common */
+#define GLUE(x, y) x y
+
+#define RETURN_ARG_COUNT(_1_, _2_, _3_, _4_, _5_, count, ...) count
+#define EXPAND_ARGS(args) RETURN_ARG_COUNT args
+#define COUNT_ARGS_MAX5(...) EXPAND_ARGS((__VA_ARGS__, 5, 4, 3, 2, 1, 0))
+
+#define OVERLOAD_MACRO2(name, count) name##count
+#define OVERLOAD_MACRO1(name, count) OVERLOAD_MACRO2(name, count)
+#define OVERLOAD_MACRO(name, count) OVERLOAD_MACRO1(name, count)
+
+#define CALL_OVERLOAD(name, ...) GLUE(OVERLOAD_MACRO(name, COUNT_ARGS_MAX5(__VA_ARGS__)), (__VA_ARGS__))
+
+#define VARIABLE_LENGTH_ARRAY(type, name, length) type *name = alloca(sizeof(type) * (length))
+
+/*
+ * PHP utility APIs for this extension
+ */
+/*
+ * Exception throwing mechanism, will never return
+ */
+#define aws_php_throw_exception(...) CALL_OVERLOAD(_AWS_PHP_THROW_EXCEPTION, __VA_ARGS__);
+#define _AWS_PHP_THROW_EXCEPTION5(format, ...) zend_error_noreturn(E_ERROR, format, __VA_ARGS__)
+#define _AWS_PHP_THROW_EXCEPTION4(format, ...) zend_error_noreturn(E_ERROR, format, __VA_ARGS__)
+#define _AWS_PHP_THROW_EXCEPTION3(format, ...) zend_error_noreturn(E_ERROR, format, __VA_ARGS__)
+#define _AWS_PHP_THROW_EXCEPTION2(format, ...) zend_error_noreturn(E_ERROR, format, __VA_ARGS__)
+#define _AWS_PHP_THROW_EXCEPTION1(format) zend_error_noreturn(E_ERROR, format)
+
+/**
+ * throws an exception resulting from argument parsing, notes the current function name in the exception
+ */
+#define aws_php_argparse_fail()                                                                                        \
+    do {                                                                                                               \
+        aws_php_throw_exception("Failed to parse arguments to %s", __func__);                                          \
+    } while (0)
+
+/**
+ * calls zend_parse_parameters() with the arguments and throws an exception if parsing fails
+ */
+#define aws_php_parse_parameters(type_spec, ...)                                                                       \
+    do {                                                                                                               \
+        if (zend_parse_parameters(ZEND_NUM_ARGS(), type_spec, __VA_ARGS__) == FAILURE) {                               \
+            aws_php_argparse_fail();                                                                                   \
+        }                                                                                                              \
+    } while (0)
+
+/**
+ * calls zend_parse_parameters_none() and throws an exception if parsing fails
+ */
+#define aws_php_parse_parameters_none()                                                                                \
+    do {                                                                                                               \
+        if (zend_parse_parameters_none() == FAILURE) {                                                                 \
+            aws_php_argparse_fail();                                                                                   \
+        }                                                                                                              \
+    } while (0)
+
+/* PHP/Zend utility functions to work across PHP versions */
+zval *aws_php_zval_new(void);
+void aws_php_zval_dtor(void *zval_ptr);
+bool aws_php_zval_as_bool(zval *z);
+void aws_php_zval_copy(zval *dest, zval *src);
+/**
+ * Replacement for ZVAL_STRINGL that is PHP version agnostic
+ */
+void aws_php_zval_stringl(zval *val, const char *str, size_t len);
+
+/* Thread queue functions for managing PHP's optional threading situation */
+typedef struct _aws_php_task {
+    void (*callback)(void *); /* task function */
+    void (*dtor)(void *);     /* deletes task_data, if non-null */
+    void *data;
+} aws_php_task;
+
+/* maximum number of queued callbacks to execute at once. Since this is to support single-threaded usage,
+ * this can be a fairly small number, as how many callbacks could we reasonably be stacking up?! */
+#define AWS_PHP_THREAD_QUEUE_MAX_DEPTH 32
+
+typedef struct _aws_php_thread_queue {
+    struct aws_mutex mutex;
+    aws_php_task queue[AWS_PHP_THREAD_QUEUE_MAX_DEPTH];
+    size_t write_slot;
+    aws_thread_id_t thread_id;
+} aws_php_thread_queue;
+
+extern aws_php_thread_queue s_aws_php_main_thread_queue;
+bool aws_php_is_main_thread(void);
+
+void aws_php_thread_queue_init(aws_php_thread_queue *queue);
+void aws_php_thread_queue_clean_up(aws_php_thread_queue *queue);
+void aws_php_thread_queue_push(aws_php_thread_queue *queue, aws_php_task task);
+bool aws_php_thread_queue_drain(aws_php_thread_queue *queue);
+
+/* called from worker thread to wait for the main thread to execute any queued work in PHP */
+void aws_php_thread_queue_yield(aws_php_thread_queue *queue);
+
+/* called from PHP thread to wait on async queued jobs, one of which MUST complete the promise */
+void aws_php_thread_queue_wait(aws_php_thread_queue *queue, struct aws_promise *promise);
+
+/**
+ * generic dispatch mechanism to call a callback provided as a zval with arguments
+ * that are converted to zvals based on the arg_types format string
+ * Uses the same format string as zend_parse_parameters
+ */
+zval aws_php_invoke_callback(zval *callback, const char *arg_types, ...);
+
+#endif /* PHP_AWS_CRT_H */

--- server/vendor/aws/aws-crt-php/ext/php_util.c ---
@@ -0,0 +1,33 @@
+
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+zval *aws_php_zval_new(void) {
+    return emalloc(sizeof(zval));
+}
+
+void aws_php_zval_dtor(void *zval_ptr) {
+    zval *z = zval_ptr;
+    zval_dtor(z);
+    efree(z);
+}
+
+bool aws_php_zval_as_bool(zval *z) {
+#if AWS_PHP_AT_LEAST_7
+    return (Z_TYPE_P(z) == IS_TRUE);
+#else
+    return (Z_TYPE_P(z) == IS_BOOL && Z_LVAL_P(z) != 0);
+#endif
+}
+
+void aws_php_zval_copy(zval *dest, zval *src) {
+#if AWS_PHP_AT_LEAST_7
+    ZVAL_COPY(dest, src);
+#else
+    ZVAL_COPY_VALUE(dest, src);
+#endif
+}

--- server/vendor/aws/aws-crt-php/ext/signing.c ---
@@ -0,0 +1,374 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+PHP_FUNCTION(aws_crt_signing_config_aws_new) {
+    if (zend_parse_parameters_none() == FAILURE) {
+        RETURN_NULL();
+    }
+
+    aws_crt_signing_config_aws *signing_config = aws_crt_signing_config_aws_new();
+    RETURN_LONG((zend_ulong)signing_config);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_release) {
+    zend_ulong php_signing_config = 0;
+
+    aws_php_parse_parameters("l", &php_signing_config);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_release(signing_config);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_algorithm) {
+    zend_ulong php_signing_config = 0;
+    zend_ulong php_algorithm = 0;
+
+    aws_php_parse_parameters("ll", &php_signing_config, &php_algorithm);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_algorithm algorithm = php_algorithm;
+    aws_crt_signing_config_aws_set_algorithm(signing_config, algorithm);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_signature_type) {
+    zend_ulong php_signing_config = 0;
+    zend_ulong php_signature_type = 0;
+
+    aws_php_parse_parameters("ll", &php_signing_config, &php_signature_type);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signature_type signature_type = php_signature_type;
+    aws_crt_signing_config_aws_set_signature_type(signing_config, signature_type);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_credentials_provider) {
+    zend_ulong php_signing_config = 0;
+    zend_ulong php_credentials_provider = 0;
+
+    aws_php_parse_parameters("ll", &php_signing_config, &php_credentials_provider);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_credentials_provider *credentials_provider = (void *)php_credentials_provider;
+    aws_crt_signing_config_aws_set_credentials_provider(signing_config, credentials_provider);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_region) {
+    zend_ulong php_signing_config = 0;
+    const char *region = NULL;
+    size_t region_len = 0;
+
+    aws_php_parse_parameters("ls", &php_signing_config, &region, &region_len);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_region(signing_config, (uint8_t *)region, region_len);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_service) {
+    zend_ulong php_signing_config = 0;
+    const char *service = NULL;
+    size_t service_len = 0;
+
+    aws_php_parse_parameters("ls", &php_signing_config, &service, &service_len);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_service(signing_config, (uint8_t *)service, service_len);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_use_double_uri_encode) {
+    zend_ulong php_signing_config = 0;
+    zend_bool php_use_double_uri_encode = 0;
+
+    aws_php_parse_parameters("lb", &php_signing_config, &php_use_double_uri_encode);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_use_double_uri_encode(signing_config, php_use_double_uri_encode);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_should_normalize_uri_path) {
+    zend_ulong php_signing_config = 0;
+    zend_bool php_should_normalize_uri_path = 0;
+
+    aws_php_parse_parameters("lb", &php_signing_config, &php_should_normalize_uri_path);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_should_normalize_uri_path(signing_config, php_should_normalize_uri_path);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_omit_session_token) {
+    zend_ulong php_signing_config = 0;
+    zend_bool php_omit_session_token = 0;
+
+    aws_php_parse_parameters("lb", &php_signing_config, &php_omit_session_token);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_omit_session_token(signing_config, php_omit_session_token);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_signed_body_value) {
+    zend_ulong php_signing_config = 0;
+    const char *signed_body_value = NULL;
+    size_t signed_body_value_len = 0;
+
+    aws_php_parse_parameters("ls", &php_signing_config, &signed_body_value, &signed_body_value_len);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_signed_body_value(
+        signing_config, (uint8_t *)signed_body_value, signed_body_value_len);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_signed_body_header_type) {
+    zend_ulong php_signing_config = 0;
+    zend_ulong php_signed_body_header_type = 0;
+
+    aws_php_parse_parameters("ll", &php_signing_config, &php_signed_body_header_type);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signed_body_header_type signed_body_header_type = php_signed_body_header_type;
+    aws_crt_signing_config_aws_set_signed_body_header_type(signing_config, signed_body_header_type);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_expiration_in_seconds) {
+    zend_ulong php_signing_config = 0;
+    zend_ulong php_expiration_in_seconds = 0;
+
+    aws_php_parse_parameters("ll", &php_signing_config, &php_expiration_in_seconds);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_expiration_in_seconds(signing_config, php_expiration_in_seconds);
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_date) {
+    zend_ulong php_signing_config = 0;
+    zend_ulong php_timestamp = 0;
+
+    aws_php_parse_parameters("ll", &php_signing_config, &php_timestamp);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+    aws_crt_signing_config_aws_set_date(signing_config, php_timestamp);
+}
+
+typedef struct _should_sign_header_data {
+    zval *should_sign_header;
+    zval *header_name;
+    bool result;
+} should_sign_header_data;
+
+static void should_sign_header_task(void *data) {
+    should_sign_header_data *task = data;
+    zval result = aws_php_invoke_callback(task->should_sign_header, "z", task->header_name);
+    task->result = aws_php_zval_as_bool(&result);
+    zval_dtor(&result);
+}
+
+static bool aws_php_should_sign_header(const char *header_name, size_t header_length, void *user_data) {
+    zval php_header_name;
+    aws_php_zval_stringl(&php_header_name, header_name, header_length);
+
+    should_sign_header_data task_data = {
+        .should_sign_header = user_data,
+        .header_name = &php_header_name,
+        .result = false,
+    };
+
+    aws_php_task task = {
+        .callback = should_sign_header_task,
+        .data = &task_data,
+    };
+
+    aws_php_thread_queue_push(&s_aws_php_main_thread_queue, task);
+    aws_php_thread_queue_yield(&s_aws_php_main_thread_queue);
+
+    zval_dtor(&php_header_name);
+
+    return task_data.result;
+}
+
+PHP_FUNCTION(aws_crt_signing_config_aws_set_should_sign_header_fn) {
+    zend_ulong php_signing_config = 0;
+    zval *php_should_sign_header = NULL;
+
+    aws_php_parse_parameters("lz", &php_signing_config, &php_should_sign_header);
+
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+
+    /* copy/retain PHP callback, add as user data for signing_config resource */
+    zval *should_sign_header = aws_php_zval_new();
+    aws_php_zval_copy(should_sign_header, php_should_sign_header);
+    aws_crt_resource_set_user_data(signing_config, should_sign_header, aws_php_zval_dtor);
+
+    aws_crt_signing_config_aws_set_should_sign_header_fn(
+        signing_config, aws_php_should_sign_header, should_sign_header);
+}
+
+PHP_FUNCTION(aws_crt_signable_new_from_http_request) {
+    zend_ulong php_http_message = 0;
+
+    aws_php_parse_parameters("l", &php_http_message);
+
+    const aws_crt_http_message *http_message = (void *)php_http_message;
+    aws_crt_signable *signable = aws_crt_signable_new_from_http_request(http_message);
+    RETURN_LONG((zend_ulong)signable);
+}
+
+PHP_FUNCTION(aws_crt_signable_new_from_chunk) {
+    zend_ulong php_input_stream = 0;
+    const char *previous_signature = NULL;
+    size_t previous_signature_len = 0;
+
+    aws_php_parse_parameters("ls", &php_input_stream, &previous_signature, &previous_signature_len);
+
+    aws_crt_input_stream *input_stream = (void *)php_input_stream;
+    aws_crt_signable *signable =
+        aws_crt_signable_new_from_chunk(input_stream, (uint8_t *)previous_signature, previous_signature_len);
+    RETURN_LONG((zend_ulong)signable);
+}
+
+PHP_FUNCTION(aws_crt_signable_new_from_canonical_request) {
+    const char *canonical_request = NULL;
+    size_t canonical_request_len = 0;
+
+    aws_crt_signable *signable =
+        aws_crt_signable_new_from_canonical_request((uint8_t *)canonical_request, canonical_request_len);
+    RETURN_LONG((zend_ulong)signable);
+}
+
+PHP_FUNCTION(aws_crt_signable_release) {
+    zend_ulong php_signable = 0;
+
+    aws_php_parse_parameters("l", &php_signable);
+
+    aws_crt_signable *signable = (void *)php_signable;
+    aws_crt_signable_release(signable);
+}
+
+PHP_FUNCTION(aws_crt_signing_result_release) {
+    zend_ulong php_signing_result = 0;
+
+    aws_php_parse_parameters("l", &php_signing_result);
+    aws_crt_signing_result *result = (void *)php_signing_result;
+    aws_crt_signing_result_release(result);
+}
+
+PHP_FUNCTION(aws_crt_signing_result_apply_to_http_request) {
+    zend_ulong php_signing_result = 0;
+    zend_ulong php_http_request = 0;
+
+    aws_php_parse_parameters("ll", &php_signing_result, &php_http_request);
+    aws_crt_signing_result *result = (void *)php_signing_result;
+    aws_crt_http_message *request = (void *)php_http_request;
+
+    if (aws_crt_signing_result_apply_to_http_request(result, request)) {
+        aws_php_throw_exception(
+            "Failed to apply signing result to HTTP request: %s", aws_crt_error_name(aws_crt_last_error()));
+    }
+}
+
+typedef struct _signing_state {
+    struct aws_promise *promise;
+    zval *on_complete;
+    aws_crt_signing_result *signing_result;
+    int error_code;
+} signing_state;
+
+/* called on main thread to deliver result to php */
+static void s_sign_aws_complete(void *data) {
+    signing_state *state = data;
+    zval *on_complete = state->on_complete;
+    aws_php_invoke_callback(on_complete, "ll", (zend_ulong)state->signing_result, (zend_ulong)state->error_code);
+}
+
+/* called from signing process in aws_sign_request_aws */
+static void s_on_sign_request_aws_complete(aws_crt_signing_result *result, int error_code, void *user_data) {
+    signing_state *state = user_data;
+    struct aws_promise *promise = state->promise;
+
+    state->signing_result = result;
+    state->error_code = error_code;
+
+    /*
+     * Must execute PHP callback before this function returns, or signing_result will be killed
+     * so the callback is queued back to the main thread and will have run when yield returns
+     */
+    aws_php_task complete_callback_task = {
+        .callback = s_sign_aws_complete,
+        .data = state,
+    };
+    aws_php_thread_queue_push(&s_aws_php_main_thread_queue, complete_callback_task);
+    aws_php_thread_queue_yield(&s_aws_php_main_thread_queue);
+
+    if (error_code) {
+        aws_promise_fail(promise, error_code);
+    } else {
+        aws_promise_complete(promise, result, NULL);
+    }
+}
+
+PHP_FUNCTION(aws_crt_sign_request_aws) {
+    zend_ulong php_signable = 0;
+    zend_ulong php_signing_config = 0;
+    zval *php_on_complete = 0;
+    zend_ulong php_user_data = 0;
+
+    aws_php_parse_parameters("llzl", &php_signable, &php_signing_config, &php_on_complete, &php_user_data);
+
+    aws_crt_signable *signable = (void *)php_signable;
+    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;
+
+    struct aws_promise *promise = aws_promise_new(aws_crt_default_allocator());
+    signing_state state = {
+        .promise = promise,
+        .on_complete = php_on_complete,
+    };
+    int ret = aws_crt_sign_request_aws(signable, signing_config, s_on_sign_request_aws_complete, &state);
+    if (ret != 0) {
+        int last_error = aws_crt_last_error();
+        aws_promise_fail(promise, last_error);
+        aws_php_throw_exception(
+            "aws_crt_sign_request_aws: error starting signing process: %s", aws_crt_error_name(last_error));
+    }
+
+    aws_php_thread_queue_wait(&s_aws_php_main_thread_queue, promise);
+
+done:
+    aws_promise_release(promise);
+    RETURN_LONG(ret);
+}
+
+PHP_FUNCTION(aws_crt_test_verify_sigv4a_signing) {
+    zend_ulong php_signable = 0;
+    zend_ulong php_signing_config = 0;
+    const char *expected_canonical_request = NULL;
+    size_t expected_canonical_request_len = 0;
+    const char *signature = NULL;
+    size_t signature_len = 0;
+    const char *ecc_key_pub_x = NULL;
+    size_t ecc_key_pub_x_len = 0;
+    const char *ecc_key_pub_y = NULL;
+    size_t ecc_key_pub_y_len = 0;
+
+    aws_php_parse_parameters(
+        "llssss",
+        &php_signable,
+        &php_signing_config,
+        &expected_canonical_request,
+        &expected_canonical_request_len,
+        &signature,
+        &signature_len,
+        &ecc_key_pub_x,
+        &ecc_key_pub_x_len,
+        &ecc_key_pub_y,
+        &ecc_key_pub_y_len);
+
+    const aws_crt_signable *signable = (void *)php_signable;
+    const aws_crt_signing_config *signing_config = (void *)php_signing_config;
+
+    bool result = AWS_OP_SUCCESS ==
+                  aws_crt_test_verify_sigv4a_signing(
+                      signable, signing_config, expected_canonical_request, signature, ecc_key_pub_x, ecc_key_pub_y);
+
+    RETURN_BOOL(result);
+}

--- server/vendor/aws/aws-crt-php/ext/stream.c ---
@@ -0,0 +1,148 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#include "php_aws_crt.h"
+
+/* PHP streams info:
+ * https://git.php.net/?p=php-src.git;a=blob;f=docs/streams.md;h=0ec3846d68bf70067297d8a6c691d2591c49b48a;hb=HEAD
+ * https://github.com/php/php-src/blob/PHP-5.6.0/main/php_streams.h
+ */
+
+PHP_FUNCTION(aws_crt_input_stream_options_new) {
+    if (zend_parse_parameters_none() == FAILURE) {
+        aws_php_argparse_fail();
+    }
+
+    aws_crt_input_stream_options *options = aws_crt_input_stream_options_new();
+    RETURN_LONG((zend_ulong)options);
+}
+
+PHP_FUNCTION(aws_crt_input_stream_options_release) {
+    zend_ulong php_options = 0;
+
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_input_stream_options *options = (void *)php_options;
+    aws_crt_input_stream_options_release(options);
+}
+
+PHP_FUNCTION(aws_crt_input_stream_options_set_user_data) {
+    zend_ulong php_options = 0;
+    zval *user_data = NULL;
+
+    aws_php_parse_parameters("lz", &php_options, &user_data);
+
+    aws_crt_input_stream_options *options = (void *)php_options;
+    php_stream *stream = NULL;
+    AWS_PHP_STREAM_FROM_ZVAL(stream, user_data);
+    aws_crt_input_stream_options_set_user_data(options, stream);
+}
+
+static int s_php_stream_seek(void *user_data, int64_t offset, aws_crt_input_stream_seek_basis basis) {
+    php_stream *stream = user_data;
+    return php_stream_seek(stream, offset, basis);
+}
+
+static int s_php_stream_read(void *user_data, uint8_t *dest, size_t dest_length) {
+    php_stream *stream = user_data;
+    return php_stream_read(stream, (char *)dest, dest_length) != 0;
+}
+
+static int s_php_stream_get_length(void *user_data, int64_t *out_length) {
+    php_stream *stream = user_data;
+    size_t pos = php_stream_tell(stream);
+    php_stream_seek(stream, 0, SEEK_END);
+    *out_length = php_stream_tell(stream);
+    php_stream_seek(stream, pos, SEEK_SET);
+    return 0;
+}
+
+static int s_php_stream_get_status(void *user_data, aws_crt_input_stream_status *out_status) {
+    php_stream *stream = user_data;
+    out_status->is_valid = stream != NULL;
+    /* We would like to use php_stream_eof here, but certain streams (notably php://memory)
+     * are not actually capable of EOF, so we get to do it the hard way */
+    int64_t length = 0;
+    int64_t pos = 0;
+    s_php_stream_get_length(stream, &length);
+    pos = php_stream_tell(stream);
+    out_status->is_end_of_stream = pos == length;
+    return 0;
+}
+
+static void s_php_stream_destroy(void *user_data) {
+    (void)user_data;
+    /* no op, stream will be freed by PHP refcount dropping from InputStream::stream */
+}
+
+PHP_FUNCTION(aws_crt_input_stream_new) {
+    zend_ulong php_options = 0;
+
+    aws_php_parse_parameters("l", &php_options);
+
+    aws_crt_input_stream_options *options = (void *)php_options;
+    aws_crt_input_stream_options_set_seek(options, s_php_stream_seek);
+    aws_crt_input_stream_options_set_read(options, s_php_stream_read);
+    aws_crt_input_stream_options_set_get_status(options, s_php_stream_get_status);
+    aws_crt_input_stream_options_set_get_length(options, s_php_stream_get_length);
+    aws_crt_input_stream_options_set_destroy(options, s_php_stream_destroy);
+    aws_crt_input_stream *stream = aws_crt_input_stream_new(options);
+    RETURN_LONG((zend_ulong)stream);
+}
+
+PHP_FUNCTION(aws_crt_input_stream_release) {
+    zend_ulong php_stream = 0;
+
+    aws_php_parse_parameters("l", &php_stream);
+
+    aws_crt_input_stream *stream = (void *)php_stream;
+    aws_crt_input_stream_release(stream);
+}
+
+PHP_FUNCTION(aws_crt_input_stream_seek) {
+    zend_ulong php_stream = 0;
+    zend_ulong offset = 0;
+    zend_ulong basis = 0;
+
+    aws_php_parse_parameters("lll", &php_stream, &offset, &basis);
+
+    aws_crt_input_stream *stream = (void *)php_stream;
+    RETURN_LONG(aws_crt_input_stream_seek(stream, offset, basis));
+}
+
+PHP_FUNCTION(aws_crt_input_stream_read) {
+    zend_ulong php_stream = 0;
+    zend_ulong length = 0;
+
+    aws_php_parse_parameters("ll", &php_stream, &length);
+
+    aws_crt_input_stream *stream = (void *)php_stream;
+    uint8_t *buf = emalloc(length);
+    int ret = aws_crt_input_stream_read(stream, buf, length);
+    XRETVAL_STRINGL((const char *)buf, length);
+    efree(buf);
+}
+
+PHP_FUNCTION(aws_crt_input_stream_eof) {
+    zend_ulong php_stream = 0;
+
+    aws_php_parse_parameters("l", &php_stream);
+
+    aws_crt_input_stream *stream = (void *)php_stream;
+    aws_crt_input_stream_status status = {0};
+    aws_crt_input_stream_get_status(stream, &status);
+    RETURN_BOOL(status.is_end_of_stream);
+}
+
+PHP_FUNCTION(aws_crt_input_stream_get_length) {
+    zend_ulong php_stream = 0;
+
+    aws_php_parse_parameters("l", &php_stream);
+
+    aws_crt_input_stream *stream = (void *)php_stream;
+    int64_t length = 0;
+    aws_crt_input_stream_get_length(stream, &length);
+    RETURN_LONG(length);
+}

--- server/vendor/aws/aws-crt-php/format-check.sh ---
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+if [[ -z $CLANG_FORMAT ]] ; then
+    CLANG_FORMAT=clang-format
+fi
+
+if NOT type $CLANG_FORMAT 2> /dev/null ; then
+    echo "No appropriate clang-format found."
+    exit 1
+fi
+
+FAIL=0
+SOURCE_FILES=`find src ext -type f \( -name '*.c' \)`
+for i in $SOURCE_FILES
+do
+    $CLANG_FORMAT -output-replacements-xml $i | grep -c "<replacement " > /dev/null
+    if [ $? -ne 1 ]
+    then
+        echo "$i failed clang-format check."
+        FAIL=1
+    fi
+done
+
+exit $FAIL

--- server/vendor/aws/aws-crt-php/gen_api.php ---
@@ -0,0 +1,24 @@
+<?php
+
+$source = "php://stdin";
+if (isset($argv[1])) {
+    $source = $argv[1];
+}
+
+$input_lines = file($source);
+foreach ($input_lines as $line) {
+    // Strip AWS_EXTERN_C_BEGIN/END
+    if (preg_match('/AWS_EXTERN_C/', $line)) {
+        continue;
+    }
+
+    // Strip macros/includes
+    if (preg_match('/^#/', $line)) {
+        continue;
+    }
+
+    // Strip visibility attributes
+    $line = str_replace('AWS_CRT_API ', '', $line);
+
+    echo($line);
+}

--- server/vendor/aws/aws-crt-php/gen_stub.php ---
@@ -0,0 +1,1998 @@
+#!/usr/bin/env php
+<?php declare(strict_types=1);
+
+// This is a copy of the gen_stub.php from the PHP build scripts, modified to
+// generate macros that we can abstract across versions of PHP
+
+use PhpParser\Comment\Doc as DocComment;
+use PhpParser\Node;
+use PhpParser\Node\Expr;
+use PhpParser\Node\Name;
+use PhpParser\Node\Stmt;
+use PhpParser\Node\Stmt\Class_;
+use PhpParser\PrettyPrinter\Standard;
+use PhpParser\PrettyPrinterAbstract;
+
+error_reporting(E_ALL);
+
+/**
+ * @return FileInfo[]
+ */
+function processDirectory(string $dir, Context $context): array {
+    $fileInfos = [];
+
+    $it = new RecursiveIteratorIterator(
+        new RecursiveDirectoryIterator($dir),
+        RecursiveIteratorIterator::LEAVES_ONLY
+    );
+    foreach ($it as $file) {
+        $pathName = $file->getPathName();
+        if (preg_match('/\.stub\.php$/', $pathName)) {
+            $fileInfo = processStubFile($pathName, $context);
+            if ($fileInfo) {
+                $fileInfos[] = $fileInfo;
+            }
+        }
+    }
+
+    return $fileInfos;
+}
+
+function processStubFile(string $stubFile, Context $context): ?FileInfo {
+    try {
+        if (!file_exists($stubFile)) {
+            throw new Exception("File $stubFile does not exist");
+        }
+
+        $arginfoFile = str_replace('.stub.php', '_arginfo.h', $stubFile);
+        $legacyFile = str_replace('.stub.php', '_legacy_arginfo.h', $stubFile);
+
+        $stubCode = file_get_contents($stubFile);
+        $stubHash = computeStubHash($stubCode);
+        $oldStubHash = extractStubHash($arginfoFile);
+        if ($stubHash === $oldStubHash && !$context->forceParse) {
+            /* Stub file did not change, do not regenerate. */
+            return null;
+        }
+
+        initPhpParser();
+        $fileInfo = parseStubFile($stubCode);
+        $arginfoCode = generateArgInfoCode($fileInfo, $stubHash, $context->minimalArgInfo);
+        if (($context->forceRegeneration || $stubHash !== $oldStubHash) && file_put_contents($arginfoFile, $arginfoCode)) {
+            echo "Saved $arginfoFile\n";
+        }
+
+        if ($fileInfo->generateLegacyArginfo) {
+            foreach ($fileInfo->getAllFuncInfos() as $funcInfo) {
+                $funcInfo->discardInfoForOldPhpVersions();
+            }
+            $arginfoCode = generateArgInfoCode($fileInfo, $stubHash, $context->minimalArgInfo);
+            if (($context->forceRegeneration || $stubHash !== $oldStubHash) && file_put_contents($legacyFile, $arginfoCode)) {
+                echo "Saved $legacyFile\n";
+            }
+		}
+
+        return $fileInfo;
+    } catch (Exception $e) {
+        echo "In $stubFile:\n{$e->getMessage()}\n";
+        exit(1);
+    }
+}
+
+function computeStubHash(string $stubCode): string {
+    return sha1(str_replace("\r\n", "\n", $stubCode));
+}
+
+function extractStubHash(string $arginfoFile): ?string {
+    if (!file_exists($arginfoFile)) {
+        return null;
+    }
+
+    $arginfoCode = file_get_contents($arginfoFile);
+    if (!preg_match('/\* Stub hash: ([0-9a-f]+) \*/', $arginfoCode, $matches)) {
+        return null;
+    }
+
+    return $matches[1];
+}
+
+class Context {
+    /** @var bool */
+    public $forceParse = false;
+    /** @var bool */
+    public $forceRegeneration = false;
+    /** @var bool */
+    public $minimalArgInfo = false;
+}
+
+class SimpleType {
+    /** @var string */
+    public $name;
+    /** @var bool */
+    public $isBuiltin;
+
+    public function __construct(string $name, bool $isBuiltin) {
+        $this->name = $name;
+        $this->isBuiltin = $isBuiltin;
+    }
+
+    public static function fromNode(Node $node): SimpleType {
+        if ($node instanceof Node\Name) {
+            if ($node->toLowerString() === 'static') {
+                // PHP internally considers "static" a builtin type.
+                return new SimpleType($node->toString(), true);
+            }
+
+            assert($node->isFullyQualified());
+            return new SimpleType($node->toString(), false);
+        }
+        if ($node instanceof Node\Identifier) {
+            return new SimpleType($node->toString(), true);
+        }
+        throw new Exception("Unexpected node type");
+    }
+
+    public static function fromPhpDoc(string $type): SimpleType
+    {
+        switch (strtolower($type)) {
+            case "void":
+            case "null":
+            case "false":
+            case "bool":
+            case "int":
+            case "float":
+            case "string":
+            case "array":
+            case "iterable":
+            case "object":
+            case "resource":
+            case "mixed":
+            case "self":
+            case "static":
+                return new SimpleType(strtolower($type), true);
+        }
+
+        if (strpos($type, "[]") !== false) {
+            return new SimpleType("array", true);
+        }
+
+        return new SimpleType($type, false);
+    }
+
+    public static function null(): SimpleType
+    {
+        return new SimpleType("null", true);
+    }
+
+    public static function void(): SimpleType
+    {
+        return new SimpleType("void", true);
+    }
+
+    public function isNull(): bool {
+        return $this->isBuiltin && $this->name === 'null';
+    }
+
+    public function toTypeCode(): string {
+        assert($this->isBuiltin);
+        switch (strtolower($this->name)) {
+        case "bool":
+            return "_IS_BOOL";
+        case "int":
+            return "IS_LONG";
+        case "float":
+            return "IS_DOUBLE";
+        case "string":
+            return "IS_STRING";
+        case "array":
+            return "IS_ARRAY";
+        case "object":
+            return "IS_OBJECT";
+        case "void":
+            return "IS_VOID";
+        case "callable":
+            return "IS_CALLABLE";
+        case "iterable":
+            return "IS_ITERABLE";
+        case "mixed":
+            return "IS_MIXED";
+        case "static":
+            return "IS_STATIC";
+        default:
+            throw new Exception("Not implemented: $this->name");
+        }
+    }
+
+    public function toTypeMask() {
+        assert($this->isBuiltin);
+        switch (strtolower($this->name)) {
+        case "null":
+            return "MAY_BE_NULL";
+        case "false":
+            return "MAY_BE_FALSE";
+        case "bool":
+            return "MAY_BE_BOOL";
+        case "int":
+            return "MAY_BE_LONG";
+        case "float":
+            return "MAY_BE_DOUBLE";
+        case "string":
+            return "MAY_BE_STRING";
+        case "array":
+            return "MAY_BE_ARRAY";
+        case "object":
+            return "MAY_BE_OBJECT";
+        case "callable":
+            return "MAY_BE_CALLABLE";
+        case "mixed":
+            return "MAY_BE_ANY";
+        case "static":
+            return "MAY_BE_STATIC";
+        default:
+            throw new Exception("Not implemented: $this->name");
+        }
+    }
+
+    public function toEscapedName(): string {
+        return str_replace('\\', '\\\\', $this->name);
+    }
+
+    public function equals(SimpleType $other) {
+        return $this->name === $other->name
+            && $this->isBuiltin === $other->isBuiltin;
+    }
+}
+
+class Type {
+    /** @var SimpleType[] $types */
+    public $types;
+
+    public function __construct(array $types) {
+        $this->types = $types;
+    }
+
+    public static function fromNode(Node $node): Type {
+        if ($node instanceof Node\UnionType) {
+            return new Type(array_map(['SimpleType', 'fromNode'], $node->types));
+        }
+        if ($node instanceof Node\NullableType) {
+            return new Type([
+                SimpleType::fromNode($node->type),
+                SimpleType::null(),
+            ]);
+        }
+        return new Type([SimpleType::fromNode($node)]);
+    }
+
+    public static function fromPhpDoc(string $phpDocType) {
+        $types = explode("|", $phpDocType);
+
+        $simpleTypes = [];
+        foreach ($types as $type) {
+            $simpleTypes[] = SimpleType::fromPhpDoc($type);
+        }
+
+        return new Type($simpleTypes);
+    }
+
+    public function isNullable(): bool {
+        foreach ($this->types as $type) {
+            if ($type->isNull()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public function getWithoutNull(): Type {
+        return new Type(array_filter($this->types, function(SimpleType $type) {
+            return !$type->isNull();
+        }));
+    }
+
+    public function tryToSimpleType(): ?SimpleType {
+        $withoutNull = $this->getWithoutNull();
+        if (count($withoutNull->types) === 1) {
+            return $withoutNull->types[0];
+        }
+        return null;
+    }
+
+    public function toArginfoType(): ?ArginfoType {
+        $classTypes = [];
+        $builtinTypes = [];
+        foreach ($this->types as $type) {
+            if ($type->isBuiltin) {
+                $builtinTypes[] = $type;
+            } else {
+                $classTypes[] = $type;
+            }
+        }
+        return new ArginfoType($classTypes, $builtinTypes);
+    }
+
+    public static function equals(?Type $a, ?Type $b): bool {
+        if ($a === null || $b === null) {
+            return $a === $b;
+        }
+
+        if (count($a->types) !== count($b->types)) {
+            return false;
+        }
+
+        for ($i = 0; $i < count($a->types); $i++) {
+            if (!$a->types[$i]->equals($b->types[$i])) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public function __toString() {
+        if ($this->types === null) {
+            return 'mixed';
+        }
+
+        return implode('|', array_map(
+            function ($type) { return $type->name; },
+            $this->types)
+        );
+    }
+}
+
+class ArginfoType {
+    /** @var ClassType[] $classTypes */
+    public $classTypes;
+
+    /** @var SimpleType[] $builtinTypes */
+    private $builtinTypes;
+
+    public function __construct(array $classTypes, array $builtinTypes) {
+        $this->classTypes = $classTypes;
+        $this->builtinTypes = $builtinTypes;
+    }
+
+    public function hasClassType(): bool {
+        return !empty($this->classTypes);
+    }
+
+    public function toClassTypeString(): string {
+        return implode('|', array_map(function(SimpleType $type) {
+            return $type->toEscapedName();
+        }, $this->classTypes));
+    }
+
+    public function toTypeMask(): string {
+        if (empty($this->builtinTypes)) {
+            return '0';
+        }
+        return implode('|', array_map(function(SimpleType $type) {
+            return $type->toTypeMask();
+        }, $this->builtinTypes));
+    }
+}
+
+class ArgInfo {
+    const SEND_BY_VAL = 0;
+    const SEND_BY_REF = 1;
+    const SEND_PREFER_REF = 2;
+
+    /** @var string */
+    public $name;
+    /** @var int */
+    public $sendBy;
+    /** @var bool */
+    public $isVariadic;
+    /** @var Type|null */
+    public $type;
+    /** @var Type|null */
+    public $phpDocType;
+    /** @var string|null */
+    public $defaultValue;
+
+    public function __construct(string $name, int $sendBy, bool $isVariadic, ?Type $type, ?Type $phpDocType, ?string $defaultValue) {
+        $this->name = $name;
+        $this->sendBy = $sendBy;
+        $this->isVariadic = $isVariadic;
+        $this->type = $type;
+        $this->phpDocType = $phpDocType;
+        $this->defaultValue = $defaultValue;
+    }
+
+    public function equals(ArgInfo $other): bool {
+        return $this->name === $other->name
+            && $this->sendBy === $other->sendBy
+            && $this->isVariadic === $other->isVariadic
+            && Type::equals($this->type, $other->type)
+            && $this->defaultValue === $other->defaultValue;
+    }
+
+    public function getSendByString(): string {
+        switch ($this->sendBy) {
+        case self::SEND_BY_VAL:
+            return "0";
+        case self::SEND_BY_REF:
+            return "1";
+        case self::SEND_PREFER_REF:
+            return "ZEND_SEND_PREFER_REF";
+        }
+        throw new Exception("Invalid sendBy value");
+    }
+
+    public function getMethodSynopsisType(): Type {
+        if ($this->type) {
+            return $this->type;
+        }
+
+        if ($this->phpDocType) {
+            return $this->phpDocType;
+        }
+
+        throw new Exception("A parameter must have a type");
+    }
+
+    public function hasProperDefaultValue(): bool {
+        return $this->defaultValue !== null && $this->defaultValue !== "UNKNOWN";
+    }
+
+    public function getDefaultValueAsArginfoString(): string {
+        if ($this->hasProperDefaultValue()) {
+            return '"' . addslashes($this->defaultValue) . '"';
+        }
+
+        return "NULL";
+    }
+
+    public function getDefaultValueAsMethodSynopsisString(): ?string {
+        if ($this->defaultValue === null) {
+            return null;
+        }
+
+        switch ($this->defaultValue) {
+            case 'UNKNOWN':
+                return null;
+            case 'false':
+            case 'true':
+            case 'null':
+                return "&{$this->defaultValue};";
+        }
+
+        return $this->defaultValue;
+    }
+}
+
+interface FunctionOrMethodName {
+    public function getDeclaration(): string;
+    public function getArgInfoName(): string;
+    public function getMethodSynopsisFilename(): string;
+    public function __toString(): string;
+    public function isMethod(): bool;
+    public function isConstructor(): bool;
+    public function isDestructor(): bool;
+}
+
+class FunctionName implements FunctionOrMethodName {
+    /** @var Name */
+    private $name;
+
+    public function __construct(Name $name) {
+        $this->name = $name;
+    }
+
+    public function getNamespace(): ?string {
+        if ($this->name->isQualified()) {
+            return $this->name->slice(0, -1)->toString();
+        }
+        return null;
+    }
+
+    public function getNonNamespacedName(): string {
+        if ($this->name->isQualified()) {
+            throw new Exception("Namespaced name not supported here");
+        }
+        return $this->name->toString();
+    }
+
+    public function getDeclarationName(): string {
+        return $this->name->getLast();
+    }
+
+    public function getDeclaration(): string {
+        return "ZEND_FUNCTION({$this->getDeclarationName()});\n";
+    }
+
+    public function getArgInfoName(): string {
+        $underscoreName = implode('_', $this->name->parts);
+        return "arginfo_$underscoreName";
+    }
+
+    public function getMethodSynopsisFilename(): string {
+        return implode('_', $this->name->parts);
+    }
+
+    public function __toString(): string {
+        return $this->name->toString();
+    }
+
+    public function isMethod(): bool {
+        return false;
+    }
+
+    public function isConstructor(): bool {
+        return false;
+    }
+
+    public function isDestructor(): bool {
+        return false;
+    }
+}
+
+class MethodName implements FunctionOrMethodName {
+    /** @var Name */
+    private $className;
+    /** @var string */
+    public $methodName;
+
+    public function __construct(Name $className, string $methodName) {
+        $this->className = $className;
+        $this->methodName = $methodName;
+    }
+
+    public function getDeclarationClassName(): string {
+        return implode('_', $this->className->parts);
+    }
+
+    public function getDeclaration(): string {
+        return "ZEND_METHOD({$this->getDeclarationClassName()}, $this->methodName);\n";
+    }
+
+    public function getArgInfoName(): string {
+        return "arginfo_class_{$this->getDeclarationClassName()}_{$this->methodName}";
+    }
+
+    public function getMethodSynopsisFilename(): string {
+        return $this->getDeclarationClassName() . "_{$this->methodName}";
+    }
+
+    public function __toString(): string {
+        return "$this->className::$this->methodName";
+    }
+
+    public function isMethod(): bool {
+        return true;
+    }
+
+    public function isConstructor(): bool {
+        return $this->methodName === "__construct";
+    }
+
+    public function isDestructor(): bool {
+        return $this->methodName === "__destruct";
+    }
+}
+
+class ReturnInfo {
+    /** @var bool */
+    public $byRef;
+    /** @var Type|null */
+    public $type;
+    /** @var Type|null */
+    public $phpDocType;
+
+    public function __construct(bool $byRef, ?Type $type, ?Type $phpDocType) {
+        $this->byRef = $byRef;
+        $this->type = $type;
+        $this->phpDocType = $phpDocType;
+    }
+
+    public function equals(ReturnInfo $other): bool {
+        return $this->byRef === $other->byRef
+            && Type::equals($this->type, $other->type);
+    }
+
+    public function getMethodSynopsisType(): ?Type {
+        return $this->type ?? $this->phpDocType;
+    }
+}
+
+class FuncInfo {
+    /** @var FunctionOrMethodName */
+    public $name;
+    /** @var int */
+    public $classFlags;
+    /** @var int */
+    public $flags;
+    /** @var string|null */
+    public $aliasType;
+    /** @var FunctionName|null */
+    public $alias;
+    /** @var bool */
+    public $isDeprecated;
+    /** @var bool */
+    public $verify;
+    /** @var ArgInfo[] */
+    public $args;
+    /** @var ReturnInfo */
+    public $return;
+    /** @var int */
+    public $numRequiredArgs;
+    /** @var string|null */
+    public $cond;
+
+    public function __construct(
+        FunctionOrMethodName $name,
+        int $classFlags,
+        int $flags,
+        ?string $aliasType,
+        ?FunctionOrMethodName $alias,
+        bool $isDeprecated,
+        bool $verify,
+        array $args,
+        ReturnInfo $return,
+        int $numRequiredArgs,
+        ?string $cond
+    ) {
+        $this->name = $name;
+        $this->classFlags = $classFlags;
+        $this->flags = $flags;
+        $this->aliasType = $aliasType;
+        $this->alias = $alias;
+        $this->isDeprecated = $isDeprecated;
+        $this->verify = $verify;
+        $this->args = $args;
+        $this->return = $return;
+        $this->numRequiredArgs = $numRequiredArgs;
+        $this->cond = $cond;
+    }
+
+    public function isMethod(): bool
+    {
+        return $this->name->isMethod();
+    }
+
+    public function isFinalMethod(): bool
+    {
+        return ($this->flags & Class_::MODIFIER_FINAL) || ($this->classFlags & Class_::MODIFIER_FINAL);
+    }
+
+    public function isInstanceMethod(): bool
+    {
+        return !($this->flags & Class_::MODIFIER_STATIC) && $this->isMethod() && !$this->name->isConstructor();
+    }
+
+    /** @return string[] */
+    public function getModifierNames(): array
+    {
+        if (!$this->isMethod()) {
+            return [];
+        }
+
+        $result = [];
+
+        if ($this->flags & Class_::MODIFIER_FINAL) {
+            $result[] = "final";
+        } elseif ($this->flags & Class_::MODIFIER_ABSTRACT && $this->classFlags & ~Class_::MODIFIER_ABSTRACT) {
+            $result[] = "abstract";
+        }
+
+        if ($this->flags & Class_::MODIFIER_PROTECTED) {
+            $result[] = "protected";
+        } elseif ($this->flags & Class_::MODIFIER_PRIVATE) {
+            $result[] = "private";
+        } else {
+            $result[] = "public";
+        }
+
+        if ($this->flags & Class_::MODIFIER_STATIC) {
+            $result[] = "static";
+        }
+
+        return $result;
+    }
+
+    public function hasParamWithUnknownDefaultValue(): bool
+    {
+        foreach ($this->args as $arg) {
+            if ($arg->defaultValue && !$arg->hasProperDefaultValue()) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public function equalsApartFromName(FuncInfo $other): bool {
+        if (count($this->args) !== count($other->args)) {
+            return false;
+        }
+
+        for ($i = 0; $i < count($this->args); $i++) {
+            if (!$this->args[$i]->equals($other->args[$i])) {
+                return false;
+            }
+        }
+
+        return $this->return->equals($other->return)
+            && $this->numRequiredArgs === $other->numRequiredArgs
+            && $this->cond === $other->cond;
+    }
+
+    public function getArgInfoName(): string {
+        return $this->name->getArgInfoName();
+    }
+
+    public function getDeclarationKey(): string
+    {
+        $name = $this->alias ?? $this->name;
+
+        return "$name|$this->cond";
+    }
+
+    public function getDeclaration(): ?string
+    {
+        if ($this->flags & Class_::MODIFIER_ABSTRACT) {
+            return null;
+        }
+
+        $name = $this->alias ?? $this->name;
+
+        return $name->getDeclaration();
+    }
+
+    public function getFunctionEntry(): string {
+        if ($this->name instanceof MethodName) {
+            if ($this->alias) {
+                if ($this->alias instanceof MethodName) {
+                    return sprintf(
+                        "\tZEND_MALIAS(%s, %s, %s, %s, %s)\n",
+                        $this->alias->getDeclarationClassName(), $this->name->methodName,
+                        $this->alias->methodName, $this->getArgInfoName(), $this->getFlagsAsArginfoString()
+                    );
+                } else if ($this->alias instanceof FunctionName) {
+                    return sprintf(
+                        "\tZEND_ME_MAPPING(%s, %s, %s, %s)\n",
+                        $this->name->methodName, $this->alias->getNonNamespacedName(),
+                        $this->getArgInfoName(), $this->getFlagsAsArginfoString()
+                    );
+                } else {
+                    throw new Error("Cannot happen");
+                }
+            } else {
+                $declarationClassName = $this->name->getDeclarationClassName();
+                if ($this->flags & Class_::MODIFIER_ABSTRACT) {
+                    return sprintf(
+                        "\tZEND_ABSTRACT_ME_WITH_FLAGS(%s, %s, %s, %s)\n",
+                        $declarationClassName, $this->name->methodName, $this->getArgInfoName(),
+                        $this->getFlagsAsArginfoString()
+                    );
+                }
+
+                return sprintf(
+                    "\tZEND_ME(%s, %s, %s, %s)\n",
+                    $declarationClassName, $this->name->methodName, $this->getArgInfoName(),
+                    $this->getFlagsAsArginfoString()
+                );
+            }
+        } else if ($this->name instanceof FunctionName) {
+            $namespace = $this->name->getNamespace();
+            $declarationName = $this->name->getDeclarationName();
+
+            if ($this->alias && $this->isDeprecated) {
+                return sprintf(
+                    "\tZEND_DEP_FALIAS(%s, %s, %s)\n",
+                    $declarationName, $this->alias->getNonNamespacedName(), $this->getArgInfoName()
+                );
+            }
+
+            if ($this->alias) {
+                return sprintf(
+                    "\tZEND_FALIAS(%s, %s, %s)\n",
+                    $declarationName, $this->alias->getNonNamespacedName(), $this->getArgInfoName()
+                );
+            }
+
+            if ($this->isDeprecated) {
+                return sprintf(
+                    "\tZEND_DEP_FE(%s, %s)\n", $declarationName, $this->getArgInfoName());
+            }
+
+            if ($namespace) {
+                // Render A\B as "A\\B" in C strings for namespaces
+                return sprintf(
+                    "\tZEND_NS_FE(\"%s\", %s, %s)\n",
+                    addslashes($namespace), $declarationName, $this->getArgInfoName());
+            } else {
+                return sprintf("\tZEND_FE(%s, %s)\n", $declarationName, $this->getArgInfoName());
+            }
+        } else {
+            throw new Error("Cannot happen");
+        }
+    }
+
+    private function getFlagsAsArginfoString(): string
+    {
+        $flags = "ZEND_ACC_PUBLIC";
+        if ($this->flags & Class_::MODIFIER_PROTECTED) {
+            $flags = "ZEND_ACC_PROTECTED";
+        } elseif ($this->flags & Class_::MODIFIER_PRIVATE) {
+            $flags = "ZEND_ACC_PRIVATE";
+        }
+
+        if ($this->flags & Class_::MODIFIER_STATIC) {
+            $flags .= "|ZEND_ACC_STATIC";
+        }
+
+        if ($this->flags & Class_::MODIFIER_FINAL) {
+            $flags .= "|ZEND_ACC_FINAL";
+        }
+
+        if ($this->flags & Class_::MODIFIER_ABSTRACT) {
+            $flags .= "|ZEND_ACC_ABSTRACT";
+        }
+
+        if ($this->isDeprecated) {
+            $flags .= "|ZEND_ACC_DEPRECATED";
+        }
+
+        return $flags;
+    }
+
+    /**
+     * @param FuncInfo[] $funcMap
+     * @param FuncInfo[] $aliasMap
+     * @throws Exception
+     */
+    public function getMethodSynopsisDocument(array $funcMap, array $aliasMap): ?string {
+
+        $doc = new DOMDocument();
+        $doc->formatOutput = true;
+        $methodSynopsis = $this->getMethodSynopsisElement($funcMap, $aliasMap, $doc);
+        if (!$methodSynopsis) {
+            return null;
+        }
+
+        $doc->appendChild($methodSynopsis);
+
+        return $doc->saveXML();
+    }
+
+    /**
+     * @param FuncInfo[] $funcMap
+     * @param FuncInfo[] $aliasMap
+     * @throws Exception
+     */
+    public function getMethodSynopsisElement(array $funcMap, array $aliasMap, DOMDocument $doc): ?DOMElement {
+        if ($this->hasParamWithUnknownDefaultValue()) {
+            return null;
+        }
+
+        if ($this->name->isConstructor()) {
+            $synopsisType = "constructorsynopsis";
+        } elseif ($this->name->isDestructor()) {
+            $synopsisType = "destructorsynopsis";
+        } else {
+            $synopsisType = "methodsynopsis";
+        }
+
+        $methodSynopsis = $doc->createElement($synopsisType);
+
+        $aliasedFunc = $this->aliasType === "alias" && isset($funcMap[$this->alias->__toString()]) ? $funcMap[$this->alias->__toString()] : null;
+        $aliasFunc = $aliasMap[$this->name->__toString()] ?? null;
+
+        if (($this->aliasType === "alias" && $aliasedFunc !== null && $aliasedFunc->isMethod() !== $this->isMethod()) ||
+            ($aliasFunc !== null && $aliasFunc->isMethod() !== $this->isMethod())
+        ) {
+            $role = $doc->createAttribute("role");
+            $role->value = $this->isMethod() ? "oop" : "procedural";
+            $methodSynopsis->appendChild($role);
+        }
+
+        $methodSynopsis->appendChild(new DOMText("\n   "));
+
+        foreach ($this->getModifierNames() as $modifierString) {
+            $modifierElement = $doc->createElement('modifier', $modifierString);
+            $methodSynopsis->appendChild($modifierElement);
+            $methodSynopsis->appendChild(new DOMText(" "));
+        }
+
+        $returnType = $this->return->getMethodSynopsisType();
+        if ($returnType) {
+            $this->appendMethodSynopsisTypeToElement($doc, $methodSynopsis, $returnType);
+        }
+
+        $methodname = $doc->createElement('methodname', $this->name->__toString());
+        $methodSynopsis->appendChild($methodname);
+
+        if (empty($this->args)) {
+            $methodSynopsis->appendChild(new DOMText("\n   "));
+            $void = $doc->createElement('void');
+            $methodSynopsis->appendChild($void);
+        } else {
+            foreach ($this->args as $arg) {
+                $methodSynopsis->appendChild(new DOMText("\n   "));
+                $methodparam = $doc->createElement('methodparam');
+                if ($arg->defaultValue !== null) {
+                    $methodparam->setAttribute("choice", "opt");
+                }
+                if ($arg->isVariadic) {
+                    $methodparam->setAttribute("rep", "repeat");
+                }
+
+                $methodSynopsis->appendChild($methodparam);
+                $this->appendMethodSynopsisTypeToElement($doc, $methodparam, $arg->getMethodSynopsisType());
+
+                $parameter = $doc->createElement('parameter', $arg->name);
+                if ($arg->sendBy !== ArgInfo::SEND_BY_VAL) {
+                    $parameter->setAttribute("role", "reference");
+                }
+
+                $methodparam->appendChild($parameter);
+                $defaultValue = $arg->getDefaultValueAsMethodSynopsisString();
+                if ($defaultValue !== null) {
+                    $initializer = $doc->createElement('initializer');
+                    if (preg_match('/^[a-zA-Z_][a-zA-Z_0-9]*$/', $defaultValue)) {
+                        $constant = $doc->createElement('constant', $defaultValue);
+                        $initializer->appendChild($constant);
+                    } else {
+                        $initializer->nodeValue = $defaultValue;
+                    }
+                    $methodparam->appendChild($initializer);
+                }
+            }
+        }
+        $methodSynopsis->appendChild(new DOMText("\n  "));
+
+        return $methodSynopsis;
+    }
+
+    public function discardInfoForOldPhpVersions(): void {
+        $this->return->type = null;
+        foreach ($this->args as $arg) {
+            $arg->type = null;
+            $arg->defaultValue = null;
+        }
+    }
+
+    private function appendMethodSynopsisTypeToElement(DOMDocument $doc, DOMElement $elementToAppend, Type $type) {
+        if (count($type->types) > 1) {
+            $typeElement = $doc->createElement('type');
+            $typeElement->setAttribute("class", "union");
+
+            foreach ($type->types as $type) {
+                $unionTypeElement = $doc->createElement('type', $type->name);
+                $typeElement->appendChild($unionTypeElement);
+            }
+        } else {
+            $typeElement = $doc->createElement('type', $type->types[0]->name);
+        }
+
+        $elementToAppend->appendChild($typeElement);
+    }
+}
+
+class ClassInfo {
+    /** @var Name */
+    public $name;
+    /** @var FuncInfo[] */
+    public $funcInfos;
+
+    public function __construct(Name $name, array $funcInfos) {
+        $this->name = $name;
+        $this->funcInfos = $funcInfos;
+    }
+}
+
+class FileInfo {
+    /** @var FuncInfo[] */
+    public $funcInfos = [];
+    /** @var ClassInfo[] */
+    public $classInfos = [];
+    /** @var bool */
+    public $generateFunctionEntries = false;
+    /** @var string */
+    public $declarationPrefix = "";
+    /** @var bool */
+    public $generateLegacyArginfo = false;
+
+    /**
+     * @return iterable<FuncInfo>
+     */
+    public function getAllFuncInfos(): iterable {
+        yield from $this->funcInfos;
+        foreach ($this->classInfos as $classInfo) {
+            yield from $classInfo->funcInfos;
+        }
+    }
+}
+
+class DocCommentTag {
+    /** @var string */
+    public $name;
+    /** @var string|null */
+    public $value;
+
+    public function __construct(string $name, ?string $value) {
+        $this->name = $name;
+        $this->value = $value;
+    }
+
+    public function getValue(): string {
+        if ($this->value === null) {
+            throw new Exception("@$this->name does not have a value");
+        }
+
+        return $this->value;
+    }
+
+    public function getType(): string {
+        $value = $this->getValue();
+
+        $matches = [];
+
+        if ($this->name === "param") {
+            preg_match('/^\s*([\w\|\\\\\[\]]+)\s*\$\w+.*$/', $value, $matches);
+        } elseif ($this->name === "return") {
+            preg_match('/^\s*([\w\|\\\\\[\]]+)\s*$/', $value, $matches);
+        }
+
+        if (isset($matches[1]) === false) {
+            throw new Exception("@$this->name doesn't contain a type or has an invalid format \"$value\"");
+        }
+
+        return $matches[1];
+    }
+
+    public function getVariableName(): string {
+        $value = $this->value;
+        if ($value === null || strlen($value) === 0) {
+            throw new Exception("@$this->name doesn't have any value");
+        }
+
+        $matches = [];
+
+        if ($this->name === "param") {
+            preg_match('/^\s*[\w\|\\\\\[\]]+\s*\$(\w+).*$/', $value, $matches);
+        } elseif ($this->name === "prefer-ref") {
+            preg_match('/^\s*\$(\w+).*$/', $value, $matches);
+        }
+
+        if (isset($matches[1]) === false) {
+            throw new Exception("@$this->name doesn't contain a variable name or has an invalid format \"$value\"");
+        }
+
+        return $matches[1];
+    }
+}
+
+/** @return DocCommentTag[] */
+function parseDocComment(DocComment $comment): array {
+    $commentText = substr($comment->getText(), 2, -2);
+    $tags = [];
+    foreach (explode("\n", $commentText) as $commentLine) {
+        $regex = '/^\*\s*@([a-z-]+)(?:\s+(.+))?$/';
+        if (preg_match($regex, trim($commentLine), $matches)) {
+            $tags[] = new DocCommentTag($matches[1], $matches[2] ?? null);
+        }
+    }
+
+    return $tags;
+}
+
+function parseFunctionLike(
+    PrettyPrinterAbstract $prettyPrinter,
+    FunctionOrMethodName $name,
+    int $classFlags,
+    int $flags,
+    Node\FunctionLike $func,
+    ?string $cond
+): FuncInfo {
+    $comment = $func->getDocComment();
+    $paramMeta = [];
+    $aliasType = null;
+    $alias = null;
+    $isDeprecated = false;
+    $verify = true;
+    $docReturnType = null;
+    $docParamTypes = [];
+
+    if ($comment) {
+        $tags = parseDocComment($comment);
+        foreach ($tags as $tag) {
+            if ($tag->name === 'prefer-ref') {
+                $varName = $tag->getVariableName();
+                if (!isset($paramMeta[$varName])) {
+                    $paramMeta[$varName] = [];
+                }
+                $paramMeta[$varName]['preferRef'] = true;
+            } else if ($tag->name === 'alias' || $tag->name === 'implementation-alias') {
+                $aliasType = $tag->name;
+                $aliasParts = explode("::", $tag->getValue());
+                if (count($aliasParts) === 1) {
+                    $alias = new FunctionName(new Name($aliasParts[0]));
+                } else {
+                    $alias = new MethodName(new Name($aliasParts[0]), $aliasParts[1]);
+                }
+            } else if ($tag->name === 'deprecated') {
+                $isDeprecated = true;
+            }  else if ($tag->name === 'no-verify') {
+                $verify = false;
+            } else if ($tag->name === 'return') {
+                $docReturnType = $tag->getType();
+            } else if ($tag->name === 'param') {
+                $docParamTypes[$tag->getVariableName()] = $tag->getType();
+            }
+        }
+    }
+
+    $varNameSet = [];
+    $args = [];
+    $numRequiredArgs = 0;
+    $foundVariadic = false;
+    foreach ($func->getParams() as $i => $param) {
+        $varName = $param->var->name;
+        $preferRef = !empty($paramMeta[$varName]['preferRef']);
+        unset($paramMeta[$varName]);
+
+        if (isset($varNameSet[$varName])) {
+            throw new Exception("Duplicate parameter name $varName for function $name");
+        }
+        $varNameSet[$varName] = true;
+
+        if ($preferRef) {
+            $sendBy = ArgInfo::SEND_PREFER_REF;
+        } else if ($param->byRef) {
+            $sendBy = ArgInfo::SEND_BY_REF;
+        } else {
+            $sendBy = ArgInfo::SEND_BY_VAL;
+        }
+
+        if ($foundVariadic) {
+            throw new Exception("Error in function $name: only the last parameter can be variadic");
+        }
+
+        $type = $param->type ? Type::fromNode($param->type) : null;
+        if ($type === null && !isset($docParamTypes[$varName])) {
+            throw new Exception("Missing parameter type for function $name()");
+        }
+
+        if ($param->default instanceof Expr\ConstFetch &&
+            $param->default->name->toLowerString() === "null" &&
+            $type && !$type->isNullable()
+        ) {
+            $simpleType = $type->tryToSimpleType();
+            if ($simpleType === null) {
+                throw new Exception(
+                    "Parameter $varName of function $name has null default, but is not nullable");
+            }
+        }
+
+        $foundVariadic = $param->variadic;
+
+        $args[] = new ArgInfo(
+            $varName,
+            $sendBy,
+            $param->variadic,
+            $type,
+            isset($docParamTypes[$varName]) ? Type::fromPhpDoc($docParamTypes[$varName]) : null,
+            $param->default ? $prettyPrinter->prettyPrintExpr($param->default) : null
+        );
+        if (!$param->default && !$param->variadic) {
+            $numRequiredArgs = $i + 1;
+        }
+    }
+
+    foreach (array_keys($paramMeta) as $var) {
+        throw new Exception("Found metadata for invalid param $var of function $name");
+    }
+
+    $returnType = $func->getReturnType();
+    if ($returnType === null && $docReturnType === null && !$name->isConstructor() && !$name->isDestructor()) {
+        throw new Exception("Missing return type for function $name()");
+    }
+
+    $return = new ReturnInfo(
+        $func->returnsByRef(),
+        $returnType ? Type::fromNode($returnType) : null,
+        $docReturnType ? Type::fromPhpDoc($docReturnType) : null
+    );
+
+    return new FuncInfo(
+        $name,
+        $classFlags,
+        $flags,
+        $aliasType,
+        $alias,
+        $isDeprecated,
+        $verify,
+        $args,
+        $return,
+        $numRequiredArgs,
+        $cond
+    );
+}
+
+function handlePreprocessorConditions(array &$conds, Stmt $stmt): ?string {
+    foreach ($stmt->getComments() as $comment) {
+        $text = trim($comment->getText());
+        if (preg_match('/^#\s*if\s+(.+)$/', $text, $matches)) {
+            $conds[] = $matches[1];
+        } else if (preg_match('/^#\s*ifdef\s+(.+)$/', $text, $matches)) {
+            $conds[] = "defined($matches[1])";
+        } else if (preg_match('/^#\s*ifndef\s+(.+)$/', $text, $matches)) {
+            $conds[] = "!defined($matches[1])";
+        } else if (preg_match('/^#\s*else$/', $text)) {
+            if (empty($conds)) {
+                throw new Exception("Encountered else without corresponding #if");
+            }
+            $cond = array_pop($conds);
+            $conds[] = "!($cond)";
+        } else if (preg_match('/^#\s*endif$/', $text)) {
+            if (empty($conds)) {
+                throw new Exception("Encountered #endif without corresponding #if");
+            }
+            array_pop($conds);
+        } else if ($text[0] === '#') {
+            throw new Exception("Unrecognized preprocessor directive \"$text\"");
+        }
+    }
+
+    return empty($conds) ? null : implode(' && ', $conds);
+}
+
+function getFileDocComment(array $stmts): ?DocComment {
+    if (empty($stmts)) {
+        return null;
+    }
+
+    $comments = $stmts[0]->getComments();
+    if (empty($comments)) {
+        return null;
+    }
+
+    if ($comments[0] instanceof DocComment) {
+        return $comments[0];
+    }
+
+    return null;
+}
+
+function handleStatements(FileInfo $fileInfo, array $stmts, PrettyPrinterAbstract $prettyPrinter) {
+    $conds = [];
+    foreach ($stmts as $stmt) {
+        if ($stmt instanceof Stmt\Nop) {
+            continue;
+        }
+
+        if ($stmt instanceof Stmt\Namespace_) {
+            handleStatements($fileInfo, $stmt->stmts, $prettyPrinter);
+            continue;
+        }
+
+        $cond = handlePreprocessorConditions($conds, $stmt);
+        if ($stmt instanceof Stmt\Function_) {
+            $fileInfo->funcInfos[] = parseFunctionLike(
+                $prettyPrinter,
+                new FunctionName($stmt->namespacedName),
+                0,
+                0,
+                $stmt,
+                $cond
+            );
+            continue;
+        }
+
+        if ($stmt instanceof Stmt\ClassLike) {
+            $className = $stmt->namespacedName;
+            $methodInfos = [];
+            foreach ($stmt->stmts as $classStmt) {
+                $cond = handlePreprocessorConditions($conds, $classStmt);
+                if ($classStmt instanceof Stmt\Nop) {
+                    continue;
+                }
+
+                if (!$classStmt instanceof Stmt\ClassMethod) {
+                    throw new Exception("Not implemented {$classStmt->getType()}");
+                }
+
+                $classFlags = 0;
+                if ($stmt instanceof Class_) {
+                    $classFlags = $stmt->flags;
+                }
+
+                $flags = $classStmt->flags;
+                if ($stmt instanceof Stmt\Interface_) {
+                    $flags |= Class_::MODIFIER_ABSTRACT;
+                }
+
+                if (!($flags & Class_::VISIBILITY_MODIFIER_MASK)) {
+                    throw new Exception("Method visibility modifier is required");
+                }
+
+                $methodInfos[] = parseFunctionLike(
+                    $prettyPrinter,
+                    new MethodName($className, $classStmt->name->toString()),
+                    $classFlags,
+                    $flags,
+                    $classStmt,
+                    $cond
+                );
+            }
+
+            $fileInfo->classInfos[] = new ClassInfo($className, $methodInfos);
+            continue;
+        }
+
+        throw new Exception("Unexpected node {$stmt->getType()}");
+    }
+}
+
+function parseStubFile(string $code): FileInfo {
+    $lexer = new PhpParser\Lexer();
+    $parser = new PhpParser\Parser\Php7($lexer);
+    $nodeTraverser = new PhpParser\NodeTraverser;
+    $nodeTraverser->addVisitor(new PhpParser\NodeVisitor\NameResolver);
+    $prettyPrinter = new class extends Standard {
+        protected function pName_FullyQualified(Name\FullyQualified $node) {
+            return implode('\\', $node->parts);
+        }
+    };
+
+    $stmts = $parser->parse($code);
+    $nodeTraverser->traverse($stmts);
+
+    $fileInfo = new FileInfo;
+    $fileDocComment = getFileDocComment($stmts);
+    if ($fileDocComment) {
+        $fileTags = parseDocComment($fileDocComment);
+        foreach ($fileTags as $tag) {
+            if ($tag->name === 'generate-function-entries') {
+                $fileInfo->generateFunctionEntries = true;
+                $fileInfo->declarationPrefix = $tag->value ? $tag->value . " " : "";
+            } else if ($tag->name === 'generate-legacy-arginfo') {
+                $fileInfo->generateLegacyArginfo = true;
+            }
+        }
+    }
+
+    handleStatements($fileInfo, $stmts, $prettyPrinter);
+    return $fileInfo;
+}
+
+function funcInfoToCode(FuncInfo $funcInfo, bool $minimal): string {
+    $code = '';
+
+    // Generate the minimal, most compatible arginfo across PHP versions
+    if ($minimal) {
+        $code .= sprintf("ZEND_BEGIN_ARG_INFO_EX(%s, 0, %d, %d)\n",
+            $funcInfo->getArgInfoName(),
+            $funcInfo->return->byRef,
+            $funcInfo->numRequiredArgs);
+        foreach ($funcInfo->args as $argInfo) {
+            $code .= sprintf("\tZEND_ARG_INFO(0, %s)\n", $argInfo->name);
+        }
+    } else {
+        $returnType = $funcInfo->return->type;
+        if ($returnType !== null) {
+            if (null !== $simpleReturnType = $returnType->tryToSimpleType()) {
+                if ($simpleReturnType->isBuiltin) {
+                    $code .= sprintf(
+                        "AWS_PHP_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(%s, %d, %d, %s, %d)\n",
+                        $funcInfo->getArgInfoName(), $funcInfo->return->byRef,
+                        $funcInfo->numRequiredArgs,
+                        $simpleReturnType->toTypeCode(), $returnType->isNullable()
+                    );
+                } else {
+                    $code .= sprintf(
+                        "ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX(%s, %d, %d, %s, %d)\n",
+                        $funcInfo->getArgInfoName(), $funcInfo->return->byRef,
+                        $funcInfo->numRequiredArgs,
+                        $simpleReturnType->toEscapedName(), $returnType->isNullable()
+                    );
+                }
+            } else {
+                $arginfoType = $returnType->toArginfoType();
+                if ($arginfoType->hasClassType()) {
+                    $code .= sprintf(
+                        "ZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(%s, %d, %d, %s, %s)\n",
+                        $funcInfo->getArgInfoName(), $funcInfo->return->byRef,
+                        $funcInfo->numRequiredArgs,
+                        $arginfoType->toClassTypeString(), $arginfoType->toTypeMask()
+                    );
+                } else {
+                    $code .= sprintf(
+                        "ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(%s, %d, %d, %s)\n",
+                        $funcInfo->getArgInfoName(), $funcInfo->return->byRef,
+                        $funcInfo->numRequiredArgs,
+                        $arginfoType->toTypeMask()
+                    );
+                }
+            }
+        } else {
+            $code .= sprintf(
+                "ZEND_BEGIN_ARG_INFO_EX(%s, 0, %d, %d)\n",
+                $funcInfo->getArgInfoName(), $funcInfo->return->byRef, $funcInfo->numRequiredArgs
+            );
+        }
+
+        foreach ($funcInfo->args as $argInfo) {
+            $argKind = $argInfo->isVariadic ? "ARG_VARIADIC" : "ARG";
+            $argDefaultKind = $argInfo->hasProperDefaultValue() ? "_WITH_DEFAULT_VALUE" : "";
+            $argType = $argInfo->type;
+            if ($argType !== null) {
+                if (null !== $simpleArgType = $argType->tryToSimpleType()) {
+                    if ($simpleArgType->isBuiltin) {
+                        $code .= sprintf(
+                            "\tZEND_%s_TYPE_INFO%s(%s, %s, %s, %d%s)\n",
+                            $argKind, $argDefaultKind, $argInfo->getSendByString(), $argInfo->name,
+                            $simpleArgType->toTypeCode(), $argType->isNullable(),
+                            $argInfo->hasProperDefaultValue() ? ", " . $argInfo->getDefaultValueAsArginfoString() : ""
+                        );
+                    } else {
+                        $code .= sprintf(
+                            "\tZEND_%s_OBJ_INFO%s(%s, %s, %s, %d%s)\n",
+                            $argKind,$argDefaultKind, $argInfo->getSendByString(), $argInfo->name,
+                            $simpleArgType->toEscapedName(), $argType->isNullable(),
+                            $argInfo->hasProperDefaultValue() ? ", " . $argInfo->getDefaultValueAsArginfoString() : ""
+                        );
+                    }
+                } else {
+                    $arginfoType = $argType->toArginfoType();
+                    if ($arginfoType->hasClassType()) {
+                        $code .= sprintf(
+                            "\tZEND_%s_OBJ_TYPE_MASK(%s, %s, %s, %s, %s)\n",
+                            $argKind, $argInfo->getSendByString(), $argInfo->name,
+                            $arginfoType->toClassTypeString(), $arginfoType->toTypeMask(),
+                            $argInfo->getDefaultValueAsArginfoString()
+                        );
+                    } else {
+                        $code .= sprintf(
+                            "\tZEND_%s_TYPE_MASK(%s, %s, %s, %s)\n",
+                            $argKind, $argInfo->getSendByString(), $argInfo->name,
+                            $arginfoType->toTypeMask(),
+                            $argInfo->getDefaultValueAsArginfoString()
+                        );
+                    }
+                }
+            } else {
+                $code .= sprintf(
+                    "\tZEND_%s_INFO%s(%s, %s%s)\n",
+                    $argKind, $argDefaultKind, $argInfo->getSendByString(), $argInfo->name,
+                    $argInfo->hasProperDefaultValue() ? ", " . $argInfo->getDefaultValueAsArginfoString() : ""
+                );
+            }
+        }
+    }
+
+    $code .= "ZEND_END_ARG_INFO()";
+    return $code . "\n";
+}
+
+/** @param FuncInfo[] $generatedFuncInfos */
+function findEquivalentFuncInfo(array $generatedFuncInfos, FuncInfo $funcInfo): ?FuncInfo {
+    foreach ($generatedFuncInfos as $generatedFuncInfo) {
+        if ($generatedFuncInfo->equalsApartFromName($funcInfo)) {
+            return $generatedFuncInfo;
+        }
+    }
+    return null;
+}
+
+/** @param iterable<FuncInfo> $funcInfos */
+function generateCodeWithConditions(
+        iterable $funcInfos, string $separator, Closure $codeGenerator): string {
+    $code = "";
+    foreach ($funcInfos as $funcInfo) {
+        $funcCode = $codeGenerator($funcInfo);
+        if ($funcCode === null) {
+            continue;
+        }
+
+        $code .= $separator;
+        if ($funcInfo->cond) {
+            $code .= "#if {$funcInfo->cond}\n";
+            $code .= $funcCode;
+            $code .= "#endif\n";
+        } else {
+            $code .= $funcCode;
+        }
+    }
+    return $code;
+}
+
+function generateArgInfoCode(FileInfo $fileInfo, string $stubHash, bool $minimal): string {
+    $code = "/* This is a generated file, edit the .stub.php file instead.\n"
+          . " * Stub hash: $stubHash */\n";
+    $generatedFuncInfos = [];
+    $code .= generateCodeWithConditions(
+        $fileInfo->getAllFuncInfos(), "\n",
+        function (FuncInfo $funcInfo) use(&$generatedFuncInfos, $minimal) {
+            /* If there already is an equivalent arginfo structure, only emit a #define */
+            if ($generatedFuncInfo = findEquivalentFuncInfo($generatedFuncInfos, $funcInfo)) {
+                $code = sprintf(
+                    "#define %s %s\n",
+                    $funcInfo->getArgInfoName(), $generatedFuncInfo->getArgInfoName()
+                );
+            } else {
+                $code = funcInfoToCode($funcInfo, $minimal);
+            }
+
+            $generatedFuncInfos[] = $funcInfo;
+            return $code;
+        }
+    );
+
+    if ($fileInfo->generateFunctionEntries) {
+        $code .= "\n\n";
+
+        $generatedFunctionDeclarations = [];
+        $code .= generateCodeWithConditions(
+            $fileInfo->getAllFuncInfos(), "",
+            function (FuncInfo $funcInfo) use($fileInfo, &$generatedFunctionDeclarations) {
+                $key = $funcInfo->getDeclarationKey();
+                if (isset($generatedFunctionDeclarations[$key])) {
+                    return null;
+                }
+
+                $generatedFunctionDeclarations[$key] = true;
+                return $fileInfo->declarationPrefix . $funcInfo->getDeclaration();
+            }
+        );
+
+        if (!empty($fileInfo->funcInfos)) {
+            $code .= generateFunctionEntries(null, $fileInfo->funcInfos);
+        }
+
+        foreach ($fileInfo->classInfos as $classInfo) {
+            $code .= generateFunctionEntries($classInfo->name, $classInfo->funcInfos);
+        }
+    }
+
+    return $code;
+}
+
+/** @param FuncInfo[] $funcInfos */
+function generateFunctionEntries(?Name $className, array $funcInfos): string {
+    $code = "";
+
+    $functionEntryName = "ext_functions";
+    if ($className) {
+        $underscoreName = implode("_", $className->parts);
+        $functionEntryName = "class_{$underscoreName}_methods";
+    }
+
+    $code .= "\n\nstatic const zend_function_entry {$functionEntryName}[] = {\n";
+    $code .= generateCodeWithConditions($funcInfos, "", function (FuncInfo $funcInfo) {
+        return $funcInfo->getFunctionEntry();
+    });
+    $code .= "\tZEND_FE_END\n";
+    $code .= "};\n";
+
+    return $code;
+}
+
+/**
+ * @param FuncInfo[] $funcMap
+ * @param FuncInfo[] $aliasMap
+ * @return array<string, string>
+ */
+function generateMethodSynopses(array $funcMap, array $aliasMap): array {
+    $result = [];
+
+    foreach ($funcMap as $funcInfo) {
+        $methodSynopsis = $funcInfo->getMethodSynopsisDocument($funcMap, $aliasMap);
+        if ($methodSynopsis !== null) {
+            $result[$funcInfo->name->getMethodSynopsisFilename() . ".xml"] = $methodSynopsis;
+        }
+    }
+
+    return $result;
+}
+
+/**
+ * @param FuncInfo[] $funcMap
+ * @param FuncInfo[] $aliasMap
+ * @return array<string, string>
+ */
+function replaceMethodSynopses(string $targetDirectory, array $funcMap, array $aliasMap): array {
+    $methodSynopses = [];
+
+    $it = new RecursiveIteratorIterator(
+        new RecursiveDirectoryIterator($targetDirectory),
+        RecursiveIteratorIterator::LEAVES_ONLY
+    );
+
+    foreach ($it as $file) {
+        $pathName = $file->getPathName();
+        if (!preg_match('/\.xml$/i', $pathName)) {
+            continue;
+        }
+
+        $xml = file_get_contents($pathName);
+        if ($xml === false) {
+            continue;
+        }
+
+        if (stripos($xml, "<methodsynopsis") === false && stripos($xml, "<constructorsynopsis") === false && stripos($xml, "<destructorsynopsis") === false) {
+            continue;
+        }
+
+        $replacedXml = preg_replace("/&([A-Za-z0-9._{}%-]+?;)/", "REPLACED-ENTITY-$1", $xml);
+
+        $doc = new DOMDocument();
+        $doc->formatOutput = false;
+        $doc->preserveWhiteSpace = true;
+        $doc->validateOnParse = true;
+        $success = $doc->loadXML($replacedXml);
+        if (!$success) {
+            echo "Failed opening $pathName\n";
+            continue;
+        }
+
+        $docComparator = new DOMDocument();
+        $docComparator->preserveWhiteSpace = false;
+        $docComparator->formatOutput = true;
+
+        $methodSynopsisElements = [];
+        foreach ($doc->getElementsByTagName("constructorsynopsis") as $element) {
+            $methodSynopsisElements[] = $element;
+        }
+        foreach ($doc->getElementsByTagName("destructorsynopsis") as $element) {
+            $methodSynopsisElements[] = $element;
+        }
+        foreach ($doc->getElementsByTagName("methodsynopsis") as $element) {
+            $methodSynopsisElements[] = $element;
+        }
+
+        foreach ($methodSynopsisElements as $methodSynopsis) {
+            if (!$methodSynopsis instanceof DOMElement) {
+                continue;
+            }
+
+            $list = $methodSynopsis->getElementsByTagName("methodname");
+            $item = $list->item(0);
+            if (!$item instanceof DOMElement) {
+                continue;
+            }
+            $funcName = $item->textContent;
+            if (!isset($funcMap[$funcName])) {
+                continue;
+            }
+            $funcInfo = $funcMap[$funcName];
+
+            $newMethodSynopsis = $funcInfo->getMethodSynopsisElement($funcMap, $aliasMap, $doc);
+            if ($newMethodSynopsis === null) {
+                continue;
+            }
+
+            // Retrieve current signature
+
+            $params = [];
+            $list = $methodSynopsis->getElementsByTagName("methodparam");
+            foreach ($list as $i => $item) {
+                if (!$item instanceof DOMElement) {
+                    continue;
+                }
+
+                $paramList = $item->getElementsByTagName("parameter");
+                if ($paramList->count() !== 1) {
+                    continue;
+                }
+
+                $paramName = $paramList->item(0)->textContent;
+                $paramTypes = [];
+
+                $paramList = $item->getElementsByTagName("type");
+                foreach ($paramList as $type) {
+                    if (!$type instanceof DOMElement) {
+                        continue;
+                    }
+
+                    $paramTypes[] = $type->textContent;
+                }
+
+                $params[$paramName] = ["index" => $i, "type" => $paramTypes];
+            }
+
+            // Check if there is any change - short circuit if there is not any.
+
+            $xml1 = $doc->saveXML($methodSynopsis);
+            $xml1 = preg_replace("/&([A-Za-z0-9._{}%-]+?;)/", "REPLACED-ENTITY-$1", $xml1);
+            $docComparator->loadXML($xml1);
+            $xml1 = $docComparator->saveXML();
+
+            $methodSynopsis->parentNode->replaceChild($newMethodSynopsis, $methodSynopsis);
+
+            $xml2 = $doc->saveXML($newMethodSynopsis);
+            $xml2 = preg_replace("/&([A-Za-z0-9._{}%-]+?;)/", "REPLACED-ENTITY-$1", $xml2);
+            $docComparator->loadXML($xml2);
+            $xml2 = $docComparator->saveXML();
+
+            if ($xml1 === $xml2) {
+                continue;
+            }
+
+            // Update parameter references
+
+            $paramList = $doc->getElementsByTagName("parameter");
+            /** @var DOMElement $paramElement */
+            foreach ($paramList as $paramElement) {
+                if ($paramElement->parentNode && $paramElement->parentNode->nodeName === "methodparam") {
+                    continue;
+                }
+
+                $name = $paramElement->textContent;
+                if (!isset($params[$name])) {
+                    continue;
+                }
+
+                $index = $params[$name]["index"];
+                if (!isset($funcInfo->args[$index])) {
+                    continue;
+                }
+
+                $paramElement->textContent = $funcInfo->args[$index]->name;
+            }
+
+            // Return the updated XML
+
+            $replacedXml = $doc->saveXML();
+
+            $replacedXml = preg_replace(
+                [
+                    "/REPLACED-ENTITY-([A-Za-z0-9._{}%-]+?;)/",
+                    "/<refentry\s+xmlns=\"([a-z0-9.:\/]+)\"\s+xml:id=\"([a-z0-9._-]+)\"\s*>/i",
+                    "/<refentry\s+xmlns=\"([a-z0-9.:\/]+)\"\s+xmlns:xlink=\"([a-z0-9.:\/]+)\"\s+xml:id=\"([a-z0-9._-]+)\"\s*>/i",
+                ],
+                [
+                    "&$1",
+                    "<refentry xml:id=\"$2\" xmlns=\"$1\">",
+                    "<refentry xml:id=\"$3\" xmlns=\"$1\" xmlns:xlink=\"$2\">",
+                ],
+                $replacedXml
+            );
+
+            $methodSynopses[$pathName] = $replacedXml;
+        }
+    }
+
+    return $methodSynopses;
+}
+
+function installPhpParser(string $version, string $phpParserDir) {
+    $lockFile = __DIR__ . "/PHP-Parser-install-lock";
+    $lockFd = fopen($lockFile, 'w+');
+    if (!flock($lockFd, LOCK_EX)) {
+        throw new Exception("Failed to acquire installation lock");
+    }
+
+    try {
+        // Check whether a parallel process has already installed PHP-Parser.
+        if (is_dir($phpParserDir)) {
+            return;
+        }
+
+        $cwd = getcwd();
+        chdir(__DIR__);
+
+        $tarName = "v$version.tar.gz";
+        passthru("wget https://github.com/nikic/PHP-Parser/archive/$tarName", $exit);
+        if ($exit !== 0) {
+            passthru("curl -LO https://github.com/nikic/PHP-Parser/archive/$tarName", $exit);
+        }
+        if ($exit !== 0) {
+            throw new Exception("Failed to download PHP-Parser tarball");
+        }
+        if (!mkdir($phpParserDir)) {
+            throw new Exception("Failed to create directory $phpParserDir");
+        }
+        passthru("tar xvzf $tarName -C PHP-Parser-$version --strip-components 1", $exit);
+        if ($exit !== 0) {
+            throw new Exception("Failed to extract PHP-Parser tarball");
+        }
+        unlink(__DIR__ . "/$tarName");
+        chdir($cwd);
+    } finally {
+        flock($lockFd, LOCK_UN);
+        @unlink($lockFile);
+    }
+}
+
+function initPhpParser() {
+    static $isInitialized = false;
+    if ($isInitialized) {
+        return;
+    }
+
+    if (!extension_loaded("tokenizer")) {
+        throw new Exception("The \"tokenizer\" extension is not available");
+    }
+
+    $isInitialized = true;
+    $version = "4.9.0";
+    $phpParserDir = __DIR__ . "/PHP-Parser-$version";
+    if (!is_dir($phpParserDir)) {
+        installPhpParser($version, $phpParserDir);
+    }
+
+    spl_autoload_register(function(string $class) use($phpParserDir) {
+        if (strpos($class, "PhpParser\\") === 0) {
+            $fileName = $phpParserDir . "/lib/" . str_replace("\\", "/", $class) . ".php";
+            require $fileName;
+        }
+    });
+}
+
+$optind = null;
+$options = getopt("fh", [
+    "force-regeneration",
+    "parameter-stats",
+    "help",
+    "verify",
+    "generate-methodsynopses",
+    "replace-methodsynopses",
+    "minimal-arginfo"], $optind);
+
+$context = new Context;
+$printParameterStats = isset($options["parameter-stats"]);
+$verify = isset($options["verify"]);
+$generateMethodSynopses = isset($options["generate-methodsynopses"]);
+$replaceMethodSynopses = isset($options["replace-methodsynopses"]);
+$context->forceRegeneration = isset($options["f"]) || isset($options["force-regeneration"]);
+$context->forceParse = $context->forceRegeneration || $printParameterStats || $verify || $generateMethodSynopses || $replaceMethodSynopses;
+$context->minimalArgInfo = isset($options["minimal-arginfo"]);
+$targetMethodSynopses = $argv[$optind + 1] ?? null;
+if ($replaceMethodSynopses && $targetMethodSynopses === null) {
+    die("A target directory must be provided.\n");
+}
+
+if (isset($options["h"]) || isset($options["help"])) {
+    die("\nusage: gen-stub.php [ -f | --force-regeneration ] [ --generate-methodsynopses ] [ --replace-methodsynopses ] [ --parameter-stats ] [ --verify ] [ -h | --help ] [ name.stub.php | directory ] [ directory ]\n\n");
+}
+
+$fileInfos = [];
+$location = $argv[$optind] ?? ".";
+if (is_file($location)) {
+    // Generate single file.
+    $fileInfo = processStubFile($location, $context);
+    if ($fileInfo) {
+        $fileInfos[] = $fileInfo;
+    }
+} else if (is_dir($location)) {
+    $fileInfos = processDirectory($location, $context);
+} else {
+    echo "$location is neither a file nor a directory.\n";
+    exit(1);
+}
+
+if ($printParameterStats) {
+    $parameterStats = [];
+
+    foreach ($fileInfos as $fileInfo) {
+        foreach ($fileInfo->getAllFuncInfos() as $funcInfo) {
+            foreach ($funcInfo->args as $argInfo) {
+                if (!isset($parameterStats[$argInfo->name])) {
+                    $parameterStats[$argInfo->name] = 0;
+                }
+                $parameterStats[$argInfo->name]++;
+            }
+        }
+    }
+
+    arsort($parameterStats);
+    echo json_encode($parameterStats, JSON_PRETTY_PRINT), "\n";
+}
+
+/** @var FuncInfo[] $funcMap */
+$funcMap = [];
+/** @var FuncInfo[] $aliasMap */
+$aliasMap = [];
+
+foreach ($fileInfos as $fileInfo) {
+    foreach ($fileInfo->getAllFuncInfos() as $funcInfo) {
+        /** @var FuncInfo $funcInfo */
+        $funcMap[$funcInfo->name->__toString()] = $funcInfo;
+
+        if ($funcInfo->aliasType === "alias") {
+            $aliasMap[$funcInfo->alias->__toString()] = $funcInfo;
+        }
+    }
+}
+
+if ($verify) {
+    $errors = [];
+
+    foreach ($aliasMap as $aliasFunc) {
+        if (!isset($funcMap[$aliasFunc->alias->__toString()])) {
+            $errors[] = "Aliased function {$aliasFunc->alias}() cannot be found";
+            continue;
+        }
+
+        if (!$aliasFunc->verify) {
+            continue;
+        }
+
+        $aliasedFunc = $funcMap[$aliasFunc->alias->__toString()];
+        $aliasedArgs = $aliasedFunc->args;
+        $aliasArgs = $aliasFunc->args;
+
+        if ($aliasFunc->isInstanceMethod() !== $aliasedFunc->isInstanceMethod()) {
+            if ($aliasFunc->isInstanceMethod()) {
+                $aliasedArgs = array_slice($aliasedArgs, 1);
+            }
+
+            if ($aliasedFunc->isInstanceMethod()) {
+                $aliasArgs = array_slice($aliasArgs, 1);
+            }
+        }
+
+        array_map(
+            function(?ArgInfo $aliasArg, ?ArgInfo $aliasedArg) use ($aliasFunc, $aliasedFunc, &$errors) {
+                if ($aliasArg === null) {
+                    assert($aliasedArg !== null);
+                    $errors[] = "{$aliasFunc->name}(): Argument \$$aliasedArg->name of aliased function {$aliasedFunc->name}() is missing";
+                    return null;
+                }
+
+                if ($aliasedArg === null) {
+                    $errors[] = "{$aliasedFunc->name}(): Argument \$$aliasArg->name of alias function {$aliasFunc->name}() is missing";
+                    return null;
+                }
+
+                if ($aliasArg->name !== $aliasedArg->name) {
+                    $errors[] = "{$aliasFunc->name}(): Argument \$$aliasArg->name and argument \$$aliasedArg->name of aliased function {$aliasedFunc->name}() must have the same name";
+                    return null;
+                }
+
+                if ($aliasArg->type != $aliasedArg->type) {
+                    $errors[] = "{$aliasFunc->name}(): Argument \$$aliasArg->name and argument \$$aliasedArg->name of aliased function {$aliasedFunc->name}() must have the same type";
+                }
+
+                if ($aliasArg->defaultValue !== $aliasedArg->defaultValue) {
+                    $errors[] = "{$aliasFunc->name}(): Argument \$$aliasArg->name and argument \$$aliasedArg->name of aliased function {$aliasedFunc->name}() must have the same default value";
+                }
+            },
+            $aliasArgs, $aliasedArgs
+        );
+
+        if ((!$aliasedFunc->isMethod() || $aliasedFunc->isFinalMethod()) &&
+            (!$aliasFunc->isMethod() || $aliasFunc->isFinalMethod()) &&
+            $aliasFunc->return != $aliasedFunc->return
+        ) {
+            $errors[] = "{$aliasFunc->name}() and {$aliasedFunc->name}() must have the same return type";
+        }
+    }
+
+    echo implode("\n", $errors);
+    if (!empty($errors)) {
+        echo "\n";
+        exit(1);
+    }
+}
+
+if ($generateMethodSynopses) {
+    $methodSynopsesDirectory = getcwd() . "/methodsynopses";
+
+    $methodSynopses = generateMethodSynopses($funcMap, $aliasMap);
+    if (!empty($methodSynopses)) {
+        if (!file_exists($methodSynopsesDirectory)) {
+            mkdir($methodSynopsesDirectory);
+        }
+
+        foreach ($methodSynopses as $filename => $content) {
+            if (file_put_contents("$methodSynopsesDirectory/$filename", $content)) {
+                echo "Saved $filename\n";
+            }
+        }
+    }
+}
+
+if ($replaceMethodSynopses) {
+    $methodSynopses = replaceMethodSynopses($targetMethodSynopses, $funcMap, $aliasMap);
+
+    foreach ($methodSynopses as $filename => $content) {
+        if (file_put_contents($filename, $content)) {
+            echo "Saved $filename\n";
+        }
+    }
+}

--- server/vendor/aws/aws-crt-php/package.xml-template_post ---
@@ -0,0 +1,19 @@
+ </contents>
+ <dependencies>
+  <required>
+   <php>
+    <min>7.4.0</min>
+   </php>
+   <pearinstaller>
+    <min>1.10.0</min>
+   </pearinstaller>
+  </required>
+ </dependencies>
+<providesextension>awscrt</providesextension>
+ <extsrcrelease/>
+ <changelog>
+  <release>
+
+  </release>
+ </changelog>
+</package>

--- server/vendor/aws/aws-crt-php/package.xml-template_pre ---
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<package packagerversion="1.8.1" version="2.0" xmlns="http://pear.php.net/dtd/package-2.0" xmlns:tasks="http://pear.php.net/dtd/tasks-1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0     http://pear.php.net/dtd/tasks-1.0.xsd     http://pear.php.net/dtd/package-2.0     http://pear.php.net/dtd/package-2.0.xsd">
+ <name>awscrt</name>
+ <channel>pecl.php.net</channel>
+ <summary>AWS Common Runtime PHP bindings</summary>
+ <description>AWS Common Runtime provides a set of low level tools as network protocols and authentication used by the AWSSDK for PHP to provide high level API to access AWS services.</description>
+ <lead>
+  <name>{{{NAME}}}</name>
+  <user>{{{USER}}}</user>
+  <email>{{{EMAIL}}}</email>
+  <active>yes</active>
+ </lead>
+ <date>{{{TODAY}}}</date>
+ <version>
+   <release>{{{VERSION}}}</release>
+   <api>1.0.0</api>
+ </version>
+ <stability>
+   <release>devel</release>
+   <api>stable</api>
+ </stability>
+ <license uri="https://www.apache.org/licenses/LICENSE-2.0">Apache License Version 2.0</license>
+ <notes>{{{NOTES}}}</notes>
+ <contents>

--- server/vendor/aws/aws-crt-php/php-win.ini ---
@@ -0,0 +1,2 @@
+extension=php_awscrt.dll
+extension=php_openssl.dll

--- server/vendor/aws/aws-crt-php/php.ini ---
@@ -0,0 +1 @@
+extension=modules/awscrt.so

--- server/vendor/aws/aws-crt-php/prepare_package_xml.sh ---
@@ -0,0 +1,144 @@
+#!/bin/zsh
+zparseopts -A opts -name: -user: -email: -version: -notes:
+if [[ $# -lt 10 ]]
+then
+  echo "Usage ${0} --name NAME, --user USER --email EMAIL --version VERSION --notes NOTES"
+  exit 1
+fi
+NAME="${opts[--name]}"
+USER="${opts[--user]}"
+EMAIL="${opts[--email]}"
+VERSION="${opts[--version]}"
+NOTES="${opts[--notes]}"
+
+TODAY=$(date -u +%Y-%m-%d)
+
+cat package.xml-template_pre \
+    | sed "s/{{{NAME}}}/$NAME/g" \
+    | sed "s/{{{USER}}}/$USER/g" \
+    | sed "s/{{{EMAIL}}}/$EMAIL/g" \
+    | sed "s/{{{TODAY}}}/$TODAY/g" \
+    | sed "s/{{{VERSION}}}/$VERSION/g" \
+    | sed "s/{{{NOTES}}}/$NOTES/g"
+
+source_ext='(c|cc|h|cpp|hpp|m4|w32|ini|frag|cmake|inl|in|py|gnu|yaml|def|pl|S|s|errordata|go|lds|num|asm|mod|peg|mk|rs|toml|sh)'
+doc_ext='(md|json|html|dot|graphml|png|gn|sha1|css|rst|)'
+
+special_docs='(LICENSE*|NOTICE|changelog.txt|CHANGELOG|THIRD-PARTY|README*|readme|METADATA|CONTRIBUTORS|UPDATING|doc.config)'
+special_tests='(ci-test.sh|format-check.sh|run_tests*|sanitizer-blacklist.txt|run-clang-tidy.sh|benchmark-build-run.sh|break-tests.sh|generate-coverage.sh|test.xml)'
+special_src='(gen_api.php|gen_stub.php|CMakeLists.txt|post.sh|postun.sh|Makefile*|build-buildspec.sh|build-deps.sh|objects.txt|go.*|BUILD*|DEPS|install_and_run.sh|codemod.sh|requirements.txt)'
+skip_files='(package.xml*|prepare_release.sh|codereview.settings|*.o|*.a|*.obj|*.lib|break-tests-android.sh|whitespace.txt|prepare_package_xml.sh|crypto_test_data.cc|*.pdf|*.svg|*.docx|cbmc-proof.txt|codecov*|litani*|*.toml)'
+
+special_scripts='(awscrt.stub.php)'
+
+skip_directories='(tests|test|AWSCRTAndroidTestRunner|docker-images|codebuild|fuzz|verfication|third_party|docs|generated-src|aws-lc|aws-crt-sys)'
+
+process_file() {
+    if (( $# == 0 ))
+    then
+      echo "ERROR: filename not passed"
+      exit 1
+    fi
+    if [[ $1 = $~skip_files ]]
+    then
+      # This file is not part of the release bundle
+      return 0
+    fi
+
+    echo -n '<file name="'"$1"'" role="'
+    # Special cases
+    case ${a} in
+    $~special_scripts)
+      echo -n 'script'
+    ;;
+    $~special_docs)
+      echo -n 'doc'
+    ;;
+    $~special_tests)
+      echo -n 'test'
+    ;;
+    $~special_src)
+      echo -n 'src'
+    ;;
+    *)
+      # Extension based cases
+      case ${a:t:e} in
+      $~source_ext)
+        echo -n 'src'
+      ;;
+      $~doc_ext)
+         echo -n 'doc'
+      ;;
+      php)
+         echo -n 'script'
+      ;;
+      *)
+         echo "${a:t:e} - ${a} - FAIL TO RECOGNIZE"
+         exit 1
+      esac
+    esac
+    echo '"/>'
+    return 0
+}
+
+
+process_dir() {
+  if (( $# == 0 ))
+  then
+    echo "WARNING: dirname not passed"
+    exit 1
+  fi
+  if [[ "${1}" = $~skip_directories ]]
+  then
+    return 0
+  fi
+  echo '<dir name="'"$1"'">'
+  cd "$1"
+  for a in *
+  do
+    if [[ -f ${a} ]]
+    then process_file "${a}"
+    else process_dir "${a}"
+    fi
+  done
+  # Special cases for compiler features placed in tests directories in and s2n
+  if [[ "${1}" = "s2n" && -d tests ]]
+  then
+      echo '<dir name="tests">'
+      echo '<dir name="features">'
+      cd tests/features
+      for a in *
+      do
+          process_file "${a}"
+      done
+      cd ../..
+      echo '</dir>'
+      echo '</dir>'
+  fi
+  echo '</dir>'
+  cd ..
+  return 0
+}
+
+echo '<dir name="/">'
+for a in *
+do
+  if [[ ${a} == 'tests' ]]
+  then
+    echo '<dir name="tests">'
+    for b in tests/*
+    do
+      echo '<file name="'$( basename "${b}" )'" role="test" />'
+    done
+    echo '</dir>'
+    continue
+  fi
+  if [[ -f ${a} ]]
+  then process_file "${a}"
+  else process_dir "${a}"
+  fi
+done
+echo '</dir>'
+
+cat package.xml-template_post
+

--- server/vendor/aws/aws-crt-php/prepare_release.sh ---
@@ -0,0 +1,31 @@
+#!/bin/zsh
+zparseopts -A opts -name: -user: -email: -version: -notes:
+if [[ $# -lt 10 ]]; then
+  echo "Usage ${0} --name NAME --user USER --email EMAIL --version VERSION --notes NOTES"
+  exit 1
+fi
+PACKAGE='awscrt'
+NAME="${opts[--name]}"
+USER="${opts[--user]}"
+EMAIL="${opts[--email]}"
+VERSION="${opts[--version]}"
+NOTES="${opts[--notes]}"
+
+./prepare_package_xml.sh --name "${NAME}" --user "${USER}" --email "${EMAIL}" --version "${VERSION}" --notes "${NOTES}" >package.xml
+if [[ $? -ne 0 ]]; then
+  echo "ERROR PROCESSING review package.xml"
+  exit 1
+fi
+tidy -xml -m -i package.xml
+pear package-validate
+if [[ $? -ne 0 ]]; then
+  echo "ERROR VALIDATING review package.xml"
+  exit 1
+fi
+pear package
+if [[ $? -ne 0 ]]; then
+  echo "ERROR PROCESSING review package.xml"
+  exit 1
+fi
+
+echo "Size of ${PACKAGE}-${VERSION}.tgz: " $(du -h "${PACKAGE}-${VERSION}.tgz")

--- server/vendor/aws/aws-crt-php/run_tests ---
@@ -0,0 +1,18 @@
+#!/usr/bin/env bash
+
+set -ex
+
+launcher=
+if command -v catchsegv; then
+    launcher=catchsegv
+fi
+
+if [ -z $PHP_BINARY ]; then
+    PHP_BINARY=$(which php)
+fi
+
+if [ ! -d vendor ]; then
+    composer update
+fi
+
+$launcher $PHP_BINARY -c php.ini vendor/bin/phpunit tests --debug

--- server/vendor/aws/aws-crt-php/run_tests.bat ---
@@ -0,0 +1,4 @@
+
+@echo on
+
+%PHP_BINARY% -c php-win.ini vendor/bin/phpunit tests --debug

--- server/vendor/aws/aws-crt-php/src/.gitignore ---
@@ -0,0 +1,3 @@
+api.h
+pkgconfig/
+*.so*

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/AwsCredentials.php ---
@@ -0,0 +1,69 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+use AWS\CRT\NativeResource as NativeResource;
+use AWS\CRT\Options as Options;
+
+/**
+ * Represents a set of AWS credentials
+ *
+ * @param array options:
+ * - string access_key_id - AWS Access Key Id
+ * - string secret_access_key - AWS Secret Access Key
+ * - string session_token - Optional STS session token
+ * - int expiration_timepoint_seconds - Optional time to expire these credentials
+ */
+final class AwsCredentials extends NativeResource {
+
+    static function defaults() {
+        return [
+            'access_key_id' => '',
+            'secret_access_key' => '',
+            'session_token' => '',
+            'expiration_timepoint_seconds' => 0,
+        ];
+    }
+
+    private $access_key_id;
+    private $secret_access_key;
+    private $session_token;
+    private $expiration_timepoint_seconds = 0;
+
+    public function __get($name) {
+        return $this->$name;
+    }
+
+    function __construct(array $options = []) {
+        parent::__construct();
+
+        $options = new Options($options, self::defaults());
+        $this->access_key_id = $options->access_key_id->asString();
+        $this->secret_access_key = $options->secret_access_key->asString();
+        $this->session_token = $options->session_token ? $options->session_token->asString() : null;
+        $this->expiration_timepoint_seconds = $options->expiration_timepoint_seconds->asInt();
+
+        if (strlen($this->access_key_id) == 0) {
+            throw new \InvalidArgumentException("access_key_id must be provided");
+        }
+        if (strlen($this->secret_access_key) == 0) {
+            throw new \InvalidArgumentException("secret_access_key must be provided");
+        }
+
+        $creds_options = self::$crt->aws_credentials_options_new();
+        self::$crt->aws_credentials_options_set_access_key_id($creds_options, $this->access_key_id);
+        self::$crt->aws_credentials_options_set_secret_access_key($creds_options, $this->secret_access_key);
+        self::$crt->aws_credentials_options_set_session_token($creds_options, $this->session_token);
+        self::$crt->aws_credentials_options_set_expiration_timepoint_seconds($creds_options, $this->expiration_timepoint_seconds);
+        $this->acquire(self::$crt->aws_credentials_new($creds_options));
+        self::$crt->aws_credentials_options_release($creds_options);
+    }
+
+    function __destruct() {
+        self::$crt->aws_credentials_release($this->release());
+        parent::__destruct();
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/CredentialsProvider.php ---
@@ -0,0 +1,23 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+use AWS\CRT\NativeResource as NativeResource;
+
+/**
+ * Base class for credentials providers
+ */
+abstract class CredentialsProvider extends NativeResource {
+
+    function __construct(array $options = []) {
+        parent::__construct();
+    }
+
+    function __destruct() {
+        self::$crt->credentials_provider_release($this->release());
+        parent::__destruct();
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/Signable.php ---
@@ -0,0 +1,43 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+use AWS\CRT\IO\InputStream;
+use AWS\CRT\NativeResource as NativeResource;
+
+class Signable extends NativeResource {
+
+    public static function fromHttpRequest($http_message) {
+        return new Signable(function() use ($http_message) {
+            return self::$crt->signable_new_from_http_request($http_message->native);
+        });
+    }
+
+    public static function fromChunk($chunk_stream, $previous_signature="") {
+        if (!($chunk_stream instanceof InputStream)) {
+            $chunk_stream = new InputStream($chunk_stream);
+        }
+        return new Signable(function() use($chunk_stream, $previous_signature) {
+            return self::$crt->signable_new_from_chunk($chunk_stream->native, $previous_signature);
+        });
+    }
+
+    public static function fromCanonicalRequest($canonical_request) {
+        return new Signable(function() use($canonical_request) {
+            return self::$crt->signable_new_from_canonical_request($canonical_request);
+        });
+    }
+
+    protected function __construct($ctor) {
+        parent::__construct();
+        $this->acquire($ctor());
+    }
+
+    function __destruct() {
+        self::$crt->signable_release($this->release());
+        parent::__destruct();
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/SignatureType.php ---
@@ -0,0 +1,15 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+class SignatureType {
+    const HTTP_REQUEST_HEADERS = 0;
+    const HTTP_REQUEST_QUERY_PARAMS = 1;
+    const HTTP_REQUEST_CHUNK = 2;
+    const HTTP_REQUEST_EVENT = 3;
+    const CANONICAL_REQUEST_HEADERS = 4;
+    const CANONICAL_REQUEST_QUERY_PARAMS = 5;
+}
\ No newline at end of file

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/SignedBodyHeaderType.php ---
@@ -0,0 +1,11 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+class SignedBodyHeaderType {
+    const NONE = 0;
+    const X_AMZ_CONTENT_SHA256 = 1;
+}
\ No newline at end of file

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/Signing.php ---
@@ -0,0 +1,22 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+use AWS\CRT\NativeResource;
+
+abstract class Signing extends NativeResource {
+    static function signRequestAws($signable, $signing_config, $on_complete) {
+        return self::$crt->sign_request_aws($signable->native, $signing_config->native,
+            function($result, $error_code) use ($on_complete) {
+                $signing_result = SigningResult::fromNative($result);
+                $on_complete($signing_result, $error_code);
+            }, null);
+    }
+
+    static function testVerifySigV4ASigning($signable, $signing_config, $expected_canonical_request, $signature, $ecc_key_pub_x, $ecc_key_pub_y) {
+        return self::$crt->test_verify_sigv4a_signing($signable, $signing_config, $expected_canonical_request, $signature, $ecc_key_pub_x, $ecc_key_pub_y);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/SigningAlgorithm.php ---
@@ -0,0 +1,11 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+class SigningAlgorithm {
+    const SIGv4 = 0;
+    const SIGv4_ASYMMETRIC = 1;
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/SigningConfigAWS.php ---
@@ -0,0 +1,75 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+use AWS\CRT\NativeResource as NativeResource;
+use AWS\CRT\Options as Options;
+
+class SigningConfigAWS extends NativeResource {
+
+    public static function defaults() {
+        return [
+            'algorithm' => SigningAlgorithm::SIGv4,
+            'signature_type' => SignatureType::HTTP_REQUEST_HEADERS,
+            'credentials_provider' => null,
+            'region' => null,
+            'service' => null,
+            'use_double_uri_encode' => false,
+            'should_normalize_uri_path' => false,
+            'omit_session_token' => false,
+            'signed_body_value' => null,
+            'signed_body_header_type' => SignedBodyHeaderType::NONE,
+            'expiration_in_seconds' => 0,
+            'date' => time(),
+            'should_sign_header' => null,
+        ];
+    }
+
+    private $options;
+
+    public function __construct(array $options = []) {
+        parent::__construct();
+        $this->options = $options = new Options($options, self::defaults());
+        $sc = $this->acquire(self::$crt->signing_config_aws_new());
+        self::$crt->signing_config_aws_set_algorithm($sc, $options->algorithm->asInt());
+        self::$crt->signing_config_aws_set_signature_type($sc, $options->signature_type->asInt());
+        if ($credentials_provider = $options->credentials_provider->asObject()) {
+            self::$crt->signing_config_aws_set_credentials_provider(
+                $sc,
+                $credentials_provider->native);
+        }
+        self::$crt->signing_config_aws_set_region(
+            $sc, $options->region->asString());
+        self::$crt->signing_config_aws_set_service(
+            $sc, $options->service->asString());
+        self::$crt->signing_config_aws_set_use_double_uri_encode(
+            $sc, $options->use_double_uri_encode->asBool());
+        self::$crt->signing_config_aws_set_should_normalize_uri_path(
+            $sc, $options->should_normalize_uri_path->asBool());
+        self::$crt->signing_config_aws_set_omit_session_token(
+            $sc, $options->omit_session_token->asBool());
+        self::$crt->signing_config_aws_set_signed_body_value(
+            $sc, $options->signed_body_value->asString());
+        self::$crt->signing_config_aws_set_signed_body_header_type(
+            $sc, $options->signed_body_header_type->asInt());
+        self::$crt->signing_config_aws_set_expiration_in_seconds(
+            $sc, $options->expiration_in_seconds->asInt());
+        self::$crt->signing_config_aws_set_date($sc, $options->date->asInt());
+        if ($should_sign_header = $options->should_sign_header->asCallable()) {
+            self::$crt->signing_config_aws_set_should_sign_header_fn($sc, $should_sign_header);
+        }
+    }
+
+    function __destruct()
+    {
+        self::$crt->signing_config_aws_release($this->release());
+        parent::__destruct();
+    }
+
+    public function __get($name) {
+        return $this->options->get($name);
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/SigningResult.php ---
@@ -0,0 +1,33 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+use AWS\CRT\NativeResource;
+use AWS\CRT\HTTP\Request;
+
+class SigningResult extends NativeResource {
+    protected function __construct($native) {
+        parent::__construct();
+
+        $this->acquire($native);
+    }
+
+    function __destruct() {
+        // No destruction necessary, SigningResults are transient, just release
+        $this->release();
+        parent::__destruct();
+    }
+
+    public static function fromNative($ptr) {
+        return new SigningResult($ptr);
+    }
+
+    public function applyToHttpRequest(&$http_request) {
+        self::$crt->signing_result_apply_to_http_request($this->native, $http_request->native);
+        // Update http_request from native
+        $http_request = Request::unmarshall($http_request->toBlob());
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Auth/StaticCredentialsProvider.php ---
@@ -0,0 +1,35 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Auth;
+
+/**
+ * Provides a static set of AWS credentials
+ *
+ * @param array options:
+ * - string access_key_id - AWS Access Key Id
+ * - string secret_access_key - AWS Secret Access Key
+ * - string session_token - Optional STS session token
+ */
+final class StaticCredentialsProvider extends CredentialsProvider {
+
+    private $credentials;
+
+    public function __get($name) {
+        return $this->$name;
+    }
+
+    function __construct(array $options = []) {
+        parent::__construct();
+        $this->credentials = new AwsCredentials($options);
+
+        $provider_options = self::$crt->credentials_provider_static_options_new();
+        self::$crt->credentials_provider_static_options_set_access_key_id($provider_options, $this->credentials->access_key_id);
+        self::$crt->credentials_provider_static_options_set_secret_access_key($provider_options, $this->credentials->secret_access_key);
+        self::$crt->credentials_provider_static_options_set_session_token($provider_options, $this->credentials->session_token);
+        $this->acquire(self::$crt->credentials_provider_static_new($provider_options));
+        self::$crt->credentials_provider_static_options_release($provider_options);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/CRT.php ---
@@ -0,0 +1,358 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT;
+
+use AWS\CRT\Internal\Extension;
+
+use \RuntimeException;
+
+/**
+ * Wrapper for the interface to the CRT. There only ever needs to be one of these, but
+ * additional instances won't cost anything other than their memory.
+ * Creating an instance of any NativeResource will activate the CRT binding. User code
+ * should only need to create one of these if they are only accessing CRT:: static functions.
+ */
+final class CRT {
+
+    private static $impl = null;
+    private static $refcount = 0;
+
+    function __construct() {
+        if (is_null(self::$impl)) {
+            try {
+                self::$impl = new Extension();
+            } catch (RuntimeException $rex) {
+                throw new RuntimeException("Unable to initialize AWS CRT via awscrt extension: \n$rex", -1);
+            }
+        }
+        ++self::$refcount;
+    }
+
+    function __destruct() {
+        if (--self::$refcount == 0) {
+            self::$impl = null;
+        }
+    }
+
+    /**
+     * @return bool whether or not the CRT is currently loaded
+     */
+    public static function isLoaded() {
+        return !is_null(self::$impl);
+    }
+
+    /**
+     * @return bool whether or not the CRT is available via one of the possible backends
+     */
+    public static function isAvailable() {
+        try {
+            new CRT();
+            return true;
+        } catch (RuntimeException $ex) {
+            return false;
+        }
+    }
+
+    /**
+     * @return integer last error code reported within the CRT
+     */
+    public static function last_error() {
+        return self::$impl->aws_crt_last_error();
+    }
+
+    /**
+     * @param integer $error Error code from the CRT, usually delivered via callback or {@see last_error}
+     * @return string Human-readable description of the provided error code
+     */
+    public static function error_str($error) {
+        return self::$impl->aws_crt_error_str((int) $error);
+    }
+
+    /**
+     * @param integer $error Error code from the CRT, usually delivered via callback or {@see last_error}
+     * @return string Name/enum identifier for the provided error code
+     */
+    public static function error_name($error) {
+        return self::$impl->aws_crt_error_name((int) $error);
+    }
+
+    public static function log_to_stdout() {
+        return self::$impl->aws_crt_log_to_stdout();
+    }
+
+    public static function log_to_stderr() {
+        return self::$impl->aws_crt_log_to_stderr();
+    }
+
+    public static function log_to_file($filename) {
+        return self::$impl->aws_crt_log_to_file($filename);
+    }
+
+    public static function log_to_stream($stream) {
+        return self::$impl->aws_crt_log_to_stream($stream);
+    }
+
+    public static function log_set_level($level) {
+        return self::$impl->aws_crt_log_set_level($level);
+    }
+
+    public static function log_stop() {
+        return self::$impl->aws_crt_log_stop();
+    }
+
+    public static function log_message($level, $message) {
+        return self::$impl->aws_crt_log_message($level, $message);
+    }
+
+    /**
+     * @return object Pointer to native event_loop_group_options
+     */
+    function event_loop_group_options_new() {
+        return self::$impl->aws_crt_event_loop_group_options_new();
+    }
+
+    /**
+     * @param object $elg_options Pointer to native event_loop_group_options
+     */
+    function event_loop_group_options_release($elg_options) {
+        self::$impl->aws_crt_event_loop_group_options_release($elg_options);
+    }
+
+    /**
+     * @param object $elg_options Pointer to native event_loop_group_options
+     * @param integer $max_threads Maximum number of threads to allow the event loop group to use, default: 0/1 per CPU core
+     */
+    function event_loop_group_options_set_max_threads($elg_options, $max_threads) {
+        self::$impl->aws_crt_event_loop_group_options_set_max_threads($elg_options, (int)$max_threads);
+    }
+
+    /**
+     * @param object Pointer to event_loop_group_options, {@see event_loop_group_options_new}
+     * @return object Pointer to the new event loop group
+     */
+    function event_loop_group_new($options) {
+        return self::$impl->aws_crt_event_loop_group_new($options);
+    }
+
+    /**
+     * @param object $elg Pointer to the event loop group to release
+     */
+    function event_loop_group_release($elg) {
+        self::$impl->aws_crt_event_loop_group_release($elg);
+    }
+
+    /**
+     * return object Pointer to native AWS credentials options
+     */
+    function aws_credentials_options_new() {
+        return self::$impl->aws_crt_credentials_options_new();
+    }
+
+    function aws_credentials_options_release($options) {
+        self::$impl->aws_crt_credentials_options_release($options);
+    }
+
+    function aws_credentials_options_set_access_key_id($options, $access_key_id) {
+        self::$impl->aws_crt_credentials_options_set_access_key_id($options, $access_key_id);
+    }
+
+    function aws_credentials_options_set_secret_access_key($options, $secret_access_key) {
+        self::$impl->aws_crt_credentials_options_set_secret_access_key($options, $secret_access_key);
+    }
+
+    function aws_credentials_options_set_session_token($options, $session_token) {
+        self::$impl->aws_crt_credentials_options_set_session_token($options, $session_token);
+    }
+
+    function aws_credentials_options_set_expiration_timepoint_seconds($options, $expiration_timepoint_seconds) {
+        self::$impl->aws_crt_credentials_options_set_expiration_timepoint_seconds($options, $expiration_timepoint_seconds);
+    }
+
+    function aws_credentials_new($options) {
+        return self::$impl->aws_crt_credentials_new($options);
+    }
+
+    function aws_credentials_release($credentials) {
+        self::$impl->aws_crt_credentials_release($credentials);
+    }
+
+    function credentials_provider_release($provider) {
+        self::$impl->aws_crt_credentials_provider_release($provider);
+    }
+
+    function credentials_provider_static_options_new() {
+        return self::$impl->aws_crt_credentials_provider_static_options_new();
+    }
+
+    function credentials_provider_static_options_release($options) {
+        self::$impl->aws_crt_credentials_provider_static_options_release($options);
+    }
+
+    function credentials_provider_static_options_set_access_key_id($options, $access_key_id) {
+        self::$impl->aws_crt_credentials_provider_static_options_set_access_key_id($options, $access_key_id);
+    }
+
+    function credentials_provider_static_options_set_secret_access_key($options, $secret_access_key) {
+        self::$impl->aws_crt_credentials_provider_static_options_set_secret_access_key($options, $secret_access_key);
+    }
+
+    function credentials_provider_static_options_set_session_token($options, $session_token) {
+        self::$impl->aws_crt_credentials_provider_static_options_set_session_token($options, $session_token);
+    }
+
+    function credentials_provider_static_new($options) {
+        return self::$impl->aws_crt_credentials_provider_static_new($options);
+    }
+
+    function input_stream_options_new() {
+        return self::$impl->aws_crt_input_stream_options_new();
+    }
+
+    function input_stream_options_release($options) {
+        self::$impl->aws_crt_input_stream_options_release($options);
+    }
+
+    function input_stream_options_set_user_data($options, $user_data) {
+        self::$impl->aws_crt_input_stream_options_set_user_data($options, $user_data);
+    }
+
+    function input_stream_new($options) {
+        return self::$impl->aws_crt_input_stream_new($options);
+    }
+
+    function input_stream_release($stream) {
+        self::$impl->aws_crt_input_stream_release($stream);
+    }
+
+    function input_stream_seek($stream, $offset, $basis) {
+        return self::$impl->aws_crt_input_stream_seek($stream, $offset, $basis);
+    }
+
+    function input_stream_read($stream, $length) {
+        return self::$impl->aws_crt_input_stream_read($stream, $length);
+    }
+
+    function input_stream_eof($stream) {
+        return self::$impl->aws_crt_input_stream_eof($stream);
+    }
+
+    function input_stream_get_length($stream) {
+        return self::$impl->aws_crt_input_stream_get_length($stream);
+    }
+
+    function http_message_new_from_blob($blob) {
+        return self::$impl->aws_crt_http_message_new_from_blob($blob);
+    }
+
+    function http_message_to_blob($message) {
+        return self::$impl->aws_crt_http_message_to_blob($message);
+    }
+
+    function http_message_release($message) {
+        self::$impl->aws_crt_http_message_release($message);
+    }
+
+    function signing_config_aws_new() {
+        return self::$impl->aws_crt_signing_config_aws_new();
+    }
+
+    function signing_config_aws_release($signing_config) {
+        return self::$impl->aws_crt_signing_config_aws_release($signing_config);
+    }
+
+    function signing_config_aws_set_algorithm($signing_config, $algorithm) {
+        self::$impl->aws_crt_signing_config_aws_set_algorithm($signing_config, (int)$algorithm);
+    }
+
+    function signing_config_aws_set_signature_type($signing_config, $signature_type) {
+        self::$impl->aws_crt_signing_config_aws_set_signature_type($signing_config, (int)$signature_type);
+    }
+
+    function signing_config_aws_set_credentials_provider($signing_config, $credentials_provider) {
+        self::$impl->aws_crt_signing_config_aws_set_credentials_provider($signing_config, $credentials_provider);
+    }
+
+    function signing_config_aws_set_region($signing_config, $region) {
+        self::$impl->aws_crt_signing_config_aws_set_region($signing_config, $region);
+    }
+
+    function signing_config_aws_set_service($signing_config, $service) {
+        self::$impl->aws_crt_signing_config_aws_set_service($signing_config, $service);
+    }
+
+    function signing_config_aws_set_use_double_uri_encode($signing_config, $use_double_uri_encode) {
+        self::$impl->aws_crt_signing_config_aws_set_use_double_uri_encode($signing_config, $use_double_uri_encode);
+    }
+
+    function signing_config_aws_set_should_normalize_uri_path($signing_config, $should_normalize_uri_path) {
+        self::$impl->aws_crt_signing_config_aws_set_should_normalize_uri_path($signing_config, $should_normalize_uri_path);
+    }
+
+    function signing_config_aws_set_omit_session_token($signing_config, $omit_session_token) {
+        self::$impl->aws_crt_signing_config_aws_set_omit_session_token($signing_config, $omit_session_token);
+    }
+
+    function signing_config_aws_set_signed_body_value($signing_config, $signed_body_value) {
+        self::$impl->aws_crt_signing_config_aws_set_signed_body_value($signing_config, $signed_body_value);
+    }
+
+    function signing_config_aws_set_signed_body_header_type($signing_config, $signed_body_header_type) {
+        self::$impl->aws_crt_signing_config_aws_set_signed_body_header_type($signing_config, $signed_body_header_type);
+    }
+
+    function signing_config_aws_set_expiration_in_seconds($signing_config, $expiration_in_seconds) {
+        self::$impl->aws_crt_signing_config_aws_set_expiration_in_seconds($signing_config, $expiration_in_seconds);
+    }
+
+    function signing_config_aws_set_date($signing_config, $timestamp) {
+        self::$impl->aws_crt_signing_config_aws_set_date($signing_config, $timestamp);
+    }
+
+    function signing_config_aws_set_should_sign_header_fn($signing_config, $should_sign_header_fn) {
+        self::$impl->aws_crt_signing_config_aws_set_should_sign_header_fn($signing_config, $should_sign_header_fn);
+    }
+
+    function signable_new_from_http_request($http_message) {
+        return self::$impl->aws_crt_signable_new_from_http_request($http_message);
+    }
+
+    function signable_new_from_chunk($chunk_stream, $previous_signature) {
+        return self::$impl->aws_crt_signable_new_from_chunk($chunk_stream, $previous_signature);
+    }
+
+    function signable_new_from_canonical_request($canonical_request) {
+        return self::$impl->aws_crt_signable_new_from_canonical_request($canonical_request);
+    }
+
+    function signable_release($signable) {
+        self::$impl->aws_crt_signable_release($signable);
+    }
+
+    function signing_result_release($signing_result) {
+        self::$impl->aws_crt_signing_result_release($signing_result);
+    }
+
+    function signing_result_apply_to_http_request($signing_result, $http_message) {
+        return self::$impl->aws_crt_signing_result_apply_to_http_request(
+            $signing_result, $http_message);
+    }
+
+    function sign_request_aws($signable, $signing_config, $on_complete, $user_data) {
+        return self::$impl->aws_crt_sign_request_aws($signable, $signing_config, $on_complete, $user_data);
+    }
+
+    function test_verify_sigv4a_signing($signable, $signing_config, $expected_canonical_request, $signature, $ecc_key_pub_x, $ecc_key_pub_y) {
+        return self::$impl->aws_crt_test_verify_sigv4a_signing($signable, $signing_config, $expected_canonical_request, $signature, $ecc_key_pub_x, $ecc_key_pub_y);
+    }
+
+    public static function crc32($input, $previous = 0) {
+        return self::$impl->aws_crt_crc32($input, $previous);
+    }
+
+    public static function crc32c($input, $previous = 0) {
+        return self::$impl->aws_crt_crc32c($input, $previous);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/HTTP/Headers.php ---
@@ -0,0 +1,50 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\HTTP;
+
+use AWS\CRT\Internal\Encoding;
+
+final class Headers {
+    private $headers;
+
+    public function __construct($headers = []) {
+        $this->headers = $headers;
+    }
+
+    public static function marshall($headers) {
+        $buf = "";
+        foreach ($headers->headers as $header => $value) {
+            $buf .= Encoding::encodeString($header);
+            $buf .= Encoding::encodeString($value);
+        }
+        return $buf;
+    }
+
+    public static function unmarshall($buf) {
+        $strings = Encoding::readStrings($buf);
+        $headers = [];
+        for ($idx = 0; $idx < count($strings);) {
+            $headers[$strings[$idx++]] = $strings[$idx++];
+        }
+        return new Headers($headers);
+    }
+
+    public function count() {
+        return count($this->headers);
+    }
+
+    public function get($header) {
+        return isset($this->headers[$header]) ? $this->headers[$header] : null;
+    }
+
+    public function set($header, $value) {
+        $this->headers[$header] = $value;
+    }
+
+    public function toArray() {
+        return $this->headers;
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/HTTP/Message.php ---
@@ -0,0 +1,95 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\HTTP;
+
+use AWS\CRT\NativeResource;
+use AWS\CRT\Internal\Encoding;
+
+abstract class Message extends NativeResource {
+    private $method;
+    private $path;
+    private $query;
+    private $headers;
+
+    public function __construct($method, $path, $query = [], $headers = []) {
+        parent::__construct();
+        $this->method = $method;
+        $this->path = $path;
+        $this->query = $query;
+        $this->headers = new Headers($headers);
+        $this->acquire(self::$crt->http_message_new_from_blob(self::marshall($this)));
+    }
+
+    public function __destruct() {
+        self::$crt->http_message_release($this->release());
+        parent::__destruct();
+    }
+
+    public function toBlob() {
+        return self::$crt->http_message_to_blob($this->native);
+    }
+
+    protected static function marshall($msg) {
+        $buf = "";
+        $buf .= Encoding::encodeString($msg->method);
+        $buf .= Encoding::encodeString($msg->pathAndQuery());
+        $buf .= Headers::marshall($msg->headers);
+        return $buf;
+    }
+
+    protected static function _unmarshall($buf, $class=Message::class) {
+        $method = Encoding::readString($buf);
+        $path_and_query = Encoding::readString($buf);
+        $parts = explode("?", $path_and_query, 2);
+        $path = isset($parts[0]) ? $parts[0] : "";
+        $query = isset($parts[1]) ? $parts[1] : "";
+        $headers = Headers::unmarshall($buf);
+
+        // Turn query params back into a dictionary
+        if (strlen($query)) {
+            $query = rawurldecode($query);
+            $query = explode("&", $query);
+            $query = array_reduce($query, function($params, $pair) {
+                list($param, $value) = explode("=", $pair, 2);
+                $params[$param] = $value;
+                return $params;
+            }, []);
+        } else {
+            $query = [];
+        }
+
+        return new $class($method, $path, $query, $headers->toArray());
+    }
+
+    public function pathAndQuery() {
+        $path = $this->path;
+        $queries = [];
+        foreach ($this->query as $param => $value) {
+            $queries []= urlencode($param) . "=" . urlencode($value);
+        }
+        $query = implode("&", $queries);
+        if (strlen($query)) {
+            $path = implode("?", [$path, $query]);
+        }
+        return $path;
+    }
+
+    public function method() {
+        return $this->method;
+    }
+
+    public function path() {
+        return $this->path;
+    }
+
+    public function query() {
+        return $this->query;
+    }
+
+    public function headers() {
+        return $this->headers;
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/HTTP/Request.php ---
@@ -0,0 +1,32 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\HTTP;
+
+use AWS\CRT\IO\InputStream;
+
+class Request extends Message {
+    private $body_stream = null;
+
+    public function __construct($method, $path, $query = [], $headers = [], $body_stream = null) {
+        parent::__construct($method, $path, $query, $headers);
+        if (!is_null($body_stream) && !($body_stream instanceof InputStream)) {
+            throw InvalidArgumentException('body_stream must be an instance of ' . InputStream::class);
+        }
+        $this->body_stream = $body_stream;
+    }
+
+    public static function marshall($request) {
+        return parent::marshall($request);
+    }
+
+    public static function unmarshall($buf) {
+        return parent::_unmarshall($buf, Request::class);
+    }
+
+    public function body_stream() {
+        return $this->body_stream;
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/HTTP/Response.php ---
@@ -0,0 +1,27 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\HTTP;
+
+class Response extends Message {
+    private $status_code;
+
+    public function __construct($method, $path, $query, $headers, $status_code) {
+        parent::__construct($method, $path, $query, $headers);
+        $this->status_code = $status_code;
+    }
+
+    public static function marshall($response) {
+        return parent::marshall($response);
+    }
+
+    public static function unmarshall($buf) {
+        return parent::_unmarshall($buf, Response::class);
+    }
+
+    public function status_code() {
+        return $this->status_code;
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/IO/EventLoopGroup.php ---
@@ -0,0 +1,39 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\IO;
+
+use AWS\CRT\NativeResource as NativeResource;
+use AWS\CRT\Options as Options;
+
+/**
+ * Represents 1 or more event loops (1 per thread) for doing I/O and background tasks.
+ * Typically, every application has one EventLoopGroup.
+ *
+ * @param array options:
+ * - int num_threads - Number of worker threads in the EventLoopGroup. Defaults to 0/1 per logical core.
+ */
+final class EventLoopGroup extends NativeResource {
+
+    static function defaults() {
+        return [
+            'max_threads' => 0,
+        ];
+    }
+
+    function __construct(array $options = []) {
+        parent::__construct();
+        $options = new Options($options, self::defaults());
+        $elg_options = self::$crt->event_loop_group_options_new();
+        self::$crt->event_loop_group_options_set_max_threads($elg_options, $options->getInt('max_threads'));
+        $this->acquire(self::$crt->event_loop_group_new($elg_options));
+        self::$crt->event_loop_group_options_release($elg_options);
+    }
+
+    function __destruct() {
+        self::$crt->event_loop_group_release($this->release());
+        parent::__destruct();
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/IO/InputStream.php ---
@@ -0,0 +1,49 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\IO;
+
+use AWS\CRT\NativeResource as NativeResource;
+
+final class InputStream extends NativeResource {
+    private $stream = null;
+
+    const SEEK_BEGIN = 0;
+    const SEEK_END = 2;
+
+    public function __construct($stream) {
+        $this->stream = $stream;
+        $options = self::$crt->input_stream_options_new();
+        // The stream implementation in native just converts the PHP stream into
+        // a native php_stream* and executes operations entirely in native
+        self::$crt->input_stream_options_set_user_data($options, $stream);
+        $this->acquire(self::$crt->input_stream_new($options));
+        self::$crt->input_stream_options_release($options);
+    }
+
+    public function __destruct() {
+        self::$crt->input_stream_release($this->release());
+        parent::__destruct();
+    }
+
+    public function eof() {
+        return self::$crt->input_stream_eof($this->native);
+    }
+
+    public function length() {
+        return self::$crt->input_stream_get_length($this->native);
+    }
+
+    public function read($length = 0) {
+        if ($length == 0) {
+            $length = $this->length();
+        }
+        return self::$crt->input_stream_read($this->native, $length);
+    }
+
+    public function seek($offset, $basis) {
+        return self::$crt->input_stream_seek($this->native, $offset, $basis);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Internal/Encoding.php ---
@@ -0,0 +1,37 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Internal;
+
+final class Encoding {
+    public static function readString(&$buffer) {
+        list($len, $str) = self::decodeString($buffer);
+        // Advance by sizeof(length) + strlen(str)
+        $buffer = substr($buffer, 4 + $len);
+        return $str;
+    }
+
+    public static function readStrings($buffer) {
+        $strings = [];
+        while (strlen($buffer)) {
+            $strings []= self::readString($buffer);
+        }
+        return $strings;
+    }
+
+    public static function decodeString($buffer) {
+        $len = unpack("N", $buffer)[1];
+        $buffer = substr($buffer, 4);
+        $str = unpack("a${len}", $buffer)[1];
+        return [$len, $str];
+    }
+
+    public static function encodeString($str) {
+        if (is_array($str)) {
+            $str = $str[0];
+        }
+        return pack("Na*", strlen($str), $str);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Internal/Extension.php ---
@@ -0,0 +1,29 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT\Internal;
+
+use \RuntimeException;
+
+/**
+ * @internal
+ * Forwards calls on to awscrt PHP extension functions
+ */
+final class Extension {
+    function __construct() {
+        if (!extension_loaded('awscrt')) {
+            throw new RuntimeException('awscrt extension is not loaded');
+        }
+    }
+
+    /**
+     * Forwards any call made on this object to the extension function of the
+     * same name with the supplied arguments. Argument type hinting and checking
+     * occurs at the CRT wrapper.
+     */
+    function __call($name, $args) {
+        return call_user_func_array($name, $args);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Log.php ---
@@ -0,0 +1,47 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT;
+use AWS\CRT\CRT;
+
+final class Log {
+    const NONE = 0;
+    const FATAL = 1;
+    const ERROR = 2;
+    const WARN = 3;
+    const INFO = 4;
+    const DEBUG = 5;
+    const TRACE = 6;
+
+    public static function toStdout() {
+        CRT::log_to_stdout();
+    }
+
+    public static function toStderr() {
+        CRT::log_to_stderr();
+    }
+
+    public static function toFile($filename) {
+        CRT::log_to_file($filename);
+    }
+
+    public static function toStream($stream) {
+        assert(get_resource_type($stream) == "stream");
+        CRT::log_to_stream($stream);
+    }
+
+    public static function stop() {
+        CRT::log_stop();
+    }
+
+    public static function setLogLevel($level) {
+        assert($level >= self::NONE && $level <= self::TRACE);
+        CRT::log_set_level($level);
+    }
+
+    public static function log($level, $message) {
+        CRT::log_message($level, $message);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/NativeResource.php ---
@@ -0,0 +1,42 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT;
+
+use AWS\CRT\CRT as CRT;
+
+/**
+ * Base class for all native resources, tracks all outstanding resources
+ * and provides basic leak checking
+ */
+abstract class NativeResource {
+    protected static $crt = null;
+    protected static $resources = [];
+    protected $native = null;
+
+    protected function __construct() {
+        if (is_null(self::$crt)) {
+            self::$crt = new CRT();
+        }
+
+        self::$resources[spl_object_hash($this)] = 1;
+    }
+
+    protected function acquire($handle) {
+        return $this->native = $handle;
+    }
+
+    protected function release() {
+        $native = $this->native;
+        $this->native = null;
+        return $native;
+    }
+
+    function __destruct() {
+        // Should have been destroyed and released by derived resource
+        assert($this->native == null);
+        unset(self::$resources[spl_object_hash($this)]);
+    }
+}

--- server/vendor/aws/aws-crt-php/src/AWS/CRT/Options.php ---
@@ -0,0 +1,77 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+namespace AWS\CRT;
+
+final class OptionValue {
+    private $value;
+    function __construct($value) {
+        $this->value = $value;
+    }
+
+    public function asObject() {
+        return $this->value;
+    }
+
+    public function asMixed() {
+        return $this->value;
+    }
+
+    public function asInt() {
+        return empty($this->value) ? 0 : (int)$this->value;
+    }
+
+    public function asBool() {
+        return boolval($this->value);
+    }
+
+    public function asString() {
+        return !empty($this->value) ? strval($this->value) : "";
+    }
+
+    public function asArray() {
+        return is_array($this->value) ? $this->value : (!empty($this->value) ? [$this->value] : []);
+    }
+
+    public function asCallable() {
+        return is_callable($this->value) ? $this->value : null;
+    }
+}
+
+final class Options {
+    private $options;
+
+    public function __construct($opts = [], $defaults = []) {
+        $this->options = array_replace($defaults, empty($opts) ? [] : $opts);
+    }
+
+    public function __get($name) {
+        return $this->get($name);
+    }
+
+    public function asArray() {
+        return $this->options;
+    }
+
+    public function toArray() {
+        return array_merge_recursive([], $this->options);
+    }
+
+    public function get($name) {
+        return new OptionValue($this->options[$name]);
+    }
+
+    public function getInt($name) {
+        return $this->get($name)->asInt();
+    }
+
+    public function getString($name) {
+        return $this->get($name)->asString();
+    }
+
+    public function getBool($name) {
+        return $this->get($name)->asBool();
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/000_CoreTest.php ---
@@ -0,0 +1,22 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\CRT;
+
+require_once('common.inc');
+
+// This intentionally does not inherit from CrtTestCase because it needs a clean-room environment
+final class CoreTest extends PHPUnit_Framework_TestCase {
+
+    // The CRT should always be available in this test suite
+    public function testIsAvailable() {
+        $this->assertTrue(CRT::isAvailable());
+    }
+
+    // We have done nothing to necessitate loading the CRT, it should not be loaded
+    public function testIsLoaded() {
+        $this->assertTrue(!CRT::isLoaded());
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-crt-php/tests/CrcTest.php ---
@@ -0,0 +1,90 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\CRT;
+
+require_once('common.inc');
+
+final class CrcTest extends CrtTestCase {
+
+    public function testCrc32ZeroesOneShot() {
+        $input = implode(array_map("chr", array_fill(0, 32, 0)));
+        $output = CRT::crc32($input);
+        $expected = 0x190A55AD;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32ZeroesIterated() {
+        $output = 0;
+        for ($i = 0; $i < 32; $i++) {
+            $output = CRT::crc32("\x00", $output);
+        }
+        $expected = 0x190A55AD;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32ValuesOneShot() {
+        $input = implode(array_map("chr", range(0, 31)));
+        $output = CRT::crc32($input);
+        $expected = 0x91267E8A;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32ValuesIterated() {
+        $output = 0;
+        foreach (range(0, 31) as $n) {
+            $output = CRT::crc32(chr($n), $output);
+        }
+        $expected = 0x91267E8A;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32LargeBuffer() {
+        $input = implode(array_map("chr", array_fill(0, 1 << 20, 0)));
+        $output = CRT::crc32($input);
+        $expected = 0xA738EA1C;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32cZeroesOneShot() {
+        $input = implode(array_map("chr", array_fill(0, 32, 0)));
+        $output = CRT::crc32c($input);
+        $expected = 0x8A9136AA;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32cZeroesIterated() {
+        $output = 0;
+        for ($i = 0; $i < 32; $i++) {
+            $output = CRT::crc32c("\x00", $output);
+        }
+        $expected = 0x8A9136AA;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32cValuesOneShot() {
+        $input = implode(array_map("chr", range(0, 31)));
+        $output = CRT::crc32c($input);
+        $expected = 0x46DD794E;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32cValuesIterated() {
+        $output = 0;
+        foreach (range(0, 31) as $n) {
+            $output = CRT::crc32c(chr($n), $output);
+        }
+        $expected = 0x46DD794E;
+        $this->assertEquals($output, $expected);
+    }
+
+    public function testCrc32cLargeBuffer() {
+        $input = implode(array_map("chr", array_fill(0, 1 << 20, 0)));
+        $output = CRT::crc32c($input);
+        $expected = 0x14298C12;
+        $this->assertEquals($output, $expected);
+    }
+    
+}

--- server/vendor/aws/aws-crt-php/tests/CredentialsTest.php ---
@@ -0,0 +1,46 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\Auth\AwsCredentials as AwsCredentials;
+use AWS\CRT\Auth\StaticCredentialsProvider as StaticCredentialsProvider;
+
+require_once('common.inc');
+
+final class CredentialsTest extends CrtTestCase {
+
+    public function testEmptyCredentials() {
+        $this->expectException(InvalidArgumentException::class);
+        $creds = new AwsCredentials(AwsCredentials::defaults());
+        $this->assertNotNull($creds, "Failed to create default/empty credentials");
+        $creds = null;
+    }
+
+    private function getCredentialsConfig() {
+        $options = AwsCredentials::defaults();
+        $options['access_key_id'] = 'TESTAWSACCESSKEYID';
+        $options['secret_access_key'] = 'TESTSECRETaccesskeyThatDefinitelyDoesntWork';
+        $options['session_token'] = 'ThisIsMyTestSessionTokenIMadeItUpMyself';
+        $options['expiration_timepoint_seconds'] = 42;
+        return $options;
+    }
+
+    public function testCredentialsLifetime() {
+        $options = $this->getCredentialsConfig();
+        $creds = new AwsCredentials($options);
+        $this->assertNotNull($creds, "Failed to create Credentials with options");
+        $this->assertEquals($creds->access_key_id, $options['access_key_id']);
+        $this->assertEquals($creds->secret_access_key, $options['secret_access_key']);
+        $this->assertEquals($creds->session_token, $options['session_token']);
+        $this->assertEquals($creds->expiration_timepoint_seconds, $options['expiration_timepoint_seconds']);
+        $creds = null;
+    }
+
+    public function testStaticCredentialsProviderLifetime() {
+        $options = $this->getCredentialsConfig();
+        $provider = new StaticCredentialsProvider($options);
+        $this->assertNotNull($provider, "Failed to create StaticCredentialsProvider");
+        $provider = null;
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/ErrorTest.php ---
@@ -0,0 +1,21 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\CRT;
+
+final class ErrorTest extends PHPUnit_Framework_TestCase {
+
+    public function testNoInitialError() {
+        $this->assertEquals(0, CRT::last_error());
+    }
+
+    public function testCanResolveErrorName() {
+        $this->assertEquals("AWS_ERROR_SUCCESS", CRT::error_name(0));
+    }
+
+    public function testCanResolveErrorStr() {
+        $this->assertEquals("Success.", CRT::error_str(0));
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/EventLoopGroupTest.php ---
@@ -0,0 +1,25 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\IO\EventLoopGroup as EventLoopGroup;
+
+require_once('common.inc');
+
+final class EventLoopGroupTest extends CrtTestCase {
+
+    public function testLifetime() {
+        $elg = new EventLoopGroup();
+        $this->assertNotNull($elg, "Failed to create default EventLoopGroup");
+        $elg = null;
+    }
+
+    public function testConstructionWithOptions() {
+        $options = EventLoopGroup::defaults();
+        $options['num_threads'] = 1;
+        $elg = new EventLoopGroup($options);
+        $this->assertNotNull($elg, "Failed to create EventLoopGroup with 1 thread");
+        $elg = null;
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/HttpMessageTest.php ---
@@ -0,0 +1,95 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\HTTP\Headers;
+use AWS\CRT\HTTP\Request;
+use AWS\CRT\HTTP\Response;
+
+require_once('common.inc');
+
+final class HttpMessageTest extends CrtTestCase {
+    public function testHeaders() {
+        $headers = new Headers();
+        $this->assertSame(0, $headers->count());
+    }
+
+    public function testHeadersMarshalling() {
+        $headers_array = [
+            "host" => "s3.amazonaws.com",
+            "test" => "this is a test header value"
+        ];
+        $headers = new Headers($headers_array);
+        $this->assertSame(2, $headers->count());
+        $this->assertSame($headers_array['host'], $headers->get('host'));
+        $this->assertSame($headers_array['test'], $headers->get('test'));
+        $buffer = Headers::marshall($headers);
+        $headers_copy = Headers::unmarshall($buffer);
+        $this->assertSame(2, $headers_copy->count());
+        $this->assertSame($headers_array['host'], $headers_copy->get('host'));
+        $this->assertSame($headers_array['test'], $headers_copy->get('test'));
+    }
+
+    private function assertMessagesMatch($a, $b) {
+        $this->assertSame($a->method(), $b->method());
+        $this->assertSame($a->path(), $b->path());
+        $this->assertSame($a->query(), $b->query());
+        $this->assertSame($a->headers()->toArray(), $b->headers()->toArray());
+    }
+
+    public function testRequestMarshalling() {
+        $headers = [
+            "host" => "s3.amazonaws.com",
+            "test" => "this is a test header value"
+        ];
+        $method = "GET";
+        $path = "/index.php";
+        $query = [];
+
+        $msg = new Request($method, $path, $query, $headers);
+        $msg_buf = Request::marshall($msg);
+        $msg_copy = Request::unmarshall($msg_buf);
+
+        $this->assertMessagesMatch($msg, $msg_copy);
+    }
+
+    public function testRequestMarshallingWithQueryParams() {
+        $headers = [
+            "host" => "s3.amazonaws.com",
+            "test" => "this is a test header value"
+        ];
+        $method = "GET";
+        $path = "/index.php";
+        $query = [
+            'request' => '1',
+            'test' => 'true',
+            'answer' => '42',
+            'foo' => 'bar',
+        ];
+
+        $msg = new Request($method, $path, $query, $headers);
+        $msg_buf = Request::marshall($msg);
+        $msg_copy = Request::unmarshall($msg_buf);
+
+        $this->assertMessagesMatch($msg, $msg_copy);
+    }
+
+    public function testResponseMarshalling() {
+        $headers = [
+            "content-length" => "42",
+            "test" => "this is a test header value"
+        ];
+        $method = "GET";
+        $path = "/index.php";
+        $query = [
+            'response' => '1'
+        ];
+
+        $msg = new Response($method, $path, $query, $headers, 200);
+        $msg_buf = Request::marshall($msg);
+        $msg_copy = Request::unmarshall($msg_buf);
+
+        $this->assertMessagesMatch($msg, $msg_copy);
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/LogTest.php ---
@@ -0,0 +1,23 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\Log;
+
+require_once('common.inc');
+
+class LogTest extends CrtTestCase {
+
+    public function testLogToStream() {
+        $log_stream = fopen("php://memory", "r+");
+        $this->assertNotNull($log_stream);
+        Log::toStream($log_stream);
+        Log::setLogLevel(Log::TRACE);
+        Log::log(Log::TRACE, "THIS IS A TEST");
+        $this->assertTrue(rewind($log_stream));
+        $log_contents = stream_get_contents($log_stream, -1, 0);
+        $this->assertStringEndsWith("THIS IS A TEST", trim($log_contents));
+        Log::stop();
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/SigningTest.php ---
@@ -0,0 +1,176 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+use AWS\CRT\Auth\SignatureType;
+use AWS\CRT\Auth\SigningAlgorithm;
+use AWS\CRT\Auth\SigningConfigAWS;
+use AWS\CRT\Auth\Signing;
+use AWS\CRT\Auth\Signable;
+use AWS\CRT\Auth\StaticCredentialsProvider;
+use AWS\CRT\HTTP\Request;
+
+require_once('common.inc');
+
+final class SigningTest extends CrtTestCase {
+
+    public function testConfigAWSLifetime() {
+        $config = new SigningConfigAWS();
+        $this->assertNotNull($config, "Failed to create default SigningConfigAWS");
+        $config = null;
+    }
+
+    public function testConfigAWSConstructionWithOptions() {
+        $options = SigningConfigAWS::defaults();
+        $options['service'] = 'CRT';
+        $options['region'] = 'CRT';
+        $config = new SigningConfigAWS($options);
+        $this->assertNotNull($config, "Failed to create SigningConfigAWS with custom options");
+        $config = null;
+    }
+
+    public function testSignableFromHttpRequestLifetime() {
+        $request = new Request('GET', '/');
+        $signable = Signable::fromHttpRequest($request);
+        $this->assertNotNull($signable, "Failed to create Signable from HTTP::Request");
+        $signable = null;
+    }
+
+    public function testSignableFromChunkLifetime() {
+        $chunk = "THIS IS A TEST CHUNK IT CONTAINS MULTITUDES";
+        $stream = fopen("php://memory", 'r+');
+        fputs($stream, $chunk);
+        rewind($stream);
+        $signable = Signable::fromChunk($stream);
+        $this->assertNotNull($signable, "Failed to create Signable from chunk stream");
+        $signable = null;
+    }
+
+    public function testSignableFromCanonicalRequestLifetime() {
+        $canonical_request = "THIS IS A CANONICAL_REQUEST. IT IS DEEPLY CANONICAL";
+        $signable = Signable::fromCanonicalRequest($canonical_request);
+        $this->assertNotNull($signable, "Failed to create Signable from canonical request");
+        $signable = null;
+    }
+
+    const SIGV4TEST_ACCESS_KEY_ID = 'AKIDEXAMPLE';
+    const SIGV4TEST_SECRET_ACCESS_KEY = 'wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY';
+    const SIGV4TEST_SESSION_TOKEN = null;
+    const SIGV4TEST_SERVICE = 'service';
+    const SIGV4TEST_REGION = 'us-east-1';
+    private static function SIGV4TEST_DATE() {
+        return mktime(12, 36, 0, 8, 30, 2015);
+    }
+
+    public function testShouldSignHeader() {
+        $credentials_provider = new StaticCredentialsProvider([
+            'access_key_id' => self::SIGV4TEST_ACCESS_KEY_ID,
+            'secret_access_key' => self::SIGV4TEST_SECRET_ACCESS_KEY,
+            'session_token' => self::SIGV4TEST_SESSION_TOKEN,
+        ]);
+        $signing_config = new SigningConfigAWS([
+            'algorithm' => SigningAlgorithm::SIGv4,
+            'signature_type' => SignatureType::HTTP_REQUEST_HEADERS,
+            'credentials_provider' => $credentials_provider,
+            'region' => self::SIGV4TEST_REGION,
+            'service' => self::SIGV4TEST_SERVICE,
+            'date' => self::SIGV4TEST_DATE(),
+            'should_sign_header' => function($header) {
+                return strtolower($header) != 'x-do-not-sign';
+            }
+        ]);
+        $http_request = new Request('GET', '/', [], [
+            'Host' => 'example.amazonaws.com',
+            'X-Do-Not-Sign' => 'DO NOT SIGN THIS']);
+        $this->assertNotNull($http_request, "Unable to create HttpRequest for signing");
+        $signable = Signable::fromHttpRequest($http_request);
+        $this->assertNotNull($signable, "Unable to create signable from HttpRequest");
+
+        Signing::signRequestAws(
+            $signable, $signing_config,
+            function($signing_result, $error_code) use (&$http_request) {
+                $this->assertEquals(0, $error_code);
+                $signing_result->applyToHttpRequest($http_request);
+            }
+        );
+
+        // This signature value is computed without the X-Do-Not-Sign header above
+        $headers = $http_request->headers();
+        $this->assertEquals(
+            'AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/service/aws4_request, SignedHeaders=host;x-amz-date, Signature=5fa00fa31553b73ebf1942676e86291e8372ff2a2260956d9b8aae1d763fbf31',
+            $headers->get('Authorization'));
+    }
+
+    public function testSigv4HeaderSigning() {
+        $credentials_provider = new StaticCredentialsProvider([
+            'access_key_id' => self::SIGV4TEST_ACCESS_KEY_ID,
+            'secret_access_key' => self::SIGV4TEST_SECRET_ACCESS_KEY,
+            'session_token' => self::SIGV4TEST_SESSION_TOKEN,
+        ]);
+        $signing_config = new SigningConfigAWS([
+            'algorithm' => SigningAlgorithm::SIGv4,
+            'signature_type' => SignatureType::HTTP_REQUEST_HEADERS,
+            'credentials_provider' => $credentials_provider,
+            'region' => self::SIGV4TEST_REGION,
+            'service' => self::SIGV4TEST_SERVICE,
+            'date' => self::SIGV4TEST_DATE(),
+        ]);
+        $http_request = new Request('GET', '/', [], ['Host' => 'example.amazonaws.com']);
+        $this->assertNotNull($http_request, "Unable to create HttpRequest for signing");
+        $signable = Signable::fromHttpRequest($http_request);
+        $this->assertNotNull($signable, "Unable to create signable from HttpRequest");
+
+        Signing::signRequestAws(
+            $signable, $signing_config,
+            function($signing_result, $error_code) use (&$http_request) {
+                $this->assertEquals(0, $error_code);
+                $signing_result->applyToHttpRequest($http_request);
+            }
+        );
+
+        $headers = $http_request->headers();
+        $this->assertEquals(
+            'AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/service/aws4_request, SignedHeaders=host;x-amz-date, Signature=5fa00fa31553b73ebf1942676e86291e8372ff2a2260956d9b8aae1d763fbf31',
+            $headers->get('Authorization'));
+        $this->assertEquals('20150830T123600Z', $headers->get('X-Amz-Date'));
+    }
+
+    public function testSigV4aHeaderSigning() {
+        $credentials_provider = new StaticCredentialsProvider([
+            'access_key_id' => self::SIGV4TEST_ACCESS_KEY_ID,
+            'secret_access_key' => self::SIGV4TEST_SECRET_ACCESS_KEY,
+            'session_token' => self::SIGV4TEST_SESSION_TOKEN,
+        ]);
+        $signing_config = new SigningConfigAWS([
+            'algorithm' => SigningAlgorithm::SIGv4_ASYMMETRIC,
+            'signature_type' => SignatureType::HTTP_REQUEST_HEADERS,
+            'credentials_provider' => $credentials_provider,
+            'region' => self::SIGV4TEST_REGION,
+            'service' => self::SIGV4TEST_SERVICE,
+            'date' => self::SIGV4TEST_DATE(),
+        ]);
+
+        $http_request = new Request('GET', '/', [], ['Host' => 'example.amazonaws.com']);
+        $this->assertNotNull($http_request, "Unable to create HttpRequest for signing");
+        $signable = Signable::fromHttpRequest($http_request);
+        $this->assertNotNull($signable, "Unable to create signable from HttpRequest");
+
+        Signing::signRequestAws(
+            $signable, $signing_config,
+            function($signing_result, $error_code) use (&$http_request) {
+                $this->assertEquals(0, $error_code);
+                $signing_result->applyToHttpRequest($http_request);
+            }
+        );
+
+        $headers = $http_request->headers();
+        $auth_header_value = $headers->get('Authorization');
+        $this->assertNotNull($auth_header_value);
+        $this->assertStringStartsWith(
+            'AWS4-ECDSA-P256-SHA256 Credential=AKIDEXAMPLE/20150830/service/aws4_request, SignedHeaders=host;x-amz-date;x-amz-region-set, Signature=',
+            $auth_header_value);
+        $this->assertEquals('20150830T123600Z', $headers->get('X-Amz-Date'));
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/StreamTest.php ---
@@ -0,0 +1,34 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\IO\InputStream as InputStream;
+
+require_once('common.inc');
+
+final class InputStreamTest extends CrtTestCase {
+
+    const MEM_STREAM_CONTENTS = "THIS IS A TEST";
+
+    private function getMemoryStream() {
+        $stream = fopen("php://memory", 'r+');
+        fputs($stream, self::MEM_STREAM_CONTENTS);
+        rewind($stream);
+        return $stream;
+    }
+
+    public function testMemoryStream() {
+        $mem_stream = $this->getMemoryStream();
+        $stream = new InputStream($mem_stream);
+        $this->assertNotNull($stream, "Failed to create InputStream from PHP memory stream");
+        $this->assertEquals(strlen(self::MEM_STREAM_CONTENTS), $stream->length(), "Stream length doesn't match source buffer");
+        $this->assertEquals(self::MEM_STREAM_CONTENTS, $stream->read(), "Stream doesn't match source buffer");
+        $this->assertTrue($stream->eof(), "Stream is not EOF after reading");
+        $this->assertEquals(0, $stream->seek(0, InputStream::SEEK_BEGIN), "Unable to rewind stream");
+        $this->assertFalse($stream->eof(), "Stream is EOF after rewinding");
+        $this->assertEquals(0, $stream->seek(0, InputStream::SEEK_END), "Unable to seek to end of stream");
+        $this->assertTrue($stream->eof(), "Stream is not EOF after seeking to end");
+        $stream = null;
+    }
+}

--- server/vendor/aws/aws-crt-php/tests/common.inc ---
@@ -0,0 +1,34 @@
+<?php
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+use AWS\CRT\CRT as CRT;
+
+ini_set("memory_limit", "512M");
+
+abstract class CrtTestCase extends PHPUnit_Framework_TestCase {
+    private static $crt = null;
+    public static function setUpBeforeClass() {
+        self::$crt = new CRT();
+    }
+
+    public static function tearDownAfterClass() {
+        self::$crt = null;
+    }
+
+    // Ensure that after every test there are no errors in the CRT itself
+    protected function assertPostConditions() {
+        if (CRT::last_error()) {
+            $this->fail("Test left an error on the stack: " . CRT::error_name(CRT::last_error()));
+        }
+    }
+
+    // Shim missing calls in older versions of PHPUnit
+    public function __call($name, $arguments) {
+        // shim expectException -> setExpectedException for PHPUnit 4.8.x
+        if ($name == 'expectException') {
+            $this->setExpectedException($arguments[0]);
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/CODE_OF_CONDUCT.md ---
@@ -0,0 +1,4 @@
+## Code of Conduct
+This project has adopted the [Amazon Open Source Code of Conduct](https://aws.github.io/code-of-conduct). 
+For more information see the [Code of Conduct FAQ](https://aws.github.io/code-of-conduct-faq) or contact 
+opensource-codeofconduct@amazon.com with any additional questions or comments.
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/CRT_INSTRUCTIONS.md ---
@@ -0,0 +1,4 @@
+## Building and enabling the Common Run Time
+
+1. **Follow instructions on crt repo** – Clone and build the repo as shown [here][https://github.com/awslabs/aws-crt-php].
+1. **Enable the CRT** – add the following line to your php.ini file `extension=path/to/aws-crt-php/modules/awscrt.so`
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/LICENSE ---
@@ -0,0 +1,141 @@
+# Apache License
+Version 2.0, January 2004
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+## 1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1
+through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the
+License.
+
+"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled
+by, or are under common control with that entity. For the purposes of this definition, "control" means
+(i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract
+or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial
+ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications, including but not limited to software
+source code, documentation source, and configuration files.
+
+"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form,
+including but not limited to compiled object code, generated documentation, and conversions to other media
+types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License,
+as indicated by a copyright notice that is included in or attached to the work (an example is provided in the
+Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from)
+the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent,
+as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not
+include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work
+and Derivative Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original version of the Work and any
+modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to
+Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to
+submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of
+electronic, verbal, or written communication sent to the Licensor or its representatives, including but not
+limited to communication on electronic mailing lists, source code control systems, and issue tracking systems
+that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but
+excluding communication that is conspicuously marked or otherwise designated in writing by the copyright
+owner as "Not a Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been
+received by Licensor and subsequently incorporated within the Work.
+
+## 2. Grant of Copyright License.
+
+Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual,
+worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare
+Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such
+Derivative Works in Source or Object form.
+
+## 3. Grant of Patent License.
+
+Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual,
+worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent
+license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such
+license applies only to those patent claims licensable by such Contributor that are necessarily infringed by
+their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such
+Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim
+or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work
+constitutes direct or contributory patent infringement, then any patent licenses granted to You under this
+License for that Work shall terminate as of the date such litigation is filed.
+
+## 4. Redistribution.
+
+You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without
+modifications, and in Source or Object form, provided that You meet the following conditions:
+
+   1. You must give any other recipients of the Work or Derivative Works a copy of this License; and
+
+   2. You must cause any modified files to carry prominent notices stating that You changed the files; and
+
+   3. You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent,
+	  trademark, and attribution notices from the Source form of the Work, excluding those notices that do
+	  not pertain to any part of the Derivative Works; and
+
+   4. If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that
+	  You distribute must include a readable copy of the attribution notices contained within such NOTICE
+	  file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one
+	  of the following places: within a NOTICE text file distributed as part of the Derivative Works; within
+	  the Source form or documentation, if provided along with the Derivative Works; or, within a display
+	  generated by the Derivative Works, if and wherever such third-party notices normally appear. The
+	  contents of the NOTICE file are for informational purposes only and do not modify the License. You may
+	  add Your own attribution notices within Derivative Works that You distribute, alongside or as an
+	  addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be
+	  construed as modifying the License.
+
+You may add Your own copyright statement to Your modifications and may provide additional or different license
+terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative
+Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the
+conditions stated in this License.
+
+## 5. Submission of Contributions.
+
+Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by
+You to the Licensor shall be under the terms and conditions of this License, without any additional terms or
+conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate
+license agreement you may have executed with Licensor regarding such Contributions.
+
+## 6. Trademarks.
+
+This License does not grant permission to use the trade names, trademarks, service marks, or product names of
+the Licensor, except as required for reasonable and customary use in describing the origin of the Work and
+reproducing the content of the NOTICE file.
+
+## 7. Disclaimer of Warranty.
+
+Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor
+provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT,
+MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the
+appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of
+permissions under this License.
+
+## 8. Limitation of Liability.
+
+In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless
+required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any
+Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential
+damages of any character arising as a result of this License or out of the use or inability to use the Work
+(including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or
+any and all other commercial damages or losses), even if such Contributor has been advised of the possibility
+of such damages.
+
+## 9. Accepting Warranty or Additional Liability.
+
+While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for,
+acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this
+License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole
+responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold
+each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason
+of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS

--- server/vendor/aws/aws-sdk-php/NOTICE ---
@@ -0,0 +1,17 @@
+# AWS SDK for PHP
+
+<http://aws.amazon.com/php>
+
+Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License").
+You may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.

--- server/vendor/aws/aws-sdk-php/THIRD-PARTY-LICENSES ---
@@ -0,0 +1,84 @@
+The AWS SDK for PHP includes the following third-party software/licensing:
+
+
+** Guzzle - https://github.com/guzzle/guzzle
+
+Copyright (c) 2014 Michael Dowling, https://github.com/mtdowling
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+----------------
+
+** jmespath.php - https://github.com/mtdowling/jmespath.php
+
+Copyright (c) 2014 Michael Dowling, https://github.com/mtdowling
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+----------------
+
+** phpunit-mock-objects -- https://github.com/sebastianbergmann/phpunit-mock-objects
+
+Copyright (c) 2002-2018, Sebastian Bergmann <sebastian@phpunit.de>.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+ * Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+
+ * Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in
+   the documentation and/or other materials provided with the
+   distribution.
+
+ * Neither the name of Sebastian Bergmann nor the names of his
+   contributors may be used to endorse or promote products derived
+   from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/composer.json ---
@@ -0,0 +1,69 @@
+{
+    "name": "aws/aws-sdk-php",
+    "homepage": "http://aws.amazon.com/sdkforphp",
+    "description": "AWS SDK for PHP - Use Amazon Web Services in your PHP project",
+    "keywords": ["aws","amazon","sdk","s3","ec2","dynamodb","cloud","glacier"],
+    "type": "library",
+    "license": "Apache-2.0",
+    "authors": [
+        {
+            "name": "Amazon Web Services",
+            "homepage": "http://aws.amazon.com"
+        }
+    ],
+    "support": {
+        "forum": "https://forums.aws.amazon.com/forum.jspa?forumID=80",
+        "issues": "https://github.com/aws/aws-sdk-php/issues"
+    },
+    "require": {
+        "php": ">=5.5",
+        "guzzlehttp/guzzle": "^5.3.3|^6.2.1|^7.0",
+        "guzzlehttp/psr7": "^1.7.0|^2.0",
+        "guzzlehttp/promises": "^1.4.0",
+        "mtdowling/jmespath.php": "^2.6",
+        "ext-pcre": "*",
+        "ext-json": "*",
+        "ext-simplexml": "*",
+        "aws/aws-crt-php": "^1.0.2"
+    },
+    "require-dev": {
+        "ext-openssl": "*",
+        "ext-dom": "*",
+        "ext-pcntl": "*",
+        "ext-sockets": "*",
+        "phpunit/phpunit": "^4.8.35|^5.4.3",
+        "behat/behat": "~3.0",
+        "doctrine/cache": "~1.4",
+        "aws/aws-php-sns-message-validator": "~1.0",
+        "nette/neon": "^2.3",
+        "andrewsville/php-token-reflection": "^1.4",
+        "psr/cache": "^1.0",
+        "psr/simple-cache": "^1.0",
+        "paragonie/random_compat": ">= 2",
+        "sebastian/comparator": "^1.2.3"
+    },
+    "suggest": {
+        "ext-openssl": "Allows working with CloudFront private distributions and verifying received SNS messages",
+        "ext-curl": "To send requests using cURL",
+        "ext-sockets": "To use client-side monitoring",
+        "doctrine/cache": "To use the DoctrineCacheAdapter",
+        "aws/aws-php-sns-message-validator": "To validate incoming SNS notifications"
+    },
+    "autoload": {
+        "psr-4": {
+            "Aws\\": "src/"
+        },
+        "files": ["src/functions.php"]
+    },
+    "autoload-dev": {
+        "psr-4": {
+            "Aws\\Test\\": "tests/"
+        },
+        "classmap": ["build/"]
+    },
+    "extra": {
+        "branch-alias": {
+            "dev-master": "3.0-dev"
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/ACMPCA/ACMPCAClient.php ---
@@ -0,0 +1,55 @@
+<?php
+namespace Aws\ACMPCA;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Certificate Manager Private Certificate Authority** service.
+ * @method \Aws\Result createCertificateAuthority(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createCertificateAuthorityAsync(array $args = [])
+ * @method \Aws\Result createCertificateAuthorityAuditReport(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createCertificateAuthorityAuditReportAsync(array $args = [])
+ * @method \Aws\Result createPermission(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createPermissionAsync(array $args = [])
+ * @method \Aws\Result deleteCertificateAuthority(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteCertificateAuthorityAsync(array $args = [])
+ * @method \Aws\Result deletePermission(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deletePermissionAsync(array $args = [])
+ * @method \Aws\Result deletePolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deletePolicyAsync(array $args = [])
+ * @method \Aws\Result describeCertificateAuthority(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeCertificateAuthorityAsync(array $args = [])
+ * @method \Aws\Result describeCertificateAuthorityAuditReport(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeCertificateAuthorityAuditReportAsync(array $args = [])
+ * @method \Aws\Result getCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getCertificateAsync(array $args = [])
+ * @method \Aws\Result getCertificateAuthorityCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getCertificateAuthorityCertificateAsync(array $args = [])
+ * @method \Aws\Result getCertificateAuthorityCsr(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getCertificateAuthorityCsrAsync(array $args = [])
+ * @method \Aws\Result getPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getPolicyAsync(array $args = [])
+ * @method \Aws\Result importCertificateAuthorityCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importCertificateAuthorityCertificateAsync(array $args = [])
+ * @method \Aws\Result issueCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise issueCertificateAsync(array $args = [])
+ * @method \Aws\Result listCertificateAuthorities(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listCertificateAuthoritiesAsync(array $args = [])
+ * @method \Aws\Result listPermissions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listPermissionsAsync(array $args = [])
+ * @method \Aws\Result listTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsAsync(array $args = [])
+ * @method \Aws\Result putPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putPolicyAsync(array $args = [])
+ * @method \Aws\Result restoreCertificateAuthority(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise restoreCertificateAuthorityAsync(array $args = [])
+ * @method \Aws\Result revokeCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise revokeCertificateAsync(array $args = [])
+ * @method \Aws\Result tagCertificateAuthority(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagCertificateAuthorityAsync(array $args = [])
+ * @method \Aws\Result untagCertificateAuthority(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagCertificateAuthorityAsync(array $args = [])
+ * @method \Aws\Result updateCertificateAuthority(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateCertificateAuthorityAsync(array $args = [])
+ */
+class ACMPCAClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ACMPCA/Exception/ACMPCAException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ACMPCA\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Certificate Manager Private Certificate Authority** service.
+ */
+class ACMPCAException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AbstractConfigurationProvider.php ---
@@ -0,0 +1,157 @@
+<?php
+namespace Aws;
+
+use GuzzleHttp\Promise;
+
+/**
+ * A configuration provider is a function that returns a promise that is
+ * fulfilled with a configuration object. This class provides base functionality
+ * usable by specific configuration provider implementations
+ */
+abstract class AbstractConfigurationProvider
+{
+    const ENV_PROFILE = 'AWS_PROFILE';
+    const ENV_CONFIG_FILE = 'AWS_CONFIG_FILE';
+
+    public static $cacheKey;
+
+    protected static $interfaceClass;
+    protected static $exceptionClass;
+
+    /**
+     * Wraps a config provider and saves provided configuration in an
+     * instance of Aws\CacheInterface. Forwards calls when no config found
+     * in cache and updates cache with the results.
+     *
+     * @param callable $provider Configuration provider function to wrap
+     * @param CacheInterface $cache Cache to store configuration
+     * @param string|null $cacheKey (optional) Cache key to use
+     *
+     * @return callable
+     */
+    public static function cache(
+        callable $provider,
+        CacheInterface $cache,
+        $cacheKey = null
+    ) {
+        $cacheKey = $cacheKey ?: static::$cacheKey;
+
+        return function () use ($provider, $cache, $cacheKey) {
+            $found = $cache->get($cacheKey);
+            if ($found instanceof static::$interfaceClass) {
+                return Promise\Create::promiseFor($found);
+            }
+
+            return $provider()
+                ->then(function ($config) use (
+                    $cache,
+                    $cacheKey
+                ) {
+                    $cache->set($cacheKey, $config);
+                    return $config;
+                });
+        };
+    }
+
+    /**
+     * Creates an aggregate configuration provider that invokes the provided
+     * variadic providers one after the other until a provider returns
+     * configuration.
+     *
+     * @return callable
+     */
+    public static function chain()
+    {
+        $links = func_get_args();
+        if (empty($links)) {
+            throw new \InvalidArgumentException('No providers in chain');
+        }
+
+        return function () use ($links) {
+            /** @var callable $parent */
+            $parent = array_shift($links);
+            $promise = $parent();
+            while ($next = array_shift($links)) {
+                $promise = $promise->otherwise($next);
+            }
+            return $promise;
+        };
+    }
+
+    /**
+     * Gets the environment's HOME directory if available.
+     *
+     * @return null|string
+     */
+    protected static function getHomeDir()
+    {
+        // On Linux/Unix-like systems, use the HOME environment variable
+        if ($homeDir = getenv('HOME')) {
+            return $homeDir;
+        }
+
+        // Get the HOMEDRIVE and HOMEPATH values for Windows hosts
+        $homeDrive = getenv('HOMEDRIVE');
+        $homePath = getenv('HOMEPATH');
+
+        return ($homeDrive && $homePath) ? $homeDrive . $homePath : null;
+    }
+
+    /**
+     * Gets default config file location from environment, falling back to aws
+     * default location
+     *
+     * @return string
+     */
+    protected static function getDefaultConfigFilename()
+    {
+        if ($filename = getenv(self::ENV_CONFIG_FILE)) {
+            return $filename;
+        }
+        return self::getHomeDir() . '/.aws/config';
+    }
+
+    /**
+     * Wraps a config provider and caches previously provided configuration.
+     *
+     * @param callable $provider Config provider function to wrap.
+     *
+     * @return callable
+     */
+    public static function memoize(callable $provider)
+    {
+        return function () use ($provider) {
+            static $result;
+            static $isConstant;
+
+            // Constant config will be returned constantly.
+            if ($isConstant) {
+                return $result;
+            }
+
+            // Create the initial promise that will be used as the cached value
+            if (null === $result) {
+                $result = $provider();
+            }
+
+            // Return config and set flag that provider is already set
+            return $result
+                ->then(function ($config) use (&$isConstant) {
+                    $isConstant = true;
+                    return $config;
+                });
+        };
+    }
+
+    /**
+     * Reject promise with standardized exception.
+     *
+     * @param $msg
+     * @return Promise\RejectedPromise
+     */
+    protected static function reject($msg)
+    {
+        $exceptionClass = static::$exceptionClass;
+        return new Promise\RejectedPromise(new $exceptionClass($msg));
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/AccessAnalyzer/AccessAnalyzerClient.php ---
@@ -0,0 +1,65 @@
+<?php
+namespace Aws\AccessAnalyzer;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Access Analyzer** service.
+ * @method \Aws\Result applyArchiveRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise applyArchiveRuleAsync(array $args = [])
+ * @method \Aws\Result cancelPolicyGeneration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise cancelPolicyGenerationAsync(array $args = [])
+ * @method \Aws\Result createAccessPreview(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAccessPreviewAsync(array $args = [])
+ * @method \Aws\Result createAnalyzer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAnalyzerAsync(array $args = [])
+ * @method \Aws\Result createArchiveRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createArchiveRuleAsync(array $args = [])
+ * @method \Aws\Result deleteAnalyzer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAnalyzerAsync(array $args = [])
+ * @method \Aws\Result deleteArchiveRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteArchiveRuleAsync(array $args = [])
+ * @method \Aws\Result getAccessPreview(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAccessPreviewAsync(array $args = [])
+ * @method \Aws\Result getAnalyzedResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAnalyzedResourceAsync(array $args = [])
+ * @method \Aws\Result getAnalyzer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAnalyzerAsync(array $args = [])
+ * @method \Aws\Result getArchiveRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getArchiveRuleAsync(array $args = [])
+ * @method \Aws\Result getFinding(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getFindingAsync(array $args = [])
+ * @method \Aws\Result getGeneratedPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getGeneratedPolicyAsync(array $args = [])
+ * @method \Aws\Result listAccessPreviewFindings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAccessPreviewFindingsAsync(array $args = [])
+ * @method \Aws\Result listAccessPreviews(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAccessPreviewsAsync(array $args = [])
+ * @method \Aws\Result listAnalyzedResources(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAnalyzedResourcesAsync(array $args = [])
+ * @method \Aws\Result listAnalyzers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAnalyzersAsync(array $args = [])
+ * @method \Aws\Result listArchiveRules(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listArchiveRulesAsync(array $args = [])
+ * @method \Aws\Result listFindings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listFindingsAsync(array $args = [])
+ * @method \Aws\Result listPolicyGenerations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listPolicyGenerationsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result startPolicyGeneration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startPolicyGenerationAsync(array $args = [])
+ * @method \Aws\Result startResourceScan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startResourceScanAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateArchiveRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateArchiveRuleAsync(array $args = [])
+ * @method \Aws\Result updateFindings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateFindingsAsync(array $args = [])
+ * @method \Aws\Result validatePolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise validatePolicyAsync(array $args = [])
+ */
+class AccessAnalyzerClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AccessAnalyzer/Exception/AccessAnalyzerException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AccessAnalyzer\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Access Analyzer** service.
+ */
+class AccessAnalyzerException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Account/AccountClient.php ---
@@ -0,0 +1,15 @@
+<?php
+namespace Aws\Account;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Account** service.
+ * @method \Aws\Result deleteAlternateContact(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAlternateContactAsync(array $args = [])
+ * @method \Aws\Result getAlternateContact(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAlternateContactAsync(array $args = [])
+ * @method \Aws\Result putAlternateContact(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putAlternateContactAsync(array $args = [])
+ */
+class AccountClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Account/Exception/AccountException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Account\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Account** service.
+ */
+class AccountException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Acm/AcmClient.php ---
@@ -0,0 +1,40 @@
+<?php
+namespace Aws\Acm;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Certificate Manager** service.
+ *
+ * @method \Aws\Result addTagsToCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise addTagsToCertificateAsync(array $args = [])
+ * @method \Aws\Result deleteCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteCertificateAsync(array $args = [])
+ * @method \Aws\Result describeCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeCertificateAsync(array $args = [])
+ * @method \Aws\Result exportCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exportCertificateAsync(array $args = [])
+ * @method \Aws\Result getAccountConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAccountConfigurationAsync(array $args = [])
+ * @method \Aws\Result getCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getCertificateAsync(array $args = [])
+ * @method \Aws\Result importCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importCertificateAsync(array $args = [])
+ * @method \Aws\Result listCertificates(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listCertificatesAsync(array $args = [])
+ * @method \Aws\Result listTagsForCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForCertificateAsync(array $args = [])
+ * @method \Aws\Result putAccountConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putAccountConfigurationAsync(array $args = [])
+ * @method \Aws\Result removeTagsFromCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise removeTagsFromCertificateAsync(array $args = [])
+ * @method \Aws\Result renewCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise renewCertificateAsync(array $args = [])
+ * @method \Aws\Result requestCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise requestCertificateAsync(array $args = [])
+ * @method \Aws\Result resendValidationEmail(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise resendValidationEmailAsync(array $args = [])
+ * @method \Aws\Result updateCertificateOptions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateCertificateOptionsAsync(array $args = [])
+ */
+class AcmClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Acm/Exception/AcmException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Acm\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Certificate Manager** service.
+ */
+class AcmException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AlexaForBusiness/AlexaForBusinessClient.php ---
@@ -0,0 +1,195 @@
+<?php
+namespace Aws\AlexaForBusiness;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Alexa For Business** service.
+ * @method \Aws\Result approveSkill(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise approveSkillAsync(array $args = [])
+ * @method \Aws\Result associateContactWithAddressBook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateContactWithAddressBookAsync(array $args = [])
+ * @method \Aws\Result associateDeviceWithNetworkProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateDeviceWithNetworkProfileAsync(array $args = [])
+ * @method \Aws\Result associateDeviceWithRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateDeviceWithRoomAsync(array $args = [])
+ * @method \Aws\Result associateSkillGroupWithRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateSkillGroupWithRoomAsync(array $args = [])
+ * @method \Aws\Result associateSkillWithSkillGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateSkillWithSkillGroupAsync(array $args = [])
+ * @method \Aws\Result associateSkillWithUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateSkillWithUsersAsync(array $args = [])
+ * @method \Aws\Result createAddressBook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAddressBookAsync(array $args = [])
+ * @method \Aws\Result createBusinessReportSchedule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBusinessReportScheduleAsync(array $args = [])
+ * @method \Aws\Result createConferenceProvider(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createConferenceProviderAsync(array $args = [])
+ * @method \Aws\Result createContact(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createContactAsync(array $args = [])
+ * @method \Aws\Result createGatewayGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createGatewayGroupAsync(array $args = [])
+ * @method \Aws\Result createNetworkProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createNetworkProfileAsync(array $args = [])
+ * @method \Aws\Result createProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createProfileAsync(array $args = [])
+ * @method \Aws\Result createRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRoomAsync(array $args = [])
+ * @method \Aws\Result createSkillGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createSkillGroupAsync(array $args = [])
+ * @method \Aws\Result createUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createUserAsync(array $args = [])
+ * @method \Aws\Result deleteAddressBook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAddressBookAsync(array $args = [])
+ * @method \Aws\Result deleteBusinessReportSchedule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBusinessReportScheduleAsync(array $args = [])
+ * @method \Aws\Result deleteConferenceProvider(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteConferenceProviderAsync(array $args = [])
+ * @method \Aws\Result deleteContact(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteContactAsync(array $args = [])
+ * @method \Aws\Result deleteDevice(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDeviceAsync(array $args = [])
+ * @method \Aws\Result deleteDeviceUsageData(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDeviceUsageDataAsync(array $args = [])
+ * @method \Aws\Result deleteGatewayGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteGatewayGroupAsync(array $args = [])
+ * @method \Aws\Result deleteNetworkProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteNetworkProfileAsync(array $args = [])
+ * @method \Aws\Result deleteProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteProfileAsync(array $args = [])
+ * @method \Aws\Result deleteRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRoomAsync(array $args = [])
+ * @method \Aws\Result deleteRoomSkillParameter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRoomSkillParameterAsync(array $args = [])
+ * @method \Aws\Result deleteSkillAuthorization(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteSkillAuthorizationAsync(array $args = [])
+ * @method \Aws\Result deleteSkillGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteSkillGroupAsync(array $args = [])
+ * @method \Aws\Result deleteUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteUserAsync(array $args = [])
+ * @method \Aws\Result disassociateContactFromAddressBook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateContactFromAddressBookAsync(array $args = [])
+ * @method \Aws\Result disassociateDeviceFromRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateDeviceFromRoomAsync(array $args = [])
+ * @method \Aws\Result disassociateSkillFromSkillGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateSkillFromSkillGroupAsync(array $args = [])
+ * @method \Aws\Result disassociateSkillFromUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateSkillFromUsersAsync(array $args = [])
+ * @method \Aws\Result disassociateSkillGroupFromRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateSkillGroupFromRoomAsync(array $args = [])
+ * @method \Aws\Result forgetSmartHomeAppliances(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise forgetSmartHomeAppliancesAsync(array $args = [])
+ * @method \Aws\Result getAddressBook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAddressBookAsync(array $args = [])
+ * @method \Aws\Result getConferencePreference(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getConferencePreferenceAsync(array $args = [])
+ * @method \Aws\Result getConferenceProvider(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getConferenceProviderAsync(array $args = [])
+ * @method \Aws\Result getContact(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getContactAsync(array $args = [])
+ * @method \Aws\Result getDevice(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeviceAsync(array $args = [])
+ * @method \Aws\Result getGateway(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getGatewayAsync(array $args = [])
+ * @method \Aws\Result getGatewayGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getGatewayGroupAsync(array $args = [])
+ * @method \Aws\Result getInvitationConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getInvitationConfigurationAsync(array $args = [])
+ * @method \Aws\Result getNetworkProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getNetworkProfileAsync(array $args = [])
+ * @method \Aws\Result getProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getProfileAsync(array $args = [])
+ * @method \Aws\Result getRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRoomAsync(array $args = [])
+ * @method \Aws\Result getRoomSkillParameter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRoomSkillParameterAsync(array $args = [])
+ * @method \Aws\Result getSkillGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSkillGroupAsync(array $args = [])
+ * @method \Aws\Result listBusinessReportSchedules(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBusinessReportSchedulesAsync(array $args = [])
+ * @method \Aws\Result listConferenceProviders(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listConferenceProvidersAsync(array $args = [])
+ * @method \Aws\Result listDeviceEvents(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDeviceEventsAsync(array $args = [])
+ * @method \Aws\Result listGatewayGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listGatewayGroupsAsync(array $args = [])
+ * @method \Aws\Result listGateways(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listGatewaysAsync(array $args = [])
+ * @method \Aws\Result listSkills(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSkillsAsync(array $args = [])
+ * @method \Aws\Result listSkillsStoreCategories(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSkillsStoreCategoriesAsync(array $args = [])
+ * @method \Aws\Result listSkillsStoreSkillsByCategory(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSkillsStoreSkillsByCategoryAsync(array $args = [])
+ * @method \Aws\Result listSmartHomeAppliances(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSmartHomeAppliancesAsync(array $args = [])
+ * @method \Aws\Result listTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsAsync(array $args = [])
+ * @method \Aws\Result putConferencePreference(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putConferencePreferenceAsync(array $args = [])
+ * @method \Aws\Result putInvitationConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putInvitationConfigurationAsync(array $args = [])
+ * @method \Aws\Result putRoomSkillParameter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putRoomSkillParameterAsync(array $args = [])
+ * @method \Aws\Result putSkillAuthorization(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putSkillAuthorizationAsync(array $args = [])
+ * @method \Aws\Result registerAVSDevice(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise registerAVSDeviceAsync(array $args = [])
+ * @method \Aws\Result rejectSkill(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise rejectSkillAsync(array $args = [])
+ * @method \Aws\Result resolveRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise resolveRoomAsync(array $args = [])
+ * @method \Aws\Result revokeInvitation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise revokeInvitationAsync(array $args = [])
+ * @method \Aws\Result searchAddressBooks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchAddressBooksAsync(array $args = [])
+ * @method \Aws\Result searchContacts(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchContactsAsync(array $args = [])
+ * @method \Aws\Result searchDevices(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchDevicesAsync(array $args = [])
+ * @method \Aws\Result searchNetworkProfiles(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchNetworkProfilesAsync(array $args = [])
+ * @method \Aws\Result searchProfiles(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchProfilesAsync(array $args = [])
+ * @method \Aws\Result searchRooms(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchRoomsAsync(array $args = [])
+ * @method \Aws\Result searchSkillGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchSkillGroupsAsync(array $args = [])
+ * @method \Aws\Result searchUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchUsersAsync(array $args = [])
+ * @method \Aws\Result sendAnnouncement(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise sendAnnouncementAsync(array $args = [])
+ * @method \Aws\Result sendInvitation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise sendInvitationAsync(array $args = [])
+ * @method \Aws\Result startDeviceSync(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startDeviceSyncAsync(array $args = [])
+ * @method \Aws\Result startSmartHomeApplianceDiscovery(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startSmartHomeApplianceDiscoveryAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateAddressBook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAddressBookAsync(array $args = [])
+ * @method \Aws\Result updateBusinessReportSchedule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBusinessReportScheduleAsync(array $args = [])
+ * @method \Aws\Result updateConferenceProvider(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateConferenceProviderAsync(array $args = [])
+ * @method \Aws\Result updateContact(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateContactAsync(array $args = [])
+ * @method \Aws\Result updateDevice(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDeviceAsync(array $args = [])
+ * @method \Aws\Result updateGateway(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateGatewayAsync(array $args = [])
+ * @method \Aws\Result updateGatewayGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateGatewayGroupAsync(array $args = [])
+ * @method \Aws\Result updateNetworkProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateNetworkProfileAsync(array $args = [])
+ * @method \Aws\Result updateProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateProfileAsync(array $args = [])
+ * @method \Aws\Result updateRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRoomAsync(array $args = [])
+ * @method \Aws\Result updateSkillGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateSkillGroupAsync(array $args = [])
+ */
+class AlexaForBusinessClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AlexaForBusiness/Exception/AlexaForBusinessException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AlexaForBusiness\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Alexa For Business** service.
+ */
+class AlexaForBusinessException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Amplify/AmplifyClient.php ---
@@ -0,0 +1,83 @@
+<?php
+namespace Aws\Amplify;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Amplify** service.
+ * @method \Aws\Result createApp(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppAsync(array $args = [])
+ * @method \Aws\Result createBackendEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackendEnvironmentAsync(array $args = [])
+ * @method \Aws\Result createBranch(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBranchAsync(array $args = [])
+ * @method \Aws\Result createDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDeploymentAsync(array $args = [])
+ * @method \Aws\Result createDomainAssociation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDomainAssociationAsync(array $args = [])
+ * @method \Aws\Result createWebhook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createWebhookAsync(array $args = [])
+ * @method \Aws\Result deleteApp(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppAsync(array $args = [])
+ * @method \Aws\Result deleteBackendEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackendEnvironmentAsync(array $args = [])
+ * @method \Aws\Result deleteBranch(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBranchAsync(array $args = [])
+ * @method \Aws\Result deleteDomainAssociation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDomainAssociationAsync(array $args = [])
+ * @method \Aws\Result deleteJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteJobAsync(array $args = [])
+ * @method \Aws\Result deleteWebhook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteWebhookAsync(array $args = [])
+ * @method \Aws\Result generateAccessLogs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise generateAccessLogsAsync(array $args = [])
+ * @method \Aws\Result getApp(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAppAsync(array $args = [])
+ * @method \Aws\Result getArtifactUrl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getArtifactUrlAsync(array $args = [])
+ * @method \Aws\Result getBackendEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackendEnvironmentAsync(array $args = [])
+ * @method \Aws\Result getBranch(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBranchAsync(array $args = [])
+ * @method \Aws\Result getDomainAssociation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDomainAssociationAsync(array $args = [])
+ * @method \Aws\Result getJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getJobAsync(array $args = [])
+ * @method \Aws\Result getWebhook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getWebhookAsync(array $args = [])
+ * @method \Aws\Result listApps(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppsAsync(array $args = [])
+ * @method \Aws\Result listArtifacts(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listArtifactsAsync(array $args = [])
+ * @method \Aws\Result listBackendEnvironments(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackendEnvironmentsAsync(array $args = [])
+ * @method \Aws\Result listBranches(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBranchesAsync(array $args = [])
+ * @method \Aws\Result listDomainAssociations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDomainAssociationsAsync(array $args = [])
+ * @method \Aws\Result listJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listJobsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result listWebhooks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listWebhooksAsync(array $args = [])
+ * @method \Aws\Result startDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startDeploymentAsync(array $args = [])
+ * @method \Aws\Result startJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startJobAsync(array $args = [])
+ * @method \Aws\Result stopJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopJobAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateApp(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAppAsync(array $args = [])
+ * @method \Aws\Result updateBranch(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBranchAsync(array $args = [])
+ * @method \Aws\Result updateDomainAssociation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDomainAssociationAsync(array $args = [])
+ * @method \Aws\Result updateWebhook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateWebhookAsync(array $args = [])
+ */
+class AmplifyClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Amplify/Exception/AmplifyException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Amplify\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Amplify** service.
+ */
+class AmplifyException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AmplifyBackend/AmplifyBackendClient.php ---
@@ -0,0 +1,71 @@
+<?php
+namespace Aws\AmplifyBackend;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AmplifyBackend** service.
+ * @method \Aws\Result cloneBackend(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise cloneBackendAsync(array $args = [])
+ * @method \Aws\Result createBackend(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackendAsync(array $args = [])
+ * @method \Aws\Result createBackendAPI(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackendAPIAsync(array $args = [])
+ * @method \Aws\Result createBackendAuth(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackendAuthAsync(array $args = [])
+ * @method \Aws\Result createBackendConfig(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackendConfigAsync(array $args = [])
+ * @method \Aws\Result createBackendStorage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackendStorageAsync(array $args = [])
+ * @method \Aws\Result createToken(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createTokenAsync(array $args = [])
+ * @method \Aws\Result deleteBackend(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackendAsync(array $args = [])
+ * @method \Aws\Result deleteBackendAPI(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackendAPIAsync(array $args = [])
+ * @method \Aws\Result deleteBackendAuth(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackendAuthAsync(array $args = [])
+ * @method \Aws\Result deleteBackendStorage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackendStorageAsync(array $args = [])
+ * @method \Aws\Result deleteToken(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteTokenAsync(array $args = [])
+ * @method \Aws\Result generateBackendAPIModels(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise generateBackendAPIModelsAsync(array $args = [])
+ * @method \Aws\Result getBackend(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackendAsync(array $args = [])
+ * @method \Aws\Result getBackendAPI(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackendAPIAsync(array $args = [])
+ * @method \Aws\Result getBackendAPIModels(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackendAPIModelsAsync(array $args = [])
+ * @method \Aws\Result getBackendAuth(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackendAuthAsync(array $args = [])
+ * @method \Aws\Result getBackendJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackendJobAsync(array $args = [])
+ * @method \Aws\Result getBackendStorage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackendStorageAsync(array $args = [])
+ * @method \Aws\Result getToken(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getTokenAsync(array $args = [])
+ * @method \Aws\Result importBackendAuth(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importBackendAuthAsync(array $args = [])
+ * @method \Aws\Result importBackendStorage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importBackendStorageAsync(array $args = [])
+ * @method \Aws\Result listBackendJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackendJobsAsync(array $args = [])
+ * @method \Aws\Result listS3Buckets(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listS3BucketsAsync(array $args = [])
+ * @method \Aws\Result removeAllBackends(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise removeAllBackendsAsync(array $args = [])
+ * @method \Aws\Result removeBackendConfig(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise removeBackendConfigAsync(array $args = [])
+ * @method \Aws\Result updateBackendAPI(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBackendAPIAsync(array $args = [])
+ * @method \Aws\Result updateBackendAuth(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBackendAuthAsync(array $args = [])
+ * @method \Aws\Result updateBackendConfig(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBackendConfigAsync(array $args = [])
+ * @method \Aws\Result updateBackendJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBackendJobAsync(array $args = [])
+ * @method \Aws\Result updateBackendStorage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBackendStorageAsync(array $args = [])
+ */
+class AmplifyBackendClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AmplifyBackend/Exception/AmplifyBackendException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AmplifyBackend\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AmplifyBackend** service.
+ */
+class AmplifyBackendException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AmplifyUIBuilder/AmplifyUIBuilderClient.php ---
@@ -0,0 +1,37 @@
+<?php
+namespace Aws\AmplifyUIBuilder;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Amplify UI Builder** service.
+ * @method \Aws\Result createComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createComponentAsync(array $args = [])
+ * @method \Aws\Result createTheme(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createThemeAsync(array $args = [])
+ * @method \Aws\Result deleteComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteComponentAsync(array $args = [])
+ * @method \Aws\Result deleteTheme(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteThemeAsync(array $args = [])
+ * @method \Aws\Result exchangeCodeForToken(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exchangeCodeForTokenAsync(array $args = [])
+ * @method \Aws\Result exportComponents(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exportComponentsAsync(array $args = [])
+ * @method \Aws\Result exportThemes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exportThemesAsync(array $args = [])
+ * @method \Aws\Result getComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getComponentAsync(array $args = [])
+ * @method \Aws\Result getTheme(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getThemeAsync(array $args = [])
+ * @method \Aws\Result listComponents(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listComponentsAsync(array $args = [])
+ * @method \Aws\Result listThemes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listThemesAsync(array $args = [])
+ * @method \Aws\Result refreshToken(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise refreshTokenAsync(array $args = [])
+ * @method \Aws\Result updateComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateComponentAsync(array $args = [])
+ * @method \Aws\Result updateTheme(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateThemeAsync(array $args = [])
+ */
+class AmplifyUIBuilderClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AmplifyUIBuilder/Exception/AmplifyUIBuilderException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AmplifyUIBuilder\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Amplify UI Builder** service.
+ */
+class AmplifyUIBuilderException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Api/AbstractModel.php ---
@@ -0,0 +1,71 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Base class that is used by most API shapes
+ */
+abstract class AbstractModel implements \ArrayAccess
+{
+    /** @var array */
+    protected $definition;
+
+    /** @var ShapeMap */
+    protected $shapeMap;
+
+    /**
+     * @param array    $definition Service description
+     * @param ShapeMap $shapeMap   Shapemap used for creating shapes
+     */
+    public function __construct(array $definition, ShapeMap $shapeMap)
+    {
+        $this->definition = $definition;
+        $this->shapeMap = $shapeMap;
+    }
+
+    public function toArray()
+    {
+        return $this->definition;
+    }
+
+    #[\ReturnTypeWillChange]
+    public function offsetGet($offset)
+    {
+        return isset($this->definition[$offset])
+            ? $this->definition[$offset] : null;
+    }
+
+    #[\ReturnTypeWillChange]
+    public function offsetSet($offset, $value)
+    {
+        $this->definition[$offset] = $value;
+    }
+
+    #[\ReturnTypeWillChange]
+    public function offsetExists($offset)
+    {
+        return isset($this->definition[$offset]);
+    }
+
+    #[\ReturnTypeWillChange]
+    public function offsetUnset($offset)
+    {
+        unset($this->definition[$offset]);
+    }
+
+    protected function shapeAt($key)
+    {
+        if (!isset($this->definition[$key])) {
+            throw new \InvalidArgumentException('Expected shape definition at '
+                . $key);
+        }
+
+        return $this->shapeFor($this->definition[$key]);
+    }
+
+    protected function shapeFor(array $definition)
+    {
+        return isset($definition['shape'])
+            ? $this->shapeMap->resolve($definition)
+            : Shape::create($definition, $this->shapeMap);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/ApiProvider.php ---
@@ -0,0 +1,244 @@
+<?php
+namespace Aws\Api;
+
+use Aws\Exception\UnresolvedApiException;
+
+/**
+ * API providers.
+ *
+ * An API provider is a function that accepts a type, service, and version and
+ * returns an array of API data on success or NULL if no API data can be created
+ * for the provided arguments.
+ *
+ * You can wrap your calls to an API provider with the
+ * {@see ApiProvider::resolve} method to ensure that API data is created. If the
+ * API data is not created, then the resolve() method will throw a
+ * {@see Aws\Exception\UnresolvedApiException}.
+ *
+ *     use Aws\Api\ApiProvider;
+ *     $provider = ApiProvider::defaultProvider();
+ *     // Returns an array or NULL.
+ *     $data = $provider('api', 's3', '2006-03-01');
+ *     // Returns an array or throws.
+ *     $data = ApiProvider::resolve($provider, 'api', 'elasticfood', '2020-01-01');
+ *
+ * You can compose multiple providers into a single provider using
+ * {@see Aws\or_chain}. This method accepts providers as arguments and
+ * returns a new function that will invoke each provider until a non-null value
+ * is returned.
+ *
+ *     $a = ApiProvider::filesystem(sys_get_temp_dir() . '/aws-beta-models');
+ *     $b = ApiProvider::manifest();
+ *
+ *     $c = \Aws\or_chain($a, $b);
+ *     $data = $c('api', 'betaservice', '2015-08-08'); // $a handles this.
+ *     $data = $c('api', 's3', '2006-03-01');          // $b handles this.
+ *     $data = $c('api', 'invalid', '2014-12-15');     // Neither handles this.
+ */
+class ApiProvider
+{
+    /** @var array A map of public API type names to their file suffix. */
+    private static $typeMap = [
+        'api'       => 'api-2',
+        'paginator' => 'paginators-1',
+        'waiter'    => 'waiters-2',
+        'docs'      => 'docs-2',
+    ];
+
+    /** @var array API manifest */
+    private $manifest;
+
+    /** @var string The directory containing service models. */
+    private $modelsDir;
+
+    /**
+     * Resolves an API provider and ensures a non-null return value.
+     *
+     * @param callable $provider Provider function to invoke.
+     * @param string   $type     Type of data ('api', 'waiter', 'paginator').
+     * @param string   $service  Service name.
+     * @param string   $version  API version.
+     *
+     * @return array
+     * @throws UnresolvedApiException
+     */
+    public static function resolve(callable $provider, $type, $service, $version)
+    {
+        // Execute the provider and return the result, if there is one.
+        $result = $provider($type, $service, $version);
+        if (is_array($result)) {
+            if (!isset($result['metadata']['serviceIdentifier'])) {
+                $result['metadata']['serviceIdentifier'] = $service;
+            }
+            return $result;
+        }
+
+        // Throw an exception with a message depending on the inputs.
+        if (!isset(self::$typeMap[$type])) {
+            $msg = "The type must be one of: " . implode(', ', self::$typeMap);
+        } elseif ($service) {
+            $msg = "The {$service} service does not have version: {$version}.";
+        } else {
+            $msg = "You must specify a service name to retrieve its API data.";
+        }
+
+        throw new UnresolvedApiException($msg);
+    }
+
+    /**
+     * Default SDK API provider.
+     *
+     * This provider loads pre-built manifest data from the `data` directory.
+     *
+     * @return self
+     */
+    public static function defaultProvider()
+    {
+        return new self(__DIR__ . '/../data', \Aws\manifest());
+    }
+
+    /**
+     * Loads API data after resolving the version to the latest, compatible,
+     * available version based on the provided manifest data.
+     *
+     * Manifest data is essentially an associative array of service names to
+     * associative arrays of API version aliases.
+     *
+     * [
+     *   ...
+     *   'ec2' => [
+     *     'latest'     => '2014-10-01',
+     *     '2014-10-01' => '2014-10-01',
+     *     '2014-09-01' => '2014-10-01',
+     *     '2014-06-15' => '2014-10-01',
+     *     ...
+     *   ],
+     *   'ecs' => [...],
+     *   'elasticache' => [...],
+     *   ...
+     * ]
+     *
+     * @param string $dir      Directory containing service models.
+     * @param array  $manifest The API version manifest data.
+     *
+     * @return self
+     */
+    public static function manifest($dir, array $manifest)
+    {
+        return new self($dir, $manifest);
+    }
+
+    /**
+     * Loads API data from the specified directory.
+     *
+     * If "latest" is specified as the version, this provider must glob the
+     * directory to find which is the latest available version.
+     *
+     * @param string $dir Directory containing service models.
+     *
+     * @return self
+     * @throws \InvalidArgumentException if the provided `$dir` is invalid.
+     */
+    public static function filesystem($dir)
+    {
+        return new self($dir);
+    }
+
+    /**
+     * Retrieves a list of valid versions for the specified service.
+     *
+     * @param string $service Service name
+     *
+     * @return array
+     */
+    public function getVersions($service)
+    {
+        if (!isset($this->manifest)) {
+            $this->buildVersionsList($service);
+        }
+
+        if (!isset($this->manifest[$service]['versions'])) {
+            return [];
+        }
+
+        return array_values(array_unique($this->manifest[$service]['versions']));
+    }
+
+    /**
+     * Execute the provider.
+     *
+     * @param string $type    Type of data ('api', 'waiter', 'paginator').
+     * @param string $service Service name.
+     * @param string $version API version.
+     *
+     * @return array|null
+     */
+    public function __invoke($type, $service, $version)
+    {
+        // Resolve the type or return null.
+        if (isset(self::$typeMap[$type])) {
+            $type = self::$typeMap[$type];
+        } else {
+            return null;
+        }
+
+        // Resolve the version or return null.
+        if (!isset($this->manifest)) {
+            $this->buildVersionsList($service);
+        }
+
+        if (!isset($this->manifest[$service]['versions'][$version])) {
+            return null;
+        }
+
+        $version = $this->manifest[$service]['versions'][$version];
+        $path = "{$this->modelsDir}/{$service}/{$version}/{$type}.json";
+
+        try {
+            return \Aws\load_compiled_json($path);
+        } catch (\InvalidArgumentException $e) {
+            return null;
+        }
+    }
+
+    /**
+     * @param string $modelsDir Directory containing service models.
+     * @param array  $manifest  The API version manifest data.
+     */
+    private function __construct($modelsDir, array $manifest = null)
+    {
+        $this->manifest = $manifest;
+        $this->modelsDir = rtrim($modelsDir, '/');
+        if (!is_dir($this->modelsDir)) {
+            throw new \InvalidArgumentException(
+                "The specified models directory, {$modelsDir}, was not found."
+            );
+        }
+    }
+
+    /**
+     * Build the versions list for the specified service by globbing the dir.
+     */
+    private function buildVersionsList($service)
+    {
+        $dir = "{$this->modelsDir}/{$service}/";
+
+        if (!is_dir($dir)) {
+            return;
+        }
+
+        // Get versions, remove . and .., and sort in descending order.
+        $results = array_diff(scandir($dir, SCANDIR_SORT_DESCENDING), ['..', '.']);
+
+        if (!$results) {
+            $this->manifest[$service] = ['versions' => []];
+        } else {
+            $this->manifest[$service] = [
+                'versions' => [
+                    'latest' => $results[0]
+                ]
+            ];
+            $this->manifest[$service]['versions'] += array_combine($results, $results);
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/DateTimeResult.php ---
@@ -0,0 +1,124 @@
+<?php
+
+namespace Aws\Api;
+
+use Aws\Api\Parser\Exception\ParserException;
+use DateTime;
+use DateTimeZone;
+use Exception;
+
+/**
+ * DateTime overrides that make DateTime work more seamlessly as a string,
+ * with JSON documents, and with JMESPath.
+ */
+class DateTimeResult extends \DateTime implements \JsonSerializable
+{
+    /**
+     * Create a new DateTimeResult from a unix timestamp.
+     * The Unix epoch (or Unix time or POSIX time or Unix
+     * timestamp) is the number of seconds that have elapsed since
+     * January 1, 1970 (midnight UTC/GMT).
+     *
+     * @return DateTimeResult
+     * @throws Exception
+     */
+    public static function fromEpoch($unixTimestamp)
+    {
+        if (!is_numeric($unixTimestamp)) {
+            throw new ParserException('Invalid timestamp value passed to DateTimeResult::fromEpoch');
+        }
+
+        // PHP 5.5 does not support sub-second precision
+        if (\PHP_VERSION_ID < 56000) {
+            return new self(gmdate('c', $unixTimestamp));
+        }
+
+        $decimalSeparator = isset(localeconv()['decimal_point']) ? localeconv()['decimal_point'] : ".";
+        $formatString = "U" . $decimalSeparator . "u";
+        $dateTime = DateTime::createFromFormat(
+            $formatString,
+            sprintf('%0.6f', $unixTimestamp),
+            new DateTimeZone('UTC')
+        );
+
+        if (false === $dateTime) {
+            throw new ParserException('Invalid timestamp value passed to DateTimeResult::fromEpoch');
+        }
+
+        return new self(
+            $dateTime->format('Y-m-d H:i:s.u'),
+            new DateTimeZone('UTC')
+        );
+    }
+
+    /**
+     * @return DateTimeResult
+     */
+    public static function fromISO8601($iso8601Timestamp)
+    {
+        if (is_numeric($iso8601Timestamp) || !is_string($iso8601Timestamp)) {
+            throw new ParserException('Invalid timestamp value passed to DateTimeResult::fromISO8601');
+        }
+
+        return new DateTimeResult($iso8601Timestamp);
+    }
+
+    /**
+     * Create a new DateTimeResult from an unknown timestamp.
+     *
+     * @return DateTimeResult
+     * @throws Exception
+     */
+    public static function fromTimestamp($timestamp, $expectedFormat = null)
+    {
+        if (empty($timestamp)) {
+            return self::fromEpoch(0);
+        }
+
+        if (!(is_string($timestamp) || is_numeric($timestamp))) {
+            throw new ParserException('Invalid timestamp value passed to DateTimeResult::fromTimestamp');
+        }
+
+        try {
+            if ($expectedFormat == 'iso8601') {
+                try {
+                    return self::fromISO8601($timestamp);
+                } catch (Exception $exception) {
+                    return self::fromEpoch($timestamp);
+                }
+            } else if ($expectedFormat == 'unixTimestamp') {
+                try {
+                    return self::fromEpoch($timestamp);
+                } catch (Exception $exception) {
+                    return self::fromISO8601($timestamp);
+                }
+            } else if (\Aws\is_valid_epoch($timestamp)) {
+                return self::fromEpoch($timestamp);
+            }
+            return self::fromISO8601($timestamp);
+        } catch (Exception $exception) {
+            throw new ParserException('Invalid timestamp value passed to DateTimeResult::fromTimestamp');
+        }
+    }
+
+    /**
+     * Serialize the DateTimeResult as an ISO 8601 date string.
+     *
+     * @return string
+     */
+    public function __toString()
+    {
+        return $this->format('c');
+    }
+
+    /**
+     * Serialize the date as an ISO 8601 date when serializing as JSON.
+     *
+     * @return string
+     */
+    #[\ReturnTypeWillChange]
+    public function jsonSerialize()
+    {
+        return (string) $this;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/DocModel.php ---
@@ -0,0 +1,128 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Encapsulates the documentation strings for a given service-version and
+ * provides methods for extracting the desired parts related to a service,
+ * operation, error, or shape (i.e., parameter).
+ */
+class DocModel
+{
+    /** @var array */
+    private $docs;
+
+    /**
+     * @param array $docs
+     *
+     * @throws \RuntimeException
+     */
+    public function __construct(array $docs)
+    {
+        if (!extension_loaded('tidy')) {
+            throw new \RuntimeException('The "tidy" PHP extension is required.');
+        }
+
+        $this->docs = $docs;
+    }
+
+    /**
+     * Convert the doc model to an array.
+     *
+     * @return array
+     */
+    public function toArray()
+    {
+        return $this->docs;
+    }
+
+    /**
+     * Retrieves documentation about the service.
+     *
+     * @return null|string
+     */
+    public function getServiceDocs()
+    {
+        return isset($this->docs['service']) ? $this->docs['service'] : null;
+    }
+
+    /**
+     * Retrieves documentation about an operation.
+     *
+     * @param string $operation Name of the operation
+     *
+     * @return null|string
+     */
+    public function getOperationDocs($operation)
+    {
+        return isset($this->docs['operations'][$operation])
+            ? $this->docs['operations'][$operation]
+            : null;
+    }
+
+    /**
+     * Retrieves documentation about an error.
+     *
+     * @param string $error Name of the error
+     *
+     * @return null|string
+     */
+    public function getErrorDocs($error)
+    {
+        return isset($this->docs['shapes'][$error]['base'])
+            ? $this->docs['shapes'][$error]['base']
+            : null;
+    }
+
+    /**
+     * Retrieves documentation about a shape, specific to the context.
+     *
+     * @param string $shapeName  Name of the shape.
+     * @param string $parentName Name of the parent/context shape.
+     * @param string $ref        Name used by the context to reference the shape.
+     *
+     * @return null|string
+     */
+    public function getShapeDocs($shapeName, $parentName, $ref)
+    {
+        if (!isset($this->docs['shapes'][$shapeName])) {
+            return '';
+        }
+
+        $result = '';
+        $d = $this->docs['shapes'][$shapeName];
+        if (isset($d['refs']["{$parentName}\$${ref}"])) {
+            $result = $d['refs']["{$parentName}\$${ref}"];
+        } elseif (isset($d['base'])) {
+            $result = $d['base'];
+        }
+
+        if (isset($d['append'])) {
+            $result .= $d['append'];
+        }
+
+        return $this->clean($result);
+    }
+
+    private function clean($content)
+    {
+        if (!$content) {
+            return '';
+        }
+
+        $tidy = new \tidy();
+        $tidy->parseString($content, [
+            'indent' => true,
+            'doctype' => 'omit',
+            'output-html' => true,
+            'show-body-only' => true,
+            'drop-empty-paras' => true,
+            'drop-font-tags' => true,
+            'drop-proprietary-attributes' => true,
+            'hide-comments' => true,
+            'logical-emphasis' => true
+        ]);
+        $tidy->cleanRepair();
+
+        return (string) $content;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/ErrorParser/AbstractErrorParser.php ---
@@ -0,0 +1,95 @@
+<?php
+namespace Aws\Api\ErrorParser;
+
+use Aws\Api\Parser\MetadataParserTrait;
+use Aws\Api\Parser\PayloadParserTrait;
+use Aws\Api\Service;
+use Aws\Api\StructureShape;
+use Aws\CommandInterface;
+use Psr\Http\Message\ResponseInterface;
+
+abstract class AbstractErrorParser
+{
+    use MetadataParserTrait;
+    use PayloadParserTrait;
+
+    /**
+     * @var Service
+     */
+    protected $api;
+
+    /**
+     * @param Service $api
+     */
+    public function __construct(Service $api = null)
+    {
+        $this->api = $api;
+    }
+
+    abstract protected function payload(
+        ResponseInterface $response,
+        StructureShape $member
+    );
+
+    protected function extractPayload(
+        StructureShape $member,
+        ResponseInterface $response
+    ) {
+        if ($member instanceof StructureShape) {
+            // Structure members parse top-level data into a specific key.
+            return $this->payload($response, $member);
+        } else {
+            // Streaming data is just the stream from the response body.
+            return $response->getBody();
+        }
+    }
+
+    protected function populateShape(
+        array &$data,
+        ResponseInterface $response,
+        CommandInterface $command = null
+    ) {
+        $data['body'] = [];
+
+        if (!empty($command) && !empty($this->api)) {
+
+            // If modeled error code is indicated, check for known error shape
+            if (!empty($data['code'])) {
+
+                $errors = $this->api->getOperation($command->getName())->getErrors();
+                foreach ($errors as $key => $error) {
+
+                    // If error code matches a known error shape, populate the body
+                    if ($data['code'] == $error['name']
+                        && $error instanceof StructureShape
+                    ) {
+                        $modeledError = $error;
+                        $data['body'] = $this->extractPayload(
+                            $modeledError,
+                            $response
+                        );
+                        $data['error_shape'] = $modeledError;
+
+                        foreach ($error->getMembers() as $name => $member) {
+                            switch ($member['location']) {
+                                case 'header':
+                                    $this->extractHeader($name, $member, $response, $data['body']);
+                                    break;
+                                case 'headers':
+                                    $this->extractHeaders($name, $member, $response, $data['body']);
+                                    break;
+                                case 'statusCode':
+                                    $this->extractStatus($name, $response, $data['body']);
+                                    break;
+                            }
+                        }
+
+                        break;
+                    }
+                }
+            }
+        }
+
+        return $data;
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/src/Api/ErrorParser/JsonParserTrait.php ---
@@ -0,0 +1,38 @@
+<?php
+namespace Aws\Api\ErrorParser;
+
+use Aws\Api\Parser\PayloadParserTrait;
+use Aws\Api\StructureShape;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * Provides basic JSON error parsing functionality.
+ */
+trait JsonParserTrait
+{
+    use PayloadParserTrait;
+
+    private function genericHandler(ResponseInterface $response)
+    {
+        $code = (string) $response->getStatusCode();
+
+        return [
+            'request_id'  => (string) $response->getHeaderLine('x-amzn-requestid'),
+            'code'        => null,
+            'message'     => null,
+            'type'        => $code[0] == '4' ? 'client' : 'server',
+            'parsed'      => $this->parseJson($response->getBody(), $response)
+        ];
+    }
+
+    protected function payload(
+        ResponseInterface $response,
+        StructureShape $member
+    ) {
+        $jsonBody = $this->parseJson($response->getBody(), $response);
+
+        if ($jsonBody) {
+            return $this->parser->parse($member, $jsonBody);
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/ErrorParser/JsonRpcErrorParser.php ---
@@ -0,0 +1,47 @@
+<?php
+namespace Aws\Api\ErrorParser;
+
+use Aws\Api\Parser\JsonParser;
+use Aws\Api\Service;
+use Aws\CommandInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * Parsers JSON-RPC errors.
+ */
+class JsonRpcErrorParser extends AbstractErrorParser
+{
+    use JsonParserTrait;
+
+    private $parser;
+
+    public function __construct(Service $api = null, JsonParser $parser = null)
+    {
+        parent::__construct($api);
+        $this->parser = $parser ?: new JsonParser();
+    }
+
+    public function __invoke(
+        ResponseInterface $response,
+        CommandInterface $command = null
+    ) {
+        $data = $this->genericHandler($response);
+
+        // Make the casing consistent across services.
+        if ($data['parsed']) {
+            $data['parsed'] = array_change_key_case($data['parsed']);
+        }
+
+        if (isset($data['parsed']['__type'])) {
+            $parts = explode('#', $data['parsed']['__type']);
+            $data['code'] = isset($parts[1]) ? $parts[1] : $parts[0];
+            $data['message'] = isset($data['parsed']['message'])
+                ? $data['parsed']['message']
+                : null;
+        }
+
+        $this->populateShape($data, $response, $command);
+
+        return $data;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/ErrorParser/RestJsonErrorParser.php ---
@@ -0,0 +1,58 @@
+<?php
+namespace Aws\Api\ErrorParser;
+
+use Aws\Api\Parser\JsonParser;
+use Aws\Api\Service;
+use Aws\Api\StructureShape;
+use Aws\CommandInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * Parses JSON-REST errors.
+ */
+class RestJsonErrorParser extends AbstractErrorParser
+{
+    use JsonParserTrait;
+
+    private $parser;
+
+    public function __construct(Service $api = null, JsonParser $parser = null)
+    {
+        parent::__construct($api);
+        $this->parser = $parser ?: new JsonParser();
+    }
+
+    public function __invoke(
+        ResponseInterface $response,
+        CommandInterface $command = null
+    ) {
+        $data = $this->genericHandler($response);
+
+        // Merge in error data from the JSON body
+        if ($json = $data['parsed']) {
+            $data = array_replace($data, $json);
+        }
+
+        // Correct error type from services like Amazon Glacier
+        if (!empty($data['type'])) {
+            $data['type'] = strtolower($data['type']);
+        }
+
+        // Retrieve the error code from services like Amazon Elastic Transcoder
+        if ($code = $response->getHeaderLine('x-amzn-errortype')) {
+            $colon = strpos($code, ':');
+            $data['code'] = $colon ? substr($code, 0, $colon) : $code;
+        }
+
+        // Retrieve error message directly
+        $data['message'] = isset($data['parsed']['message'])
+            ? $data['parsed']['message']
+            : (isset($data['parsed']['Message'])
+                ? $data['parsed']['Message']
+                : null);
+
+        $this->populateShape($data, $response, $command);
+
+        return $data;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/ErrorParser/XmlErrorParser.php ---
@@ -0,0 +1,111 @@
+<?php
+namespace Aws\Api\ErrorParser;
+
+use Aws\Api\Parser\PayloadParserTrait;
+use Aws\Api\Parser\XmlParser;
+use Aws\Api\Service;
+use Aws\Api\StructureShape;
+use Aws\CommandInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * Parses XML errors.
+ */
+class XmlErrorParser extends AbstractErrorParser
+{
+    use PayloadParserTrait;
+
+    protected $parser;
+
+    public function __construct(Service $api = null, XmlParser $parser = null)
+    {
+        parent::__construct($api);
+        $this->parser = $parser ?: new XmlParser();
+    }
+
+    public function __invoke(
+        ResponseInterface $response,
+        CommandInterface $command = null
+    ) {
+        $code = (string) $response->getStatusCode();
+
+        $data = [
+            'type' => $code[0] == '4' ? 'client' : 'server',
+            'request_id' => null,
+            'code' => null,
+            'message' => null,
+            'parsed' => null
+        ];
+
+        $body = $response->getBody();
+        if ($body->getSize() > 0) {
+            $this->parseBody($this->parseXml($body, $response), $data);
+        } else {
+            $this->parseHeaders($response, $data);
+        }
+
+        $this->populateShape($data, $response, $command);
+
+        return $data;
+    }
+
+    private function parseHeaders(ResponseInterface $response, array &$data)
+    {
+        if ($response->getStatusCode() == '404') {
+            $data['code'] = 'NotFound';
+        }
+
+        $data['message'] = $response->getStatusCode() . ' '
+            . $response->getReasonPhrase();
+
+        if ($requestId = $response->getHeaderLine('x-amz-request-id')) {
+            $data['request_id'] = $requestId;
+            $data['message'] .= " (Request-ID: $requestId)";
+        }
+    }
+
+    private function parseBody(\SimpleXMLElement $body, array &$data)
+    {
+        $data['parsed'] = $body;
+        $prefix = $this->registerNamespacePrefix($body);
+
+        if ($tempXml = $body->xpath("//{$prefix}Code[1]")) {
+            $data['code'] = (string) $tempXml[0];
+        }
+
+        if ($tempXml = $body->xpath("//{$prefix}Message[1]")) {
+            $data['message'] = (string) $tempXml[0];
+        }
+
+        $tempXml = $body->xpath("//{$prefix}RequestId[1]");
+        if (isset($tempXml[0])) {
+            $data['request_id'] = (string)$tempXml[0];
+        }
+    }
+
+    protected function registerNamespacePrefix(\SimpleXMLElement $element)
+    {
+        $namespaces = $element->getDocNamespaces();
+        if (!isset($namespaces[''])) {
+            return '';
+        } 
+        
+        // Account for the default namespace being defined and PHP not
+        // being able to handle it :(.
+        $element->registerXPathNamespace('ns', $namespaces['']);
+        return 'ns:';
+    }
+
+    protected function payload(
+        ResponseInterface $response,
+        StructureShape $member
+    ) {
+        $xmlBody = $this->parseXml($response->getBody(), $response);
+        $prefix = $this->registerNamespacePrefix($xmlBody);
+        $errorBody = $xmlBody->xpath("//{$prefix}Error");
+
+        if (is_array($errorBody) && !empty($errorBody[0])) {
+            return $this->parser->parse($member, $errorBody[0]);
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/ListShape.php ---
@@ -0,0 +1,35 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Represents a list shape.
+ */
+class ListShape extends Shape
+{
+    private $member;
+
+    public function __construct(array $definition, ShapeMap $shapeMap)
+    {
+        $definition['type'] = 'list';
+        parent::__construct($definition, $shapeMap);
+    }
+
+    /**
+     * @return Shape
+     * @throws \RuntimeException if no member is specified
+     */
+    public function getMember()
+    {
+        if (!$this->member) {
+            if (!isset($this->definition['member'])) {
+                throw new \RuntimeException('No member attribute specified');
+            }
+            $this->member = Shape::create(
+                $this->definition['member'],
+                $this->shapeMap
+            );
+        }
+
+        return $this->member;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/MapShape.php ---
@@ -0,0 +1,54 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Represents a map shape.
+ */
+class MapShape extends Shape
+{
+    /** @var Shape */
+    private $value;
+
+    /** @var Shape */
+    private $key;
+
+    public function __construct(array $definition, ShapeMap $shapeMap)
+    {
+        $definition['type'] = 'map';
+        parent::__construct($definition, $shapeMap);
+    }
+
+    /**
+     * @return Shape
+     * @throws \RuntimeException if no value is specified
+     */
+    public function getValue()
+    {
+        if (!$this->value) {
+            if (!isset($this->definition['value'])) {
+                throw new \RuntimeException('No value specified');
+            }
+
+            $this->value = Shape::create(
+                $this->definition['value'],
+                $this->shapeMap
+            );
+        }
+
+        return $this->value;
+    }
+
+    /**
+     * @return Shape
+     */
+    public function getKey()
+    {
+        if (!$this->key) {
+            $this->key = isset($this->definition['key'])
+                ? Shape::create($this->definition['key'], $this->shapeMap)
+                : new Shape(['type' => 'string'], $this->shapeMap);
+        }
+
+        return $this->key;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Operation.php ---
@@ -0,0 +1,97 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Represents an API operation.
+ */
+class Operation extends AbstractModel
+{
+    private $input;
+    private $output;
+    private $errors;
+
+    public function __construct(array $definition, ShapeMap $shapeMap)
+    {
+        $definition['type'] = 'structure';
+
+        if (!isset($definition['http']['method'])) {
+            $definition['http']['method'] = 'POST';
+        }
+
+        if (!isset($definition['http']['requestUri'])) {
+            $definition['http']['requestUri'] = '/';
+        }
+
+        parent::__construct($definition, $shapeMap);
+    }
+
+    /**
+     * Returns an associative array of the HTTP attribute of the operation:
+     *
+     * - method: HTTP method of the operation
+     * - requestUri: URI of the request (can include URI template placeholders)
+     *
+     * @return array
+     */
+    public function getHttp()
+    {
+        return $this->definition['http'];
+    }
+
+    /**
+     * Get the input shape of the operation.
+     *
+     * @return StructureShape
+     */
+    public function getInput()
+    {
+        if (!$this->input) {
+            if ($input = $this['input']) {
+                $this->input = $this->shapeFor($input);
+            } else {
+                $this->input = new StructureShape([], $this->shapeMap);
+            }
+        }
+
+        return $this->input;
+    }
+
+    /**
+     * Get the output shape of the operation.
+     *
+     * @return StructureShape
+     */
+    public function getOutput()
+    {
+        if (!$this->output) {
+            if ($output = $this['output']) {
+                $this->output = $this->shapeFor($output);
+            } else {
+                $this->output = new StructureShape([], $this->shapeMap);
+            }
+        }
+
+        return $this->output;
+    }
+
+    /**
+     * Get an array of operation error shapes.
+     *
+     * @return Shape[]
+     */
+    public function getErrors()
+    {
+        if ($this->errors === null) {
+            if ($errors = $this['errors']) {
+                foreach ($errors as $key => $error) {
+                    $errors[$key] = $this->shapeFor($error);
+                }
+                $this->errors = $errors;
+            } else {
+                $this->errors = [];
+            }
+        }
+
+        return $this->errors;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/AbstractParser.php ---
@@ -0,0 +1,46 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\Service;
+use Aws\Api\StructureShape;
+use Aws\CommandInterface;
+use Aws\ResultInterface;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamInterface;
+
+/**
+ * @internal
+ */
+abstract class AbstractParser
+{
+    /** @var \Aws\Api\Service Representation of the service API*/
+    protected $api;
+
+    /** @var callable */
+    protected $parser;
+
+    /**
+     * @param Service $api Service description.
+     */
+    public function __construct(Service $api)
+    {
+        $this->api = $api;
+    }
+
+    /**
+     * @param CommandInterface  $command  Command that was executed.
+     * @param ResponseInterface $response Response that was received.
+     *
+     * @return ResultInterface
+     */
+    abstract public function __invoke(
+        CommandInterface $command,
+        ResponseInterface $response
+    );
+
+    abstract public function parseMemberFromStream(
+        StreamInterface $stream,
+        StructureShape $member,
+        $response
+    );
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/AbstractRestParser.php ---
@@ -0,0 +1,184 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\DateTimeResult;
+use Aws\Api\Shape;
+use Aws\Api\StructureShape;
+use Aws\Result;
+use Aws\CommandInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * @internal
+ */
+abstract class AbstractRestParser extends AbstractParser
+{
+    use PayloadParserTrait;
+
+    /**
+     * Parses a payload from a response.
+     *
+     * @param ResponseInterface $response Response to parse.
+     * @param StructureShape    $member   Member to parse
+     * @param array             $result   Result value
+     *
+     * @return mixed
+     */
+    abstract protected function payload(
+        ResponseInterface $response,
+        StructureShape $member,
+        array &$result
+    );
+
+    public function __invoke(
+        CommandInterface $command,
+        ResponseInterface $response
+    ) {
+        $output = $this->api->getOperation($command->getName())->getOutput();
+        $result = [];
+
+        if ($payload = $output['payload']) {
+            $this->extractPayload($payload, $output, $response, $result);
+        }
+
+        foreach ($output->getMembers() as $name => $member) {
+            switch ($member['location']) {
+                case 'header':
+                    $this->extractHeader($name, $member, $response, $result);
+                    break;
+                case 'headers':
+                    $this->extractHeaders($name, $member, $response, $result);
+                    break;
+                case 'statusCode':
+                    $this->extractStatus($name, $response, $result);
+                    break;
+            }
+        }
+
+        if (!$payload
+            && $response->getBody()->getSize() > 0
+            && count($output->getMembers()) > 0
+        ) {
+            // if no payload was found, then parse the contents of the body
+            $this->payload($response, $output, $result);
+        }
+
+        return new Result($result);
+    }
+
+    private function extractPayload(
+        $payload,
+        StructureShape $output,
+        ResponseInterface $response,
+        array &$result
+    ) {
+        $member = $output->getMember($payload);
+
+        if (!empty($member['eventstream'])) {
+            $result[$payload] = new EventParsingIterator(
+                $response->getBody(),
+                $member,
+                $this
+            );
+        } else if ($member instanceof StructureShape) {
+            // Structure members parse top-level data into a specific key.
+            $result[$payload] = [];
+            $this->payload($response, $member, $result[$payload]);
+        } else {
+            // Streaming data is just the stream from the response body.
+            $result[$payload] = $response->getBody();
+        }
+    }
+
+    /**
+     * Extract a single header from the response into the result.
+     */
+    private function extractHeader(
+        $name,
+        Shape $shape,
+        ResponseInterface $response,
+        &$result
+    ) {
+        $value = $response->getHeaderLine($shape['locationName'] ?: $name);
+
+        switch ($shape->getType()) {
+            case 'float':
+            case 'double':
+                $value = (float) $value;
+                break;
+            case 'long':
+                $value = (int) $value;
+                break;
+            case 'boolean':
+                $value = filter_var($value, FILTER_VALIDATE_BOOLEAN);
+                break;
+            case 'blob':
+                $value = base64_decode($value);
+                break;
+            case 'timestamp':
+                try {
+                    $value = DateTimeResult::fromTimestamp(
+                        $value,
+                        !empty($shape['timestampFormat']) ? $shape['timestampFormat'] : null
+                    );
+                    break;
+                } catch (\Exception $e) {
+                    // If the value cannot be parsed, then do not add it to the
+                    // output structure.
+                    return;
+                }
+            case 'string':
+                try {
+                    if ($shape['jsonvalue']) {
+                        $value = $this->parseJson(base64_decode($value), $response);
+                    }
+
+                    // If value is not set, do not add to output structure.
+                    if (!isset($value)) {
+                        return;
+                    }
+                    break;
+                } catch (\Exception $e) {
+                    //If the value cannot be parsed, then do not add it to the
+                    //output structure.
+                    return;
+                }
+        }
+
+        $result[$name] = $value;
+    }
+
+    /**
+     * Extract a map of headers with an optional prefix from the response.
+     */
+    private function extractHeaders(
+        $name,
+        Shape $shape,
+        ResponseInterface $response,
+        &$result
+    ) {
+        // Check if the headers are prefixed by a location name
+        $result[$name] = [];
+        $prefix = $shape['locationName'];
+        $prefixLen = strlen($prefix);
+
+        foreach ($response->getHeaders() as $k => $values) {
+            if (!$prefixLen) {
+                $result[$name][$k] = implode(', ', $values);
+            } elseif (stripos($k, $prefix) === 0) {
+                $result[$name][substr($k, $prefixLen)] = implode(', ', $values);
+            }
+        }
+    }
+
+    /**
+     * Places the status code of the response into the result array.
+     */
+    private function extractStatus(
+        $name,
+        ResponseInterface $response,
+        array &$result
+    ) {
+        $result[$name] = (int) $response->getStatusCode();
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/Crc32ValidatingParser.php ---
@@ -0,0 +1,54 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\StructureShape;
+use Aws\CommandInterface;
+use Aws\Exception\AwsException;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamInterface;
+use GuzzleHttp\Psr7;
+
+/**
+ * @internal Decorates a parser and validates the x-amz-crc32 header.
+ */
+class Crc32ValidatingParser extends AbstractParser
+{
+    /**
+     * @param callable $parser Parser to wrap.
+     */
+    public function __construct(callable $parser)
+    {
+        $this->parser = $parser;
+    }
+
+    public function __invoke(
+        CommandInterface $command,
+        ResponseInterface $response
+    ) {
+        if ($expected = $response->getHeaderLine('x-amz-crc32')) {
+            $hash = hexdec(Psr7\Utils::hash($response->getBody(), 'crc32b'));
+            if ($expected != $hash) {
+                throw new AwsException(
+                    "crc32 mismatch. Expected {$expected}, found {$hash}.",
+                    $command,
+                    [
+                        'code'             => 'ClientChecksumMismatch',
+                        'connection_error' => true,
+                        'response'         => $response
+                    ]
+                );
+            }
+        }
+
+        $fn = $this->parser;
+        return $fn($command, $response);
+    }
+
+    public function parseMemberFromStream(
+        StreamInterface $stream,
+        StructureShape $member,
+        $response
+    ) {
+        return $this->parser->parseMemberFromStream($stream, $member, $response);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/DecodingEventStreamIterator.php ---
@@ -0,0 +1,340 @@
+<?php
+
+namespace Aws\Api\Parser;
+
+use \Iterator;
+use Aws\Api\DateTimeResult;
+use GuzzleHttp\Psr7;
+use Psr\Http\Message\StreamInterface;
+use Aws\Api\Parser\Exception\ParserException;
+
+/**
+ * @internal Implements a decoder for a binary encoded event stream that will
+ * decode, validate, and provide individual events from the stream.
+ */
+class DecodingEventStreamIterator implements Iterator
+{
+    const HEADERS = 'headers';
+    const PAYLOAD = 'payload';
+
+    const LENGTH_TOTAL = 'total_length';
+    const LENGTH_HEADERS = 'headers_length';
+
+    const CRC_PRELUDE = 'prelude_crc';
+
+    const BYTES_PRELUDE = 12;
+    const BYTES_TRAILING = 4;
+
+    private static $preludeFormat = [
+        self::LENGTH_TOTAL => 'decodeUint32',
+        self::LENGTH_HEADERS => 'decodeUint32',
+        self::CRC_PRELUDE => 'decodeUint32',
+    ];
+
+    private static $lengthFormatMap = [
+        1 => 'decodeUint8',
+        2 => 'decodeUint16',
+        4 => 'decodeUint32',
+        8 => 'decodeUint64',
+    ];
+
+    private static $headerTypeMap = [
+        0 => 'decodeBooleanTrue',
+        1 => 'decodeBooleanFalse',
+        2 => 'decodeInt8',
+        3 => 'decodeInt16',
+        4 => 'decodeInt32',
+        5 => 'decodeInt64',
+        6 => 'decodeBytes',
+        7 => 'decodeString',
+        8 => 'decodeTimestamp',
+        9 => 'decodeUuid',
+    ];
+
+    /** @var StreamInterface Stream of eventstream shape to parse. */
+    private $stream;
+
+    /** @var array Currently parsed event. */
+    private $currentEvent;
+
+    /** @var int Current in-order event key. */
+    private $key;
+
+    /** @var resource|\HashContext CRC32 hash context for event validation */
+    private $hashContext;
+
+    /** @var int $currentPosition */
+    private $currentPosition;
+
+    /**
+     * DecodingEventStreamIterator constructor.
+     *
+     * @param StreamInterface $stream
+     */
+    public function __construct(StreamInterface $stream)
+    {
+        $this->stream = $stream;
+        $this->rewind();
+    }
+
+    private function parseHeaders($headerBytes)
+    {
+        $headers = [];
+        $bytesRead = 0;
+
+        while ($bytesRead < $headerBytes) {
+            list($key, $numBytes) = $this->decodeString(1);
+            $bytesRead += $numBytes;
+
+            list($type, $numBytes) = $this->decodeUint8();
+            $bytesRead += $numBytes;
+
+            $f = self::$headerTypeMap[$type];
+            list($value, $numBytes) = $this->{$f}();
+            $bytesRead += $numBytes;
+
+            if (isset($headers[$key])) {
+                throw new ParserException('Duplicate key in event headers.');
+            }
+            $headers[$key] = $value;
+        }
+
+        return [$headers, $bytesRead];
+    }
+
+    private function parsePrelude()
+    {
+        $prelude = [];
+        $bytesRead = 0;
+
+        $calculatedCrc = null;
+        foreach (self::$preludeFormat as $key => $decodeFunction) {
+            if ($key === self::CRC_PRELUDE) {
+                $hashCopy = hash_copy($this->hashContext);
+                $calculatedCrc = hash_final($this->hashContext, true);
+                $this->hashContext = $hashCopy;
+            }
+            list($value, $numBytes) = $this->{$decodeFunction}();
+            $bytesRead += $numBytes;
+
+            $prelude[$key] = $value;
+        }
+
+        if (unpack('N', $calculatedCrc)[1] !== $prelude[self::CRC_PRELUDE]) {
+            throw new ParserException('Prelude checksum mismatch.');
+        }
+
+        return [$prelude, $bytesRead];
+    }
+
+    private function parseEvent()
+    {
+        $event = [];
+
+        if ($this->stream->tell() < $this->stream->getSize()) {
+            $this->hashContext = hash_init('crc32b');
+
+            $bytesLeft = $this->stream->getSize() - $this->stream->tell();
+            list($prelude, $numBytes) = $this->parsePrelude();
+            if ($prelude[self::LENGTH_TOTAL] > $bytesLeft) {
+                throw new ParserException('Message length too long.');
+            }
+            $bytesLeft -= $numBytes;
+
+            if ($prelude[self::LENGTH_HEADERS] > $bytesLeft) {
+                throw new ParserException('Headers length too long.');
+            }
+
+            list(
+                $event[self::HEADERS],
+                $numBytes
+            ) = $this->parseHeaders($prelude[self::LENGTH_HEADERS]);
+
+            $event[self::PAYLOAD] = Psr7\Utils::streamFor(
+                $this->readAndHashBytes(
+                    $prelude[self::LENGTH_TOTAL] - self::BYTES_PRELUDE
+                    - $numBytes - self::BYTES_TRAILING
+                )
+            );
+
+            $calculatedCrc = hash_final($this->hashContext, true);
+            $messageCrc = $this->stream->read(4);
+            if ($calculatedCrc !== $messageCrc) {
+                throw new ParserException('Message checksum mismatch.');
+            }
+        }
+
+        return $event;
+    }
+
+    // Iterator Functionality
+
+    /**
+     * @return array
+     */
+    #[\ReturnTypeWillChange]
+    public function current()
+    {
+        return $this->currentEvent;
+    }
+
+    /**
+     * @return int
+     */
+    #[\ReturnTypeWillChange]
+    public function key()
+    {
+        return $this->key;
+    }
+
+    #[\ReturnTypeWillChange]
+    public function next()
+    {
+        $this->currentPosition = $this->stream->tell();
+        if ($this->valid()) {
+            $this->key++;
+            $this->currentEvent = $this->parseEvent();
+        }
+    }
+
+    #[\ReturnTypeWillChange]
+    public function rewind()
+    {
+        $this->stream->rewind();
+        $this->key = 0;
+        $this->currentPosition = 0;
+        $this->currentEvent = $this->parseEvent();
+    }
+
+    /**
+     * @return bool
+     */
+    #[\ReturnTypeWillChange]
+    public function valid()
+    {
+        return $this->currentPosition < $this->stream->getSize();
+    }
+
+    // Decoding Utilities
+
+    private function readAndHashBytes($num)
+    {
+        $bytes = $this->stream->read($num);
+        hash_update($this->hashContext, $bytes);
+        return $bytes;
+    }
+
+    private function decodeBooleanTrue()
+    {
+        return [true, 0];
+    }
+
+    private function decodeBooleanFalse()
+    {
+        return [false, 0];
+    }
+
+    private function uintToInt($val, $size)
+    {
+        $signedCap = pow(2, $size - 1);
+        if ($val > $signedCap) {
+            $val -= (2 * $signedCap);
+        }
+        return $val;
+    }
+
+    private function decodeInt8()
+    {
+        $val = (int)unpack('C', $this->readAndHashBytes(1))[1];
+        return [$this->uintToInt($val, 8), 1];
+    }
+
+    private function decodeUint8()
+    {
+        return [unpack('C', $this->readAndHashBytes(1))[1], 1];
+    }
+
+    private function decodeInt16()
+    {
+        $val = (int)unpack('n', $this->readAndHashBytes(2))[1];
+        return [$this->uintToInt($val, 16), 2];
+    }
+
+    private function decodeUint16()
+    {
+        return [unpack('n', $this->readAndHashBytes(2))[1], 2];
+    }
+
+    private function decodeInt32()
+    {
+        $val = (int)unpack('N', $this->readAndHashBytes(4))[1];
+        return [$this->uintToInt($val, 32), 4];
+    }
+
+    private function decodeUint32()
+    {
+        return [unpack('N', $this->readAndHashBytes(4))[1], 4];
+    }
+
+    private function decodeInt64()
+    {
+        $val = $this->unpackInt64($this->readAndHashBytes(8))[1];
+        return [$this->uintToInt($val, 64), 8];
+    }
+
+    private function decodeUint64()
+    {
+        return [$this->unpackInt64($this->readAndHashBytes(8))[1], 8];
+    }
+
+    private function unpackInt64($bytes)
+    {
+        if (version_compare(PHP_VERSION, '5.6.3', '<')) {
+            $d = unpack('N2', $bytes);
+            return [1 => $d[1] << 32 | $d[2]];
+        }
+        return unpack('J', $bytes);
+    }
+
+    private function decodeBytes($lengthBytes=2)
+    {
+        if (!isset(self::$lengthFormatMap[$lengthBytes])) {
+            throw new ParserException('Undefined variable length format.');
+        }
+        $f = self::$lengthFormatMap[$lengthBytes];
+        list($len, $bytes) = $this->{$f}();
+        return [$this->readAndHashBytes($len), $len + $bytes];
+    }
+
+    private function decodeString($lengthBytes=2)
+    {
+        if (!isset(self::$lengthFormatMap[$lengthBytes])) {
+            throw new ParserException('Undefined variable length format.');
+        }
+        $f = self::$lengthFormatMap[$lengthBytes];
+        list($len, $bytes) = $this->{$f}();
+        return [$this->readAndHashBytes($len), $len + $bytes];
+    }
+
+    private function decodeTimestamp()
+    {
+        list($val, $bytes) = $this->decodeInt64();
+        return [
+            DateTimeResult::createFromFormat('U.u', $val / 1000),
+            $bytes
+        ];
+    }
+
+    private function decodeUuid()
+    {
+        $val = unpack('H32', $this->readAndHashBytes(16))[1];
+        return [
+            substr($val, 0, 8) . '-'
+            . substr($val, 8, 4) . '-'
+            . substr($val, 12, 4) . '-'
+            . substr($val, 16, 4) . '-'
+            . substr($val, 20, 12),
+            16
+        ];
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/EventParsingIterator.php ---
@@ -0,0 +1,112 @@
+<?php
+
+namespace Aws\Api\Parser;
+
+use \Iterator;
+use Aws\Exception\EventStreamDataException;
+use Aws\Api\Parser\Exception\ParserException;
+use Aws\Api\StructureShape;
+use Psr\Http\Message\StreamInterface;
+
+/**
+ * @internal Implements a decoder for a binary encoded event stream that will
+ * decode, validate, and provide individual events from the stream.
+ */
+class EventParsingIterator implements Iterator
+{
+    /** @var StreamInterface */
+    private $decodingIterator;
+
+    /** @var StructureShape */
+    private $shape;
+
+    /** @var AbstractParser */
+    private $parser;
+
+    public function __construct(
+        StreamInterface $stream,
+        StructureShape $shape,
+        AbstractParser $parser
+    ) {
+        $this->decodingIterator = new DecodingEventStreamIterator($stream);
+        $this->shape = $shape;
+        $this->parser = $parser;
+    }
+
+    #[\ReturnTypeWillChange]
+    public function current()
+    {
+        return $this->parseEvent($this->decodingIterator->current());
+    }
+
+    #[\ReturnTypeWillChange]
+    public function key()
+    {
+        return $this->decodingIterator->key();
+    }
+
+    #[\ReturnTypeWillChange]
+    public function next()
+    {
+        $this->decodingIterator->next();
+    }
+
+    #[\ReturnTypeWillChange]
+    public function rewind()
+    {
+        $this->decodingIterator->rewind();
+    }
+
+    #[\ReturnTypeWillChange]
+    public function valid()
+    {
+        return $this->decodingIterator->valid();
+    }
+
+    private function parseEvent(array $event)
+    {
+        if (!empty($event['headers'][':message-type'])) {
+            if ($event['headers'][':message-type'] === 'error') {
+                return $this->parseError($event);
+            }
+            if ($event['headers'][':message-type'] !== 'event') {
+                throw new ParserException('Failed to parse unknown message type.');
+            }
+        }
+
+        if (empty($event['headers'][':event-type'])) {
+            throw new ParserException('Failed to parse without event type.');
+        }
+        $eventShape = $this->shape->getMember($event['headers'][':event-type']);
+
+        $parsedEvent = [];
+        foreach ($eventShape['members'] as $shape => $details) {
+            if (!empty($details['eventpayload'])) {
+                $payloadShape = $eventShape->getMember($shape);
+                if ($payloadShape['type'] === 'blob') {
+                    $parsedEvent[$shape] = $event['payload'];
+                } else {
+                    $parsedEvent[$shape] = $this->parser->parseMemberFromStream(
+                        $event['payload'],
+                        $payloadShape,
+                        null
+                    );
+                }
+            } else {
+                $parsedEvent[$shape] = $event['headers'][$shape];
+            }
+        }
+
+        return [
+            $event['headers'][':event-type'] => $parsedEvent
+        ];
+    }
+
+    private function parseError(array $event)
+    {
+        throw new EventStreamDataException(
+            $event['headers'][':error-code'],
+            $event['headers'][':error-message']
+        );
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/Exception/ParserException.php ---
@@ -0,0 +1,56 @@
+<?php
+namespace Aws\Api\Parser\Exception;
+
+use Aws\HasMonitoringEventsTrait;
+use Aws\MonitoringEventsInterface;
+use Aws\ResponseContainerInterface;
+use Psr\Http\Message\ResponseInterface;
+
+class ParserException extends \RuntimeException implements
+    MonitoringEventsInterface,
+    ResponseContainerInterface
+{
+    use HasMonitoringEventsTrait;
+
+    private $errorCode;
+    private $requestId;
+    private $response;
+
+    public function __construct($message = '', $code = 0, $previous = null, array $context = [])
+    {
+        $this->errorCode = isset($context['error_code']) ? $context['error_code'] : null;
+        $this->requestId = isset($context['request_id']) ? $context['request_id'] : null;
+        $this->response = isset($context['response']) ? $context['response'] : null;
+        parent::__construct($message, $code, $previous);
+    }
+
+    /**
+     * Get the error code, if any.
+     *
+     * @return string|null
+     */
+    public function getErrorCode()
+    {
+        return $this->errorCode;
+    }
+
+    /**
+     * Get the request ID, if any.
+     *
+     * @return string|null
+     */
+    public function getRequestId()
+    {
+        return $this->requestId;
+    }
+
+    /**
+     * Get the received HTTP response if any.
+     *
+     * @return ResponseInterface|null
+     */
+    public function getResponse()
+    {
+        return $this->response;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/JsonParser.php ---
@@ -0,0 +1,71 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\DateTimeResult;
+use Aws\Api\Shape;
+
+/**
+ * @internal Implements standard JSON parsing.
+ */
+class JsonParser
+{
+    public function parse(Shape $shape, $value)
+    {
+        if ($value === null) {
+            return $value;
+        }
+
+        switch ($shape['type']) {
+            case 'structure':
+                if (isset($shape['document']) && $shape['document']) {
+                    return $value;
+                }
+                $target = [];
+                foreach ($shape->getMembers() as $name => $member) {
+                    $locationName = $member['locationName'] ?: $name;
+                    if (isset($value[$locationName])) {
+                        $target[$name] = $this->parse($member, $value[$locationName]);
+                    }
+                }
+                if (isset($shape['union'])
+                    && $shape['union']
+                    && is_array($value)
+                    && empty($target)
+                ) {
+                    foreach ($value as $key => $val) {
+                        $target['Unknown'][$key] = $val;
+                    }
+                }
+                return $target;
+
+            case 'list':
+                $member = $shape->getMember();
+                $target = [];
+                foreach ($value as $v) {
+                    $target[] = $this->parse($member, $v);
+                }
+                return $target;
+
+            case 'map':
+                $values = $shape->getValue();
+                $target = [];
+                foreach ($value as $k => $v) {
+                    $target[$k] = $this->parse($values, $v);
+                }
+                return $target;
+
+            case 'timestamp':
+                return DateTimeResult::fromTimestamp(
+                    $value,
+                    !empty($shape['timestampFormat']) ? $shape['timestampFormat'] : null
+                );
+
+            case 'blob':
+                return base64_decode($value);
+
+            default:
+                return $value;
+        }
+    }
+}
+

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/JsonRpcParser.php ---
@@ -0,0 +1,51 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\StructureShape;
+use Aws\Api\Service;
+use Aws\Result;
+use Aws\CommandInterface;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamInterface;
+
+/**
+ * @internal Implements JSON-RPC parsing (e.g., DynamoDB)
+ */
+class JsonRpcParser extends AbstractParser
+{
+    use PayloadParserTrait;
+
+    /**
+     * @param Service    $api    Service description
+     * @param JsonParser $parser JSON body builder
+     */
+    public function __construct(Service $api, JsonParser $parser = null)
+    {
+        parent::__construct($api);
+        $this->parser = $parser ?: new JsonParser();
+    }
+
+    public function __invoke(
+        CommandInterface $command,
+        ResponseInterface $response
+    ) {
+        $operation = $this->api->getOperation($command->getName());
+        $result = null === $operation['output']
+            ? null
+            : $this->parseMemberFromStream(
+                $response->getBody(),
+                $operation->getOutput(),
+                $response
+            );
+
+        return new Result($result ?: []);
+    }
+
+    public function parseMemberFromStream(
+        StreamInterface $stream,
+        StructureShape $member,
+        $response
+    ) {
+        return $this->parser->parse($member, $this->parseJson($stream, $response));
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/MetadataParserTrait.php ---
@@ -0,0 +1,90 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\DateTimeResult;
+use Aws\Api\Shape;
+use Psr\Http\Message\ResponseInterface;
+
+trait MetadataParserTrait
+{
+    /**
+     * Extract a single header from the response into the result.
+     */
+    protected function extractHeader(
+        $name,
+        Shape $shape,
+        ResponseInterface $response,
+        &$result
+    ) {
+        $value = $response->getHeaderLine($shape['locationName'] ?: $name);
+
+        switch ($shape->getType()) {
+            case 'float':
+            case 'double':
+                $value = (float) $value;
+                break;
+            case 'long':
+                $value = (int) $value;
+                break;
+            case 'boolean':
+                $value = filter_var($value, FILTER_VALIDATE_BOOLEAN);
+                break;
+            case 'blob':
+                $value = base64_decode($value);
+                break;
+            case 'timestamp':
+                try {
+                    $value = DateTimeResult::fromTimestamp(
+                        $value,
+                        !empty($shape['timestampFormat']) ? $shape['timestampFormat'] : null
+                    );
+                    break;
+                } catch (\Exception $e) {
+                    // If the value cannot be parsed, then do not add it to the
+                    // output structure.
+                    return;
+                }
+            case 'string':
+                if ($shape['jsonvalue']) {
+                    $value = $this->parseJson(base64_decode($value), $response);
+                }
+                break;
+        }
+
+        $result[$name] = $value;
+    }
+
+    /**
+     * Extract a map of headers with an optional prefix from the response.
+     */
+    protected function extractHeaders(
+        $name,
+        Shape $shape,
+        ResponseInterface $response,
+        &$result
+    ) {
+        // Check if the headers are prefixed by a location name
+        $result[$name] = [];
+        $prefix = $shape['locationName'];
+        $prefixLen = strlen($prefix);
+
+        foreach ($response->getHeaders() as $k => $values) {
+            if (!$prefixLen) {
+                $result[$name][$k] = implode(', ', $values);
+            } elseif (stripos($k, $prefix) === 0) {
+                $result[$name][substr($k, $prefixLen)] = implode(', ', $values);
+            }
+        }
+    }
+
+    /**
+     * Places the status code of the response into the result array.
+     */
+    protected function extractStatus(
+        $name,
+        ResponseInterface $response,
+        array &$result
+    ) {
+        $result[$name] = (int) $response->getStatusCode();
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/PayloadParserTrait.php ---
@@ -0,0 +1,61 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\Parser\Exception\ParserException;
+use Psr\Http\Message\ResponseInterface;
+
+trait PayloadParserTrait
+{
+    /**
+     * @param string $json
+     *
+     * @throws ParserException
+     *
+     * @return array
+     */
+    private function parseJson($json, $response)
+    {
+        $jsonPayload = json_decode($json, true);
+
+        if (JSON_ERROR_NONE !== json_last_error()) {
+            throw new ParserException(
+                'Error parsing JSON: ' . json_last_error_msg(),
+                0,
+                null,
+                ['response' => $response]
+            );
+        }
+
+        return $jsonPayload;
+    }
+
+    /**
+     * @param string $xml
+     *
+     * @throws ParserException
+     *
+     * @return \SimpleXMLElement
+     */
+    protected function parseXml($xml, $response)
+    {
+        $priorSetting = libxml_use_internal_errors(true);
+        try {
+            libxml_clear_errors();
+            $xmlPayload = new \SimpleXMLElement($xml);
+            if ($error = libxml_get_last_error()) {
+                throw new \RuntimeException($error->message);
+            }
+        } catch (\Exception $e) {
+            throw new ParserException(
+                "Error parsing XML: {$e->getMessage()}",
+                0,
+                $e,
+                ['response' => $response]
+            );
+        } finally {
+            libxml_use_internal_errors($priorSetting);
+        }
+
+        return $xmlPayload;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/QueryParser.php ---
@@ -0,0 +1,60 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\Service;
+use Aws\Api\StructureShape;
+use Aws\Result;
+use Aws\CommandInterface;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamInterface;
+
+/**
+ * @internal Parses query (XML) responses (e.g., EC2, SQS, and many others)
+ */
+class QueryParser extends AbstractParser
+{
+    use PayloadParserTrait;
+
+    /** @var bool */
+    private $honorResultWrapper;
+
+    /**
+     * @param Service   $api                Service description
+     * @param XmlParser $xmlParser          Optional XML parser
+     * @param bool      $honorResultWrapper Set to false to disable the peeling
+     *                                      back of result wrappers from the
+     *                                      output structure.
+     */
+    public function __construct(
+        Service $api,
+        XmlParser $xmlParser = null,
+        $honorResultWrapper = true
+    ) {
+        parent::__construct($api);
+        $this->parser = $xmlParser ?: new XmlParser();
+        $this->honorResultWrapper = $honorResultWrapper;
+    }
+
+    public function __invoke(
+        CommandInterface $command,
+        ResponseInterface $response
+    ) {
+        $output = $this->api->getOperation($command->getName())->getOutput();
+        $xml = $this->parseXml($response->getBody(), $response);
+
+        if ($this->honorResultWrapper && $output['resultWrapper']) {
+            $xml = $xml->{$output['resultWrapper']};
+        }
+
+        return new Result($this->parser->parse($output, $xml));
+    }
+
+    public function parseMemberFromStream(
+        StreamInterface $stream,
+        StructureShape $member,
+        $response
+    ) {
+        $xml = $this->parseXml($stream, $response);
+        return $this->parser->parse($member, $xml);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/RestJsonParser.php ---
@@ -0,0 +1,49 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\Service;
+use Aws\Api\StructureShape;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamInterface;
+
+/**
+ * @internal Implements REST-JSON parsing (e.g., Glacier, Elastic Transcoder)
+ */
+class RestJsonParser extends AbstractRestParser
+{
+    use PayloadParserTrait;
+
+    /**
+     * @param Service    $api    Service description
+     * @param JsonParser $parser JSON body builder
+     */
+    public function __construct(Service $api, JsonParser $parser = null)
+    {
+        parent::__construct($api);
+        $this->parser = $parser ?: new JsonParser();
+    }
+
+    protected function payload(
+        ResponseInterface $response,
+        StructureShape $member,
+        array &$result
+    ) {
+        $jsonBody = $this->parseJson($response->getBody(), $response);
+
+        if ($jsonBody) {
+            $result += $this->parser->parse($member, $jsonBody);
+        }
+    }
+
+    public function parseMemberFromStream(
+        StreamInterface $stream,
+        StructureShape $member,
+        $response
+    ) {
+        $jsonBody = $this->parseJson($stream, $response);
+        if ($jsonBody) {
+            return $this->parser->parse($member, $jsonBody);
+        }
+        return [];
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/RestXmlParser.php ---
@@ -0,0 +1,42 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\StructureShape;
+use Aws\Api\Service;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamInterface;
+
+/**
+ * @internal Implements REST-XML parsing (e.g., S3, CloudFront, etc...)
+ */
+class RestXmlParser extends AbstractRestParser
+{
+    use PayloadParserTrait;
+
+    /**
+     * @param Service   $api    Service description
+     * @param XmlParser $parser XML body parser
+     */
+    public function __construct(Service $api, XmlParser $parser = null)
+    {
+        parent::__construct($api);
+        $this->parser = $parser ?: new XmlParser();
+    }
+
+    protected function payload(
+        ResponseInterface $response,
+        StructureShape $member,
+        array &$result
+    ) {
+        $result += $this->parseMemberFromStream($response->getBody(), $member, $response);
+    }
+
+    public function parseMemberFromStream(
+        StreamInterface $stream,
+        StructureShape $member,
+        $response
+    ) {
+        $xml = $this->parseXml($stream, $response);
+        return $this->parser->parse($member, $xml);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Parser/XmlParser.php ---
@@ -0,0 +1,179 @@
+<?php
+namespace Aws\Api\Parser;
+
+use Aws\Api\DateTimeResult;
+use Aws\Api\ListShape;
+use Aws\Api\MapShape;
+use Aws\Api\Parser\Exception\ParserException;
+use Aws\Api\Shape;
+use Aws\Api\StructureShape;
+
+/**
+ * @internal Implements standard XML parsing for REST-XML and Query protocols.
+ */
+class XmlParser
+{
+    public function parse(StructureShape $shape, \SimpleXMLElement $value)
+    {
+        return $this->dispatch($shape, $value);
+    }
+
+    private function dispatch($shape, \SimpleXMLElement $value)
+    {
+        static $methods = [
+            'structure' => 'parse_structure',
+            'list'      => 'parse_list',
+            'map'       => 'parse_map',
+            'blob'      => 'parse_blob',
+            'boolean'   => 'parse_boolean',
+            'integer'   => 'parse_integer',
+            'float'     => 'parse_float',
+            'double'    => 'parse_float',
+            'timestamp' => 'parse_timestamp',
+        ];
+
+        $type = $shape['type'];
+        if (isset($methods[$type])) {
+            return $this->{$methods[$type]}($shape, $value);
+        }
+
+        return (string) $value;
+    }
+
+    private function parse_structure(
+        StructureShape $shape,
+        \SimpleXMLElement $value
+    ) {
+        $target = [];
+
+        foreach ($shape->getMembers() as $name => $member) {
+            // Extract the name of the XML node
+            $node = $this->memberKey($member, $name);
+            if (isset($value->{$node})) {
+                $target[$name] = $this->dispatch($member, $value->{$node});
+            } else {
+                $memberShape = $shape->getMember($name);
+                if (!empty($memberShape['xmlAttribute'])) {
+                    $target[$name] = $this->parse_xml_attribute(
+                        $shape,
+                        $memberShape,
+                        $value
+                    );
+                }
+            }
+        }
+        if (isset($shape['union'])
+            && $shape['union']
+            && empty($target)
+        ) {
+            foreach ($value as $key => $val) {
+                $name = $val->children()->getName();
+                $target['Unknown'][$name] = $val->$name;
+            }
+        }
+        return $target;
+    }
+
+    private function memberKey(Shape $shape, $name)
+    {
+        if (null !== $shape['locationName']) {
+            return $shape['locationName'];
+        }
+
+        if ($shape instanceof ListShape && $shape['flattened']) {
+            return $shape->getMember()['locationName'] ?: $name;
+        }
+
+        return $name;
+    }
+
+    private function parse_list(ListShape $shape, \SimpleXMLElement  $value)
+    {
+        $target = [];
+        $member = $shape->getMember();
+
+        if (!$shape['flattened']) {
+            $value = $value->{$member['locationName'] ?: 'member'};
+        }
+
+        foreach ($value as $v) {
+            $target[] = $this->dispatch($member, $v);
+        }
+
+        return $target;
+    }
+
+    private function parse_map(MapShape $shape, \SimpleXMLElement $value)
+    {
+        $target = [];
+
+        if (!$shape['flattened']) {
+            $value = $value->entry;
+        }
+
+        $mapKey = $shape->getKey();
+        $mapValue = $shape->getValue();
+        $keyName = $shape->getKey()['locationName'] ?: 'key';
+        $valueName = $shape->getValue()['locationName'] ?: 'value';
+
+        foreach ($value as $node) {
+            $key = $this->dispatch($mapKey, $node->{$keyName});
+            $value = $this->dispatch($mapValue, $node->{$valueName});
+            $target[$key] = $value;
+        }
+
+        return $target;
+    }
+
+    private function parse_blob(Shape $shape, $value)
+    {
+        return base64_decode((string) $value);
+    }
+
+    private function parse_float(Shape $shape, $value)
+    {
+        return (float) (string) $value;
+    }
+
+    private function parse_integer(Shape $shape, $value)
+    {
+        return (int) (string) $value;
+    }
+
+    private function parse_boolean(Shape $shape, $value)
+    {
+        return $value == 'true';
+    }
+
+    private function parse_timestamp(Shape $shape, $value)
+    {
+        if (is_string($value)
+            || is_int($value)
+            || (is_object($value)
+                && method_exists($value, '__toString'))
+        ) {
+            return DateTimeResult::fromTimestamp(
+                (string) $value,
+                !empty($shape['timestampFormat']) ? $shape['timestampFormat'] : null
+            );
+        }
+        throw new ParserException('Invalid timestamp value passed to XmlParser::parse_timestamp');
+    }
+
+    private function parse_xml_attribute(Shape $shape, Shape $memberShape, $value)
+    {
+        $namespace = $shape['xmlNamespace']['uri']
+            ? $shape['xmlNamespace']['uri']
+            : '';
+        $prefix = $shape['xmlNamespace']['prefix']
+            ? $shape['xmlNamespace']['prefix']
+            : '';
+        if (!empty($prefix)) {
+            $prefix .= ':';
+        }
+        $key = str_replace($prefix, '', $memberShape['locationName']);
+
+        $attributes = $value->attributes($namespace);
+        return isset($attributes[$key]) ? (string) $attributes[$key] : null;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/Ec2ParamBuilder.php ---
@@ -0,0 +1,40 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\Shape;
+use Aws\Api\ListShape;
+
+/**
+ * @internal
+ */
+class Ec2ParamBuilder extends QueryParamBuilder
+{
+    protected function queryName(Shape $shape, $default = null)
+    {
+        return ($shape['queryName']
+            ?: ucfirst($shape['locationName']))
+                ?: $default;
+    }
+
+    protected function isFlat(Shape $shape)
+    {
+        return false;
+    }
+
+    protected function format_list(
+        ListShape $shape,
+        array $value,
+        $prefix,
+        &$query
+    ) {
+        // Handle empty list serialization
+        if (!$value) {
+            $query[$prefix] = false;
+        } else {
+            $items = $shape->getMember();
+            foreach ($value as $k => $v) {
+                $this->format($items, $v, $prefix . '.' . ($k + 1), $query);
+            }
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/JsonBody.php ---
@@ -0,0 +1,99 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\Service;
+use Aws\Api\Shape;
+use Aws\Api\TimestampShape;
+use Aws\Exception\InvalidJsonException;
+
+/**
+ * Formats the JSON body of a JSON-REST or JSON-RPC operation.
+ * @internal
+ */
+class JsonBody
+{
+    private $api;
+
+    public function __construct(Service $api)
+    {
+        $this->api = $api;
+    }
+
+    /**
+     * Gets the JSON Content-Type header for a service API
+     *
+     * @param Service $service
+     *
+     * @return string
+     */
+    public static function getContentType(Service $service)
+    {
+        return 'application/x-amz-json-'
+            . number_format($service->getMetadata('jsonVersion'), 1);
+    }
+
+    /**
+     * Builds the JSON body based on an array of arguments.
+     *
+     * @param Shape $shape Operation being constructed
+     * @param array $args  Associative array of arguments
+     *
+     * @return string
+     */
+    public function build(Shape $shape, array $args)
+    {
+        $result = json_encode($this->format($shape, $args));
+        return $result == '[]' ? '{}' : $result;
+    }
+
+    private function format(Shape $shape, $value)
+    {
+        switch ($shape['type']) {
+            case 'structure':
+                $data = [];
+                if (isset($shape['document']) && $shape['document']) {
+                    return $value;
+                }
+                foreach ($value as $k => $v) {
+                    if ($v !== null && $shape->hasMember($k)) {
+                        $valueShape = $shape->getMember($k);
+                        $data[$valueShape['locationName'] ?: $k]
+                            = $this->format($valueShape, $v);
+                    }
+                }
+                if (empty($data)) {
+                    return new \stdClass;
+                }
+                return $data;
+
+            case 'list':
+                $items = $shape->getMember();
+                foreach ($value as $k => $v) {
+                    $value[$k] = $this->format($items, $v);
+                }
+                return $value;
+
+            case 'map':
+                if (empty($value)) {
+                    return new \stdClass;
+                }
+                $values = $shape->getValue();
+                foreach ($value as $k => $v) {
+                    $value[$k] = $this->format($values, $v);
+                }
+                return $value;
+
+            case 'blob':
+                return base64_encode($value);
+
+            case 'timestamp':
+                $timestampFormat = !empty($shape['timestampFormat'])
+                    ? $shape['timestampFormat']
+                    : 'unixTimestamp';
+                return TimestampShape::format($value, $timestampFormat);
+
+            default:
+                return $value;
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/JsonRpcSerializer.php ---
@@ -0,0 +1,69 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\Service;
+use Aws\CommandInterface;
+use GuzzleHttp\Psr7\Request;
+use Psr\Http\Message\RequestInterface;
+
+/**
+ * Prepares a JSON-RPC request for transfer.
+ * @internal
+ */
+class JsonRpcSerializer
+{
+    /** @var JsonBody */
+    private $jsonFormatter;
+
+    /** @var string */
+    private $endpoint;
+
+    /** @var Service */
+    private $api;
+
+    /** @var string */
+    private $contentType;
+
+    /**
+     * @param Service  $api           Service description
+     * @param string   $endpoint      Endpoint to connect to
+     * @param JsonBody $jsonFormatter Optional JSON formatter to use
+     */
+    public function __construct(
+        Service $api,
+        $endpoint,
+        JsonBody $jsonFormatter = null
+    ) {
+        $this->endpoint = $endpoint;
+        $this->api = $api;
+        $this->jsonFormatter = $jsonFormatter ?: new JsonBody($this->api);
+        $this->contentType = JsonBody::getContentType($api);
+    }
+
+    /**
+     * When invoked with an AWS command, returns a serialization array
+     * containing "method", "uri", "headers", and "body" key value pairs.
+     *
+     * @param CommandInterface $command
+     *
+     * @return RequestInterface
+     */
+    public function __invoke(CommandInterface $command)
+    {
+        $name = $command->getName();
+        $operation = $this->api->getOperation($name);
+
+        return new Request(
+            $operation['http']['method'],
+            $this->endpoint,
+            [
+                'X-Amz-Target' => $this->api->getMetadata('targetPrefix') . '.' . $name,
+                'Content-Type' => $this->contentType
+            ],
+            $this->jsonFormatter->build(
+                $operation->getInput(),
+                $command->toArray()
+            )
+        );
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/QueryParamBuilder.php ---
@@ -0,0 +1,157 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\StructureShape;
+use Aws\Api\ListShape;
+use Aws\Api\MapShape;
+use Aws\Api\Shape;
+use Aws\Api\TimestampShape;
+
+/**
+ * @internal
+ */
+class QueryParamBuilder
+{
+    private $methods;
+
+    protected function queryName(Shape $shape, $default = null)
+    {
+        if (null !== $shape['queryName']) {
+            return $shape['queryName'];
+        }
+
+        if (null !== $shape['locationName']) {
+            return $shape['locationName'];
+        }
+
+        if ($this->isFlat($shape) && !empty($shape['member']['locationName'])) {
+            return $shape['member']['locationName'];
+        }
+
+        return $default;
+    }
+
+    protected function isFlat(Shape $shape)
+    {
+        return $shape['flattened'] === true;
+    }
+
+    public function __invoke(StructureShape $shape, array $params)
+    {
+        if (!$this->methods) {
+            $this->methods = array_fill_keys(get_class_methods($this), true);
+        }
+
+        $query = [];
+        $this->format_structure($shape, $params, '', $query);
+
+        return $query;
+    }
+
+    protected function format(Shape $shape, $value, $prefix, array &$query)
+    {
+        $type = 'format_' . $shape['type'];
+        if (isset($this->methods[$type])) {
+            $this->{$type}($shape, $value, $prefix, $query);
+        } else {
+            $query[$prefix] = (string) $value;
+        }
+    }
+
+    protected function format_structure(
+        StructureShape $shape,
+        array $value,
+        $prefix,
+        &$query
+    ) {
+        if ($prefix) {
+            $prefix .= '.';
+        }
+
+        foreach ($value as $k => $v) {
+            if ($shape->hasMember($k)) {
+                $member = $shape->getMember($k);
+                $this->format(
+                    $member,
+                    $v,
+                    $prefix . $this->queryName($member, $k),
+                    $query
+                );
+            }
+        }
+    }
+
+    protected function format_list(
+        ListShape $shape,
+        array $value,
+        $prefix,
+        &$query
+    ) {
+        // Handle empty list serialization
+        if (!$value) {
+            $query[$prefix] = '';
+            return;
+        }
+
+        $items = $shape->getMember();
+
+        if (!$this->isFlat($shape)) {
+            $locationName = $shape->getMember()['locationName'] ?: 'member';
+            $prefix .= ".$locationName";
+        } elseif ($name = $this->queryName($items)) {
+            $parts = explode('.', $prefix);
+            $parts[count($parts) - 1] = $name;
+            $prefix = implode('.', $parts);
+        }
+
+        foreach ($value as $k => $v) {
+            $this->format($items, $v, $prefix . '.' . ($k + 1), $query);
+        }
+    }
+
+    protected function format_map(
+        MapShape $shape,
+        array $value,
+        $prefix,
+        array &$query
+    ) {
+        $vals = $shape->getValue();
+        $keys = $shape->getKey();
+
+        if (!$this->isFlat($shape)) {
+            $prefix .= '.entry';
+        }
+
+        $i = 0;
+        $keyName = '%s.%d.' . $this->queryName($keys, 'key');
+        $valueName = '%s.%s.' . $this->queryName($vals, 'value');
+
+        foreach ($value as $k => $v) {
+            $i++;
+            $this->format($keys, $k, sprintf($keyName, $prefix, $i), $query);
+            $this->format($vals, $v, sprintf($valueName, $prefix, $i), $query);
+        }
+    }
+
+    protected function format_blob(Shape $shape, $value, $prefix, array &$query)
+    {
+        $query[$prefix] = base64_encode($value);
+    }
+
+    protected function format_timestamp(
+        TimestampShape $shape,
+        $value,
+        $prefix,
+        array &$query
+    ) {
+        $timestampFormat = !empty($shape['timestampFormat'])
+            ? $shape['timestampFormat']
+            : 'iso8601';
+        $query[$prefix] = TimestampShape::format($value, $timestampFormat);
+    }
+
+    protected function format_boolean(Shape $shape, $value, $prefix, array &$query)
+    {
+        $query[$prefix] = ($value) ? 'true' : 'false';
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/QuerySerializer.php ---
@@ -0,0 +1,69 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\Service;
+use Aws\CommandInterface;
+use GuzzleHttp\Psr7\Request;
+use Psr\Http\Message\RequestInterface;
+
+/**
+ * Serializes a query protocol request.
+ * @internal
+ */
+class QuerySerializer
+{
+    private $endpoint;
+    private $api;
+    private $paramBuilder;
+
+    public function __construct(
+        Service $api,
+        $endpoint,
+        callable $paramBuilder = null
+    ) {
+        $this->api = $api;
+        $this->endpoint = $endpoint;
+        $this->paramBuilder = $paramBuilder ?: new QueryParamBuilder();
+    }
+
+    /**
+     * When invoked with an AWS command, returns a serialization array
+     * containing "method", "uri", "headers", and "body" key value pairs.
+     *
+     * @param CommandInterface $command
+     *
+     * @return RequestInterface
+     */
+    public function __invoke(CommandInterface $command)
+    {
+        $operation = $this->api->getOperation($command->getName());
+
+        $body = [
+            'Action'  => $command->getName(),
+            'Version' => $this->api->getMetadata('apiVersion')
+        ];
+
+        $params = $command->toArray();
+
+        // Only build up the parameters when there are parameters to build
+        if ($params) {
+            $body += call_user_func(
+                $this->paramBuilder,
+                $operation->getInput(),
+                $params
+            );
+        }
+
+        $body = http_build_query($body, '', '&', PHP_QUERY_RFC3986);
+
+        return new Request(
+            'POST',
+            $this->endpoint,
+            [
+                'Content-Length' => strlen($body),
+                'Content-Type'   => 'application/x-www-form-urlencoded'
+            ],
+            $body
+        );
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/RestJsonSerializer.php ---
@@ -0,0 +1,42 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\Service;
+use Aws\Api\StructureShape;
+
+/**
+ * Serializes requests for the REST-JSON protocol.
+ * @internal
+ */
+class RestJsonSerializer extends RestSerializer
+{
+    /** @var JsonBody */
+    private $jsonFormatter;
+
+    /** @var string */
+    private $contentType;
+
+    /**
+     * @param Service  $api           Service API description
+     * @param string   $endpoint      Endpoint to connect to
+     * @param JsonBody $jsonFormatter Optional JSON formatter to use
+     */
+    public function __construct(
+        Service $api,
+        $endpoint,
+        JsonBody $jsonFormatter = null
+    ) {
+        parent::__construct($api, $endpoint);
+        $this->contentType = 'application/json';
+        $this->jsonFormatter = $jsonFormatter ?: new JsonBody($api);
+    }
+
+    protected function payload(StructureShape $member, array $value, array &$opts)
+    {
+        $body = isset($value) ?
+            ((string) $this->jsonFormatter->build($member, $value))
+            : "{}";
+        $opts['headers']['Content-Type'] = $this->contentType;
+        $opts['body'] = $body;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/RestSerializer.php ---
@@ -0,0 +1,250 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\MapShape;
+use Aws\Api\Service;
+use Aws\Api\Operation;
+use Aws\Api\Shape;
+use Aws\Api\StructureShape;
+use Aws\Api\TimestampShape;
+use Aws\CommandInterface;
+use GuzzleHttp\Psr7;
+use GuzzleHttp\Psr7\Uri;
+use GuzzleHttp\Psr7\UriResolver;
+use Psr\Http\Message\RequestInterface;
+
+/**
+ * Serializes HTTP locations like header, uri, payload, etc...
+ * @internal
+ */
+abstract class RestSerializer
+{
+    /** @var Service */
+    private $api;
+
+    /** @var Psr7\Uri */
+    private $endpoint;
+
+    /**
+     * @param Service $api      Service API description
+     * @param string  $endpoint Endpoint to connect to
+     */
+    public function __construct(Service $api, $endpoint)
+    {
+        $this->api = $api;
+        $this->endpoint = Psr7\Utils::uriFor($endpoint);
+    }
+
+    /**
+     * @param CommandInterface $command Command to serialized
+     *
+     * @return RequestInterface
+     */
+    public function __invoke(CommandInterface $command)
+    {
+        $operation = $this->api->getOperation($command->getName());
+        $args = $command->toArray();
+        $opts = $this->serialize($operation, $args);
+        $uri = $this->buildEndpoint($operation, $args, $opts);
+
+        return new Psr7\Request(
+            $operation['http']['method'],
+            $uri,
+            isset($opts['headers']) ? $opts['headers'] : [],
+            isset($opts['body']) ? $opts['body'] : null
+        );
+    }
+
+    /**
+     * Modifies a hash of request options for a payload body.
+     *
+     * @param StructureShape   $member  Member to serialize
+     * @param array            $value   Value to serialize
+     * @param array            $opts    Request options to modify.
+     */
+    abstract protected function payload(
+        StructureShape $member,
+        array $value,
+        array &$opts
+    );
+
+    private function serialize(Operation $operation, array $args)
+    {
+        $opts = [];
+        $input = $operation->getInput();
+
+        // Apply the payload trait if present
+        if ($payload = $input['payload']) {
+            $this->applyPayload($input, $payload, $args, $opts);
+        }
+
+        foreach ($args as $name => $value) {
+            if ($input->hasMember($name)) {
+                $member = $input->getMember($name);
+                $location = $member['location'];
+                if (!$payload && !$location) {
+                    $bodyMembers[$name] = $value;
+                } elseif ($location == 'header') {
+                    $this->applyHeader($name, $member, $value, $opts);
+                } elseif ($location == 'querystring') {
+                    $this->applyQuery($name, $member, $value, $opts);
+                } elseif ($location == 'headers') {
+                    $this->applyHeaderMap($name, $member, $value, $opts);
+                }
+            }
+        }
+
+        if (isset($bodyMembers)) {
+            $this->payload($operation->getInput(), $bodyMembers, $opts);
+        } else if (!isset($opts['body']) && $this->hasPayloadParam($input, $payload)) {
+            $this->payload($operation->getInput(), [], $opts);
+        }
+
+        return $opts;
+    }
+
+    private function applyPayload(StructureShape $input, $name, array $args, array &$opts)
+    {
+        if (!isset($args[$name])) {
+            return;
+        }
+
+        $m = $input->getMember($name);
+
+        if ($m['streaming'] ||
+           ($m['type'] == 'string' || $m['type'] == 'blob')
+        ) {
+            // Streaming bodies or payloads that are strings are
+            // always just a stream of data.
+            $opts['body'] = Psr7\Utils::streamFor($args[$name]);
+            return;
+        }
+
+        $this->payload($m, $args[$name], $opts);
+    }
+
+    private function applyHeader($name, Shape $member, $value, array &$opts)
+    {
+        if ($member->getType() === 'timestamp') {
+            $timestampFormat = !empty($member['timestampFormat'])
+                ? $member['timestampFormat']
+                : 'rfc822';
+            $value = TimestampShape::format($value, $timestampFormat);
+        }
+        if ($member['jsonvalue']) {
+            $value = json_encode($value);
+            if (empty($value) && JSON_ERROR_NONE !== json_last_error()) {
+                throw new \InvalidArgumentException('Unable to encode the provided value'
+                    . ' with \'json_encode\'. ' . json_last_error_msg());
+            }
+
+            $value = base64_encode($value);
+        }
+
+        $opts['headers'][$member['locationName'] ?: $name] = $value;
+    }
+
+    /**
+     * Note: This is currently only present in the Amazon S3 model.
+     */
+    private function applyHeaderMap($name, Shape $member, array $value, array &$opts)
+    {
+        $prefix = $member['locationName'];
+        foreach ($value as $k => $v) {
+            $opts['headers'][$prefix . $k] = $v;
+        }
+    }
+
+    private function applyQuery($name, Shape $member, $value, array &$opts)
+    {
+        if ($member instanceof MapShape) {
+            $opts['query'] = isset($opts['query']) && is_array($opts['query'])
+                ? $opts['query'] + $value
+                : $value;
+        } elseif ($value !== null) {
+            $type = $member->getType();
+            if ($type === 'boolean') {
+                $value = $value ? 'true' : 'false';
+            } elseif ($type === 'timestamp') {
+                $timestampFormat = !empty($member['timestampFormat'])
+                    ? $member['timestampFormat']
+                    : 'iso8601';
+                $value = TimestampShape::format($value, $timestampFormat);
+            }
+
+            $opts['query'][$member['locationName'] ?: $name] = $value;
+        }
+    }
+
+    private function buildEndpoint(Operation $operation, array $args, array $opts)
+    {
+        $varspecs = [];
+
+        // Create an associative array of varspecs used in expansions
+        foreach ($operation->getInput()->getMembers() as $name => $member) {
+            if ($member['location'] == 'uri') {
+                $varspecs[$member['locationName'] ?: $name] =
+                    isset($args[$name])
+                        ? $args[$name]
+                        : null;
+            }
+        }
+
+        $relative = preg_replace_callback(
+            '/\{([^\}]+)\}/',
+            function (array $matches) use ($varspecs) {
+                $isGreedy = substr($matches[1], -1, 1) == '+';
+                $k = $isGreedy ? substr($matches[1], 0, -1) : $matches[1];
+                if (!isset($varspecs[$k])) {
+                    return '';
+                }
+
+                if ($isGreedy) {
+                    return str_replace('%2F', '/', rawurlencode($varspecs[$k]));
+                }
+
+                return rawurlencode($varspecs[$k]);
+            },
+            $operation['http']['requestUri']
+        );
+
+        // Add the query string variables or appending to one if needed.
+        if (!empty($opts['query'])) {
+            $append = Psr7\Query::build($opts['query']);
+            $relative .= strpos($relative, '?') ? "&{$append}" : "?$append";
+        }
+
+        // If endpoint has path, remove leading '/' to preserve URI resolution.
+        $path = $this->endpoint->getPath();
+        if ($path && $relative[0] === '/') {
+            $relative = substr($relative, 1);
+        }
+
+        // Expand path place holders using Amazon's slightly different URI
+        // template syntax.
+        return UriResolver::resolve($this->endpoint, new Uri($relative));
+    }
+
+    /**
+     * @param StructureShape $input
+     */
+    private function hasPayloadParam(StructureShape $input, $payload)
+    {
+        if ($payload) {
+            $potentiallyEmptyTypes = ['blob','string'];
+            if ($this->api->getMetadata('protocol') == 'rest-xml') {
+                $potentiallyEmptyTypes[] = 'structure';
+            }
+            $payloadMember = $input->getMember($payload);
+            if (in_array($payloadMember['type'], $potentiallyEmptyTypes)) {
+                return false;
+            }
+        }
+        foreach ($input->getMembers() as $member) {
+            if (!isset($member['location'])) {
+                return true;
+            }
+        }
+        return false;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/RestXmlSerializer.php ---
@@ -0,0 +1,48 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\StructureShape;
+use Aws\Api\Service;
+
+/**
+ * @internal
+ */
+class RestXmlSerializer extends RestSerializer
+{
+    /** @var XmlBody */
+    private $xmlBody;
+
+    /**
+     * @param Service $api      Service API description
+     * @param string  $endpoint Endpoint to connect to
+     * @param XmlBody $xmlBody  Optional XML formatter to use
+     */
+    public function __construct(
+        Service $api,
+        $endpoint,
+        XmlBody $xmlBody = null
+    ) {
+        parent::__construct($api, $endpoint);
+        $this->xmlBody = $xmlBody ?: new XmlBody($api);
+    }
+
+    protected function payload(StructureShape $member, array $value, array &$opts)
+    {
+        $opts['headers']['Content-Type'] = 'application/xml';
+        $opts['body'] = $this->getXmlBody($member, $value);
+    }
+
+    /**
+     * @param StructureShape $member
+     * @param array $value
+     * @return string
+     */
+    private function getXmlBody(StructureShape $member, array $value)
+    {
+        $xmlBody = (string)$this->xmlBody->build($member, $value);
+        $xmlBody = str_replace("'", "&apos;", $xmlBody);
+        $xmlBody = str_replace('\r', "&#13;", $xmlBody);
+        $xmlBody = str_replace('\n', "&#10;", $xmlBody);
+        return $xmlBody;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Serializer/XmlBody.php ---
@@ -0,0 +1,220 @@
+<?php
+namespace Aws\Api\Serializer;
+
+use Aws\Api\MapShape;
+use Aws\Api\Service;
+use Aws\Api\Shape;
+use Aws\Api\StructureShape;
+use Aws\Api\ListShape;
+use Aws\Api\TimestampShape;
+use XMLWriter;
+
+/**
+ * @internal Formats the XML body of a REST-XML services.
+ */
+class XmlBody
+{
+    /** @var \Aws\Api\Service */
+    private $api;
+
+    /**
+     * @param Service $api API being used to create the XML body.
+     */
+    public function __construct(Service $api)
+    {
+        $this->api = $api;
+    }
+
+    /**
+     * Builds the XML body based on an array of arguments.
+     *
+     * @param Shape $shape Operation being constructed
+     * @param array $args  Associative array of arguments
+     *
+     * @return string
+     */
+    public function build(Shape $shape, array $args)
+    {
+        $xml = new XMLWriter();
+        $xml->openMemory();
+        $xml->startDocument('1.0', 'UTF-8');
+        $this->format($shape, $shape['locationName'] ?: $shape['name'], $args, $xml);
+        $xml->endDocument();
+
+        return $xml->outputMemory();
+    }
+
+    private function startElement(Shape $shape, $name, XMLWriter $xml)
+    {
+        $xml->startElement($name);
+
+        if ($ns = $shape['xmlNamespace']) {
+            $xml->writeAttribute(
+                isset($ns['prefix']) ? "xmlns:{$ns['prefix']}" : 'xmlns',
+                $shape['xmlNamespace']['uri']
+            );
+        }
+    }
+
+    private function format(Shape $shape, $name, $value, XMLWriter $xml)
+    {
+        // Any method mentioned here has a custom serialization handler.
+        static $methods = [
+            'add_structure' => true,
+            'add_list'      => true,
+            'add_blob'      => true,
+            'add_timestamp' => true,
+            'add_boolean'   => true,
+            'add_map'       => true,
+            'add_string'    => true
+        ];
+
+        $type = 'add_' . $shape['type'];
+        if (isset($methods[$type])) {
+            $this->{$type}($shape, $name, $value, $xml);
+        } else {
+            $this->defaultShape($shape, $name, $value, $xml);
+        }
+    }
+
+    private function defaultShape(Shape $shape, $name, $value, XMLWriter $xml)
+    {
+        $this->startElement($shape, $name, $xml);
+        $xml->text($value);
+        $xml->endElement();
+    }
+
+    private function add_structure(
+        StructureShape $shape,
+        $name,
+        array $value,
+        \XMLWriter $xml
+    ) {
+        $this->startElement($shape, $name, $xml);
+
+        foreach ($this->getStructureMembers($shape, $value) as $k => $definition) {
+            $this->format(
+                $definition['member'],
+                $definition['member']['locationName'] ?: $k,
+                $definition['value'],
+                $xml
+            );
+        }
+
+        $xml->endElement();
+    }
+
+    private function getStructureMembers(StructureShape $shape, array $value)
+    {
+        $members = [];
+
+        foreach ($value as $k => $v) {
+            if ($v !== null && $shape->hasMember($k)) {
+                $definition = [
+                    'member' => $shape->getMember($k),
+                    'value'  => $v,
+                ];
+
+                if ($definition['member']['xmlAttribute']) {
+                    // array_unshift_associative
+                    $members = [$k => $definition] + $members;
+                } else {
+                    $members[$k] = $definition;
+                }
+            }
+        }
+
+        return $members;
+    }
+
+    private function add_list(
+        ListShape $shape,
+        $name,
+        array $value,
+        XMLWriter $xml
+    ) {
+        $items = $shape->getMember();
+
+        if ($shape['flattened']) {
+            $elementName = $name;
+        } else {
+            $this->startElement($shape, $name, $xml);
+            $elementName = $items['locationName'] ?: 'member';
+        }
+
+        foreach ($value as $v) {
+            $this->format($items, $elementName, $v, $xml);
+        }
+
+        if (!$shape['flattened']) {
+            $xml->endElement();
+        }
+    }
+
+    private function add_map(
+        MapShape $shape,
+        $name,
+        array $value,
+        XMLWriter $xml
+    ) {
+        $xmlEntry = $shape['flattened'] ? $shape['locationName'] : 'entry';
+        $xmlKey = $shape->getKey()['locationName'] ?: 'key';
+        $xmlValue = $shape->getValue()['locationName'] ?: 'value';
+
+        $this->startElement($shape, $name, $xml);
+
+        foreach ($value as $key => $v) {
+            $this->startElement($shape, $xmlEntry, $xml);
+            $this->format($shape->getKey(), $xmlKey, $key, $xml);
+            $this->format($shape->getValue(), $xmlValue, $v, $xml);
+            $xml->endElement();
+        }
+
+        $xml->endElement();
+    }
+
+    private function add_blob(Shape $shape, $name, $value, XMLWriter $xml)
+    {
+        $this->startElement($shape, $name, $xml);
+        $xml->writeRaw(base64_encode($value));
+        $xml->endElement();
+    }
+
+    private function add_timestamp(
+        TimestampShape $shape,
+        $name,
+        $value,
+        XMLWriter $xml
+    ) {
+        $this->startElement($shape, $name, $xml);
+        $timestampFormat = !empty($shape['timestampFormat'])
+            ? $shape['timestampFormat']
+            : 'iso8601';
+        $xml->writeRaw(TimestampShape::format($value, $timestampFormat));
+        $xml->endElement();
+    }
+
+    private function add_boolean(
+        Shape $shape,
+        $name,
+        $value,
+        XMLWriter $xml
+    ) {
+        $this->startElement($shape, $name, $xml);
+        $xml->writeRaw($value ? 'true' : 'false');
+        $xml->endElement();
+    }
+
+    private function add_string(
+        Shape $shape,
+        $name,
+        $value,
+        XMLWriter $xml
+    ) {
+        if ($shape['xmlAttribute']) {
+            $xml->writeAttribute($shape['locationName'] ?: $name, $value);
+        } else {
+            $this->defaultShape($shape, $name, $value, $xml);
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Service.php ---
@@ -0,0 +1,468 @@
+<?php
+namespace Aws\Api;
+
+use Aws\Api\Serializer\QuerySerializer;
+use Aws\Api\Serializer\Ec2ParamBuilder;
+use Aws\Api\Parser\QueryParser;
+
+/**
+ * Represents a web service API model.
+ */
+class Service extends AbstractModel
+{
+    /** @var callable */
+    private $apiProvider;
+
+    /** @var string */
+    private $serviceName;
+
+    /** @var string */
+    private $apiVersion;
+
+    /** @var Operation[] */
+    private $operations = [];
+
+    /** @var array */
+    private $paginators = null;
+
+    /** @var array */
+    private $waiters = null;
+
+    /**
+     * @param array    $definition
+     * @param callable $provider
+     *
+     * @internal param array $definition Service description
+     */
+    public function __construct(array $definition, callable $provider)
+    {
+        static $defaults = [
+            'operations' => [],
+            'shapes'     => [],
+            'metadata'   => []
+        ], $defaultMeta = [
+            'apiVersion'       => null,
+            'serviceFullName'  => null,
+            'serviceId'        => null,
+            'endpointPrefix'   => null,
+            'signingName'      => null,
+            'signatureVersion' => null,
+            'protocol'         => null,
+            'uid'              => null
+        ];
+
+        $definition += $defaults;
+        $definition['metadata'] += $defaultMeta;
+        $this->definition = $definition;
+        $this->apiProvider = $provider;
+        parent::__construct($definition, new ShapeMap($definition['shapes']));
+
+        if (isset($definition['metadata']['serviceIdentifier'])) {
+            $this->serviceName = $this->getServiceName();
+        } else {
+            $this->serviceName = $this->getEndpointPrefix();
+        }
+
+        $this->apiVersion = $this->getApiVersion();
+    }
+
+    /**
+     * Creates a request serializer for the provided API object.
+     *
+     * @param Service $api      API that contains a protocol.
+     * @param string  $endpoint Endpoint to send requests to.
+     *
+     * @return callable
+     * @throws \UnexpectedValueException
+     */
+    public static function createSerializer(Service $api, $endpoint)
+    {
+        static $mapping = [
+            'json'      => 'Aws\Api\Serializer\JsonRpcSerializer',
+            'query'     => 'Aws\Api\Serializer\QuerySerializer',
+            'rest-json' => 'Aws\Api\Serializer\RestJsonSerializer',
+            'rest-xml'  => 'Aws\Api\Serializer\RestXmlSerializer'
+        ];
+
+        $proto = $api->getProtocol();
+
+        if (isset($mapping[$proto])) {
+            return new $mapping[$proto]($api, $endpoint);
+        }
+
+        if ($proto == 'ec2') {
+            return new QuerySerializer($api, $endpoint, new Ec2ParamBuilder());
+        }
+
+        throw new \UnexpectedValueException(
+            'Unknown protocol: ' . $api->getProtocol()
+        );
+    }
+
+    /**
+     * Creates an error parser for the given protocol.
+     *
+     * Redundant method signature to preserve backwards compatibility.
+     *
+     * @param string $protocol Protocol to parse (e.g., query, json, etc.)
+     *
+     * @return callable
+     * @throws \UnexpectedValueException
+     */
+    public static function createErrorParser($protocol, Service $api = null)
+    {
+        static $mapping = [
+            'json'      => 'Aws\Api\ErrorParser\JsonRpcErrorParser',
+            'query'     => 'Aws\Api\ErrorParser\XmlErrorParser',
+            'rest-json' => 'Aws\Api\ErrorParser\RestJsonErrorParser',
+            'rest-xml'  => 'Aws\Api\ErrorParser\XmlErrorParser',
+            'ec2'       => 'Aws\Api\ErrorParser\XmlErrorParser'
+        ];
+
+        if (isset($mapping[$protocol])) {
+            return new $mapping[$protocol]($api);
+        }
+
+        throw new \UnexpectedValueException("Unknown protocol: $protocol");
+    }
+
+    /**
+     * Applies the listeners needed to parse client models.
+     *
+     * @param Service $api API to create a parser for
+     * @return callable
+     * @throws \UnexpectedValueException
+     */
+    public static function createParser(Service $api)
+    {
+        static $mapping = [
+            'json'      => 'Aws\Api\Parser\JsonRpcParser',
+            'query'     => 'Aws\Api\Parser\QueryParser',
+            'rest-json' => 'Aws\Api\Parser\RestJsonParser',
+            'rest-xml'  => 'Aws\Api\Parser\RestXmlParser'
+        ];
+
+        $proto = $api->getProtocol();
+        if (isset($mapping[$proto])) {
+            return new $mapping[$proto]($api);
+        }
+
+        if ($proto == 'ec2') {
+            return new QueryParser($api, null, false);
+        }
+
+        throw new \UnexpectedValueException(
+            'Unknown protocol: ' . $api->getProtocol()
+        );
+    }
+
+    /**
+     * Get the full name of the service
+     *
+     * @return string
+     */
+    public function getServiceFullName()
+    {
+        return $this->definition['metadata']['serviceFullName'];
+    }
+
+    /**
+     * Get the service id
+     *
+     * @return string
+     */
+    public function getServiceId()
+    {
+        return $this->definition['metadata']['serviceId'];
+    }
+
+    /**
+     * Get the API version of the service
+     *
+     * @return string
+     */
+    public function getApiVersion()
+    {
+        return $this->definition['metadata']['apiVersion'];
+    }
+
+    /**
+     * Get the API version of the service
+     *
+     * @return string
+     */
+    public function getEndpointPrefix()
+    {
+        return $this->definition['metadata']['endpointPrefix'];
+    }
+
+    /**
+     * Get the signing name used by the service.
+     *
+     * @return string
+     */
+    public function getSigningName()
+    {
+        return $this->definition['metadata']['signingName']
+            ?: $this->definition['metadata']['endpointPrefix'];
+    }
+
+    /**
+     * Get the service name.
+     *
+     * @return string
+     */
+    public function getServiceName()
+    {
+        return $this->definition['metadata']['serviceIdentifier'];
+    }
+
+    /**
+     * Get the default signature version of the service.
+     *
+     * Note: this method assumes "v4" when not specified in the model.
+     *
+     * @return string
+     */
+    public function getSignatureVersion()
+    {
+        return $this->definition['metadata']['signatureVersion'] ?: 'v4';
+    }
+
+    /**
+     * Get the protocol used by the service.
+     *
+     * @return string
+     */
+    public function getProtocol()
+    {
+        return $this->definition['metadata']['protocol'];
+    }
+
+    /**
+     * Get the uid string used by the service
+     *
+     * @return string
+     */
+    public function getUid()
+    {
+        return $this->definition['metadata']['uid'];
+    }
+
+    /**
+     * Check if the description has a specific operation by name.
+     *
+     * @param string $name Operation to check by name
+     *
+     * @return bool
+     */
+    public function hasOperation($name)
+    {
+        return isset($this['operations'][$name]);
+    }
+
+    /**
+     * Get an operation by name.
+     *
+     * @param string $name Operation to retrieve by name
+     *
+     * @return Operation
+     * @throws \InvalidArgumentException If the operation is not found
+     */
+    public function getOperation($name)
+    {
+        if (!isset($this->operations[$name])) {
+            if (!isset($this->definition['operations'][$name])) {
+                throw new \InvalidArgumentException("Unknown operation: $name");
+            }
+            $this->operations[$name] = new Operation(
+                $this->definition['operations'][$name],
+                $this->shapeMap
+            );
+        }
+
+        return $this->operations[$name];
+    }
+
+    /**
+     * Get all of the operations of the description.
+     *
+     * @return Operation[]
+     */
+    public function getOperations()
+    {
+        $result = [];
+        foreach ($this->definition['operations'] as $name => $definition) {
+            $result[$name] = $this->getOperation($name);
+        }
+
+        return $result;
+    }
+
+    /**
+     * Get all of the error shapes of the service
+     *
+     * @return array
+     */
+    public function getErrorShapes()
+    {
+        $result = [];
+        foreach ($this->definition['shapes'] as $name => $definition) {
+            if (!empty($definition['exception'])) {
+                $definition['name'] = $name;
+                $result[] = new StructureShape($definition, $this->getShapeMap());
+            }
+        }
+
+        return $result;
+    }
+
+    /**
+     * Get all of the service metadata or a specific metadata key value.
+     *
+     * @param string|null $key Key to retrieve or null to retrieve all metadata
+     *
+     * @return mixed Returns the result or null if the key is not found
+     */
+    public function getMetadata($key = null)
+    {
+        if (!$key) {
+            return $this['metadata'];
+        }
+
+        if (isset($this->definition['metadata'][$key])) {
+            return $this->definition['metadata'][$key];
+        }
+
+        return null;
+    }
+
+    /**
+     * Gets an associative array of available paginator configurations where
+     * the key is the name of the paginator, and the value is the paginator
+     * configuration.
+     *
+     * @return array
+     * @unstable The configuration format of paginators may change in the future
+     */
+    public function getPaginators()
+    {
+        if (!isset($this->paginators)) {
+            $res = call_user_func(
+                $this->apiProvider,
+                'paginator',
+                $this->serviceName,
+                $this->apiVersion
+            );
+            $this->paginators = isset($res['pagination'])
+                ? $res['pagination']
+                : [];
+        }
+
+        return $this->paginators;
+    }
+
+    /**
+     * Determines if the service has a paginator by name.
+     *
+     * @param string $name Name of the paginator.
+     *
+     * @return bool
+     */
+    public function hasPaginator($name)
+    {
+        return isset($this->getPaginators()[$name]);
+    }
+
+    /**
+     * Retrieve a paginator by name.
+     *
+     * @param string $name Paginator to retrieve by name. This argument is
+     *                     typically the operation name.
+     * @return array
+     * @throws \UnexpectedValueException if the paginator does not exist.
+     * @unstable The configuration format of paginators may change in the future
+     */
+    public function getPaginatorConfig($name)
+    {
+        static $defaults = [
+            'input_token'  => null,
+            'output_token' => null,
+            'limit_key'    => null,
+            'result_key'   => null,
+            'more_results' => null,
+        ];
+
+        if ($this->hasPaginator($name)) {
+            return $this->paginators[$name] + $defaults;
+        }
+
+        throw new \UnexpectedValueException("There is no {$name} "
+            . "paginator defined for the {$this->serviceName} service.");
+    }
+
+    /**
+     * Gets an associative array of available waiter configurations where the
+     * key is the name of the waiter, and the value is the waiter
+     * configuration.
+     *
+     * @return array
+     */
+    public function getWaiters()
+    {
+        if (!isset($this->waiters)) {
+            $res = call_user_func(
+                $this->apiProvider,
+                'waiter',
+                $this->serviceName,
+                $this->apiVersion
+            );
+            $this->waiters = isset($res['waiters'])
+                ? $res['waiters']
+                : [];
+        }
+
+        return $this->waiters;
+    }
+
+    /**
+     * Determines if the service has a waiter by name.
+     *
+     * @param string $name Name of the waiter.
+     *
+     * @return bool
+     */
+    public function hasWaiter($name)
+    {
+        return isset($this->getWaiters()[$name]);
+    }
+
+    /**
+     * Get a waiter configuration by name.
+     *
+     * @param string $name Name of the waiter by name.
+     *
+     * @return array
+     * @throws \UnexpectedValueException if the waiter does not exist.
+     */
+    public function getWaiterConfig($name)
+    {
+        // Error if the waiter is not defined
+        if ($this->hasWaiter($name)) {
+            return $this->waiters[$name];
+        }
+
+        throw new \UnexpectedValueException("There is no {$name} waiter "
+            . "defined for the {$this->serviceName} service.");
+    }
+
+    /**
+     * Get the shape map used by the API.
+     *
+     * @return ShapeMap
+     */
+    public function getShapeMap()
+    {
+        return $this->shapeMap;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Shape.php ---
@@ -0,0 +1,69 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Base class representing a modeled shape.
+ */
+class Shape extends AbstractModel
+{
+    /**
+     * Get a concrete shape for the given definition.
+     *
+     * @param array    $definition
+     * @param ShapeMap $shapeMap
+     *
+     * @return mixed
+     * @throws \RuntimeException if the type is invalid
+     */
+    public static function create(array $definition, ShapeMap $shapeMap)
+    {
+        static $map = [
+            'structure' => 'Aws\Api\StructureShape',
+            'map'       => 'Aws\Api\MapShape',
+            'list'      => 'Aws\Api\ListShape',
+            'timestamp' => 'Aws\Api\TimestampShape',
+            'integer'   => 'Aws\Api\Shape',
+            'double'    => 'Aws\Api\Shape',
+            'float'     => 'Aws\Api\Shape',
+            'long'      => 'Aws\Api\Shape',
+            'string'    => 'Aws\Api\Shape',
+            'byte'      => 'Aws\Api\Shape',
+            'character' => 'Aws\Api\Shape',
+            'blob'      => 'Aws\Api\Shape',
+            'boolean'   => 'Aws\Api\Shape'
+        ];
+
+        if (isset($definition['shape'])) {
+            return $shapeMap->resolve($definition);
+        }
+
+        if (!isset($map[$definition['type']])) {
+            throw new \RuntimeException('Invalid type: '
+                . print_r($definition, true));
+        }
+
+        $type = $map[$definition['type']];
+
+        return new $type($definition, $shapeMap);
+    }
+
+    /**
+     * Get the type of the shape
+     *
+     * @return string
+     */
+    public function getType()
+    {
+        return $this->definition['type'];
+    }
+
+    /**
+     * Get the name of the shape
+     *
+     * @return string
+     */
+    public function getName()
+    {
+        return $this->definition['name'];
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/ShapeMap.php ---
@@ -0,0 +1,68 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Builds shape based on shape references.
+ */
+class ShapeMap
+{
+    /** @var array */
+    private $definitions;
+
+    /** @var Shape[] */
+    private $simple;
+
+    /**
+     * @param array $shapeModels Associative array of shape definitions.
+     */
+    public function __construct(array $shapeModels)
+    {
+        $this->definitions = $shapeModels;
+    }
+
+    /**
+     * Get an array of shape names.
+     *
+     * @return array
+     */
+    public function getShapeNames()
+    {
+        return array_keys($this->definitions);
+    }
+
+    /**
+     * Resolve a shape reference
+     *
+     * @param array $shapeRef Shape reference shape
+     *
+     * @return Shape
+     * @throws \InvalidArgumentException
+     */
+    public function resolve(array $shapeRef)
+    {
+        $shape = $shapeRef['shape'];
+
+        if (!isset($this->definitions[$shape])) {
+            throw new \InvalidArgumentException('Shape not found: ' . $shape);
+        }
+
+        $isSimple = count($shapeRef) == 1;
+        if ($isSimple && isset($this->simple[$shape])) {
+            return $this->simple[$shape];
+        }
+
+        $definition = $shapeRef + $this->definitions[$shape];
+        $definition['name'] = $definition['shape'];
+        if (isset($definition['shape'])) {
+            unset($definition['shape']);
+        }
+
+        $result = Shape::create($definition, $this);
+
+        if ($isSimple) {
+            $this->simple[$shape] = $result;
+        }
+
+        return $result;
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/StructureShape.php ---
@@ -0,0 +1,79 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Represents a structure shape and resolve member shape references.
+ */
+class StructureShape extends Shape
+{
+    /**
+     * @var Shape[]
+     */
+    private $members;
+
+    public function __construct(array $definition, ShapeMap $shapeMap)
+    {
+        $definition['type'] = 'structure';
+
+        if (!isset($definition['members'])) {
+            $definition['members'] = [];
+        }
+
+        parent::__construct($definition, $shapeMap);
+    }
+
+    /**
+     * Gets a list of all members
+     *
+     * @return Shape[]
+     */
+    public function getMembers()
+    {
+        if (empty($this->members)) {
+            $this->generateMembersHash();
+        }
+
+        return $this->members;
+    }
+
+    /**
+     * Check if a specific member exists by name.
+     *
+     * @param string $name Name of the member to check
+     *
+     * @return bool
+     */
+    public function hasMember($name)
+    {
+        return isset($this->definition['members'][$name]);
+    }
+
+    /**
+     * Retrieve a member by name.
+     *
+     * @param string $name Name of the member to retrieve
+     *
+     * @return Shape
+     * @throws \InvalidArgumentException if the member is not found.
+     */
+    public function getMember($name)
+    {
+        $members = $this->getMembers();
+
+        if (!isset($members[$name])) {
+            throw new \InvalidArgumentException('Unknown member ' . $name);
+        }
+
+        return $members[$name];
+    }
+
+
+    private function generateMembersHash()
+    {
+        $this->members = [];
+
+        foreach ($this->definition['members'] as $name => $definition) {
+            $this->members[$name] = $this->shapeFor($definition);
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/TimestampShape.php ---
@@ -0,0 +1,48 @@
+<?php
+namespace Aws\Api;
+
+/**
+ * Represents a timestamp shape.
+ */
+class TimestampShape extends Shape
+{
+    public function __construct(array $definition, ShapeMap $shapeMap)
+    {
+        $definition['type'] = 'timestamp';
+        parent::__construct($definition, $shapeMap);
+    }
+
+    /**
+     * Formats a timestamp value for a service.
+     *
+     * @param mixed  $value  Value to format
+     * @param string $format Format used to serialize the value
+     *
+     * @return int|string
+     * @throws \UnexpectedValueException if the format is unknown.
+     * @throws \InvalidArgumentException if the value is an unsupported type.
+     */
+    public static function format($value, $format)
+    {
+        if ($value instanceof \DateTime) {
+            $value = $value->getTimestamp();
+        } elseif (is_string($value)) {
+            $value = strtotime($value);
+        } elseif (!is_int($value)) {
+            throw new \InvalidArgumentException('Unable to handle the provided'
+                . ' timestamp type: ' . gettype($value));
+        }
+
+        switch ($format) {
+            case 'iso8601':
+                return gmdate('Y-m-d\TH:i:s\Z', $value);
+            case 'rfc822':
+                return gmdate('D, d M Y H:i:s \G\M\T', $value);
+            case 'unixTimestamp':
+                return $value;
+            default:
+                throw new \UnexpectedValueException('Unknown timestamp format: '
+                    . $format);
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Api/Validator.php ---
@@ -0,0 +1,345 @@
+<?php
+namespace Aws\Api;
+
+use Aws;
+
+/**
+ * Validates a schema against a hash of input.
+ */
+class Validator
+{
+    private $path = [];
+    private $errors = [];
+    private $constraints = [];
+
+    private static $defaultConstraints = [
+        'required' => true,
+        'min'      => true,
+        'max'      => false,
+        'pattern'  => false
+    ];
+
+    /**
+     * @param array $constraints Associative array of constraints to enforce.
+     *                           Accepts the following keys: "required", "min",
+     *                           "max", and "pattern". If a key is not
+     *                           provided, the constraint will assume false.
+     */
+    public function __construct(array $constraints = null)
+    {
+        static $assumedFalseValues = [
+            'required' => false,
+            'min'      => false,
+            'max'      => false,
+            'pattern'  => false
+        ];
+        $this->constraints = empty($constraints)
+            ? self::$defaultConstraints
+            : $constraints + $assumedFalseValues;
+    }
+
+    /**
+     * Validates the given input against the schema.
+     *
+     * @param string $name  Operation name
+     * @param Shape  $shape Shape to validate
+     * @param array  $input Input to validate
+     *
+     * @throws \InvalidArgumentException if the input is invalid.
+     */
+    public function validate($name, Shape $shape, array $input)
+    {
+        $this->dispatch($shape, $input);
+
+        if ($this->errors) {
+            $message = sprintf(
+                "Found %d error%s while validating the input provided for the "
+                    . "%s operation:\n%s",
+                count($this->errors),
+                count($this->errors) > 1 ? 's' : '',
+                $name,
+                implode("\n", $this->errors)
+            );
+            $this->errors = [];
+
+            throw new \InvalidArgumentException($message);
+        }
+    }
+
+    private function dispatch(Shape $shape, $value)
+    {
+        static $methods = [
+            'structure' => 'check_structure',
+            'list'      => 'check_list',
+            'map'       => 'check_map',
+            'blob'      => 'check_blob',
+            'boolean'   => 'check_boolean',
+            'integer'   => 'check_numeric',
+            'float'     => 'check_numeric',
+            'long'      => 'check_numeric',
+            'string'    => 'check_string',
+            'byte'      => 'check_string',
+            'char'      => 'check_string'
+        ];
+
+        $type = $shape->getType();
+        if (isset($methods[$type])) {
+            $this->{$methods[$type]}($shape, $value);
+        }
+    }
+
+    private function check_structure(StructureShape $shape, $value)
+    {
+        $isDocument = (isset($shape['document']) && $shape['document']);
+        $isUnion = (isset($shape['union']) && $shape['union']);
+        if ($isDocument) {
+            if (!$this->checkDocumentType($value)) {
+                $this->addError("is not a valid document type");
+                return;
+            }
+        } elseif ($isUnion) {
+            if (!$this->checkUnion($value)) {
+                $this->addError("is a union type and must have exactly one non null value");
+                return;
+            }
+        } elseif (!$this->checkAssociativeArray($value)) {
+            return;
+        }
+
+        if ($this->constraints['required'] && $shape['required']) {
+            foreach ($shape['required'] as $req) {
+                if (!isset($value[$req])) {
+                    $this->path[] = $req;
+                    $this->addError('is missing and is a required parameter');
+                    array_pop($this->path);
+                }
+            }
+        }
+        if (!$isDocument) {
+            foreach ($value as $name => $v) {
+                if ($shape->hasMember($name)) {
+                    $this->path[] = $name;
+                    $this->dispatch(
+                        $shape->getMember($name),
+                        isset($value[$name]) ? $value[$name] : null
+                    );
+                    array_pop($this->path);
+                }
+            }
+        }
+    }
+
+    private function check_list(ListShape $shape, $value)
+    {
+        if (!is_array($value)) {
+            $this->addError('must be an array. Found '
+                . Aws\describe_type($value));
+            return;
+        }
+
+        $this->validateRange($shape, count($value), "list element count");
+
+        $items = $shape->getMember();
+        foreach ($value as $index => $v) {
+            $this->path[] = $index;
+            $this->dispatch($items, $v);
+            array_pop($this->path);
+        }
+    }
+
+    private function check_map(MapShape $shape, $value)
+    {
+        if (!$this->checkAssociativeArray($value)) {
+            return;
+        }
+
+        $values = $shape->getValue();
+        foreach ($value as $key => $v) {
+            $this->path[] = $key;
+            $this->dispatch($values, $v);
+            array_pop($this->path);
+        }
+    }
+
+    private function check_blob(Shape $shape, $value)
+    {
+        static $valid = [
+            'string' => true,
+            'integer' => true,
+            'double' => true,
+            'resource' => true
+        ];
+
+        $type = gettype($value);
+        if (!isset($valid[$type])) {
+            if ($type != 'object' || !method_exists($value, '__toString')) {
+                $this->addError('must be an fopen resource, a '
+                    . 'GuzzleHttp\Stream\StreamInterface object, or something '
+                    . 'that can be cast to a string. Found '
+                    . Aws\describe_type($value));
+            }
+        }
+    }
+
+    private function check_numeric(Shape $shape, $value)
+    {
+        if (!is_numeric($value)) {
+            $this->addError('must be numeric. Found '
+                . Aws\describe_type($value));
+            return;
+        }
+
+        $this->validateRange($shape, $value, "numeric value");
+    }
+
+    private function check_boolean(Shape $shape, $value)
+    {
+        if (!is_bool($value)) {
+            $this->addError('must be a boolean. Found '
+                . Aws\describe_type($value));
+        }
+    }
+
+    private function check_string(Shape $shape, $value)
+    {
+        if ($shape['jsonvalue']) {
+            if (!self::canJsonEncode($value)) {
+                $this->addError('must be a value encodable with \'json_encode\'.'
+                    . ' Found ' . Aws\describe_type($value));
+            }
+            return;
+        }
+
+        if (!$this->checkCanString($value)) {
+            $this->addError('must be a string or an object that implements '
+                . '__toString(). Found ' . Aws\describe_type($value));
+            return;
+        }
+
+        $this->validateRange($shape, strlen($value), "string length");
+
+        if ($this->constraints['pattern']) {
+            $pattern = $shape['pattern'];
+            if ($pattern && !preg_match("/$pattern/", $value)) {
+                $this->addError("Pattern /$pattern/ failed to match '$value'");
+            }
+        }
+    }
+
+    private function validateRange(Shape $shape, $length, $descriptor)
+    {
+        if ($this->constraints['min']) {
+            $min = $shape['min'];
+            if ($min && $length < $min) {
+                $this->addError("expected $descriptor to be >= $min, but "
+                    . "found $descriptor of $length");
+            }
+        }
+
+        if ($this->constraints['max']) {
+            $max = $shape['max'];
+            if ($max && $length > $max) {
+                $this->addError("expected $descriptor to be <= $max, but "
+                    . "found $descriptor of $length");
+            }
+        }
+    }
+
+    private function checkArray($arr)
+    {
+        return $this->isIndexed($arr) || $this->isAssociative($arr);
+    }
+
+    private function isAssociative($arr)
+    {
+        return count(array_filter(array_keys($arr), "is_string")) == count($arr);
+    }
+
+    private function isIndexed(array $arr)
+    {
+        return $arr == array_values($arr);
+    }
+
+    private function checkCanString($value)
+    {
+        static $valid = [
+            'string'  => true,
+            'integer' => true,
+            'double'  => true,
+            'NULL'    => true,
+        ];
+
+        $type = gettype($value);
+
+        return isset($valid[$type]) ||
+            ($type == 'object' && method_exists($value, '__toString'));
+    }
+
+    private function checkAssociativeArray($value)
+    {
+        $isAssociative = false;
+
+        if (is_array($value)) {
+            $expectedIndex = 0;
+            $key = key($value);
+
+            do {
+                $isAssociative = $key !== $expectedIndex++;
+                next($value);
+                $key = key($value);
+            } while (!$isAssociative && null !== $key);
+        }
+
+        if (!$isAssociative) {
+            $this->addError('must be an associative array. Found '
+                . Aws\describe_type($value));
+            return false;
+        }
+
+        return true;
+    }
+
+    private function checkDocumentType($value)
+    {
+        if (is_array($value)) {
+            $typeOfFirstKey = gettype(key($value));
+            foreach ($value as $key => $val) {
+               if (!$this->checkDocumentType($val) || gettype($key) != $typeOfFirstKey) {
+                   return false;
+               }
+            }
+            return $this->checkArray($value);
+        }
+        return is_null($value)
+            || is_numeric($value)
+            || is_string($value)
+            || is_bool($value);
+    }
+
+    private function checkUnion($value)
+    {
+        if (is_array($value)) {
+            $nonNullCount = 0;
+            foreach ($value as $key => $val) {
+                if (!is_null($val) && !(strpos($key, "@") === 0)) {
+                    $nonNullCount++;
+                }
+            }
+            return $nonNullCount == 1;
+        }
+        return !is_null($value);
+    }
+
+    private function addError($message)
+    {
+        $this->errors[] =
+            implode('', array_map(function ($s) { return "[{$s}]"; }, $this->path))
+            . ' '
+            . $message;
+    }
+
+    private function canJsonEncode($data)
+    {
+        return !is_resource($data);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/ApiGateway/ApiGatewayClient.php ---
@@ -0,0 +1,272 @@
+<?php
+namespace Aws\ApiGateway;
+
+use Aws\AwsClient;
+use Aws\CommandInterface;
+use Psr\Http\Message\RequestInterface;
+
+/**
+ * This client is used to interact with the **AWS API Gateway** service.
+ *
+ * @method \Aws\Result createApiKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApiKeyAsync(array $args = [])
+ * @method \Aws\Result createAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAuthorizerAsync(array $args = [])
+ * @method \Aws\Result createBasePathMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBasePathMappingAsync(array $args = [])
+ * @method \Aws\Result createDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDeploymentAsync(array $args = [])
+ * @method \Aws\Result createDocumentationPart(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDocumentationPartAsync(array $args = [])
+ * @method \Aws\Result createDocumentationVersion(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDocumentationVersionAsync(array $args = [])
+ * @method \Aws\Result createDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDomainNameAsync(array $args = [])
+ * @method \Aws\Result createModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createModelAsync(array $args = [])
+ * @method \Aws\Result createRequestValidator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRequestValidatorAsync(array $args = [])
+ * @method \Aws\Result createResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createResourceAsync(array $args = [])
+ * @method \Aws\Result createRestApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRestApiAsync(array $args = [])
+ * @method \Aws\Result createStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createStageAsync(array $args = [])
+ * @method \Aws\Result createUsagePlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createUsagePlanAsync(array $args = [])
+ * @method \Aws\Result createUsagePlanKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createUsagePlanKeyAsync(array $args = [])
+ * @method \Aws\Result createVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createVpcLinkAsync(array $args = [])
+ * @method \Aws\Result deleteApiKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApiKeyAsync(array $args = [])
+ * @method \Aws\Result deleteAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAuthorizerAsync(array $args = [])
+ * @method \Aws\Result deleteBasePathMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBasePathMappingAsync(array $args = [])
+ * @method \Aws\Result deleteClientCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteClientCertificateAsync(array $args = [])
+ * @method \Aws\Result deleteDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDeploymentAsync(array $args = [])
+ * @method \Aws\Result deleteDocumentationPart(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDocumentationPartAsync(array $args = [])
+ * @method \Aws\Result deleteDocumentationVersion(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDocumentationVersionAsync(array $args = [])
+ * @method \Aws\Result deleteDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDomainNameAsync(array $args = [])
+ * @method \Aws\Result deleteGatewayResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteGatewayResponseAsync(array $args = [])
+ * @method \Aws\Result deleteIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteIntegrationAsync(array $args = [])
+ * @method \Aws\Result deleteIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result deleteMethod(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteMethodAsync(array $args = [])
+ * @method \Aws\Result deleteMethodResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteMethodResponseAsync(array $args = [])
+ * @method \Aws\Result deleteModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteModelAsync(array $args = [])
+ * @method \Aws\Result deleteRequestValidator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRequestValidatorAsync(array $args = [])
+ * @method \Aws\Result deleteResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteResourceAsync(array $args = [])
+ * @method \Aws\Result deleteRestApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRestApiAsync(array $args = [])
+ * @method \Aws\Result deleteStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteStageAsync(array $args = [])
+ * @method \Aws\Result deleteUsagePlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteUsagePlanAsync(array $args = [])
+ * @method \Aws\Result deleteUsagePlanKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteUsagePlanKeyAsync(array $args = [])
+ * @method \Aws\Result deleteVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVpcLinkAsync(array $args = [])
+ * @method \Aws\Result flushStageAuthorizersCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise flushStageAuthorizersCacheAsync(array $args = [])
+ * @method \Aws\Result flushStageCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise flushStageCacheAsync(array $args = [])
+ * @method \Aws\Result generateClientCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise generateClientCertificateAsync(array $args = [])
+ * @method \Aws\Result getAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAccountAsync(array $args = [])
+ * @method \Aws\Result getApiKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApiKeyAsync(array $args = [])
+ * @method \Aws\Result getApiKeys(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApiKeysAsync(array $args = [])
+ * @method \Aws\Result getAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAuthorizerAsync(array $args = [])
+ * @method \Aws\Result getAuthorizers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAuthorizersAsync(array $args = [])
+ * @method \Aws\Result getBasePathMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBasePathMappingAsync(array $args = [])
+ * @method \Aws\Result getBasePathMappings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBasePathMappingsAsync(array $args = [])
+ * @method \Aws\Result getClientCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getClientCertificateAsync(array $args = [])
+ * @method \Aws\Result getClientCertificates(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getClientCertificatesAsync(array $args = [])
+ * @method \Aws\Result getDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeploymentAsync(array $args = [])
+ * @method \Aws\Result getDeployments(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeploymentsAsync(array $args = [])
+ * @method \Aws\Result getDocumentationPart(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDocumentationPartAsync(array $args = [])
+ * @method \Aws\Result getDocumentationParts(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDocumentationPartsAsync(array $args = [])
+ * @method \Aws\Result getDocumentationVersion(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDocumentationVersionAsync(array $args = [])
+ * @method \Aws\Result getDocumentationVersions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDocumentationVersionsAsync(array $args = [])
+ * @method \Aws\Result getDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDomainNameAsync(array $args = [])
+ * @method \Aws\Result getDomainNames(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDomainNamesAsync(array $args = [])
+ * @method \Aws\Result getExport(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getExportAsync(array $args = [])
+ * @method \Aws\Result getGatewayResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getGatewayResponseAsync(array $args = [])
+ * @method \Aws\Result getGatewayResponses(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getGatewayResponsesAsync(array $args = [])
+ * @method \Aws\Result getIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getIntegrationAsync(array $args = [])
+ * @method \Aws\Result getIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result getMethod(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getMethodAsync(array $args = [])
+ * @method \Aws\Result getMethodResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getMethodResponseAsync(array $args = [])
+ * @method \Aws\Result getModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getModelAsync(array $args = [])
+ * @method \Aws\Result getModelTemplate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getModelTemplateAsync(array $args = [])
+ * @method \Aws\Result getModels(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getModelsAsync(array $args = [])
+ * @method \Aws\Result getRequestValidator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRequestValidatorAsync(array $args = [])
+ * @method \Aws\Result getRequestValidators(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRequestValidatorsAsync(array $args = [])
+ * @method \Aws\Result getResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getResourceAsync(array $args = [])
+ * @method \Aws\Result getResources(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getResourcesAsync(array $args = [])
+ * @method \Aws\Result getRestApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRestApiAsync(array $args = [])
+ * @method \Aws\Result getRestApis(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRestApisAsync(array $args = [])
+ * @method \Aws\Result getSdk(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSdkAsync(array $args = [])
+ * @method \Aws\Result getSdkType(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSdkTypeAsync(array $args = [])
+ * @method \Aws\Result getSdkTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSdkTypesAsync(array $args = [])
+ * @method \Aws\Result getStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getStageAsync(array $args = [])
+ * @method \Aws\Result getStages(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getStagesAsync(array $args = [])
+ * @method \Aws\Result getTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getTagsAsync(array $args = [])
+ * @method \Aws\Result getUsage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getUsageAsync(array $args = [])
+ * @method \Aws\Result getUsagePlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getUsagePlanAsync(array $args = [])
+ * @method \Aws\Result getUsagePlanKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getUsagePlanKeyAsync(array $args = [])
+ * @method \Aws\Result getUsagePlanKeys(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getUsagePlanKeysAsync(array $args = [])
+ * @method \Aws\Result getUsagePlans(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getUsagePlansAsync(array $args = [])
+ * @method \Aws\Result getVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVpcLinkAsync(array $args = [])
+ * @method \Aws\Result getVpcLinks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVpcLinksAsync(array $args = [])
+ * @method \Aws\Result importApiKeys(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importApiKeysAsync(array $args = [])
+ * @method \Aws\Result importDocumentationParts(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importDocumentationPartsAsync(array $args = [])
+ * @method \Aws\Result importRestApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importRestApiAsync(array $args = [])
+ * @method \Aws\Result putGatewayResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putGatewayResponseAsync(array $args = [])
+ * @method \Aws\Result putIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putIntegrationAsync(array $args = [])
+ * @method \Aws\Result putIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result putMethod(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putMethodAsync(array $args = [])
+ * @method \Aws\Result putMethodResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putMethodResponseAsync(array $args = [])
+ * @method \Aws\Result putRestApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putRestApiAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result testInvokeAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise testInvokeAuthorizerAsync(array $args = [])
+ * @method \Aws\Result testInvokeMethod(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise testInvokeMethodAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAccountAsync(array $args = [])
+ * @method \Aws\Result updateApiKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApiKeyAsync(array $args = [])
+ * @method \Aws\Result updateAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAuthorizerAsync(array $args = [])
+ * @method \Aws\Result updateBasePathMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBasePathMappingAsync(array $args = [])
+ * @method \Aws\Result updateClientCertificate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateClientCertificateAsync(array $args = [])
+ * @method \Aws\Result updateDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDeploymentAsync(array $args = [])
+ * @method \Aws\Result updateDocumentationPart(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDocumentationPartAsync(array $args = [])
+ * @method \Aws\Result updateDocumentationVersion(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDocumentationVersionAsync(array $args = [])
+ * @method \Aws\Result updateDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDomainNameAsync(array $args = [])
+ * @method \Aws\Result updateGatewayResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateGatewayResponseAsync(array $args = [])
+ * @method \Aws\Result updateIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateIntegrationAsync(array $args = [])
+ * @method \Aws\Result updateIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result updateMethod(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateMethodAsync(array $args = [])
+ * @method \Aws\Result updateMethodResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateMethodResponseAsync(array $args = [])
+ * @method \Aws\Result updateModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateModelAsync(array $args = [])
+ * @method \Aws\Result updateRequestValidator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRequestValidatorAsync(array $args = [])
+ * @method \Aws\Result updateResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateResourceAsync(array $args = [])
+ * @method \Aws\Result updateRestApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRestApiAsync(array $args = [])
+ * @method \Aws\Result updateStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateStageAsync(array $args = [])
+ * @method \Aws\Result updateUsage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateUsageAsync(array $args = [])
+ * @method \Aws\Result updateUsagePlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateUsagePlanAsync(array $args = [])
+ * @method \Aws\Result updateVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateVpcLinkAsync(array $args = [])
+ */
+class ApiGatewayClient extends AwsClient
+{
+    public function __construct(array $args)
+    {
+        parent::__construct($args);
+        $stack = $this->getHandlerList();
+        $stack->appendBuild([__CLASS__, '_add_accept_header']);
+    }
+
+    public static function _add_accept_header(callable $handler)
+    {
+        return function (
+            CommandInterface $command,
+            RequestInterface $request
+        ) use ($handler) {
+            $request = $request->withHeader('Accept', 'application/json');
+
+            return $handler($command, $request);
+        };
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/ApiGateway/Exception/ApiGatewayException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ApiGateway\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS API Gateway** service.
+ */
+class ApiGatewayException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ApiGatewayManagementApi/ApiGatewayManagementApiClient.php ---
@@ -0,0 +1,15 @@
+<?php
+namespace Aws\ApiGatewayManagementApi;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AmazonApiGatewayManagementApi** service.
+ * @method \Aws\Result deleteConnection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteConnectionAsync(array $args = [])
+ * @method \Aws\Result getConnection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getConnectionAsync(array $args = [])
+ * @method \Aws\Result postToConnection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise postToConnectionAsync(array $args = [])
+ */
+class ApiGatewayManagementApiClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ApiGatewayManagementApi/Exception/ApiGatewayManagementApiException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ApiGatewayManagementApi\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AmazonApiGatewayManagementApi** service.
+ */
+class ApiGatewayManagementApiException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ApiGatewayV2/ApiGatewayV2Client.php ---
@@ -0,0 +1,153 @@
+<?php
+namespace Aws\ApiGatewayV2;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AmazonApiGatewayV2** service.
+ * @method \Aws\Result createApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApiAsync(array $args = [])
+ * @method \Aws\Result createApiMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApiMappingAsync(array $args = [])
+ * @method \Aws\Result createAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAuthorizerAsync(array $args = [])
+ * @method \Aws\Result createDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDeploymentAsync(array $args = [])
+ * @method \Aws\Result createDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDomainNameAsync(array $args = [])
+ * @method \Aws\Result createIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createIntegrationAsync(array $args = [])
+ * @method \Aws\Result createIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result createModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createModelAsync(array $args = [])
+ * @method \Aws\Result createRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRouteAsync(array $args = [])
+ * @method \Aws\Result createRouteResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRouteResponseAsync(array $args = [])
+ * @method \Aws\Result createStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createStageAsync(array $args = [])
+ * @method \Aws\Result createVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createVpcLinkAsync(array $args = [])
+ * @method \Aws\Result deleteAccessLogSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAccessLogSettingsAsync(array $args = [])
+ * @method \Aws\Result deleteApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApiAsync(array $args = [])
+ * @method \Aws\Result deleteApiMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApiMappingAsync(array $args = [])
+ * @method \Aws\Result deleteAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAuthorizerAsync(array $args = [])
+ * @method \Aws\Result deleteCorsConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteCorsConfigurationAsync(array $args = [])
+ * @method \Aws\Result deleteDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDeploymentAsync(array $args = [])
+ * @method \Aws\Result deleteDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDomainNameAsync(array $args = [])
+ * @method \Aws\Result deleteIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteIntegrationAsync(array $args = [])
+ * @method \Aws\Result deleteIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result deleteModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteModelAsync(array $args = [])
+ * @method \Aws\Result deleteRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRouteAsync(array $args = [])
+ * @method \Aws\Result deleteRouteRequestParameter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRouteRequestParameterAsync(array $args = [])
+ * @method \Aws\Result deleteRouteResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRouteResponseAsync(array $args = [])
+ * @method \Aws\Result deleteRouteSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRouteSettingsAsync(array $args = [])
+ * @method \Aws\Result deleteStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteStageAsync(array $args = [])
+ * @method \Aws\Result deleteVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVpcLinkAsync(array $args = [])
+ * @method \Aws\Result exportApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exportApiAsync(array $args = [])
+ * @method \Aws\Result resetAuthorizersCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise resetAuthorizersCacheAsync(array $args = [])
+ * @method \Aws\Result getApiResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApiResourceAsync(array $args = [])
+ * @method \Aws\Result getApiMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApiMappingAsync(array $args = [])
+ * @method \Aws\Result getApiMappings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApiMappingsAsync(array $args = [])
+ * @method \Aws\Result getApis(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApisAsync(array $args = [])
+ * @method \Aws\Result getAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAuthorizerAsync(array $args = [])
+ * @method \Aws\Result getAuthorizers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAuthorizersAsync(array $args = [])
+ * @method \Aws\Result getDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeploymentAsync(array $args = [])
+ * @method \Aws\Result getDeployments(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeploymentsAsync(array $args = [])
+ * @method \Aws\Result getDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDomainNameAsync(array $args = [])
+ * @method \Aws\Result getDomainNames(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDomainNamesAsync(array $args = [])
+ * @method \Aws\Result getIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getIntegrationAsync(array $args = [])
+ * @method \Aws\Result getIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result getIntegrationResponses(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getIntegrationResponsesAsync(array $args = [])
+ * @method \Aws\Result getIntegrations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getIntegrationsAsync(array $args = [])
+ * @method \Aws\Result getModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getModelAsync(array $args = [])
+ * @method \Aws\Result getModelTemplate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getModelTemplateAsync(array $args = [])
+ * @method \Aws\Result getModels(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getModelsAsync(array $args = [])
+ * @method \Aws\Result getRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRouteAsync(array $args = [])
+ * @method \Aws\Result getRouteResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRouteResponseAsync(array $args = [])
+ * @method \Aws\Result getRouteResponses(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRouteResponsesAsync(array $args = [])
+ * @method \Aws\Result getRoutes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRoutesAsync(array $args = [])
+ * @method \Aws\Result getStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getStageAsync(array $args = [])
+ * @method \Aws\Result getStages(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getStagesAsync(array $args = [])
+ * @method \Aws\Result getTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getTagsAsync(array $args = [])
+ * @method \Aws\Result getVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVpcLinkAsync(array $args = [])
+ * @method \Aws\Result getVpcLinks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVpcLinksAsync(array $args = [])
+ * @method \Aws\Result importApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importApiAsync(array $args = [])
+ * @method \Aws\Result reimportApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise reimportApiAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApiAsync(array $args = [])
+ * @method \Aws\Result updateApiMapping(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApiMappingAsync(array $args = [])
+ * @method \Aws\Result updateAuthorizer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAuthorizerAsync(array $args = [])
+ * @method \Aws\Result updateDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDeploymentAsync(array $args = [])
+ * @method \Aws\Result updateDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDomainNameAsync(array $args = [])
+ * @method \Aws\Result updateIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateIntegrationAsync(array $args = [])
+ * @method \Aws\Result updateIntegrationResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateIntegrationResponseAsync(array $args = [])
+ * @method \Aws\Result updateModel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateModelAsync(array $args = [])
+ * @method \Aws\Result updateRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRouteAsync(array $args = [])
+ * @method \Aws\Result updateRouteResponse(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRouteResponseAsync(array $args = [])
+ * @method \Aws\Result updateStage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateStageAsync(array $args = [])
+ * @method \Aws\Result updateVpcLink(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateVpcLinkAsync(array $args = [])
+ */
+class ApiGatewayV2Client extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ApiGatewayV2/Exception/ApiGatewayV2Exception.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ApiGatewayV2\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AmazonApiGatewayV2** service.
+ */
+class ApiGatewayV2Exception extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AppConfig/AppConfigClient.php ---
@@ -0,0 +1,75 @@
+<?php
+namespace Aws\AppConfig;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon AppConfig** service.
+ * @method \Aws\Result createApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApplicationAsync(array $args = [])
+ * @method \Aws\Result createConfigurationProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createConfigurationProfileAsync(array $args = [])
+ * @method \Aws\Result createDeploymentStrategy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDeploymentStrategyAsync(array $args = [])
+ * @method \Aws\Result createEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createEnvironmentAsync(array $args = [])
+ * @method \Aws\Result createHostedConfigurationVersion(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createHostedConfigurationVersionAsync(array $args = [])
+ * @method \Aws\Result deleteApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApplicationAsync(array $args = [])
+ * @method \Aws\Result deleteConfigurationProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteConfigurationProfileAsync(array $args = [])
+ * @method \Aws\Result deleteDeploymentStrategy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDeploymentStrategyAsync(array $args = [])
+ * @method \Aws\Result deleteEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteEnvironmentAsync(array $args = [])
+ * @method \Aws\Result deleteHostedConfigurationVersion(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteHostedConfigurationVersionAsync(array $args = [])
+ * @method \Aws\Result getApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApplicationAsync(array $args = [])
+ * @method \Aws\Result getConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getConfigurationAsync(array $args = [])
+ * @method \Aws\Result getConfigurationProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getConfigurationProfileAsync(array $args = [])
+ * @method \Aws\Result getDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeploymentAsync(array $args = [])
+ * @method \Aws\Result getDeploymentStrategy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeploymentStrategyAsync(array $args = [])
+ * @method \Aws\Result getEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEnvironmentAsync(array $args = [])
+ * @method \Aws\Result getHostedConfigurationVersion(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getHostedConfigurationVersionAsync(array $args = [])
+ * @method \Aws\Result listApplications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listApplicationsAsync(array $args = [])
+ * @method \Aws\Result listConfigurationProfiles(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listConfigurationProfilesAsync(array $args = [])
+ * @method \Aws\Result listDeploymentStrategies(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDeploymentStrategiesAsync(array $args = [])
+ * @method \Aws\Result listDeployments(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDeploymentsAsync(array $args = [])
+ * @method \Aws\Result listEnvironments(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listEnvironmentsAsync(array $args = [])
+ * @method \Aws\Result listHostedConfigurationVersions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listHostedConfigurationVersionsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result startDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startDeploymentAsync(array $args = [])
+ * @method \Aws\Result stopDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopDeploymentAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApplicationAsync(array $args = [])
+ * @method \Aws\Result updateConfigurationProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateConfigurationProfileAsync(array $args = [])
+ * @method \Aws\Result updateDeploymentStrategy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDeploymentStrategyAsync(array $args = [])
+ * @method \Aws\Result updateEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateEnvironmentAsync(array $args = [])
+ * @method \Aws\Result validateConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise validateConfigurationAsync(array $args = [])
+ */
+class AppConfigClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AppConfig/Exception/AppConfigException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AppConfig\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon AppConfig** service.
+ */
+class AppConfigException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AppConfigData/AppConfigDataClient.php ---
@@ -0,0 +1,13 @@
+<?php
+namespace Aws\AppConfigData;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS AppConfig Data** service.
+ * @method \Aws\Result getLatestConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getLatestConfigurationAsync(array $args = [])
+ * @method \Aws\Result startConfigurationSession(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startConfigurationSessionAsync(array $args = [])
+ */
+class AppConfigDataClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AppConfigData/Exception/AppConfigDataException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AppConfigData\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS AppConfig Data** service.
+ */
+class AppConfigDataException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AppIntegrationsService/AppIntegrationsServiceClient.php ---
@@ -0,0 +1,39 @@
+<?php
+namespace Aws\AppIntegrationsService;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon AppIntegrations Service** service.
+ * @method \Aws\Result createDataIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDataIntegrationAsync(array $args = [])
+ * @method \Aws\Result createEventIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createEventIntegrationAsync(array $args = [])
+ * @method \Aws\Result deleteDataIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDataIntegrationAsync(array $args = [])
+ * @method \Aws\Result deleteEventIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteEventIntegrationAsync(array $args = [])
+ * @method \Aws\Result getDataIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDataIntegrationAsync(array $args = [])
+ * @method \Aws\Result getEventIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEventIntegrationAsync(array $args = [])
+ * @method \Aws\Result listDataIntegrationAssociations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDataIntegrationAssociationsAsync(array $args = [])
+ * @method \Aws\Result listDataIntegrations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDataIntegrationsAsync(array $args = [])
+ * @method \Aws\Result listEventIntegrationAssociations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listEventIntegrationAssociationsAsync(array $args = [])
+ * @method \Aws\Result listEventIntegrations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listEventIntegrationsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateDataIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDataIntegrationAsync(array $args = [])
+ * @method \Aws\Result updateEventIntegration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateEventIntegrationAsync(array $args = [])
+ */
+class AppIntegrationsServiceClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AppIntegrationsService/Exception/AppIntegrationsServiceException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AppIntegrationsService\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon AppIntegrations Service** service.
+ */
+class AppIntegrationsServiceException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AppMesh/AppMeshClient.php ---
@@ -0,0 +1,85 @@
+<?php
+namespace Aws\AppMesh;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS App Mesh** service.
+ * @method \Aws\Result createMesh(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createMeshAsync(array $args = [])
+ * @method \Aws\Result createRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRouteAsync(array $args = [])
+ * @method \Aws\Result createVirtualNode(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createVirtualNodeAsync(array $args = [])
+ * @method \Aws\Result createVirtualRouter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createVirtualRouterAsync(array $args = [])
+ * @method \Aws\Result deleteMesh(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteMeshAsync(array $args = [])
+ * @method \Aws\Result deleteRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRouteAsync(array $args = [])
+ * @method \Aws\Result deleteVirtualNode(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVirtualNodeAsync(array $args = [])
+ * @method \Aws\Result deleteVirtualRouter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVirtualRouterAsync(array $args = [])
+ * @method \Aws\Result describeMesh(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeMeshAsync(array $args = [])
+ * @method \Aws\Result describeRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeRouteAsync(array $args = [])
+ * @method \Aws\Result describeVirtualNode(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeVirtualNodeAsync(array $args = [])
+ * @method \Aws\Result describeVirtualRouter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeVirtualRouterAsync(array $args = [])
+ * @method \Aws\Result listMeshes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listMeshesAsync(array $args = [])
+ * @method \Aws\Result listRoutes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listRoutesAsync(array $args = [])
+ * @method \Aws\Result listVirtualNodes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listVirtualNodesAsync(array $args = [])
+ * @method \Aws\Result listVirtualRouters(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listVirtualRoutersAsync(array $args = [])
+ * @method \Aws\Result updateRoute(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRouteAsync(array $args = [])
+ * @method \Aws\Result updateVirtualNode(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateVirtualNodeAsync(array $args = [])
+ * @method \Aws\Result updateVirtualRouter(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateVirtualRouterAsync(array $args = [])
+ * @method \Aws\Result createGatewayRoute(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise createGatewayRouteAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result createVirtualGateway(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise createVirtualGatewayAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result createVirtualService(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise createVirtualServiceAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result deleteGatewayRoute(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise deleteGatewayRouteAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result deleteVirtualGateway(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise deleteVirtualGatewayAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result deleteVirtualService(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise deleteVirtualServiceAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result describeGatewayRoute(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise describeGatewayRouteAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result describeVirtualGateway(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise describeVirtualGatewayAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result describeVirtualService(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise describeVirtualServiceAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result listGatewayRoutes(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise listGatewayRoutesAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result listTagsForResource(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result listVirtualGateways(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise listVirtualGatewaysAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result listVirtualServices(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise listVirtualServicesAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result tagResource(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result untagResource(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result updateGatewayRoute(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise updateGatewayRouteAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result updateMesh(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise updateMeshAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result updateVirtualGateway(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise updateVirtualGatewayAsync(array $args = []) (supported in versions 2019-01-25)
+ * @method \Aws\Result updateVirtualService(array $args = []) (supported in versions 2019-01-25)
+ * @method \GuzzleHttp\Promise\Promise updateVirtualServiceAsync(array $args = []) (supported in versions 2019-01-25)
+ */
+class AppMeshClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AppMesh/Exception/AppMeshException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AppMesh\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS App Mesh** service.
+ */
+class AppMeshException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AppRegistry/AppRegistryClient.php ---
@@ -0,0 +1,51 @@
+<?php
+namespace Aws\AppRegistry;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Service Catalog App Registry** service.
+ * @method \Aws\Result associateAttributeGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateAttributeGroupAsync(array $args = [])
+ * @method \Aws\Result associateResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateResourceAsync(array $args = [])
+ * @method \Aws\Result createApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApplicationAsync(array $args = [])
+ * @method \Aws\Result createAttributeGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAttributeGroupAsync(array $args = [])
+ * @method \Aws\Result deleteApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApplicationAsync(array $args = [])
+ * @method \Aws\Result deleteAttributeGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAttributeGroupAsync(array $args = [])
+ * @method \Aws\Result disassociateAttributeGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateAttributeGroupAsync(array $args = [])
+ * @method \Aws\Result disassociateResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateResourceAsync(array $args = [])
+ * @method \Aws\Result getApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApplicationAsync(array $args = [])
+ * @method \Aws\Result getAssociatedResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAssociatedResourceAsync(array $args = [])
+ * @method \Aws\Result getAttributeGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAttributeGroupAsync(array $args = [])
+ * @method \Aws\Result listApplications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listApplicationsAsync(array $args = [])
+ * @method \Aws\Result listAssociatedAttributeGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssociatedAttributeGroupsAsync(array $args = [])
+ * @method \Aws\Result listAssociatedResources(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssociatedResourcesAsync(array $args = [])
+ * @method \Aws\Result listAttributeGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAttributeGroupsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result syncResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise syncResourceAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApplicationAsync(array $args = [])
+ * @method \Aws\Result updateAttributeGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAttributeGroupAsync(array $args = [])
+ */
+class AppRegistryClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AppRegistry/Exception/AppRegistryException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AppRegistry\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Service Catalog App Registry** service.
+ */
+class AppRegistryException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AppRunner/AppRunnerClient.php ---
@@ -0,0 +1,53 @@
+<?php
+namespace Aws\AppRunner;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS App Runner** service.
+ * @method \Aws\Result associateCustomDomain(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateCustomDomainAsync(array $args = [])
+ * @method \Aws\Result createAutoScalingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAutoScalingConfigurationAsync(array $args = [])
+ * @method \Aws\Result createConnection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createConnectionAsync(array $args = [])
+ * @method \Aws\Result createService(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createServiceAsync(array $args = [])
+ * @method \Aws\Result deleteAutoScalingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAutoScalingConfigurationAsync(array $args = [])
+ * @method \Aws\Result deleteConnection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteConnectionAsync(array $args = [])
+ * @method \Aws\Result deleteService(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteServiceAsync(array $args = [])
+ * @method \Aws\Result describeAutoScalingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAutoScalingConfigurationAsync(array $args = [])
+ * @method \Aws\Result describeCustomDomains(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeCustomDomainsAsync(array $args = [])
+ * @method \Aws\Result describeService(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeServiceAsync(array $args = [])
+ * @method \Aws\Result disassociateCustomDomain(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateCustomDomainAsync(array $args = [])
+ * @method \Aws\Result listAutoScalingConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAutoScalingConfigurationsAsync(array $args = [])
+ * @method \Aws\Result listConnections(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listConnectionsAsync(array $args = [])
+ * @method \Aws\Result listOperations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listOperationsAsync(array $args = [])
+ * @method \Aws\Result listServices(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listServicesAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result pauseService(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise pauseServiceAsync(array $args = [])
+ * @method \Aws\Result resumeService(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise resumeServiceAsync(array $args = [])
+ * @method \Aws\Result startDeployment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startDeploymentAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateService(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateServiceAsync(array $args = [])
+ */
+class AppRunnerClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AppRunner/Exception/AppRunnerException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AppRunner\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS App Runner** service.
+ */
+class AppRunnerException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AppSync/AppSyncClient.php ---
@@ -0,0 +1,107 @@
+<?php
+namespace Aws\AppSync;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS AppSync** service.
+ * @method \Aws\Result associateApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateApiAsync(array $args = [])
+ * @method \Aws\Result createApiCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApiCacheAsync(array $args = [])
+ * @method \Aws\Result createApiKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApiKeyAsync(array $args = [])
+ * @method \Aws\Result createDataSource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDataSourceAsync(array $args = [])
+ * @method \Aws\Result createDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDomainNameAsync(array $args = [])
+ * @method \Aws\Result createFunction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createFunctionAsync(array $args = [])
+ * @method \Aws\Result createGraphqlApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createGraphqlApiAsync(array $args = [])
+ * @method \Aws\Result createResolver(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createResolverAsync(array $args = [])
+ * @method \Aws\Result createType(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createTypeAsync(array $args = [])
+ * @method \Aws\Result deleteApiCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApiCacheAsync(array $args = [])
+ * @method \Aws\Result deleteApiKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApiKeyAsync(array $args = [])
+ * @method \Aws\Result deleteDataSource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDataSourceAsync(array $args = [])
+ * @method \Aws\Result deleteDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDomainNameAsync(array $args = [])
+ * @method \Aws\Result deleteFunction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteFunctionAsync(array $args = [])
+ * @method \Aws\Result deleteGraphqlApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteGraphqlApiAsync(array $args = [])
+ * @method \Aws\Result deleteResolver(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteResolverAsync(array $args = [])
+ * @method \Aws\Result deleteType(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteTypeAsync(array $args = [])
+ * @method \Aws\Result disassociateApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateApiAsync(array $args = [])
+ * @method \Aws\Result flushApiCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise flushApiCacheAsync(array $args = [])
+ * @method \Aws\Result getApiAssociation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApiAssociationAsync(array $args = [])
+ * @method \Aws\Result getApiCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getApiCacheAsync(array $args = [])
+ * @method \Aws\Result getDataSource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDataSourceAsync(array $args = [])
+ * @method \Aws\Result getDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDomainNameAsync(array $args = [])
+ * @method \Aws\Result getFunction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getFunctionAsync(array $args = [])
+ * @method \Aws\Result getGraphqlApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getGraphqlApiAsync(array $args = [])
+ * @method \Aws\Result getIntrospectionSchema(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getIntrospectionSchemaAsync(array $args = [])
+ * @method \Aws\Result getResolver(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getResolverAsync(array $args = [])
+ * @method \Aws\Result getSchemaCreationStatus(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSchemaCreationStatusAsync(array $args = [])
+ * @method \Aws\Result getType(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getTypeAsync(array $args = [])
+ * @method \Aws\Result listApiKeys(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listApiKeysAsync(array $args = [])
+ * @method \Aws\Result listDataSources(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDataSourcesAsync(array $args = [])
+ * @method \Aws\Result listDomainNames(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDomainNamesAsync(array $args = [])
+ * @method \Aws\Result listFunctions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listFunctionsAsync(array $args = [])
+ * @method \Aws\Result listGraphqlApis(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listGraphqlApisAsync(array $args = [])
+ * @method \Aws\Result listResolvers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listResolversAsync(array $args = [])
+ * @method \Aws\Result listResolversByFunction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listResolversByFunctionAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result listTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTypesAsync(array $args = [])
+ * @method \Aws\Result startSchemaCreation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startSchemaCreationAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateApiCache(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApiCacheAsync(array $args = [])
+ * @method \Aws\Result updateApiKey(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApiKeyAsync(array $args = [])
+ * @method \Aws\Result updateDataSource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDataSourceAsync(array $args = [])
+ * @method \Aws\Result updateDomainName(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDomainNameAsync(array $args = [])
+ * @method \Aws\Result updateFunction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateFunctionAsync(array $args = [])
+ * @method \Aws\Result updateGraphqlApi(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateGraphqlApiAsync(array $args = [])
+ * @method \Aws\Result updateResolver(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateResolverAsync(array $args = [])
+ * @method \Aws\Result updateType(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateTypeAsync(array $args = [])
+ */
+class AppSyncClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AppSync/Exception/AppSyncException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AppSync\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS AppSync** service.
+ */
+class AppSyncException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Appflow/AppflowClient.php ---
@@ -0,0 +1,45 @@
+<?php
+namespace Aws\Appflow;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon Appflow** service.
+ * @method \Aws\Result createConnectorProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createConnectorProfileAsync(array $args = [])
+ * @method \Aws\Result createFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createFlowAsync(array $args = [])
+ * @method \Aws\Result deleteConnectorProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteConnectorProfileAsync(array $args = [])
+ * @method \Aws\Result deleteFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteFlowAsync(array $args = [])
+ * @method \Aws\Result describeConnectorEntity(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeConnectorEntityAsync(array $args = [])
+ * @method \Aws\Result describeConnectorProfiles(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeConnectorProfilesAsync(array $args = [])
+ * @method \Aws\Result describeConnectors(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeConnectorsAsync(array $args = [])
+ * @method \Aws\Result describeFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeFlowAsync(array $args = [])
+ * @method \Aws\Result describeFlowExecutionRecords(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeFlowExecutionRecordsAsync(array $args = [])
+ * @method \Aws\Result listConnectorEntities(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listConnectorEntitiesAsync(array $args = [])
+ * @method \Aws\Result listFlows(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listFlowsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result startFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startFlowAsync(array $args = [])
+ * @method \Aws\Result stopFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopFlowAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateConnectorProfile(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateConnectorProfileAsync(array $args = [])
+ * @method \Aws\Result updateFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateFlowAsync(array $args = [])
+ */
+class AppflowClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Appflow/Exception/AppflowException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Appflow\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon Appflow** service.
+ */
+class AppflowException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationAutoScaling/ApplicationAutoScalingClient.php ---
@@ -0,0 +1,29 @@
+<?php
+namespace Aws\ApplicationAutoScaling;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Application Auto Scaling** service.
+ * @method \Aws\Result deleteScalingPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteScalingPolicyAsync(array $args = [])
+ * @method \Aws\Result deleteScheduledAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteScheduledActionAsync(array $args = [])
+ * @method \Aws\Result deregisterScalableTarget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deregisterScalableTargetAsync(array $args = [])
+ * @method \Aws\Result describeScalableTargets(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScalableTargetsAsync(array $args = [])
+ * @method \Aws\Result describeScalingActivities(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScalingActivitiesAsync(array $args = [])
+ * @method \Aws\Result describeScalingPolicies(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScalingPoliciesAsync(array $args = [])
+ * @method \Aws\Result describeScheduledActions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScheduledActionsAsync(array $args = [])
+ * @method \Aws\Result putScalingPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putScalingPolicyAsync(array $args = [])
+ * @method \Aws\Result putScheduledAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putScheduledActionAsync(array $args = [])
+ * @method \Aws\Result registerScalableTarget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise registerScalableTargetAsync(array $args = [])
+ */
+class ApplicationAutoScalingClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationAutoScaling/Exception/ApplicationAutoScalingException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ApplicationAutoScaling\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Application Auto Scaling** service.
+ */
+class ApplicationAutoScalingException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationCostProfiler/ApplicationCostProfilerClient.php ---
@@ -0,0 +1,21 @@
+<?php
+namespace Aws\ApplicationCostProfiler;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Application Cost Profiler** service.
+ * @method \Aws\Result deleteReportDefinition(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteReportDefinitionAsync(array $args = [])
+ * @method \Aws\Result getReportDefinition(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getReportDefinitionAsync(array $args = [])
+ * @method \Aws\Result importApplicationUsage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importApplicationUsageAsync(array $args = [])
+ * @method \Aws\Result listReportDefinitions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listReportDefinitionsAsync(array $args = [])
+ * @method \Aws\Result putReportDefinition(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putReportDefinitionAsync(array $args = [])
+ * @method \Aws\Result updateReportDefinition(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateReportDefinitionAsync(array $args = [])
+ */
+class ApplicationCostProfilerClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationCostProfiler/Exception/ApplicationCostProfilerException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ApplicationCostProfiler\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Application Cost Profiler** service.
+ */
+class ApplicationCostProfilerException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationDiscoveryService/ApplicationDiscoveryServiceClient.php ---
@@ -0,0 +1,59 @@
+<?php
+namespace Aws\ApplicationDiscoveryService;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Application Discovery Service** service.
+ * @method \Aws\Result associateConfigurationItemsToApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateConfigurationItemsToApplicationAsync(array $args = [])
+ * @method \Aws\Result batchDeleteImportData(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchDeleteImportDataAsync(array $args = [])
+ * @method \Aws\Result createApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApplicationAsync(array $args = [])
+ * @method \Aws\Result createTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createTagsAsync(array $args = [])
+ * @method \Aws\Result deleteApplications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApplicationsAsync(array $args = [])
+ * @method \Aws\Result deleteTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteTagsAsync(array $args = [])
+ * @method \Aws\Result describeAgents(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAgentsAsync(array $args = [])
+ * @method \Aws\Result describeConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeConfigurationsAsync(array $args = [])
+ * @method \Aws\Result describeContinuousExports(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeContinuousExportsAsync(array $args = [])
+ * @method \Aws\Result describeExportConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeExportConfigurationsAsync(array $args = [])
+ * @method \Aws\Result describeExportTasks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeExportTasksAsync(array $args = [])
+ * @method \Aws\Result describeImportTasks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeImportTasksAsync(array $args = [])
+ * @method \Aws\Result describeTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeTagsAsync(array $args = [])
+ * @method \Aws\Result disassociateConfigurationItemsFromApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateConfigurationItemsFromApplicationAsync(array $args = [])
+ * @method \Aws\Result exportConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exportConfigurationsAsync(array $args = [])
+ * @method \Aws\Result getDiscoverySummary(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDiscoverySummaryAsync(array $args = [])
+ * @method \Aws\Result listConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listConfigurationsAsync(array $args = [])
+ * @method \Aws\Result listServerNeighbors(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listServerNeighborsAsync(array $args = [])
+ * @method \Aws\Result startContinuousExport(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startContinuousExportAsync(array $args = [])
+ * @method \Aws\Result startDataCollectionByAgentIds(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startDataCollectionByAgentIdsAsync(array $args = [])
+ * @method \Aws\Result startExportTask(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startExportTaskAsync(array $args = [])
+ * @method \Aws\Result startImportTask(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startImportTaskAsync(array $args = [])
+ * @method \Aws\Result stopContinuousExport(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopContinuousExportAsync(array $args = [])
+ * @method \Aws\Result stopDataCollectionByAgentIds(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopDataCollectionByAgentIdsAsync(array $args = [])
+ * @method \Aws\Result updateApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApplicationAsync(array $args = [])
+ */
+class ApplicationDiscoveryServiceClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationDiscoveryService/Exception/ApplicationDiscoveryServiceException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ApplicationDiscoveryService\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Application Discovery Service** service.
+ */
+class ApplicationDiscoveryServiceException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationInsights/ApplicationInsightsClient.php ---
@@ -0,0 +1,63 @@
+<?php
+namespace Aws\ApplicationInsights;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon CloudWatch Application Insights** service.
+ * @method \Aws\Result createApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApplicationAsync(array $args = [])
+ * @method \Aws\Result createComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createComponentAsync(array $args = [])
+ * @method \Aws\Result createLogPattern(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createLogPatternAsync(array $args = [])
+ * @method \Aws\Result deleteApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApplicationAsync(array $args = [])
+ * @method \Aws\Result deleteComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteComponentAsync(array $args = [])
+ * @method \Aws\Result deleteLogPattern(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteLogPatternAsync(array $args = [])
+ * @method \Aws\Result describeApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeApplicationAsync(array $args = [])
+ * @method \Aws\Result describeComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeComponentAsync(array $args = [])
+ * @method \Aws\Result describeComponentConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeComponentConfigurationAsync(array $args = [])
+ * @method \Aws\Result describeComponentConfigurationRecommendation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeComponentConfigurationRecommendationAsync(array $args = [])
+ * @method \Aws\Result describeLogPattern(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeLogPatternAsync(array $args = [])
+ * @method \Aws\Result describeObservation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeObservationAsync(array $args = [])
+ * @method \Aws\Result describeProblem(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeProblemAsync(array $args = [])
+ * @method \Aws\Result describeProblemObservations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeProblemObservationsAsync(array $args = [])
+ * @method \Aws\Result listApplications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listApplicationsAsync(array $args = [])
+ * @method \Aws\Result listComponents(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listComponentsAsync(array $args = [])
+ * @method \Aws\Result listConfigurationHistory(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listConfigurationHistoryAsync(array $args = [])
+ * @method \Aws\Result listLogPatternSets(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listLogPatternSetsAsync(array $args = [])
+ * @method \Aws\Result listLogPatterns(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listLogPatternsAsync(array $args = [])
+ * @method \Aws\Result listProblems(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listProblemsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApplicationAsync(array $args = [])
+ * @method \Aws\Result updateComponent(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateComponentAsync(array $args = [])
+ * @method \Aws\Result updateComponentConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateComponentConfigurationAsync(array $args = [])
+ * @method \Aws\Result updateLogPattern(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateLogPatternAsync(array $args = [])
+ */
+class ApplicationInsightsClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ApplicationInsights/Exception/ApplicationInsightsException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ApplicationInsights\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon CloudWatch Application Insights** service.
+ */
+class ApplicationInsightsException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Appstream/AppstreamClient.php ---
@@ -0,0 +1,125 @@
+<?php
+namespace Aws\Appstream;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon AppStream** service.
+ * @method \Aws\Result associateApplicationFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateApplicationFleetAsync(array $args = [])
+ * @method \Aws\Result associateFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateFleetAsync(array $args = [])
+ * @method \Aws\Result batchAssociateUserStack(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchAssociateUserStackAsync(array $args = [])
+ * @method \Aws\Result batchDisassociateUserStack(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchDisassociateUserStackAsync(array $args = [])
+ * @method \Aws\Result copyImage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise copyImageAsync(array $args = [])
+ * @method \Aws\Result createAppBlock(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppBlockAsync(array $args = [])
+ * @method \Aws\Result createApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createApplicationAsync(array $args = [])
+ * @method \Aws\Result createDirectoryConfig(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDirectoryConfigAsync(array $args = [])
+ * @method \Aws\Result createFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createFleetAsync(array $args = [])
+ * @method \Aws\Result createImageBuilder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createImageBuilderAsync(array $args = [])
+ * @method \Aws\Result createImageBuilderStreamingURL(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createImageBuilderStreamingURLAsync(array $args = [])
+ * @method \Aws\Result createStack(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createStackAsync(array $args = [])
+ * @method \Aws\Result createStreamingURL(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createStreamingURLAsync(array $args = [])
+ * @method \Aws\Result createUpdatedImage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createUpdatedImageAsync(array $args = [])
+ * @method \Aws\Result createUsageReportSubscription(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createUsageReportSubscriptionAsync(array $args = [])
+ * @method \Aws\Result createUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createUserAsync(array $args = [])
+ * @method \Aws\Result deleteAppBlock(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppBlockAsync(array $args = [])
+ * @method \Aws\Result deleteApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteApplicationAsync(array $args = [])
+ * @method \Aws\Result deleteDirectoryConfig(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDirectoryConfigAsync(array $args = [])
+ * @method \Aws\Result deleteFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteFleetAsync(array $args = [])
+ * @method \Aws\Result deleteImage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteImageAsync(array $args = [])
+ * @method \Aws\Result deleteImageBuilder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteImageBuilderAsync(array $args = [])
+ * @method \Aws\Result deleteImagePermissions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteImagePermissionsAsync(array $args = [])
+ * @method \Aws\Result deleteStack(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteStackAsync(array $args = [])
+ * @method \Aws\Result deleteUsageReportSubscription(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteUsageReportSubscriptionAsync(array $args = [])
+ * @method \Aws\Result deleteUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteUserAsync(array $args = [])
+ * @method \Aws\Result describeAppBlocks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppBlocksAsync(array $args = [])
+ * @method \Aws\Result describeApplicationFleetAssociations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeApplicationFleetAssociationsAsync(array $args = [])
+ * @method \Aws\Result describeApplications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeApplicationsAsync(array $args = [])
+ * @method \Aws\Result describeDirectoryConfigs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeDirectoryConfigsAsync(array $args = [])
+ * @method \Aws\Result describeFleets(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeFleetsAsync(array $args = [])
+ * @method \Aws\Result describeImageBuilders(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeImageBuildersAsync(array $args = [])
+ * @method \Aws\Result describeImagePermissions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeImagePermissionsAsync(array $args = [])
+ * @method \Aws\Result describeImages(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeImagesAsync(array $args = [])
+ * @method \Aws\Result describeSessions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeSessionsAsync(array $args = [])
+ * @method \Aws\Result describeStacks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeStacksAsync(array $args = [])
+ * @method \Aws\Result describeUsageReportSubscriptions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeUsageReportSubscriptionsAsync(array $args = [])
+ * @method \Aws\Result describeUserStackAssociations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeUserStackAssociationsAsync(array $args = [])
+ * @method \Aws\Result describeUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeUsersAsync(array $args = [])
+ * @method \Aws\Result disableUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disableUserAsync(array $args = [])
+ * @method \Aws\Result disassociateApplicationFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateApplicationFleetAsync(array $args = [])
+ * @method \Aws\Result disassociateFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateFleetAsync(array $args = [])
+ * @method \Aws\Result enableUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise enableUserAsync(array $args = [])
+ * @method \Aws\Result expireSession(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise expireSessionAsync(array $args = [])
+ * @method \Aws\Result listAssociatedFleets(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssociatedFleetsAsync(array $args = [])
+ * @method \Aws\Result listAssociatedStacks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssociatedStacksAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result startFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startFleetAsync(array $args = [])
+ * @method \Aws\Result startImageBuilder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startImageBuilderAsync(array $args = [])
+ * @method \Aws\Result stopFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopFleetAsync(array $args = [])
+ * @method \Aws\Result stopImageBuilder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopImageBuilderAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateApplicationAsync(array $args = [])
+ * @method \Aws\Result updateDirectoryConfig(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDirectoryConfigAsync(array $args = [])
+ * @method \Aws\Result updateFleet(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateFleetAsync(array $args = [])
+ * @method \Aws\Result updateImagePermissions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateImagePermissionsAsync(array $args = [])
+ * @method \Aws\Result updateStack(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateStackAsync(array $args = [])
+ */
+class AppstreamClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Appstream/Exception/AppstreamException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Appstream\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon AppStream** service.
+ */
+class AppstreamException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Arn/AccessPointArn.php ---
@@ -0,0 +1,66 @@
+<?php
+namespace Aws\Arn;
+
+use Aws\Arn\Exception\InvalidArnException;
+
+/**
+ * @internal
+ */
+class AccessPointArn extends Arn implements AccessPointArnInterface
+{
+    use ResourceTypeAndIdTrait;
+
+    /**
+     * AccessPointArn constructor
+     *
+     * @param $data
+     */
+    public function __construct($data)
+    {
+        parent::__construct($data);
+        static::validate($this->data);
+    }
+
+    public static function parse($string)
+    {
+        $data = parent::parse($string);
+        $data = self::parseResourceTypeAndId($data);
+        $data['accesspoint_name'] = $data['resource_id'];
+        return $data;
+    }
+
+    public function getAccesspointName()
+    {
+        return $this->data['accesspoint_name'];
+    }
+
+    /**
+     * Validation specific to AccessPointArn
+     *
+     * @param array $data
+     */
+    protected static function validate(array $data)
+    {
+        self::validateRegion($data, 'access point ARN');
+        self::validateAccountId($data, 'access point ARN');
+
+        if ($data['resource_type'] !== 'accesspoint') {
+            throw new InvalidArnException("The 6th component of an access point ARN"
+                . " represents the resource type and must be 'accesspoint'.");
+        }
+
+        if (empty($data['resource_id'])) {
+            throw new InvalidArnException("The 7th component of an access point ARN"
+                . " represents the resource ID and must not be empty.");
+        }
+        if (strpos($data['resource_id'], ':') !== false) {
+            throw new InvalidArnException("The resource ID component of an access"
+                . " point ARN must not contain additional components"
+                . " (delimited by ':').");
+        }
+        if (!self::isValidHostLabel($data['resource_id'])) {
+            throw new InvalidArnException("The resource ID in an access point ARN"
+                . " must be a valid host label value.");
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/AccessPointArnInterface.php ---
@@ -0,0 +1,10 @@
+<?php
+namespace Aws\Arn;
+
+/**
+ * @internal
+ */
+interface AccessPointArnInterface extends ArnInterface
+{
+    public function getAccesspointName();
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/Arn.php ---
@@ -0,0 +1,188 @@
+<?php
+namespace Aws\Arn;
+
+use Aws\Arn\Exception\InvalidArnException;
+
+/**
+ * Amazon Resource Names (ARNs) uniquely identify AWS resources. The Arn class
+ * parses and stores a generic ARN object representation that can apply to any
+ * service resource.
+ *
+ * @internal
+ */
+class Arn implements ArnInterface
+{
+    protected $data;
+    protected $string;
+
+    public static function parse($string)
+    {
+        $data = [
+            'arn' => null,
+            'partition' => null,
+            'service' => null,
+            'region' => null,
+            'account_id' => null,
+            'resource' => null,
+        ];
+
+        $length = strlen($string);
+        $lastDelim = 0;
+        $numComponents = 0;
+        for ($i = 0; $i < $length; $i++) {
+
+            if (($numComponents < 5 && $string[$i] === ':')) {
+                // Split components between delimiters
+                $data[key($data)] = substr($string, $lastDelim, $i - $lastDelim);
+
+                // Do not include delimiter character itself
+                $lastDelim = $i + 1;
+                next($data);
+                $numComponents++;
+            }
+
+            if ($i === $length - 1) {
+                // Put the remainder in the last component.
+                if (in_array($numComponents, [5])) {
+                    $data['resource'] = substr($string, $lastDelim);
+                } else {
+                    // If there are < 5 components, put remainder in current
+                    // component.
+                    $data[key($data)] = substr($string, $lastDelim);
+                }
+            }
+        }
+
+        return $data;
+    }
+
+    public function __construct($data)
+    {
+        if (is_array($data)) {
+            $this->data = $data;
+        } elseif (is_string($data)) {
+            $this->data = static::parse($data);
+        } else {
+            throw new InvalidArnException('Constructor accepts a string or an'
+                . ' array as an argument.');
+        }
+
+        static::validate($this->data);
+    }
+
+    public function __toString()
+    {
+        if (!isset($this->string)) {
+            $components = [
+                $this->getPrefix(),
+                $this->getPartition(),
+                $this->getService(),
+                $this->getRegion(),
+                $this->getAccountId(),
+                $this->getResource(),
+            ];
+
+            $this->string = implode(':', $components);
+        }
+        return $this->string;
+    }
+
+    public function getPrefix()
+    {
+        return $this->data['arn'];
+    }
+
+    public function getPartition()
+    {
+        return $this->data['partition'];
+    }
+
+    public function getService()
+    {
+        return $this->data['service'];
+    }
+
+    public function getRegion()
+    {
+        return $this->data['region'];
+    }
+
+    public function getAccountId()
+    {
+        return $this->data['account_id'];
+    }
+
+    public function getResource()
+    {
+        return $this->data['resource'];
+    }
+
+    public function toArray()
+    {
+        return $this->data;
+    }
+
+    /**
+     * Minimally restrictive generic ARN validation
+     *
+     * @param array $data
+     */
+    protected static function validate(array $data)
+    {
+        if ($data['arn'] !== 'arn') {
+            throw new InvalidArnException("The 1st component of an ARN must be"
+                . " 'arn'.");
+        }
+
+        if (empty($data['partition'])) {
+            throw new InvalidArnException("The 2nd component of an ARN"
+                . " represents the partition and must not be empty.");
+        }
+
+        if (empty($data['service'])) {
+            throw new InvalidArnException("The 3rd component of an ARN"
+                . " represents the service and must not be empty.");
+        }
+
+        if (empty($data['resource'])) {
+            throw new InvalidArnException("The 6th component of an ARN"
+                . " represents the resource information and must not be empty."
+                . " Individual service ARNs may include additional delimiters"
+                . " to further qualify resources.");
+        }
+    }
+
+    protected static function validateAccountId($data, $arnName)
+    {
+        if (!self::isValidHostLabel($data['account_id'])) {
+            throw new InvalidArnException("The 5th component of a {$arnName}"
+                . " is required, represents the account ID, and"
+                . " must be a valid host label.");
+        }
+    }
+
+    protected static function validateRegion($data, $arnName)
+    {
+        if (empty($data['region'])) {
+            throw new InvalidArnException("The 4th component of a {$arnName}"
+                . " represents the region and must not be empty.");
+        }
+    }
+
+    /**
+     * Validates whether a string component is a valid host label
+     *
+     * @param $string
+     * @return bool
+     */
+    protected static function isValidHostLabel($string)
+    {
+        if (empty($string) || strlen($string) > 63) {
+            return false;
+        }
+        if ($value = preg_match("/^[a-zA-Z0-9-]+$/", $string)) {
+            return true;
+        }
+        return false;
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/src/Arn/ArnInterface.php ---
@@ -0,0 +1,37 @@
+<?php
+namespace Aws\Arn;
+
+/**
+ * Amazon Resource Names (ARNs) uniquely identify AWS resources. Classes
+ * implementing ArnInterface parse and store an ARN object representation.
+ *
+ * Valid ARN formats include:
+ *
+ *   arn:partition:service:region:account-id:resource-id
+ *   arn:partition:service:region:account-id:resource-type/resource-id
+ *   arn:partition:service:region:account-id:resource-type:resource-id
+ *
+ * Some components may be omitted, depending on the service and resource type.
+ *
+ * @internal
+ */
+interface ArnInterface
+{
+    public static function parse($string);
+
+    public function __toString();
+
+    public function getPrefix();
+
+    public function getPartition();
+
+    public function getService();
+
+    public function getRegion();
+
+    public function getAccountId();
+
+    public function getResource();
+
+    public function toArray();
+}
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/src/Arn/ArnParser.php ---
@@ -0,0 +1,69 @@
+<?php
+namespace Aws\Arn;
+
+use Aws\Arn\S3\AccessPointArn as S3AccessPointArn;
+use Aws\Arn\ObjectLambdaAccessPointArn;
+use Aws\Arn\S3\MultiRegionAccessPointArn;
+use Aws\Arn\S3\OutpostsBucketArn;
+use Aws\Arn\S3\RegionalBucketArn;
+use Aws\Arn\S3\OutpostsAccessPointArn;
+
+/**
+ * This class provides functionality to parse ARN strings and return a
+ * corresponding ARN object. ARN-parsing logic may be subject to change in the
+ * future, so this should not be relied upon for external customer usage.
+ *
+ * @internal
+ */
+class ArnParser
+{
+    /**
+     * @param $string
+     * @return bool
+     */
+    public static function isArn($string)
+    {
+        return strpos($string, 'arn:') === 0;
+    }
+
+    /**
+     * Parses a string and returns an instance of ArnInterface. Returns a
+     * specific type of Arn object if it has a specific class representation
+     * or a generic Arn object if not.
+     *
+     * @param $string
+     * @return ArnInterface
+     */
+    public static function parse($string)
+    {
+        $data = Arn::parse($string);
+        if ($data['service'] === 's3-object-lambda') {
+            return new ObjectLambdaAccessPointArn($string);
+        }
+        $resource = self::explodeResourceComponent($data['resource']);
+        if ($resource[0] === 'outpost') {
+            if (isset($resource[2]) && $resource[2] === 'bucket') {
+                return new OutpostsBucketArn($string);
+            }
+            if (isset($resource[2]) && $resource[2] === 'accesspoint') {
+                return new OutpostsAccessPointArn($string);
+            }
+        }
+        if (empty($data['region'])) {
+            return new MultiRegionAccessPointArn($string);
+        }
+        if ($resource[0] === 'accesspoint') {
+            if ($data['service'] === 's3') {
+                return new S3AccessPointArn($string);
+            }
+            return new AccessPointArn($string);
+        }
+
+        return new Arn($data);
+    }
+
+    private static function explodeResourceComponent($resource)
+    {
+        return preg_split("/[\/:]/", $resource);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/Exception/InvalidArnException.php ---
@@ -0,0 +1,7 @@
+<?php
+namespace Aws\Arn\Exception;
+
+/**
+ * Represents a failed attempt to construct an Arn
+ */
+class InvalidArnException extends \RuntimeException {}

--- server/vendor/aws/aws-sdk-php/src/Arn/ObjectLambdaAccessPointArn.php ---
@@ -0,0 +1,35 @@
+<?php
+namespace Aws\Arn;
+
+/**
+ * This class represents an S3 Object bucket ARN, which is in the
+ * following format:
+ *
+ * @internal
+ */
+class ObjectLambdaAccessPointArn extends AccessPointArn
+{
+    /**
+     * Parses a string into an associative array of components that represent
+     * a ObjectLambdaAccessPointArn
+     *
+     * @param $string
+     * @return array
+     */
+    public static function parse($string)
+    {
+        $data = parent::parse($string);
+        return parent::parseResourceTypeAndId($data);
+    }
+
+    /**
+     *
+     * @param array $data
+     */
+    protected static function validate(array $data)
+    {
+        parent::validate($data);
+        self::validateRegion($data, 'S3 Object Lambda ARN');
+        self::validateAccountId($data, 'S3 Object Lambda ARN');
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/ResourceTypeAndIdTrait.php ---
@@ -0,0 +1,30 @@
+<?php
+namespace Aws\Arn;
+
+/**
+ * @internal
+ */
+trait ResourceTypeAndIdTrait
+{
+    public function getResourceType()
+    {
+        return $this->data['resource_type'];
+    }
+
+    public function getResourceId()
+    {
+        return $this->data['resource_id'];
+    }
+
+    protected static function parseResourceTypeAndId(array $data)
+    {
+        $resourceData = preg_split("/[\/:]/", $data['resource'], 2);
+        $data['resource_type'] = isset($resourceData[0])
+            ? $resourceData[0]
+            : null;
+        $data['resource_id'] = isset($resourceData[1])
+            ? $resourceData[1]
+            : null;
+        return $data;
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/src/Arn/S3/AccessPointArn.php ---
@@ -0,0 +1,27 @@
+<?php
+namespace Aws\Arn\S3;
+
+use Aws\Arn\AccessPointArn as BaseAccessPointArn;
+use Aws\Arn\AccessPointArnInterface;
+use Aws\Arn\ArnInterface;
+use Aws\Arn\Exception\InvalidArnException;
+
+/**
+ * @internal
+ */
+class AccessPointArn extends BaseAccessPointArn implements AccessPointArnInterface
+{
+    /**
+     * Validation specific to AccessPointArn
+     *
+     * @param array $data
+     */
+    public static function validate(array $data)
+    {
+        parent::validate($data);
+        if ($data['service'] !== 's3') {
+            throw new InvalidArnException("The 3rd component of an S3 access"
+                . " point ARN represents the region and must be 's3'.");
+        }
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/src/Arn/S3/BucketArnInterface.php ---
@@ -0,0 +1,12 @@
+<?php
+namespace Aws\Arn\S3;
+
+use Aws\Arn\ArnInterface;
+
+/**
+ * @internal
+ */
+interface BucketArnInterface extends ArnInterface
+{
+    public function getBucketName();
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/S3/MultiRegionAccessPointArn.php ---
@@ -0,0 +1,38 @@
+<?php
+namespace Aws\Arn\S3;
+
+use Aws\Arn\Arn;
+use Aws\Arn\ResourceTypeAndIdTrait;
+
+/**
+ * This class represents an S3 multi-region bucket ARN, which is in the
+ * following format:
+ *
+ * @internal
+ */
+class MultiRegionAccessPointArn extends AccessPointArn
+{
+    use ResourceTypeAndIdTrait;
+
+    /**
+     * Parses a string into an associative array of components that represent
+     * a MultiRegionArn
+     *
+     * @param $string
+     * @return array
+     */
+    public static function parse($string)
+    {
+        return parent::parse($string);
+    }
+
+    /**
+     *
+     * @param array $data
+     */
+    public static function validate(array $data)
+    {
+        Arn::validate($data);
+    }
+
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/S3/OutpostsAccessPointArn.php ---
@@ -0,0 +1,110 @@
+<?php
+namespace Aws\Arn\S3;
+
+use Aws\Arn\AccessPointArn as BaseAccessPointArn;
+use Aws\Arn\AccessPointArnInterface;
+use Aws\Arn\Arn;
+use Aws\Arn\Exception\InvalidArnException;
+
+/**
+ * This class represents an S3 Outposts access point ARN, which is in the
+ * following format:
+ *
+ * arn:{partition}:s3-outposts:{region}:{accountId}:outpost:{outpostId}:accesspoint:{accesspointName}
+ *
+ * ':' and '/' can be used interchangeably as delimiters for components after
+ * the account ID.
+ *
+ * @internal
+ */
+class OutpostsAccessPointArn extends BaseAccessPointArn implements
+    AccessPointArnInterface,
+    OutpostsArnInterface
+{
+    public static function parse($string)
+    {
+        $data = parent::parse($string);
+        return self::parseOutpostData($data);
+    }
+
+    public function getOutpostId()
+    {
+        return $this->data['outpost_id'];
+    }
+
+    public function getAccesspointName()
+    {
+        return $this->data['accesspoint_name'];
+    }
+
+    private static function parseOutpostData(array $data)
+    {
+        $resourceData = preg_split("/[\/:]/", $data['resource_id']);
+
+        $data['outpost_id'] = isset($resourceData[0])
+            ? $resourceData[0]
+            : null;
+        $data['accesspoint_type'] = isset($resourceData[1])
+            ? $resourceData[1]
+            : null;
+        $data['accesspoint_name'] = isset($resourceData[2])
+            ? $resourceData[2]
+            : null;
+        if (isset($resourceData[3])) {
+            $data['resource_extra'] = implode(':', array_slice($resourceData, 3));
+        }
+
+        return $data;
+    }
+
+    /**
+     * Validation specific to OutpostsAccessPointArn. Note this uses the base Arn
+     * class validation instead of the direct parent due to it having slightly
+     * differing requirements from its parent.
+     *
+     * @param array $data
+     */
+    public static function validate(array $data)
+    {
+        Arn::validate($data);
+
+        if (($data['service'] !== 's3-outposts')) {
+            throw new InvalidArnException("The 3rd component of an S3 Outposts"
+                . " access point ARN represents the service and must be"
+                . " 's3-outposts'.");
+        }
+
+        self::validateRegion($data, 'S3 Outposts access point ARN');
+        self::validateAccountId($data, 'S3 Outposts access point ARN');
+
+        if (($data['resource_type'] !== 'outpost')) {
+            throw new InvalidArnException("The 6th component of an S3 Outposts"
+                . " access point ARN represents the resource type and must be"
+                . " 'outpost'.");
+        }
+
+        if (!self::isValidHostLabel($data['outpost_id'])) {
+            throw new InvalidArnException("The 7th component of an S3 Outposts"
+                . " access point ARN is required, represents the outpost ID, and"
+                . " must be a valid host label.");
+        }
+
+        if ($data['accesspoint_type'] !== 'accesspoint') {
+            throw new InvalidArnException("The 8th component of an S3 Outposts"
+                . " access point ARN must be 'accesspoint'");
+        }
+
+        if (!self::isValidHostLabel($data['accesspoint_name'])) {
+            throw new InvalidArnException("The 9th component of an S3 Outposts"
+                . " access point ARN is required, represents the accesspoint name,"
+                . " and must be a valid host label.");
+        }
+
+        if (!empty($data['resource_extra'])) {
+            throw new InvalidArnException("An S3 Outposts access point ARN"
+                . " should only have 9 components, delimited by the characters"
+                . " ':' and '/'. '{$data['resource_extra']}' was found after the"
+                . " 9th component.");
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/S3/OutpostsArnInterface.php ---
@@ -0,0 +1,12 @@
+<?php
+namespace Aws\Arn\S3;
+
+use Aws\Arn\ArnInterface;
+
+/**
+ * @internal
+ */
+interface OutpostsArnInterface extends ArnInterface
+{
+    public function getOutpostId();
+}

--- server/vendor/aws/aws-sdk-php/src/Arn/S3/OutpostsBucketArn.php ---
@@ -0,0 +1,99 @@
+<?php
+namespace Aws\Arn\S3;
+
+use Aws\Arn\Arn;
+use Aws\Arn\Exception\InvalidArnException;
+use Aws\Arn\ResourceTypeAndIdTrait;
+
+/**
+ * This class represents an S3 Outposts bucket ARN, which is in the
+ * following format:
+ *
+ * @internal
+ */
+class OutpostsBucketArn extends Arn implements
+    BucketArnInterface,
+    OutpostsArnInterface
+{
+    use ResourceTypeAndIdTrait;
+
+    /**
+     * Parses a string into an associative array of components that represent
+     * a OutpostsBucketArn
+     *
+     * @param $string
+     * @return array
+     */
+    public static function parse($string)
+    {
+        $data = parent::parse($string);
+        $data = self::parseResourceTypeAndId($data);
+        return self::parseOutpostData($data);
+    }
+
+    public function getBucketName()
+    {
+        return $this->data['bucket_name'];
+    }
+
+    public function getOutpostId()
+    {
+        return $this->data['outpost_id'];
+    }
+
+    private static function parseOutpostData(array $data)
+    {
+        $resourceData = preg_split("/[\/:]/", $data['resource_id'], 3);
+
+        $data['outpost_id'] = isset($resourceData[0])
+            ? $resourceData[0]
+            : null;
+        $data['bucket_label'] = isset($resourceData[1])
+            ? $resourceData[1]
+            : null;
+        $data['bucket_name'] = isset($resourceData[2])
+            ? $resourceData[2]
+            : null;
+
+        return $data;
+    }
+
+    /**
+     *
+     * @param array $data
+     */
+    public static function validate(array $data)
+    {
+        Arn::validate($data);
+
+        if (($data['service'] !== 's3-outposts')) {
+            throw new InvalidArnException("The 3rd component of an S3 Outposts"
+                . " bucket ARN represents the service and must be 's3-outposts'.");
+        }
+
+        self::validateRegion($data, 'S3 Outposts bucket ARN');
+        self::validateAccountId($data, 'S3 Outposts bucket ARN');
+
+        if (($data['resource_type'] !== 'outpost')) {
+            throw new InvalidArnException("The 6th component of an S3 Outposts"
+                . " bucket ARN represents the resource type and must be"
+                . " 'outpost'.");
+        }
+
+        if (!self::isValidHostLabel($data['outpost_id'])) {
+            throw new InvalidArnException("The 7th component of an S3 Outposts"
+                . " bucket ARN is required, represents the outpost ID, and"
+                . " must be a valid host label.");
+        }
+
+        if ($data['bucket_label'] !== 'bucket') {
+            throw new InvalidArnException("The 8th component of an S3 Outposts"
+                . " bucket ARN must be 'bucket'");
+        }
+
+        if (empty($data['bucket_name'])) {
+            throw new InvalidArnException("The 9th component of an S3 Outposts"
+                . " bucket ARN represents the bucket name and must not be empty.");
+        }
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/Athena/AthenaClient.php ---
@@ -0,0 +1,77 @@
+<?php
+namespace Aws\Athena;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon Athena** service.
+ * @method \Aws\Result batchGetNamedQuery(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchGetNamedQueryAsync(array $args = [])
+ * @method \Aws\Result batchGetQueryExecution(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchGetQueryExecutionAsync(array $args = [])
+ * @method \Aws\Result createDataCatalog(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createDataCatalogAsync(array $args = [])
+ * @method \Aws\Result createNamedQuery(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createNamedQueryAsync(array $args = [])
+ * @method \Aws\Result createPreparedStatement(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createPreparedStatementAsync(array $args = [])
+ * @method \Aws\Result createWorkGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createWorkGroupAsync(array $args = [])
+ * @method \Aws\Result deleteDataCatalog(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteDataCatalogAsync(array $args = [])
+ * @method \Aws\Result deleteNamedQuery(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteNamedQueryAsync(array $args = [])
+ * @method \Aws\Result deletePreparedStatement(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deletePreparedStatementAsync(array $args = [])
+ * @method \Aws\Result deleteWorkGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteWorkGroupAsync(array $args = [])
+ * @method \Aws\Result getDataCatalog(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDataCatalogAsync(array $args = [])
+ * @method \Aws\Result getDatabase(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDatabaseAsync(array $args = [])
+ * @method \Aws\Result getNamedQuery(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getNamedQueryAsync(array $args = [])
+ * @method \Aws\Result getPreparedStatement(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getPreparedStatementAsync(array $args = [])
+ * @method \Aws\Result getQueryExecution(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getQueryExecutionAsync(array $args = [])
+ * @method \Aws\Result getQueryResults(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getQueryResultsAsync(array $args = [])
+ * @method \Aws\Result getTableMetadata(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getTableMetadataAsync(array $args = [])
+ * @method \Aws\Result getWorkGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getWorkGroupAsync(array $args = [])
+ * @method \Aws\Result listDataCatalogs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDataCatalogsAsync(array $args = [])
+ * @method \Aws\Result listDatabases(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listDatabasesAsync(array $args = [])
+ * @method \Aws\Result listEngineVersions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listEngineVersionsAsync(array $args = [])
+ * @method \Aws\Result listNamedQueries(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listNamedQueriesAsync(array $args = [])
+ * @method \Aws\Result listPreparedStatements(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listPreparedStatementsAsync(array $args = [])
+ * @method \Aws\Result listQueryExecutions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listQueryExecutionsAsync(array $args = [])
+ * @method \Aws\Result listTableMetadata(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTableMetadataAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result listWorkGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listWorkGroupsAsync(array $args = [])
+ * @method \Aws\Result startQueryExecution(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startQueryExecutionAsync(array $args = [])
+ * @method \Aws\Result stopQueryExecution(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopQueryExecutionAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateDataCatalog(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateDataCatalogAsync(array $args = [])
+ * @method \Aws\Result updatePreparedStatement(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updatePreparedStatementAsync(array $args = [])
+ * @method \Aws\Result updateWorkGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateWorkGroupAsync(array $args = [])
+ */
+class AthenaClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Athena/Exception/AthenaException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Athena\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon Athena** service.
+ */
+class AthenaException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AuditManager/AuditManagerClient.php ---
@@ -0,0 +1,131 @@
+<?php
+namespace Aws\AuditManager;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Audit Manager** service.
+ * @method \Aws\Result associateAssessmentReportEvidenceFolder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateAssessmentReportEvidenceFolderAsync(array $args = [])
+ * @method \Aws\Result batchAssociateAssessmentReportEvidence(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchAssociateAssessmentReportEvidenceAsync(array $args = [])
+ * @method \Aws\Result batchCreateDelegationByAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchCreateDelegationByAssessmentAsync(array $args = [])
+ * @method \Aws\Result batchDeleteDelegationByAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchDeleteDelegationByAssessmentAsync(array $args = [])
+ * @method \Aws\Result batchDisassociateAssessmentReportEvidence(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchDisassociateAssessmentReportEvidenceAsync(array $args = [])
+ * @method \Aws\Result batchImportEvidenceToAssessmentControl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchImportEvidenceToAssessmentControlAsync(array $args = [])
+ * @method \Aws\Result createAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAssessmentAsync(array $args = [])
+ * @method \Aws\Result createAssessmentFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAssessmentFrameworkAsync(array $args = [])
+ * @method \Aws\Result createAssessmentReport(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAssessmentReportAsync(array $args = [])
+ * @method \Aws\Result createControl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createControlAsync(array $args = [])
+ * @method \Aws\Result deleteAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAssessmentAsync(array $args = [])
+ * @method \Aws\Result deleteAssessmentFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAssessmentFrameworkAsync(array $args = [])
+ * @method \Aws\Result deleteAssessmentFrameworkShare(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAssessmentFrameworkShareAsync(array $args = [])
+ * @method \Aws\Result deleteAssessmentReport(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAssessmentReportAsync(array $args = [])
+ * @method \Aws\Result deleteControl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteControlAsync(array $args = [])
+ * @method \Aws\Result deregisterAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deregisterAccountAsync(array $args = [])
+ * @method \Aws\Result deregisterOrganizationAdminAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deregisterOrganizationAdminAccountAsync(array $args = [])
+ * @method \Aws\Result disassociateAssessmentReportEvidenceFolder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateAssessmentReportEvidenceFolderAsync(array $args = [])
+ * @method \Aws\Result getAccountStatus(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAccountStatusAsync(array $args = [])
+ * @method \Aws\Result getAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAssessmentAsync(array $args = [])
+ * @method \Aws\Result getAssessmentFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAssessmentFrameworkAsync(array $args = [])
+ * @method \Aws\Result getAssessmentReportUrl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAssessmentReportUrlAsync(array $args = [])
+ * @method \Aws\Result getChangeLogs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getChangeLogsAsync(array $args = [])
+ * @method \Aws\Result getControl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getControlAsync(array $args = [])
+ * @method \Aws\Result getDelegations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDelegationsAsync(array $args = [])
+ * @method \Aws\Result getEvidence(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEvidenceAsync(array $args = [])
+ * @method \Aws\Result getEvidenceByEvidenceFolder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEvidenceByEvidenceFolderAsync(array $args = [])
+ * @method \Aws\Result getEvidenceFolder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEvidenceFolderAsync(array $args = [])
+ * @method \Aws\Result getEvidenceFoldersByAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEvidenceFoldersByAssessmentAsync(array $args = [])
+ * @method \Aws\Result getEvidenceFoldersByAssessmentControl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEvidenceFoldersByAssessmentControlAsync(array $args = [])
+ * @method \Aws\Result getInsights(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getInsightsAsync(array $args = [])
+ * @method \Aws\Result getInsightsByAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getInsightsByAssessmentAsync(array $args = [])
+ * @method \Aws\Result getOrganizationAdminAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getOrganizationAdminAccountAsync(array $args = [])
+ * @method \Aws\Result getServicesInScope(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getServicesInScopeAsync(array $args = [])
+ * @method \Aws\Result getSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSettingsAsync(array $args = [])
+ * @method \Aws\Result listAssessmentControlInsightsByControlDomain(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssessmentControlInsightsByControlDomainAsync(array $args = [])
+ * @method \Aws\Result listAssessmentFrameworkShareRequests(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssessmentFrameworkShareRequestsAsync(array $args = [])
+ * @method \Aws\Result listAssessmentFrameworks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssessmentFrameworksAsync(array $args = [])
+ * @method \Aws\Result listAssessmentReports(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssessmentReportsAsync(array $args = [])
+ * @method \Aws\Result listAssessments(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAssessmentsAsync(array $args = [])
+ * @method \Aws\Result listControlDomainInsights(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listControlDomainInsightsAsync(array $args = [])
+ * @method \Aws\Result listControlDomainInsightsByAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listControlDomainInsightsByAssessmentAsync(array $args = [])
+ * @method \Aws\Result listControlInsightsByControlDomain(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listControlInsightsByControlDomainAsync(array $args = [])
+ * @method \Aws\Result listControls(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listControlsAsync(array $args = [])
+ * @method \Aws\Result listKeywordsForDataSource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listKeywordsForDataSourceAsync(array $args = [])
+ * @method \Aws\Result listNotifications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listNotificationsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result registerAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise registerAccountAsync(array $args = [])
+ * @method \Aws\Result registerOrganizationAdminAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise registerOrganizationAdminAccountAsync(array $args = [])
+ * @method \Aws\Result startAssessmentFrameworkShare(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startAssessmentFrameworkShareAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateAssessment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAssessmentAsync(array $args = [])
+ * @method \Aws\Result updateAssessmentControl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAssessmentControlAsync(array $args = [])
+ * @method \Aws\Result updateAssessmentControlSetStatus(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAssessmentControlSetStatusAsync(array $args = [])
+ * @method \Aws\Result updateAssessmentFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAssessmentFrameworkAsync(array $args = [])
+ * @method \Aws\Result updateAssessmentFrameworkShare(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAssessmentFrameworkShareAsync(array $args = [])
+ * @method \Aws\Result updateAssessmentStatus(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAssessmentStatusAsync(array $args = [])
+ * @method \Aws\Result updateControl(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateControlAsync(array $args = [])
+ * @method \Aws\Result updateSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateSettingsAsync(array $args = [])
+ * @method \Aws\Result validateAssessmentReportIntegrity(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise validateAssessmentReportIntegrityAsync(array $args = [])
+ */
+class AuditManagerClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AuditManager/Exception/AuditManagerException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AuditManager\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Audit Manager** service.
+ */
+class AuditManagerException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AugmentedAIRuntime/AugmentedAIRuntimeClient.php ---
@@ -0,0 +1,19 @@
+<?php
+namespace Aws\AugmentedAIRuntime;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon Augmented AI Runtime** service.
+ * @method \Aws\Result deleteHumanLoop(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteHumanLoopAsync(array $args = [])
+ * @method \Aws\Result describeHumanLoop(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeHumanLoopAsync(array $args = [])
+ * @method \Aws\Result listHumanLoops(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listHumanLoopsAsync(array $args = [])
+ * @method \Aws\Result startHumanLoop(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startHumanLoopAsync(array $args = [])
+ * @method \Aws\Result stopHumanLoop(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopHumanLoopAsync(array $args = [])
+ */
+class AugmentedAIRuntimeClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AugmentedAIRuntime/Exception/AugmentedAIRuntimeException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AugmentedAIRuntime\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon Augmented AI Runtime** service.
+ */
+class AugmentedAIRuntimeException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AutoScaling/AutoScalingClient.php ---
@@ -0,0 +1,132 @@
+<?php
+namespace Aws\AutoScaling;
+
+use Aws\AwsClient;
+
+/**
+ * Auto Scaling client.
+ *
+ * @method \Aws\Result attachInstances(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise attachInstancesAsync(array $args = [])
+ * @method \Aws\Result attachLoadBalancerTargetGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise attachLoadBalancerTargetGroupsAsync(array $args = [])
+ * @method \Aws\Result attachLoadBalancers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise attachLoadBalancersAsync(array $args = [])
+ * @method \Aws\Result batchDeleteScheduledAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchDeleteScheduledActionAsync(array $args = [])
+ * @method \Aws\Result batchPutScheduledUpdateGroupAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchPutScheduledUpdateGroupActionAsync(array $args = [])
+ * @method \Aws\Result cancelInstanceRefresh(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise cancelInstanceRefreshAsync(array $args = [])
+ * @method \Aws\Result completeLifecycleAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise completeLifecycleActionAsync(array $args = [])
+ * @method \Aws\Result createAutoScalingGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAutoScalingGroupAsync(array $args = [])
+ * @method \Aws\Result createLaunchConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createLaunchConfigurationAsync(array $args = [])
+ * @method \Aws\Result createOrUpdateTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createOrUpdateTagsAsync(array $args = [])
+ * @method \Aws\Result deleteAutoScalingGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAutoScalingGroupAsync(array $args = [])
+ * @method \Aws\Result deleteLaunchConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteLaunchConfigurationAsync(array $args = [])
+ * @method \Aws\Result deleteLifecycleHook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteLifecycleHookAsync(array $args = [])
+ * @method \Aws\Result deleteNotificationConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteNotificationConfigurationAsync(array $args = [])
+ * @method \Aws\Result deletePolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deletePolicyAsync(array $args = [])
+ * @method \Aws\Result deleteScheduledAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteScheduledActionAsync(array $args = [])
+ * @method \Aws\Result deleteTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteTagsAsync(array $args = [])
+ * @method \Aws\Result deleteWarmPool(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteWarmPoolAsync(array $args = [])
+ * @method \Aws\Result describeAccountLimits(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAccountLimitsAsync(array $args = [])
+ * @method \Aws\Result describeAdjustmentTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAdjustmentTypesAsync(array $args = [])
+ * @method \Aws\Result describeAutoScalingGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAutoScalingGroupsAsync(array $args = [])
+ * @method \Aws\Result describeAutoScalingInstances(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAutoScalingInstancesAsync(array $args = [])
+ * @method \Aws\Result describeAutoScalingNotificationTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAutoScalingNotificationTypesAsync(array $args = [])
+ * @method \Aws\Result describeInstanceRefreshes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeInstanceRefreshesAsync(array $args = [])
+ * @method \Aws\Result describeLaunchConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeLaunchConfigurationsAsync(array $args = [])
+ * @method \Aws\Result describeLifecycleHookTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeLifecycleHookTypesAsync(array $args = [])
+ * @method \Aws\Result describeLifecycleHooks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeLifecycleHooksAsync(array $args = [])
+ * @method \Aws\Result describeLoadBalancerTargetGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeLoadBalancerTargetGroupsAsync(array $args = [])
+ * @method \Aws\Result describeLoadBalancers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeLoadBalancersAsync(array $args = [])
+ * @method \Aws\Result describeMetricCollectionTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeMetricCollectionTypesAsync(array $args = [])
+ * @method \Aws\Result describeNotificationConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeNotificationConfigurationsAsync(array $args = [])
+ * @method \Aws\Result describePolicies(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describePoliciesAsync(array $args = [])
+ * @method \Aws\Result describeScalingActivities(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScalingActivitiesAsync(array $args = [])
+ * @method \Aws\Result describeScalingProcessTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScalingProcessTypesAsync(array $args = [])
+ * @method \Aws\Result describeScheduledActions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScheduledActionsAsync(array $args = [])
+ * @method \Aws\Result describeTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeTagsAsync(array $args = [])
+ * @method \Aws\Result describeTerminationPolicyTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeTerminationPolicyTypesAsync(array $args = [])
+ * @method \Aws\Result describeWarmPool(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeWarmPoolAsync(array $args = [])
+ * @method \Aws\Result detachInstances(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise detachInstancesAsync(array $args = [])
+ * @method \Aws\Result detachLoadBalancerTargetGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise detachLoadBalancerTargetGroupsAsync(array $args = [])
+ * @method \Aws\Result detachLoadBalancers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise detachLoadBalancersAsync(array $args = [])
+ * @method \Aws\Result disableMetricsCollection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disableMetricsCollectionAsync(array $args = [])
+ * @method \Aws\Result enableMetricsCollection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise enableMetricsCollectionAsync(array $args = [])
+ * @method \Aws\Result enterStandby(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise enterStandbyAsync(array $args = [])
+ * @method \Aws\Result executePolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise executePolicyAsync(array $args = [])
+ * @method \Aws\Result exitStandby(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exitStandbyAsync(array $args = [])
+ * @method \Aws\Result getPredictiveScalingForecast(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getPredictiveScalingForecastAsync(array $args = [])
+ * @method \Aws\Result putLifecycleHook(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putLifecycleHookAsync(array $args = [])
+ * @method \Aws\Result putNotificationConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putNotificationConfigurationAsync(array $args = [])
+ * @method \Aws\Result putScalingPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putScalingPolicyAsync(array $args = [])
+ * @method \Aws\Result putScheduledUpdateGroupAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putScheduledUpdateGroupActionAsync(array $args = [])
+ * @method \Aws\Result putWarmPool(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putWarmPoolAsync(array $args = [])
+ * @method \Aws\Result recordLifecycleActionHeartbeat(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise recordLifecycleActionHeartbeatAsync(array $args = [])
+ * @method \Aws\Result resumeProcesses(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise resumeProcessesAsync(array $args = [])
+ * @method \Aws\Result setDesiredCapacity(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise setDesiredCapacityAsync(array $args = [])
+ * @method \Aws\Result setInstanceHealth(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise setInstanceHealthAsync(array $args = [])
+ * @method \Aws\Result setInstanceProtection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise setInstanceProtectionAsync(array $args = [])
+ * @method \Aws\Result startInstanceRefresh(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startInstanceRefreshAsync(array $args = [])
+ * @method \Aws\Result suspendProcesses(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise suspendProcessesAsync(array $args = [])
+ * @method \Aws\Result terminateInstanceInAutoScalingGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise terminateInstanceInAutoScalingGroupAsync(array $args = [])
+ * @method \Aws\Result updateAutoScalingGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAutoScalingGroupAsync(array $args = [])
+ */
+class AutoScalingClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AutoScaling/Exception/AutoScalingException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AutoScaling\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error while interacting with the Auto Scaling service.
+ */
+class AutoScalingException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AutoScalingPlans/AutoScalingPlansClient.php ---
@@ -0,0 +1,21 @@
+<?php
+namespace Aws\AutoScalingPlans;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Auto Scaling Plans** service.
+ * @method \Aws\Result createScalingPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createScalingPlanAsync(array $args = [])
+ * @method \Aws\Result deleteScalingPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteScalingPlanAsync(array $args = [])
+ * @method \Aws\Result describeScalingPlanResources(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScalingPlanResourcesAsync(array $args = [])
+ * @method \Aws\Result describeScalingPlans(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeScalingPlansAsync(array $args = [])
+ * @method \Aws\Result getScalingPlanResourceForecastData(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getScalingPlanResourceForecastDataAsync(array $args = [])
+ * @method \Aws\Result updateScalingPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateScalingPlanAsync(array $args = [])
+ */
+class AutoScalingPlansClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/AutoScalingPlans/Exception/AutoScalingPlansException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\AutoScalingPlans\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Auto Scaling Plans** service.
+ */
+class AutoScalingPlansException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/AwsClient.php ---
@@ -0,0 +1,449 @@
+<?php
+namespace Aws;
+
+use Aws\Api\ApiProvider;
+use Aws\Api\DocModel;
+use Aws\Api\Service;
+use Aws\ClientSideMonitoring\ApiCallAttemptMonitoringMiddleware;
+use Aws\ClientSideMonitoring\ApiCallMonitoringMiddleware;
+use Aws\ClientSideMonitoring\ConfigurationProvider;
+use Aws\EndpointDiscovery\EndpointDiscoveryMiddleware;
+use Aws\Signature\SignatureProvider;
+use GuzzleHttp\Psr7\Uri;
+
+/**
+ * Default AWS client implementation
+ */
+class AwsClient implements AwsClientInterface
+{
+    use AwsClientTrait;
+
+    /** @var array */
+    private $aliases;
+
+    /** @var array */
+    private $config;
+
+    /** @var string */
+    private $region;
+
+    /** @var string */
+    private $endpoint;
+
+    /** @var Service */
+    private $api;
+
+    /** @var callable */
+    private $signatureProvider;
+
+    /** @var callable */
+    private $credentialProvider;
+
+    /** @var HandlerList */
+    private $handlerList;
+
+    /** @var array*/
+    private $defaultRequestOptions;
+
+    /**
+     * Get an array of client constructor arguments used by the client.
+     *
+     * @return array
+     */
+    public static function getArguments()
+    {
+        return ClientResolver::getDefaultArguments();
+    }
+
+    /**
+     * The client constructor accepts the following options:
+     *
+     * - api_provider: (callable) An optional PHP callable that accepts a
+     *   type, service, and version argument, and returns an array of
+     *   corresponding configuration data. The type value can be one of api,
+     *   waiter, or paginator.
+     * - credentials:
+     *   (Aws\Credentials\CredentialsInterface|array|bool|callable) Specifies
+     *   the credentials used to sign requests. Provide an
+     *   Aws\Credentials\CredentialsInterface object, an associative array of
+     *   "key", "secret", and an optional "token" key, `false` to use null
+     *   credentials, or a callable credentials provider used to create
+     *   credentials or return null. See Aws\Credentials\CredentialProvider for
+     *   a list of built-in credentials providers. If no credentials are
+     *   provided, the SDK will attempt to load them from the environment.
+     * - csm:
+     *   (Aws\ClientSideMonitoring\ConfigurationInterface|array|callable) Specifies
+     *   the credentials used to sign requests. Provide an
+     *   Aws\ClientSideMonitoring\ConfigurationInterface object, a callable
+     *   configuration provider used to create client-side monitoring configuration,
+     *   `false` to disable csm, or an associative array with the following keys:
+     *   enabled: (bool) Set to true to enable client-side monitoring, defaults
+     *   to false; host: (string) the host location to send monitoring events to,
+     *   defaults to 127.0.0.1; port: (int) The port used for the host connection,
+     *   defaults to 31000; client_id: (string) An identifier for this project
+     * - debug: (bool|array) Set to true to display debug information when
+     *   sending requests. Alternatively, you can provide an associative array
+     *   with the following keys: logfn: (callable) Function that is invoked
+     *   with log messages; stream_size: (int) When the size of a stream is
+     *   greater than this number, the stream data will not be logged (set to
+     *   "0" to not log any stream data); scrub_auth: (bool) Set to false to
+     *   disable the scrubbing of auth data from the logged messages; http:
+     *   (bool) Set to false to disable the "debug" feature of lower level HTTP
+     *   adapters (e.g., verbose curl output).
+     * - stats: (bool|array) Set to true to gather transfer statistics on
+     *   requests sent. Alternatively, you can provide an associative array with
+     *   the following keys: retries: (bool) Set to false to disable reporting
+     *   on retries attempted; http: (bool) Set to true to enable collecting
+     *   statistics from lower level HTTP adapters (e.g., values returned in
+     *   GuzzleHttp\TransferStats). HTTP handlers must support an
+     *   `http_stats_receiver` option for this to have an effect; timer: (bool)
+     *   Set to true to enable a command timer that reports the total wall clock
+     *   time spent on an operation in seconds.
+     * - disable_host_prefix_injection: (bool) Set to true to disable host prefix
+     *   injection logic for services that use it. This disables the entire
+     *   prefix injection, including the portions supplied by user-defined
+     *   parameters. Setting this flag will have no effect on services that do
+     *   not use host prefix injection.
+     * - endpoint: (string) The full URI of the webservice. This is only
+     *   required when connecting to a custom endpoint (e.g., a local version
+     *   of S3).
+     * - endpoint_discovery: (Aws\EndpointDiscovery\ConfigurationInterface,
+     *   Aws\CacheInterface, array, callable) Settings for endpoint discovery.
+     *   Provide an instance of Aws\EndpointDiscovery\ConfigurationInterface,
+     *   an instance Aws\CacheInterface, a callable that provides a promise for
+     *   a Configuration object, or an associative array with the following
+     *   keys: enabled: (bool) Set to true to enable endpoint discovery, false
+     *   to explicitly disable it, defaults to false; cache_limit: (int) The
+     *   maximum number of keys in the endpoints cache, defaults to 1000.
+     * - endpoint_provider: (callable) An optional PHP callable that
+     *   accepts a hash of options including a "service" and "region" key and
+     *   returns NULL or a hash of endpoint data, of which the "endpoint" key
+     *   is required. See Aws\Endpoint\EndpointProvider for a list of built-in
+     *   providers.
+     * - handler: (callable) A handler that accepts a command object,
+     *   request object and returns a promise that is fulfilled with an
+     *   Aws\ResultInterface object or rejected with an
+     *   Aws\Exception\AwsException. A handler does not accept a next handler
+     *   as it is terminal and expected to fulfill a command. If no handler is
+     *   provided, a default Guzzle handler will be utilized.
+     * - http: (array, default=array(0)) Set to an array of SDK request
+     *   options to apply to each request (e.g., proxy, verify, etc.).
+     * - http_handler: (callable) An HTTP handler is a function that
+     *   accepts a PSR-7 request object and returns a promise that is fulfilled
+     *   with a PSR-7 response object or rejected with an array of exception
+     *   data. NOTE: This option supersedes any provided "handler" option.
+     * - idempotency_auto_fill: (bool|callable) Set to false to disable SDK to
+     *   populate parameters that enabled 'idempotencyToken' trait with a random
+     *   UUID v4 value on your behalf. Using default value 'true' still allows
+     *   parameter value to be overwritten when provided. Note: auto-fill only
+     *   works when cryptographically secure random bytes generator functions
+     *   (random_bytes, openssl_random_pseudo_bytes or mcrypt_create_iv) can be
+     *   found. You may also provide a callable source of random bytes.
+     * - profile: (string) Allows you to specify which profile to use when
+     *   credentials are created from the AWS credentials file in your HOME
+     *   directory. This setting overrides the AWS_PROFILE environment
+     *   variable. Note: Specifying "profile" will cause the "credentials" key
+     *   to be ignored.
+     * - region: (string, required) Region to connect to. See
+     *   http://docs.aws.amazon.com/general/latest/gr/rande.html for a list of
+     *   available regions.
+     * - retries: (int, Aws\Retry\ConfigurationInterface, Aws\CacheInterface,
+     *   array, callable) Configures the retry mode and maximum number of
+     *   allowed retries for a client (pass 0 to disable retries). Provide an
+     *   integer for 'legacy' mode with the specified number of retries.
+     *   Otherwise provide an instance of Aws\Retry\ConfigurationInterface, an
+     *   instance of  Aws\CacheInterface, a callable function, or an array with
+     *   the following keys: mode: (string) Set to 'legacy', 'standard' (uses
+     *   retry quota management), or 'adapative' (an experimental mode that adds
+     *   client-side rate limiting to standard mode); max_attempts (int) The
+     *   maximum number of attempts for a given request.
+     * - scheme: (string, default=string(5) "https") URI scheme to use when
+     *   connecting connect. The SDK will utilize "https" endpoints (i.e.,
+     *   utilize SSL/TLS connections) by default. You can attempt to connect to
+     *   a service over an unencrypted "http" endpoint by setting ``scheme`` to
+     *   "http".
+     * - signature_provider: (callable) A callable that accepts a signature
+     *   version name (e.g., "v4"), a service name, and region, and
+     *   returns a SignatureInterface object or null. This provider is used to
+     *   create signers utilized by the client. See
+     *   Aws\Signature\SignatureProvider for a list of built-in providers
+     * - signature_version: (string) A string representing a custom
+     *   signature version to use with a service (e.g., v4). Note that
+     *   per/operation signature version MAY override this requested signature
+     *   version.
+     * - use_aws_shared_config_files: (bool, default=bool(true)) Set to false to
+     *   disable checking for shared config file in '~/.aws/config' and
+     *   '~/.aws/credentials'.  This will override the AWS_CONFIG_FILE
+     *   environment variable.
+     * - validate: (bool, default=bool(true)) Set to false to disable
+     *   client-side parameter validation.
+     * - version: (string, required) The version of the webservice to
+     *   utilize (e.g., 2006-03-01).
+     *
+     * @param array $args Client configuration arguments.
+     *
+     * @throws \InvalidArgumentException if any required options are missing or
+     *                                   the service is not supported.
+     */
+    public function __construct(array $args)
+    {
+        list($service, $exceptionClass) = $this->parseClass();
+        if (!isset($args['service'])) {
+            $args['service'] = manifest($service)['endpoint'];
+        }
+        if (!isset($args['exception_class'])) {
+            $args['exception_class'] = $exceptionClass;
+        }
+        $this->handlerList = new HandlerList();
+        $resolver = new ClientResolver(static::getArguments());
+        $config = $resolver->resolve($args, $this->handlerList);
+        $this->api = $config['api'];
+        $this->signatureProvider = $config['signature_provider'];
+        $this->endpoint = new Uri($config['endpoint']);
+        $this->credentialProvider = $config['credentials'];
+        $this->region = isset($config['region']) ? $config['region'] : null;
+        $this->config = $config['config'];
+        $this->defaultRequestOptions = $config['http'];
+        $this->addSignatureMiddleware();
+        $this->addInvocationId();
+        $this->addEndpointParameterMiddleware($args);
+        $this->addEndpointDiscoveryMiddleware($config, $args);
+        $this->loadAliases();
+        $this->addStreamRequestPayload();
+
+        if (isset($args['with_resolved'])) {
+            $args['with_resolved']($config);
+        }
+    }
+
+    public function getHandlerList()
+    {
+        return $this->handlerList;
+    }
+
+    public function getConfig($option = null)
+    {
+        return $option === null
+            ? $this->config
+            : (isset($this->config[$option])
+                ? $this->config[$option]
+                : null);
+    }
+
+    public function getCredentials()
+    {
+        $fn = $this->credentialProvider;
+        return $fn();
+    }
+
+    public function getEndpoint()
+    {
+        return $this->endpoint;
+    }
+
+    public function getRegion()
+    {
+        return $this->region;
+    }
+
+    public function getApi()
+    {
+        return $this->api;
+    }
+
+    public function getCommand($name, array $args = [])
+    {
+        // Fail fast if the command cannot be found in the description.
+        if (!isset($this->getApi()['operations'][$name])) {
+            $name = ucfirst($name);
+            if (!isset($this->getApi()['operations'][$name])) {
+                throw new \InvalidArgumentException("Operation not found: $name");
+            }
+        }
+
+        if (!isset($args['@http'])) {
+            $args['@http'] = $this->defaultRequestOptions;
+        } else {
+            $args['@http'] += $this->defaultRequestOptions;
+        }
+
+        return new Command($name, $args, clone $this->getHandlerList());
+    }
+
+    public function __sleep()
+    {
+        throw new \RuntimeException('Instances of ' . static::class
+            . ' cannot be serialized');
+    }
+
+    /**
+     * Get the signature_provider function of the client.
+     *
+     * @return callable
+     */
+    final public function getSignatureProvider()
+    {
+        return $this->signatureProvider;
+    }
+
+    /**
+     * Parse the class name and setup the custom exception class of the client
+     * and return the "service" name of the client and "exception_class".
+     *
+     * @return array
+     */
+    private function parseClass()
+    {
+        $klass = get_class($this);
+
+        if ($klass === __CLASS__) {
+            return ['', 'Aws\Exception\AwsException'];
+        }
+
+        $service = substr($klass, strrpos($klass, '\\') + 1, -6);
+
+        return [
+            strtolower($service),
+            "Aws\\{$service}\\Exception\\{$service}Exception"
+        ];
+    }
+
+    private function addEndpointParameterMiddleware($args)
+    {
+        if (empty($args['disable_host_prefix_injection'])) {
+            $list = $this->getHandlerList();
+            $list->appendBuild(
+                EndpointParameterMiddleware::wrap(
+                    $this->api
+                ),
+                'endpoint_parameter'
+            );
+        }
+    }
+
+    private function addEndpointDiscoveryMiddleware($config, $args)
+    {
+        $list = $this->getHandlerList();
+
+        if (!isset($args['endpoint'])) {
+            $list->appendBuild(
+                EndpointDiscoveryMiddleware::wrap(
+                    $this,
+                    $args,
+                    $config['endpoint_discovery']
+                ),
+                'EndpointDiscoveryMiddleware'
+            );
+        }
+    }
+
+    private function addSignatureMiddleware()
+    {
+        $api = $this->getApi();
+        $provider = $this->signatureProvider;
+        $version = $this->config['signature_version'];
+        $name = $this->config['signing_name'];
+        $region = $this->config['signing_region'];
+
+        $resolver = static function (
+            CommandInterface $c
+        ) use ($api, $provider, $name, $region, $version) {
+            if (!empty($c['@context']['signing_region'])) {
+                $region = $c['@context']['signing_region'];
+            }
+            if (!empty($c['@context']['signing_service'])) {
+                $name = $c['@context']['signing_service'];
+            }
+            $authType = $api->getOperation($c->getName())['authtype'];
+            switch ($authType){
+                case 'none':
+                    $version = 'anonymous';
+                    break;
+                case 'v4-unsigned-body':
+                    $version = 'v4-unsigned-body';
+                    break;
+            }
+            return SignatureProvider::resolve($provider, $version, $name, $region);
+        };
+        $this->handlerList->appendSign(
+            Middleware::signer($this->credentialProvider, $resolver),
+            'signer'
+        );
+    }
+
+    private function addInvocationId()
+    {
+        // Add invocation id to each request
+        $this->handlerList->prependSign(Middleware::invocationId(), 'invocation-id');
+    }
+
+    private function loadAliases($file = null)
+    {
+        if (!isset($this->aliases)) {
+            if (is_null($file)) {
+                $file = __DIR__ . '/data/aliases.json';
+            }
+            $aliases = \Aws\load_compiled_json($file);
+            $serviceId = $this->api->getServiceId();
+            $version = $this->getApi()->getApiVersion();
+            if (!empty($aliases['operations'][$serviceId][$version])) {
+                $this->aliases = array_flip($aliases['operations'][$serviceId][$version]);
+            }
+        }
+    }
+
+    private function addStreamRequestPayload()
+    {
+        $streamRequestPayloadMiddleware = StreamRequestPayloadMiddleware::wrap(
+            $this->api
+        );
+
+        $this->handlerList->prependSign(
+            $streamRequestPayloadMiddleware,
+            'StreamRequestPayloadMiddleware'
+        );
+    }
+
+    /**
+     * Returns a service model and doc model with any necessary changes
+     * applied.
+     *
+     * @param array $api  Array of service data being documented.
+     * @param array $docs Array of doc model data.
+     *
+     * @return array Tuple containing a [Service, DocModel]
+     *
+     * @internal This should only used to document the service API.
+     * @codeCoverageIgnore
+     */
+    public static function applyDocFilters(array $api, array $docs)
+    {
+        $aliases = \Aws\load_compiled_json(__DIR__ . '/data/aliases.json');
+        $serviceId = $api['metadata']['serviceId'];
+        $version = $api['metadata']['apiVersion'];
+
+        // Replace names for any operations with SDK aliases
+        if (!empty($aliases['operations'][$serviceId][$version])) {
+            foreach ($aliases['operations'][$serviceId][$version] as $op => $alias) {
+                $api['operations'][$alias] = $api['operations'][$op];
+                $docs['operations'][$alias] = $docs['operations'][$op];
+                unset($api['operations'][$op], $docs['operations'][$op]);
+            }
+        }
+        ksort($api['operations']);
+
+        return [
+            new Service($api, ApiProvider::defaultProvider()),
+            new DocModel($docs)
+        ];
+    }
+
+    /**
+     * @deprecated
+     * @return static
+     */
+    public static function factory(array $config = [])
+    {
+        return new static($config);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/AwsClientInterface.php ---
@@ -0,0 +1,169 @@
+<?php
+namespace Aws;
+
+use Psr\Http\Message\UriInterface;
+use GuzzleHttp\Promise\PromiseInterface;
+
+/**
+ * Represents an AWS client.
+ */
+interface AwsClientInterface
+{
+    /**
+     * Creates and executes a command for an operation by name.
+     *
+     * Suffixing an operation name with "Async" will return a
+     * promise that can be used to execute commands asynchronously.
+     *
+     * @param string $name      Name of the command to execute.
+     * @param array  $arguments Arguments to pass to the getCommand method.
+     *
+     * @return ResultInterface
+     * @throws \Exception
+     */
+    public function __call($name, array $arguments);
+
+    /**
+     * Create a command for an operation name.
+     *
+     * Special keys may be set on the command to control how it behaves,
+     * including:
+     *
+     * - @http: Associative array of transfer specific options to apply to the
+     *   request that is serialized for this command. Available keys include
+     *   "proxy", "verify", "timeout", "connect_timeout", "debug", "delay", and
+     *   "headers".
+     *
+     * @param string $name Name of the operation to use in the command
+     * @param array  $args Arguments to pass to the command
+     *
+     * @return CommandInterface
+     * @throws \InvalidArgumentException if no command can be found by name
+     */
+    public function getCommand($name, array $args = []);
+
+    /**
+     * Execute a single command.
+     *
+     * @param CommandInterface $command Command to execute
+     *
+     * @return ResultInterface
+     * @throws \Exception
+     */
+    public function execute(CommandInterface $command);
+
+    /**
+     * Execute a command asynchronously.
+     *
+     * @param CommandInterface $command Command to execute
+     *
+     * @return \GuzzleHttp\Promise\PromiseInterface
+     */
+    public function executeAsync(CommandInterface $command);
+
+    /**
+     * Returns a promise that is fulfilled with an
+     * {@see \Aws\Credentials\CredentialsInterface} object.
+     *
+     * If you need the credentials synchronously, then call the wait() method
+     * on the returned promise.
+     *
+     * @return PromiseInterface
+     */
+    public function getCredentials();
+
+    /**
+     * Get the region to which the client is configured to send requests.
+     *
+     * @return string
+     */
+    public function getRegion();
+
+    /**
+     * Gets the default endpoint, or base URL, used by the client.
+     *
+     * @return UriInterface
+     */
+    public function getEndpoint();
+
+    /**
+     * Get the service description associated with the client.
+     *
+     * @return \Aws\Api\Service
+     */
+    public function getApi();
+
+    /**
+     * Get a client configuration value.
+     *
+     * @param string|null $option The option to retrieve. Pass null to retrieve
+     *                            all options.
+     * @return mixed|null
+     */
+    public function getConfig($option = null);
+
+    /**
+     * Get the handler list used to transfer commands.
+     *
+     * This list can be modified to add middleware or to change the underlying
+     * handler used to send HTTP requests.
+     *
+     * @return HandlerList
+     */
+    public function getHandlerList();
+
+    /**
+     * Get a resource iterator for the specified operation.
+     *
+     * @param string $name Name of the iterator to retrieve.
+     * @param array  $args Command arguments to use with each command.
+     *
+     * @return \Iterator
+     * @throws \UnexpectedValueException if the iterator config is invalid.
+     */
+    public function getIterator($name, array $args = []);
+
+    /**
+     * Get a result paginator for the specified operation.
+     *
+     * @param string $name   Name of the operation used for iterator
+     * @param array  $args   Command args to be used with each command
+     *
+     * @return \Aws\ResultPaginator
+     * @throws \UnexpectedValueException if the iterator config is invalid.
+     */
+    public function getPaginator($name, array $args = []);
+
+    /**
+     * Wait until a resource is in a particular state.
+     *
+     * @param string|callable $name Name of the waiter that defines the wait
+     *                              configuration and conditions.
+     * @param array  $args          Args to be used with each command executed
+     *                              by the waiter. Waiter configuration options
+     *                              can be provided in an associative array in
+     *                              the @waiter key.
+     * @return void
+     * @throws \UnexpectedValueException if the waiter is invalid.
+     */
+    public function waitUntil($name, array $args = []);
+
+    /**
+     * Get a waiter that waits until a resource is in a particular state.
+     *
+     * Retrieving a waiter can be useful when you wish to wait asynchronously:
+     *
+     *     $waiter = $client->getWaiter('foo', ['bar' => 'baz']);
+     *     $waiter->promise()->then(function () { echo 'Done!'; });
+     *
+     * @param string|callable $name Name of the waiter that defines the wait
+     *                              configuration and conditions.
+     * @param array  $args          Args to be used with each command executed
+     *                              by the waiter. Waiter configuration options
+     *                              can be provided in an associative array in
+     *                              the @waiter key.
+     * @return \Aws\Waiter
+     * @throws \UnexpectedValueException if the waiter is invalid.
+     */
+    public function getWaiter($name, array $args = []);
+}

--- server/vendor/aws/aws-sdk-php/src/AwsClientTrait.php ---
@@ -0,0 +1,101 @@
+<?php
+namespace Aws;
+
+use Aws\Api\Service;
+
+/**
+ * A trait providing generic functionality for interacting with Amazon Web
+ * Services. This is meant to be used in classes implementing
+ * \Aws\AwsClientInterface
+ */
+trait AwsClientTrait
+{
+    public function getPaginator($name, array $args = [])
+    {
+        $config = $this->getApi()->getPaginatorConfig($name);
+
+        return new ResultPaginator($this, $name, $args, $config);
+    }
+
+    public function getIterator($name, array $args = [])
+    {
+        $config = $this->getApi()->getPaginatorConfig($name);
+        if (!$config['result_key']) {
+            throw new \UnexpectedValueException(sprintf(
+                'There are no resources to iterate for the %s operation of %s',
+                $name, $this->getApi()['serviceFullName']
+            ));
+        }
+
+        $key = is_array($config['result_key'])
+            ? $config['result_key'][0]
+            : $config['result_key'];
+
+        if ($config['output_token'] && $config['input_token']) {
+            return $this->getPaginator($name, $args)->search($key);
+        }
+
+        $result = $this->execute($this->getCommand($name, $args))->search($key);
+
+        return new \ArrayIterator((array) $result);
+    }
+
+    public function waitUntil($name, array $args = [])
+    {
+        return $this->getWaiter($name, $args)->promise()->wait();
+    }
+
+    public function getWaiter($name, array $args = [])
+    {
+        $config = isset($args['@waiter']) ? $args['@waiter'] : [];
+        $config += $this->getApi()->getWaiterConfig($name);
+
+        return new Waiter($this, $name, $args, $config);
+    }
+
+    public function execute(CommandInterface $command)
+    {
+        return $this->executeAsync($command)->wait();
+    }
+
+    public function executeAsync(CommandInterface $command)
+    {
+        $handler = $command->getHandlerList()->resolve();
+        return $handler($command);
+    }
+
+    public function __call($name, array $args)
+    {
+        if (substr($name, -5) === 'Async') {
+            $name = substr($name, 0, -5);
+            $isAsync = true;
+        }
+
+        if (!empty($this->aliases[ucfirst($name)])) {
+            $name = $this->aliases[ucfirst($name)];
+        }
+
+        $params = isset($args[0]) ? $args[0] : [];
+
+        if (!empty($isAsync)) {
+            return $this->executeAsync(
+                $this->getCommand($name, $params)
+            );
+        }
+
+        return $this->execute($this->getCommand($name, $params));
+    }
+
+    /**
+     * @param string $name
+     * @param array $args
+     *
+     * @return CommandInterface
+     */
+    abstract public function getCommand($name, array $args = []);
+
+    /**
+     * @return Service
+     */
+    abstract public function getApi();
+}

--- server/vendor/aws/aws-sdk-php/src/Backup/BackupClient.php ---
@@ -0,0 +1,141 @@
+<?php
+namespace Aws\Backup;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Backup** service.
+ * @method \Aws\Result createBackupPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackupPlanAsync(array $args = [])
+ * @method \Aws\Result createBackupSelection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackupSelectionAsync(array $args = [])
+ * @method \Aws\Result createBackupVault(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBackupVaultAsync(array $args = [])
+ * @method \Aws\Result createFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createFrameworkAsync(array $args = [])
+ * @method \Aws\Result createReportPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createReportPlanAsync(array $args = [])
+ * @method \Aws\Result deleteBackupPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackupPlanAsync(array $args = [])
+ * @method \Aws\Result deleteBackupSelection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackupSelectionAsync(array $args = [])
+ * @method \Aws\Result deleteBackupVault(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackupVaultAsync(array $args = [])
+ * @method \Aws\Result deleteBackupVaultAccessPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackupVaultAccessPolicyAsync(array $args = [])
+ * @method \Aws\Result deleteBackupVaultLockConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackupVaultLockConfigurationAsync(array $args = [])
+ * @method \Aws\Result deleteBackupVaultNotifications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBackupVaultNotificationsAsync(array $args = [])
+ * @method \Aws\Result deleteFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteFrameworkAsync(array $args = [])
+ * @method \Aws\Result deleteRecoveryPoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRecoveryPointAsync(array $args = [])
+ * @method \Aws\Result deleteReportPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteReportPlanAsync(array $args = [])
+ * @method \Aws\Result describeBackupJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBackupJobAsync(array $args = [])
+ * @method \Aws\Result describeBackupVault(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBackupVaultAsync(array $args = [])
+ * @method \Aws\Result describeCopyJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeCopyJobAsync(array $args = [])
+ * @method \Aws\Result describeFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeFrameworkAsync(array $args = [])
+ * @method \Aws\Result describeGlobalSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeGlobalSettingsAsync(array $args = [])
+ * @method \Aws\Result describeProtectedResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeProtectedResourceAsync(array $args = [])
+ * @method \Aws\Result describeRecoveryPoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeRecoveryPointAsync(array $args = [])
+ * @method \Aws\Result describeRegionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeRegionSettingsAsync(array $args = [])
+ * @method \Aws\Result describeReportJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeReportJobAsync(array $args = [])
+ * @method \Aws\Result describeReportPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeReportPlanAsync(array $args = [])
+ * @method \Aws\Result describeRestoreJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeRestoreJobAsync(array $args = [])
+ * @method \Aws\Result disassociateRecoveryPoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateRecoveryPointAsync(array $args = [])
+ * @method \Aws\Result exportBackupPlanTemplate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise exportBackupPlanTemplateAsync(array $args = [])
+ * @method \Aws\Result getBackupPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackupPlanAsync(array $args = [])
+ * @method \Aws\Result getBackupPlanFromJSON(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackupPlanFromJSONAsync(array $args = [])
+ * @method \Aws\Result getBackupPlanFromTemplate(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackupPlanFromTemplateAsync(array $args = [])
+ * @method \Aws\Result getBackupSelection(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackupSelectionAsync(array $args = [])
+ * @method \Aws\Result getBackupVaultAccessPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackupVaultAccessPolicyAsync(array $args = [])
+ * @method \Aws\Result getBackupVaultNotifications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBackupVaultNotificationsAsync(array $args = [])
+ * @method \Aws\Result getRecoveryPointRestoreMetadata(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRecoveryPointRestoreMetadataAsync(array $args = [])
+ * @method \Aws\Result getSupportedResourceTypes(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSupportedResourceTypesAsync(array $args = [])
+ * @method \Aws\Result listBackupJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackupJobsAsync(array $args = [])
+ * @method \Aws\Result listBackupPlanTemplates(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackupPlanTemplatesAsync(array $args = [])
+ * @method \Aws\Result listBackupPlanVersions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackupPlanVersionsAsync(array $args = [])
+ * @method \Aws\Result listBackupPlans(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackupPlansAsync(array $args = [])
+ * @method \Aws\Result listBackupSelections(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackupSelectionsAsync(array $args = [])
+ * @method \Aws\Result listBackupVaults(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBackupVaultsAsync(array $args = [])
+ * @method \Aws\Result listCopyJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listCopyJobsAsync(array $args = [])
+ * @method \Aws\Result listFrameworks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listFrameworksAsync(array $args = [])
+ * @method \Aws\Result listProtectedResources(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listProtectedResourcesAsync(array $args = [])
+ * @method \Aws\Result listRecoveryPointsByBackupVault(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listRecoveryPointsByBackupVaultAsync(array $args = [])
+ * @method \Aws\Result listRecoveryPointsByResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listRecoveryPointsByResourceAsync(array $args = [])
+ * @method \Aws\Result listReportJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listReportJobsAsync(array $args = [])
+ * @method \Aws\Result listReportPlans(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listReportPlansAsync(array $args = [])
+ * @method \Aws\Result listRestoreJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listRestoreJobsAsync(array $args = [])
+ * @method \Aws\Result listTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsAsync(array $args = [])
+ * @method \Aws\Result putBackupVaultAccessPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putBackupVaultAccessPolicyAsync(array $args = [])
+ * @method \Aws\Result putBackupVaultLockConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putBackupVaultLockConfigurationAsync(array $args = [])
+ * @method \Aws\Result putBackupVaultNotifications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putBackupVaultNotificationsAsync(array $args = [])
+ * @method \Aws\Result startBackupJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startBackupJobAsync(array $args = [])
+ * @method \Aws\Result startCopyJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startCopyJobAsync(array $args = [])
+ * @method \Aws\Result startReportJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startReportJobAsync(array $args = [])
+ * @method \Aws\Result startRestoreJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startRestoreJobAsync(array $args = [])
+ * @method \Aws\Result stopBackupJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopBackupJobAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateBackupPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBackupPlanAsync(array $args = [])
+ * @method \Aws\Result updateFramework(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateFrameworkAsync(array $args = [])
+ * @method \Aws\Result updateGlobalSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateGlobalSettingsAsync(array $args = [])
+ * @method \Aws\Result updateRecoveryPointLifecycle(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRecoveryPointLifecycleAsync(array $args = [])
+ * @method \Aws\Result updateRegionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRegionSettingsAsync(array $args = [])
+ * @method \Aws\Result updateReportPlan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateReportPlanAsync(array $args = [])
+ */
+class BackupClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Backup/Exception/BackupException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Backup\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Backup** service.
+ */
+class BackupException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/BackupGateway/BackupGatewayClient.php ---
@@ -0,0 +1,41 @@
+<?php
+namespace Aws\BackupGateway;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Backup Gateway** service.
+ * @method \Aws\Result associateGatewayToServer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateGatewayToServerAsync(array $args = [])
+ * @method \Aws\Result createGateway(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createGatewayAsync(array $args = [])
+ * @method \Aws\Result deleteGateway(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteGatewayAsync(array $args = [])
+ * @method \Aws\Result deleteHypervisor(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteHypervisorAsync(array $args = [])
+ * @method \Aws\Result disassociateGatewayFromServer(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateGatewayFromServerAsync(array $args = [])
+ * @method \Aws\Result importHypervisorConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise importHypervisorConfigurationAsync(array $args = [])
+ * @method \Aws\Result listGateways(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listGatewaysAsync(array $args = [])
+ * @method \Aws\Result listHypervisors(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listHypervisorsAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result listVirtualMachines(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listVirtualMachinesAsync(array $args = [])
+ * @method \Aws\Result putMaintenanceStartTime(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putMaintenanceStartTimeAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result testHypervisorConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise testHypervisorConfigurationAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateGatewayInformation(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateGatewayInformationAsync(array $args = [])
+ * @method \Aws\Result updateHypervisor(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateHypervisorAsync(array $args = [])
+ */
+class BackupGatewayClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/BackupGateway/Exception/BackupGatewayException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\BackupGateway\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Backup Gateway** service.
+ */
+class BackupGatewayException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Batch/BatchClient.php ---
@@ -0,0 +1,57 @@
+<?php
+namespace Aws\Batch;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Batch** service.
+ * @method \Aws\Result cancelJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise cancelJobAsync(array $args = [])
+ * @method \Aws\Result createComputeEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createComputeEnvironmentAsync(array $args = [])
+ * @method \Aws\Result createJobQueue(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createJobQueueAsync(array $args = [])
+ * @method \Aws\Result createSchedulingPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createSchedulingPolicyAsync(array $args = [])
+ * @method \Aws\Result deleteComputeEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteComputeEnvironmentAsync(array $args = [])
+ * @method \Aws\Result deleteJobQueue(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteJobQueueAsync(array $args = [])
+ * @method \Aws\Result deleteSchedulingPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteSchedulingPolicyAsync(array $args = [])
+ * @method \Aws\Result deregisterJobDefinition(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deregisterJobDefinitionAsync(array $args = [])
+ * @method \Aws\Result describeComputeEnvironments(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeComputeEnvironmentsAsync(array $args = [])
+ * @method \Aws\Result describeJobDefinitions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeJobDefinitionsAsync(array $args = [])
+ * @method \Aws\Result describeJobQueues(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeJobQueuesAsync(array $args = [])
+ * @method \Aws\Result describeJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeJobsAsync(array $args = [])
+ * @method \Aws\Result describeSchedulingPolicies(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeSchedulingPoliciesAsync(array $args = [])
+ * @method \Aws\Result listJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listJobsAsync(array $args = [])
+ * @method \Aws\Result listSchedulingPolicies(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSchedulingPoliciesAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result registerJobDefinition(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise registerJobDefinitionAsync(array $args = [])
+ * @method \Aws\Result submitJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise submitJobAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result terminateJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise terminateJobAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateComputeEnvironment(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateComputeEnvironmentAsync(array $args = [])
+ * @method \Aws\Result updateJobQueue(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateJobQueueAsync(array $args = [])
+ * @method \Aws\Result updateSchedulingPolicy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateSchedulingPolicyAsync(array $args = [])
+ */
+class BatchClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Batch/Exception/BatchException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Batch\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Batch** service.
+ */
+class BatchException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Braket/BraketClient.php ---
@@ -0,0 +1,35 @@
+<?php
+namespace Aws\Braket;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Braket** service.
+ * @method \Aws\Result cancelJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise cancelJobAsync(array $args = [])
+ * @method \Aws\Result cancelQuantumTask(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise cancelQuantumTaskAsync(array $args = [])
+ * @method \Aws\Result createJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createJobAsync(array $args = [])
+ * @method \Aws\Result createQuantumTask(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createQuantumTaskAsync(array $args = [])
+ * @method \Aws\Result getDevice(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getDeviceAsync(array $args = [])
+ * @method \Aws\Result getJob(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getJobAsync(array $args = [])
+ * @method \Aws\Result getQuantumTask(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getQuantumTaskAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result searchDevices(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchDevicesAsync(array $args = [])
+ * @method \Aws\Result searchJobs(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchJobsAsync(array $args = [])
+ * @method \Aws\Result searchQuantumTasks(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchQuantumTasksAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ */
+class BraketClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Braket/Exception/BraketException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Braket\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Braket** service.
+ */
+class BraketException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/Budgets/BudgetsClient.php ---
@@ -0,0 +1,53 @@
+<?php
+namespace Aws\Budgets;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **AWS Budgets** service.
+ * @method \Aws\Result createBudget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBudgetAsync(array $args = [])
+ * @method \Aws\Result createBudgetAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBudgetActionAsync(array $args = [])
+ * @method \Aws\Result createNotification(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createNotificationAsync(array $args = [])
+ * @method \Aws\Result createSubscriber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createSubscriberAsync(array $args = [])
+ * @method \Aws\Result deleteBudget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBudgetAsync(array $args = [])
+ * @method \Aws\Result deleteBudgetAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteBudgetActionAsync(array $args = [])
+ * @method \Aws\Result deleteNotification(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteNotificationAsync(array $args = [])
+ * @method \Aws\Result deleteSubscriber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteSubscriberAsync(array $args = [])
+ * @method \Aws\Result describeBudget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBudgetAsync(array $args = [])
+ * @method \Aws\Result describeBudgetAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBudgetActionAsync(array $args = [])
+ * @method \Aws\Result describeBudgetActionHistories(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBudgetActionHistoriesAsync(array $args = [])
+ * @method \Aws\Result describeBudgetActionsForAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBudgetActionsForAccountAsync(array $args = [])
+ * @method \Aws\Result describeBudgetActionsForBudget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBudgetActionsForBudgetAsync(array $args = [])
+ * @method \Aws\Result describeBudgetPerformanceHistory(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBudgetPerformanceHistoryAsync(array $args = [])
+ * @method \Aws\Result describeBudgets(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeBudgetsAsync(array $args = [])
+ * @method \Aws\Result describeNotificationsForBudget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeNotificationsForBudgetAsync(array $args = [])
+ * @method \Aws\Result describeSubscribersForNotification(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeSubscribersForNotificationAsync(array $args = [])
+ * @method \Aws\Result executeBudgetAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise executeBudgetActionAsync(array $args = [])
+ * @method \Aws\Result updateBudget(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBudgetAsync(array $args = [])
+ * @method \Aws\Result updateBudgetAction(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBudgetActionAsync(array $args = [])
+ * @method \Aws\Result updateNotification(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateNotificationAsync(array $args = [])
+ * @method \Aws\Result updateSubscriber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateSubscriberAsync(array $args = [])
+ */
+class BudgetsClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Budgets/Exception/BudgetsException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Budgets\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **AWS Budgets** service.
+ */
+class BudgetsException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/CacheInterface.php ---
@@ -0,0 +1,34 @@
+<?php
+namespace Aws;
+
+/**
+ * Represents a simple cache interface.
+ */
+interface CacheInterface
+{
+    /**
+     * Get a cache item by key.
+     *
+     * @param string $key Key to retrieve.
+     *
+     * @return mixed|null Returns the value or null if not found.
+     */
+    public function get($key);
+
+    /**
+     * Set a cache key value.
+     *
+     * @param string $key   Key to set
+     * @param mixed  $value Value to set.
+     * @param int    $ttl   Number of seconds the item is allowed to live. Set
+     *                      to 0 to allow an unlimited lifetime.
+     */
+    public function set($key, $value, $ttl = 0);
+
+    /**
+     * Remove a cache key.
+     *
+     * @param string $key Key to remove.
+     */
+    public function remove($key);
+}

--- server/vendor/aws/aws-sdk-php/src/Chime/ChimeClient.php ---
@@ -0,0 +1,389 @@
+<?php
+namespace Aws\Chime;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon Chime** service.
+ * @method \Aws\Result associatePhoneNumberWithUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associatePhoneNumberWithUserAsync(array $args = [])
+ * @method \Aws\Result associatePhoneNumbersWithVoiceConnector(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associatePhoneNumbersWithVoiceConnectorAsync(array $args = [])
+ * @method \Aws\Result associatePhoneNumbersWithVoiceConnectorGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associatePhoneNumbersWithVoiceConnectorGroupAsync(array $args = [])
+ * @method \Aws\Result associateSigninDelegateGroupsWithAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateSigninDelegateGroupsWithAccountAsync(array $args = [])
+ * @method \Aws\Result batchCreateAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchCreateAttendeeAsync(array $args = [])
+ * @method \Aws\Result batchCreateChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchCreateChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result batchCreateRoomMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchCreateRoomMembershipAsync(array $args = [])
+ * @method \Aws\Result batchDeletePhoneNumber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchDeletePhoneNumberAsync(array $args = [])
+ * @method \Aws\Result batchSuspendUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchSuspendUserAsync(array $args = [])
+ * @method \Aws\Result batchUnsuspendUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchUnsuspendUserAsync(array $args = [])
+ * @method \Aws\Result batchUpdatePhoneNumber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchUpdatePhoneNumberAsync(array $args = [])
+ * @method \Aws\Result batchUpdateUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchUpdateUserAsync(array $args = [])
+ * @method \Aws\Result createAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAccountAsync(array $args = [])
+ * @method \Aws\Result createAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppInstanceAsync(array $args = [])
+ * @method \Aws\Result createAppInstanceAdmin(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppInstanceAdminAsync(array $args = [])
+ * @method \Aws\Result createAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result createAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAttendeeAsync(array $args = [])
+ * @method \Aws\Result createBot(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createBotAsync(array $args = [])
+ * @method \Aws\Result createChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelAsync(array $args = [])
+ * @method \Aws\Result createChannelBan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelBanAsync(array $args = [])
+ * @method \Aws\Result createChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result createChannelModerator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelModeratorAsync(array $args = [])
+ * @method \Aws\Result createMediaCapturePipeline(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createMediaCapturePipelineAsync(array $args = [])
+ * @method \Aws\Result createMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createMeetingAsync(array $args = [])
+ * @method \Aws\Result createMeetingDialOut(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createMeetingDialOutAsync(array $args = [])
+ * @method \Aws\Result createMeetingWithAttendees(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createMeetingWithAttendeesAsync(array $args = [])
+ * @method \Aws\Result createPhoneNumberOrder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createPhoneNumberOrderAsync(array $args = [])
+ * @method \Aws\Result createProxySession(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createProxySessionAsync(array $args = [])
+ * @method \Aws\Result createRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRoomAsync(array $args = [])
+ * @method \Aws\Result createRoomMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createRoomMembershipAsync(array $args = [])
+ * @method \Aws\Result createSipMediaApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createSipMediaApplicationAsync(array $args = [])
+ * @method \Aws\Result createSipMediaApplicationCall(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createSipMediaApplicationCallAsync(array $args = [])
+ * @method \Aws\Result createSipRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createSipRuleAsync(array $args = [])
+ * @method \Aws\Result createUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createUserAsync(array $args = [])
+ * @method \Aws\Result createVoiceConnector(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createVoiceConnectorAsync(array $args = [])
+ * @method \Aws\Result createVoiceConnectorGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createVoiceConnectorGroupAsync(array $args = [])
+ * @method \Aws\Result deleteAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAccountAsync(array $args = [])
+ * @method \Aws\Result deleteAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppInstanceAsync(array $args = [])
+ * @method \Aws\Result deleteAppInstanceAdmin(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppInstanceAdminAsync(array $args = [])
+ * @method \Aws\Result deleteAppInstanceStreamingConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppInstanceStreamingConfigurationsAsync(array $args = [])
+ * @method \Aws\Result deleteAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result deleteAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAttendeeAsync(array $args = [])
+ * @method \Aws\Result deleteChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelAsync(array $args = [])
+ * @method \Aws\Result deleteChannelBan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelBanAsync(array $args = [])
+ * @method \Aws\Result deleteChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result deleteChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelMessageAsync(array $args = [])
+ * @method \Aws\Result deleteChannelModerator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelModeratorAsync(array $args = [])
+ * @method \Aws\Result deleteEventsConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteEventsConfigurationAsync(array $args = [])
+ * @method \Aws\Result deleteMediaCapturePipeline(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteMediaCapturePipelineAsync(array $args = [])
+ * @method \Aws\Result deleteMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteMeetingAsync(array $args = [])
+ * @method \Aws\Result deletePhoneNumber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deletePhoneNumberAsync(array $args = [])
+ * @method \Aws\Result deleteProxySession(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteProxySessionAsync(array $args = [])
+ * @method \Aws\Result deleteRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRoomAsync(array $args = [])
+ * @method \Aws\Result deleteRoomMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteRoomMembershipAsync(array $args = [])
+ * @method \Aws\Result deleteSipMediaApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteSipMediaApplicationAsync(array $args = [])
+ * @method \Aws\Result deleteSipRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteSipRuleAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnector(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnectorEmergencyCallingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorEmergencyCallingConfigurationAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnectorGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorGroupAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnectorOrigination(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorOriginationAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnectorProxy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorProxyAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnectorStreamingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorStreamingConfigurationAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnectorTermination(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorTerminationAsync(array $args = [])
+ * @method \Aws\Result deleteVoiceConnectorTerminationCredentials(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteVoiceConnectorTerminationCredentialsAsync(array $args = [])
+ * @method \Aws\Result describeAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppInstanceAsync(array $args = [])
+ * @method \Aws\Result describeAppInstanceAdmin(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppInstanceAdminAsync(array $args = [])
+ * @method \Aws\Result describeAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result describeChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelAsync(array $args = [])
+ * @method \Aws\Result describeChannelBan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelBanAsync(array $args = [])
+ * @method \Aws\Result describeChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result describeChannelMembershipForAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelMembershipForAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result describeChannelModeratedByAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelModeratedByAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result describeChannelModerator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelModeratorAsync(array $args = [])
+ * @method \Aws\Result disassociatePhoneNumberFromUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociatePhoneNumberFromUserAsync(array $args = [])
+ * @method \Aws\Result disassociatePhoneNumbersFromVoiceConnector(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociatePhoneNumbersFromVoiceConnectorAsync(array $args = [])
+ * @method \Aws\Result disassociatePhoneNumbersFromVoiceConnectorGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociatePhoneNumbersFromVoiceConnectorGroupAsync(array $args = [])
+ * @method \Aws\Result disassociateSigninDelegateGroupsFromAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateSigninDelegateGroupsFromAccountAsync(array $args = [])
+ * @method \Aws\Result getAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAccountAsync(array $args = [])
+ * @method \Aws\Result getAccountSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAccountSettingsAsync(array $args = [])
+ * @method \Aws\Result getAppInstanceRetentionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAppInstanceRetentionSettingsAsync(array $args = [])
+ * @method \Aws\Result getAppInstanceStreamingConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAppInstanceStreamingConfigurationsAsync(array $args = [])
+ * @method \Aws\Result getAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAttendeeAsync(array $args = [])
+ * @method \Aws\Result getBot(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getBotAsync(array $args = [])
+ * @method \Aws\Result getChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getChannelMessageAsync(array $args = [])
+ * @method \Aws\Result getEventsConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getEventsConfigurationAsync(array $args = [])
+ * @method \Aws\Result getGlobalSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getGlobalSettingsAsync(array $args = [])
+ * @method \Aws\Result getMediaCapturePipeline(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getMediaCapturePipelineAsync(array $args = [])
+ * @method \Aws\Result getMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getMeetingAsync(array $args = [])
+ * @method \Aws\Result getMessagingSessionEndpoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getMessagingSessionEndpointAsync(array $args = [])
+ * @method \Aws\Result getPhoneNumber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getPhoneNumberAsync(array $args = [])
+ * @method \Aws\Result getPhoneNumberOrder(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getPhoneNumberOrderAsync(array $args = [])
+ * @method \Aws\Result getPhoneNumberSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getPhoneNumberSettingsAsync(array $args = [])
+ * @method \Aws\Result getProxySession(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getProxySessionAsync(array $args = [])
+ * @method \Aws\Result getRetentionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRetentionSettingsAsync(array $args = [])
+ * @method \Aws\Result getRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getRoomAsync(array $args = [])
+ * @method \Aws\Result getSipMediaApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSipMediaApplicationAsync(array $args = [])
+ * @method \Aws\Result getSipMediaApplicationLoggingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSipMediaApplicationLoggingConfigurationAsync(array $args = [])
+ * @method \Aws\Result getSipRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getSipRuleAsync(array $args = [])
+ * @method \Aws\Result getUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getUserAsync(array $args = [])
+ * @method \Aws\Result getUserSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getUserSettingsAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnector(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorEmergencyCallingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorEmergencyCallingConfigurationAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorGroupAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorLoggingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorLoggingConfigurationAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorOrigination(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorOriginationAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorProxy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorProxyAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorStreamingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorStreamingConfigurationAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorTermination(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorTerminationAsync(array $args = [])
+ * @method \Aws\Result getVoiceConnectorTerminationHealth(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getVoiceConnectorTerminationHealthAsync(array $args = [])
+ * @method \Aws\Result inviteUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise inviteUsersAsync(array $args = [])
+ * @method \Aws\Result listAccounts(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAccountsAsync(array $args = [])
+ * @method \Aws\Result listAppInstanceAdmins(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppInstanceAdminsAsync(array $args = [])
+ * @method \Aws\Result listAppInstanceUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppInstanceUsersAsync(array $args = [])
+ * @method \Aws\Result listAppInstances(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppInstancesAsync(array $args = [])
+ * @method \Aws\Result listAttendeeTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAttendeeTagsAsync(array $args = [])
+ * @method \Aws\Result listAttendees(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAttendeesAsync(array $args = [])
+ * @method \Aws\Result listBots(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listBotsAsync(array $args = [])
+ * @method \Aws\Result listChannelBans(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelBansAsync(array $args = [])
+ * @method \Aws\Result listChannelMemberships(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelMembershipsAsync(array $args = [])
+ * @method \Aws\Result listChannelMembershipsForAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelMembershipsForAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result listChannelMessages(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelMessagesAsync(array $args = [])
+ * @method \Aws\Result listChannelModerators(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelModeratorsAsync(array $args = [])
+ * @method \Aws\Result listChannels(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelsAsync(array $args = [])
+ * @method \Aws\Result listChannelsModeratedByAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelsModeratedByAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result listMediaCapturePipelines(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listMediaCapturePipelinesAsync(array $args = [])
+ * @method \Aws\Result listMeetingTags(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listMeetingTagsAsync(array $args = [])
+ * @method \Aws\Result listMeetings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listMeetingsAsync(array $args = [])
+ * @method \Aws\Result listPhoneNumberOrders(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listPhoneNumberOrdersAsync(array $args = [])
+ * @method \Aws\Result listPhoneNumbers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listPhoneNumbersAsync(array $args = [])
+ * @method \Aws\Result listProxySessions(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listProxySessionsAsync(array $args = [])
+ * @method \Aws\Result listRoomMemberships(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listRoomMembershipsAsync(array $args = [])
+ * @method \Aws\Result listRooms(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listRoomsAsync(array $args = [])
+ * @method \Aws\Result listSipMediaApplications(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSipMediaApplicationsAsync(array $args = [])
+ * @method \Aws\Result listSipRules(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSipRulesAsync(array $args = [])
+ * @method \Aws\Result listSupportedPhoneNumberCountries(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listSupportedPhoneNumberCountriesAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result listUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listUsersAsync(array $args = [])
+ * @method \Aws\Result listVoiceConnectorGroups(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listVoiceConnectorGroupsAsync(array $args = [])
+ * @method \Aws\Result listVoiceConnectorTerminationCredentials(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listVoiceConnectorTerminationCredentialsAsync(array $args = [])
+ * @method \Aws\Result listVoiceConnectors(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listVoiceConnectorsAsync(array $args = [])
+ * @method \Aws\Result logoutUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise logoutUserAsync(array $args = [])
+ * @method \Aws\Result putAppInstanceRetentionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putAppInstanceRetentionSettingsAsync(array $args = [])
+ * @method \Aws\Result putAppInstanceStreamingConfigurations(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putAppInstanceStreamingConfigurationsAsync(array $args = [])
+ * @method \Aws\Result putEventsConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putEventsConfigurationAsync(array $args = [])
+ * @method \Aws\Result putRetentionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putRetentionSettingsAsync(array $args = [])
+ * @method \Aws\Result putSipMediaApplicationLoggingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putSipMediaApplicationLoggingConfigurationAsync(array $args = [])
+ * @method \Aws\Result putVoiceConnectorEmergencyCallingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putVoiceConnectorEmergencyCallingConfigurationAsync(array $args = [])
+ * @method \Aws\Result putVoiceConnectorLoggingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putVoiceConnectorLoggingConfigurationAsync(array $args = [])
+ * @method \Aws\Result putVoiceConnectorOrigination(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putVoiceConnectorOriginationAsync(array $args = [])
+ * @method \Aws\Result putVoiceConnectorProxy(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putVoiceConnectorProxyAsync(array $args = [])
+ * @method \Aws\Result putVoiceConnectorStreamingConfiguration(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putVoiceConnectorStreamingConfigurationAsync(array $args = [])
+ * @method \Aws\Result putVoiceConnectorTermination(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putVoiceConnectorTerminationAsync(array $args = [])
+ * @method \Aws\Result putVoiceConnectorTerminationCredentials(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putVoiceConnectorTerminationCredentialsAsync(array $args = [])
+ * @method \Aws\Result redactChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise redactChannelMessageAsync(array $args = [])
+ * @method \Aws\Result redactConversationMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise redactConversationMessageAsync(array $args = [])
+ * @method \Aws\Result redactRoomMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise redactRoomMessageAsync(array $args = [])
+ * @method \Aws\Result regenerateSecurityToken(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise regenerateSecurityTokenAsync(array $args = [])
+ * @method \Aws\Result resetPersonalPIN(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise resetPersonalPINAsync(array $args = [])
+ * @method \Aws\Result restorePhoneNumber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise restorePhoneNumberAsync(array $args = [])
+ * @method \Aws\Result searchAvailablePhoneNumbers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise searchAvailablePhoneNumbersAsync(array $args = [])
+ * @method \Aws\Result sendChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise sendChannelMessageAsync(array $args = [])
+ * @method \Aws\Result startMeetingTranscription(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startMeetingTranscriptionAsync(array $args = [])
+ * @method \Aws\Result stopMeetingTranscription(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopMeetingTranscriptionAsync(array $args = [])
+ * @method \Aws\Result tagAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagAttendeeAsync(array $args = [])
+ * @method \Aws\Result tagMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagMeetingAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagAttendeeAsync(array $args = [])
+ * @method \Aws\Result untagMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagMeetingAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateAccount(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAccountAsync(array $args = [])
+ * @method \Aws\Result updateAccountSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAccountSettingsAsync(array $args = [])
+ * @method \Aws\Result updateAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAppInstanceAsync(array $args = [])
+ * @method \Aws\Result updateAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result updateBot(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateBotAsync(array $args = [])
+ * @method \Aws\Result updateChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateChannelAsync(array $args = [])
+ * @method \Aws\Result updateChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateChannelMessageAsync(array $args = [])
+ * @method \Aws\Result updateChannelReadMarker(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateChannelReadMarkerAsync(array $args = [])
+ * @method \Aws\Result updateGlobalSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateGlobalSettingsAsync(array $args = [])
+ * @method \Aws\Result updatePhoneNumber(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updatePhoneNumberAsync(array $args = [])
+ * @method \Aws\Result updatePhoneNumberSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updatePhoneNumberSettingsAsync(array $args = [])
+ * @method \Aws\Result updateProxySession(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateProxySessionAsync(array $args = [])
+ * @method \Aws\Result updateRoom(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRoomAsync(array $args = [])
+ * @method \Aws\Result updateRoomMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateRoomMembershipAsync(array $args = [])
+ * @method \Aws\Result updateSipMediaApplication(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateSipMediaApplicationAsync(array $args = [])
+ * @method \Aws\Result updateSipMediaApplicationCall(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateSipMediaApplicationCallAsync(array $args = [])
+ * @method \Aws\Result updateSipRule(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateSipRuleAsync(array $args = [])
+ * @method \Aws\Result updateUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateUserAsync(array $args = [])
+ * @method \Aws\Result updateUserSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateUserSettingsAsync(array $args = [])
+ * @method \Aws\Result updateVoiceConnector(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateVoiceConnectorAsync(array $args = [])
+ * @method \Aws\Result updateVoiceConnectorGroup(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateVoiceConnectorGroupAsync(array $args = [])
+ */
+class ChimeClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/Chime/Exception/ChimeException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\Chime\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon Chime** service.
+ */
+class ChimeException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ChimeSDKIdentity/ChimeSDKIdentityClient.php ---
@@ -0,0 +1,57 @@
+<?php
+namespace Aws\ChimeSDKIdentity;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon Chime SDK Identity** service.
+ * @method \Aws\Result createAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppInstanceAsync(array $args = [])
+ * @method \Aws\Result createAppInstanceAdmin(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppInstanceAdminAsync(array $args = [])
+ * @method \Aws\Result createAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result deleteAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppInstanceAsync(array $args = [])
+ * @method \Aws\Result deleteAppInstanceAdmin(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppInstanceAdminAsync(array $args = [])
+ * @method \Aws\Result deleteAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result deregisterAppInstanceUserEndpoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deregisterAppInstanceUserEndpointAsync(array $args = [])
+ * @method \Aws\Result describeAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppInstanceAsync(array $args = [])
+ * @method \Aws\Result describeAppInstanceAdmin(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppInstanceAdminAsync(array $args = [])
+ * @method \Aws\Result describeAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result describeAppInstanceUserEndpoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeAppInstanceUserEndpointAsync(array $args = [])
+ * @method \Aws\Result getAppInstanceRetentionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAppInstanceRetentionSettingsAsync(array $args = [])
+ * @method \Aws\Result listAppInstanceAdmins(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppInstanceAdminsAsync(array $args = [])
+ * @method \Aws\Result listAppInstanceUserEndpoints(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppInstanceUserEndpointsAsync(array $args = [])
+ * @method \Aws\Result listAppInstanceUsers(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppInstanceUsersAsync(array $args = [])
+ * @method \Aws\Result listAppInstances(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAppInstancesAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result putAppInstanceRetentionSettings(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putAppInstanceRetentionSettingsAsync(array $args = [])
+ * @method \Aws\Result registerAppInstanceUserEndpoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise registerAppInstanceUserEndpointAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateAppInstance(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAppInstanceAsync(array $args = [])
+ * @method \Aws\Result updateAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result updateAppInstanceUserEndpoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateAppInstanceUserEndpointAsync(array $args = [])
+ */
+class ChimeSDKIdentityClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ChimeSDKIdentity/Exception/ChimeSDKIdentityException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ChimeSDKIdentity\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon Chime SDK Identity** service.
+ */
+class ChimeSDKIdentityException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ChimeSDKMeetings/ChimeSDKMeetingsClient.php ---
@@ -0,0 +1,31 @@
+<?php
+namespace Aws\ChimeSDKMeetings;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon Chime SDK Meetings** service.
+ * @method \Aws\Result batchCreateAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchCreateAttendeeAsync(array $args = [])
+ * @method \Aws\Result createAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createAttendeeAsync(array $args = [])
+ * @method \Aws\Result createMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createMeetingAsync(array $args = [])
+ * @method \Aws\Result createMeetingWithAttendees(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createMeetingWithAttendeesAsync(array $args = [])
+ * @method \Aws\Result deleteAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteAttendeeAsync(array $args = [])
+ * @method \Aws\Result deleteMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteMeetingAsync(array $args = [])
+ * @method \Aws\Result getAttendee(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getAttendeeAsync(array $args = [])
+ * @method \Aws\Result getMeeting(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getMeetingAsync(array $args = [])
+ * @method \Aws\Result listAttendees(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listAttendeesAsync(array $args = [])
+ * @method \Aws\Result startMeetingTranscription(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise startMeetingTranscriptionAsync(array $args = [])
+ * @method \Aws\Result stopMeetingTranscription(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise stopMeetingTranscriptionAsync(array $args = [])
+ */
+class ChimeSDKMeetingsClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ChimeSDKMeetings/Exception/ChimeSDKMeetingsException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ChimeSDKMeetings\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon Chime SDK Meetings** service.
+ */
+class ChimeSDKMeetingsException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ChimeSDKMessaging/ChimeSDKMessagingClient.php ---
@@ -0,0 +1,99 @@
+<?php
+namespace Aws\ChimeSDKMessaging;
+
+use Aws\AwsClient;
+
+/**
+ * This client is used to interact with the **Amazon Chime SDK Messaging** service.
+ * @method \Aws\Result associateChannelFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise associateChannelFlowAsync(array $args = [])
+ * @method \Aws\Result batchCreateChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise batchCreateChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result channelFlowCallback(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise channelFlowCallbackAsync(array $args = [])
+ * @method \Aws\Result createChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelAsync(array $args = [])
+ * @method \Aws\Result createChannelBan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelBanAsync(array $args = [])
+ * @method \Aws\Result createChannelFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelFlowAsync(array $args = [])
+ * @method \Aws\Result createChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result createChannelModerator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise createChannelModeratorAsync(array $args = [])
+ * @method \Aws\Result deleteChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelAsync(array $args = [])
+ * @method \Aws\Result deleteChannelBan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelBanAsync(array $args = [])
+ * @method \Aws\Result deleteChannelFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelFlowAsync(array $args = [])
+ * @method \Aws\Result deleteChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result deleteChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelMessageAsync(array $args = [])
+ * @method \Aws\Result deleteChannelModerator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise deleteChannelModeratorAsync(array $args = [])
+ * @method \Aws\Result describeChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelAsync(array $args = [])
+ * @method \Aws\Result describeChannelBan(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelBanAsync(array $args = [])
+ * @method \Aws\Result describeChannelFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelFlowAsync(array $args = [])
+ * @method \Aws\Result describeChannelMembership(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelMembershipAsync(array $args = [])
+ * @method \Aws\Result describeChannelMembershipForAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelMembershipForAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result describeChannelModeratedByAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelModeratedByAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result describeChannelModerator(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise describeChannelModeratorAsync(array $args = [])
+ * @method \Aws\Result disassociateChannelFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise disassociateChannelFlowAsync(array $args = [])
+ * @method \Aws\Result getChannelMembershipPreferences(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getChannelMembershipPreferencesAsync(array $args = [])
+ * @method \Aws\Result getChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getChannelMessageAsync(array $args = [])
+ * @method \Aws\Result getChannelMessageStatus(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getChannelMessageStatusAsync(array $args = [])
+ * @method \Aws\Result getMessagingSessionEndpoint(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise getMessagingSessionEndpointAsync(array $args = [])
+ * @method \Aws\Result listChannelBans(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelBansAsync(array $args = [])
+ * @method \Aws\Result listChannelFlows(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelFlowsAsync(array $args = [])
+ * @method \Aws\Result listChannelMemberships(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelMembershipsAsync(array $args = [])
+ * @method \Aws\Result listChannelMembershipsForAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelMembershipsForAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result listChannelMessages(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelMessagesAsync(array $args = [])
+ * @method \Aws\Result listChannelModerators(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelModeratorsAsync(array $args = [])
+ * @method \Aws\Result listChannels(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelsAsync(array $args = [])
+ * @method \Aws\Result listChannelsAssociatedWithChannelFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelsAssociatedWithChannelFlowAsync(array $args = [])
+ * @method \Aws\Result listChannelsModeratedByAppInstanceUser(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listChannelsModeratedByAppInstanceUserAsync(array $args = [])
+ * @method \Aws\Result listTagsForResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise listTagsForResourceAsync(array $args = [])
+ * @method \Aws\Result putChannelMembershipPreferences(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise putChannelMembershipPreferencesAsync(array $args = [])
+ * @method \Aws\Result redactChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise redactChannelMessageAsync(array $args = [])
+ * @method \Aws\Result sendChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise sendChannelMessageAsync(array $args = [])
+ * @method \Aws\Result tagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise tagResourceAsync(array $args = [])
+ * @method \Aws\Result untagResource(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise untagResourceAsync(array $args = [])
+ * @method \Aws\Result updateChannel(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateChannelAsync(array $args = [])
+ * @method \Aws\Result updateChannelFlow(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateChannelFlowAsync(array $args = [])
+ * @method \Aws\Result updateChannelMessage(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateChannelMessageAsync(array $args = [])
+ * @method \Aws\Result updateChannelReadMarker(array $args = [])
+ * @method \GuzzleHttp\Promise\Promise updateChannelReadMarkerAsync(array $args = [])
+ */
+class ChimeSDKMessagingClient extends AwsClient {}

--- server/vendor/aws/aws-sdk-php/src/ChimeSDKMessaging/Exception/ChimeSDKMessagingException.php ---
@@ -0,0 +1,9 @@
+<?php
+namespace Aws\ChimeSDKMessaging\Exception;
+
+use Aws\Exception\AwsException;
+
+/**
+ * Represents an error interacting with the **Amazon Chime SDK Messaging** service.
+ */
+class ChimeSDKMessagingException extends AwsException {}

--- server/vendor/aws/aws-sdk-php/src/ClientResolver.php ---
@@ -0,0 +1,1007 @@
+<?php
+namespace Aws;
+
+use Aws\Api\Validator;
+use Aws\Api\ApiProvider;
+use Aws\Api\Service;
+use Aws\ClientSideMonitoring\ApiCallAttemptMonitoringMiddleware;
+use Aws\ClientSideMonitoring\ApiCallMonitoringMiddleware;
+use Aws\ClientSideMonitoring\Configuration;
+use Aws\Credentials\Credentials;
+use Aws\Credentials\CredentialsInterface;
+use Aws\Endpoint\PartitionEndpointProvider;
+use Aws\Endpoint\UseFipsEndpoint\Configuration as UseFipsEndpointConfiguration;
+use Aws\Endpoint\UseFipsEndpoint\ConfigurationProvider as UseFipsConfigProvider;
+use Aws\Endpoint\UseFipsEndpoint\ConfigurationInterface as UseFipsEndpointConfigurationInterface;
+use Aws\Endpoint\UseDualstackEndpoint\Configuration as UseDualStackEndpointConfiguration;
+use Aws\Endpoint\UseDualstackEndpoint\ConfigurationProvider as UseDualStackConfigProvider;
+use Aws\Endpoint\UseDualstackEndpoint\ConfigurationInterface as UseDualStackEndpointConfigurationInterface;
+use Aws\EndpointDiscovery\ConfigurationInterface;
+use Aws\EndpointDiscovery\ConfigurationProvider;
+use Aws\Exception\InvalidRegionException;
+use Aws\Retry\ConfigurationInterface as RetryConfigInterface;
+use Aws\Retry\ConfigurationProvider as RetryConfigProvider;
+use Aws\Signature\SignatureProvider;
+use Aws\Endpoint\EndpointProvider;
+use GuzzleHttp\Promise\PromiseInterface;
+use Aws\Credentials\CredentialProvider;
+use InvalidArgumentException as IAE;
+use Psr\Http\Message\RequestInterface;
+
+/**
+ * @internal Resolves a hash of client arguments to construct a client.
+ */
+class ClientResolver
+{
+    /** @var array */
+    private $argDefinitions;
+
+    /** @var array Map of types to a corresponding function */
+    private static $typeMap = [
+        'resource' => 'is_resource',
+        'callable' => 'is_callable',
+        'int'      => 'is_int',
+        'bool'     => 'is_bool',
+        'string'   => 'is_string',
+        'object'   => 'is_object',
+        'array'    => 'is_array',
+    ];
+
+    private static $defaultArgs = [
+        'service' => [
+            'type'     => 'value',
+            'valid'    => ['string'],
+            'doc'      => 'Name of the service to utilize. This value will be supplied by default when using one of the SDK clients (e.g., Aws\\S3\\S3Client).',
+            'required' => true,
+            'internal' => true
+        ],
+        'exception_class' => [
+            'type'     => 'value',
+            'valid'    => ['string'],
+            'doc'      => 'Exception class to create when an error occurs.',
+            'default'  => 'Aws\Exception\AwsException',
+            'internal' => true
+        ],
+        'scheme' => [
+            'type'     => 'value',
+            'valid'    => ['string'],
+            'default'  => 'https',
+            'doc'      => 'URI scheme to use when connecting connect. The SDK will utilize "https" endpoints (i.e., utilize SSL/TLS connections) by default. You can attempt to connect to a service over an unencrypted "http" endpoint by setting ``scheme`` to "http".',
+        ],
+        'disable_host_prefix_injection' => [
+            'type'      => 'value',
+            'valid'     => ['bool'],
+            'doc'       => 'Set to true to disable host prefix injection logic for services that use it. This disables the entire prefix injection, including the portions supplied by user-defined parameters. Setting this flag will have no effect on services that do not use host prefix injection.',
+            'default'   => false,
+        ],
+        'endpoint' => [
+            'type'  => 'value',
+            'valid' => ['string'],
+            'doc'   => 'The full URI of the webservice. This is only required when connecting to a custom endpoint (e.g., a local version of S3).',
+            'fn'    => [__CLASS__, '_apply_endpoint'],
+        ],
+        'region' => [
+            'type'     => 'value',
+            'valid'    => ['string'],
+            'required' => [__CLASS__, '_missing_region'],
+            'doc'      => 'Region to connect to. See http://docs.aws.amazon.com/general/latest/gr/rande.html for a list of available regions.',
+        ],
+        'version' => [
+            'type'     => 'value',
+            'valid'    => ['string'],
+            'required' => [__CLASS__, '_missing_version'],
+            'doc'      => 'The version of the webservice to utilize (e.g., 2006-03-01).',
+        ],
+        'signature_provider' => [
+            'type'    => 'value',
+            'valid'   => ['callable'],
+            'doc'     => 'A callable that accepts a signature version name (e.g., "v4"), a service name, and region, and  returns a SignatureInterface object or null. This provider is used to create signers utilized by the client. See Aws\\Signature\\SignatureProvider for a list of built-in providers',
+            'default' => [__CLASS__, '_default_signature_provider'],
+        ],
+        'api_provider' => [
+            'type'     => 'value',
+            'valid'    => ['callable'],
+            'doc'      => 'An optional PHP callable that accepts a type, service, and version argument, and returns an array of corresponding configuration data. The type value can be one of api, waiter, or paginator.',
+            'fn'       => [__CLASS__, '_apply_api_provider'],
+            'default'  => [ApiProvider::class, 'defaultProvider'],
+        ],
+        'use_fips_endpoint' => [
+            'type'      => 'value',
+            'valid'     => ['bool', UseFipsEndpointConfiguration::class, CacheInterface::class, 'callable'],
+            'doc'       => 'Set to true to enable the use of FIPS pseudo regions',
+            'fn'        => [__CLASS__, '_apply_use_fips_endpoint'],
+            'default'   => [__CLASS__, '_default_use_fips_endpoint'],
+        ],
+        'use_dual_stack_endpoint' => [
+            'type'      => 'value',
+            'valid'     => ['bool', UseDualStackEndpointConfiguration::class, CacheInterface::class, 'callable'],
+            'doc'       => 'Set to true to enable the use of dual-stack endpoints',
+            'fn'        => [__CLASS__, '_apply_use_dual_stack_endpoint'],
+            'default'   => [__CLASS__, '_default_use_dual_stack_endpoint'],
+        ],
+        'endpoint_provider' => [
+            'type'     => 'value',
+            'valid'    => ['callable'],
+            'fn'       => [__CLASS__, '_apply_endpoint_provider'],
+            'doc'      => 'An optional PHP callable that accepts a hash of options including a "service" and "region" key and returns NULL or a hash of endpoint data, of which the "endpoint" key is required. See Aws\\Endpoint\\EndpointProvider for a list of built-in providers.',
+            'default'  => [__CLASS__, '_default_endpoint_provider'],
+        ],
+        'serializer' => [
+            'default'   => [__CLASS__, '_default_serializer'],
+            'fn'        => [__CLASS__, '_apply_serializer'],
+            'internal'  => true,
+            'type'      => 'value',
+            'valid'     => ['callable'],
+        ],
+        'signature_version' => [
+            'type'    => 'config',
+            'valid'   => ['string'],
+            'doc'     => 'A string representing a custom signature version to use with a service (e.g., v4). Note that per/operation signature version MAY override this requested signature version.',
+            'default' => [__CLASS__, '_default_signature_version'],
+        ],
+        'signing_name' => [
+            'type'    => 'config',
+            'valid'   => ['string'],
+            'doc'     => 'A string representing a custom service name to be used when calculating a request signature.',
+            'default' => [__CLASS__, '_default_signing_name'],
+        ],
+        'signing_region' => [
+            'type'    => 'config',
+            'valid'   => ['string'],
+            'doc'     => 'A string representing a custom region name to be used when calculating a request signature.',
+            'default' => [__CLASS__, '_default_signing_region'],
+        ],
+        'profile' => [
+            'type'  => 'config',
+            'valid' => ['string'],
+            'doc'   => 'Allows you to specify which profile to use when credentials are created from the AWS credentials file in your HOME directory. This setting overrides the AWS_PROFILE environment variable. Note: Specifying "profile" will cause the "credentials" and "use_aws_shared_config_files" keys to be ignored.',
+            'fn'    => [__CLASS__, '_apply_profile'],
+        ],
+        'credentials' => [
+            'type'    => 'value',
+            'valid'   => [CredentialsInterface::class, CacheInterface::class, 'array', 'bool', 'callable'],
+            'doc'     => 'Specifies the credentials used to sign requests. Provide an Aws\Credentials\CredentialsInterface object, an associative array of "key", "secret", and an optional "token" key, `false` to use null credentials, or a callable credentials provider used to create credentials or return null. See Aws\\Credentials\\CredentialProvider for a list of built-in credentials providers. If no credentials are provided, the SDK will attempt to load them from the environment.',
+            'fn'      => [__CLASS__, '_apply_credentials'],
+            'default' => [__CLASS__, '_default_credential_provider'],
+        ],
+        'endpoint_discovery' => [
+            'type'     => 'value',
+            'valid'    => [ConfigurationInterface::class, CacheInterface::class, 'array', 'callable'],
+            'doc'      => 'Specifies settings for endpoint discovery. Provide an instance of Aws\EndpointDiscovery\ConfigurationInterface, an instance Aws\CacheInterface, a callable that provides a promise for a Configuration object, or an associative array with the following keys: enabled: (bool) Set to true to enable endpoint discovery, false to explicitly disable it. Defaults to false; cache_limit: (int) The maximum number of keys in the endpoints cache. Defaults to 1000.',
+            'fn'       => [__CLASS__, '_apply_endpoint_discovery'],
+            'default'  => [__CLASS__, '_default_endpoint_discovery_provider']
+        ],
+        'stats' => [
+            'type'  => 'value',
+            'valid' => ['bool', 'array'],
+            'default' => false,
+            'doc'   => 'Set to true to gather transfer statistics on requests sent. Alternatively, you can provide an associative array with the following keys: retries: (bool) Set to false to disable reporting on retries attempted; http: (bool) Set to true to enable collecting statistics from lower level HTTP adapters (e.g., values returned in GuzzleHttp\TransferStats). HTTP handlers must support an http_stats_receiver option for this to have an effect; timer: (bool) Set to true to enable a command timer that reports the total wall clock time spent on an operation in seconds.',
+            'fn'    => [__CLASS__, '_apply_stats'],
+        ],
+        'retries' => [
+            'type'    => 'value',
+            'valid'   => ['int', RetryConfigInterface::class, CacheInterface::class, 'callable', 'array'],
+            'doc'     => "Configures the retry mode and maximum number of allowed retries for a client (pass 0 to disable retries). Provide an integer for 'legacy' mode with the specified number of retries. Otherwise provide an instance of Aws\Retry\ConfigurationInterface, an instance of  Aws\CacheInterface, a callable function, or an array with the following keys: mode: (string) Set to 'legacy', 'standard' (uses retry quota management), or 'adapative' (an experimental mode that adds client-side rate limiting to standard mode); max_attempts: (int) The maximum number of attempts for a given request. ",
+            'fn'      => [__CLASS__, '_apply_retries'],
+            'default' => [RetryConfigProvider::class, 'defaultProvider']
+        ],
+        'validate' => [
+            'type'    => 'value',
+            'valid'   => ['bool', 'array'],
+            'default' => true,
+            'doc'     => 'Set to false to disable client-side parameter validation. Set to true to utilize default validation constraints. Set to an associative array of validation options to enable specific validation constraints.',
+            'fn'      => [__CLASS__, '_apply_validate'],
+        ],
+        'debug' => [
+            'type'  => 'value',
+            'valid' => ['bool', 'array'],
+            'doc'   => 'Set to true to display debug information when sending requests. Alternatively, you can provide an associative array with the following keys: logfn: (callable) Function that is invoked with log messages; stream_size: (int) When the size of a stream is greater than this number, the stream data will not be logged (set to "0" to not log any stream data); scrub_auth: (bool) Set to false to disable the scrubbing of auth data from the logged messages; http: (bool) Set to false to disable the "debug" feature of lower level HTTP adapters (e.g., verbose curl output).',
+            'fn'    => [__CLASS__, '_apply_debug'],
+        ],
+        'csm' => [
+            'type'     => 'value',
+            'valid'    => [\Aws\ClientSideMonitoring\ConfigurationInterface::class, 'callable', 'array', 'bool'],
+            'doc'      => 'CSM options for the client. Provides a callable wrapping a promise, a boolean "false", an instance of ConfigurationInterface, or an associative array of "enabled", "host", "port", and "client_id".',
+            'fn'       => [__CLASS__, '_apply_csm'],
+            'default'  => [\Aws\ClientSideMonitoring\ConfigurationProvider::class, 'defaultProvider']
+        ],
+        'http' => [
+            'type'    => 'value',
+            'valid'   => ['array'],
+            'default' => [],
+            'doc'     => 'Set to an array of SDK request options to apply to each request (e.g., proxy, verify, etc.).',
+        ],
+        'http_handler' => [
+            'type'    => 'value',
+            'valid'   => ['callable'],
+            'doc'     => 'An HTTP handler is a function that accepts a PSR-7 request object and returns a promise that is fulfilled with a PSR-7 response object or rejected with an array of exception data. NOTE: This option supersedes any provided "handler" option.',
+            'fn'      => [__CLASS__, '_apply_http_handler']
+        ],
+        'handler' => [
+            'type'     => 'value',
+            'valid'    => ['callable'],
+            'doc'      => 'A handler that accepts a command object, request object and returns a promise that is fulfilled with an Aws\ResultInterface object or rejected with an Aws\Exception\AwsException. A handler does not accept a next handler as it is terminal and expected to fulfill a command. If no handler is provided, a default Guzzle handler will be utilized.',
+            'fn'       => [__CLASS__, '_apply_handler'],
+            'default'  => [__CLASS__, '_default_handler']
+        ],
+        'ua_append' => [
+            'type'     => 'value',
+            'valid'    => ['string', 'array'],
+            'doc'      => 'Provide a string or array of strings to send in the User-Agent header.',
+            'fn'       => [__CLASS__, '_apply_user_agent'],
+            'default'  => [],
+        ],
+        'idempotency_auto_fill' => [
+            'type'      => 'value',
+            'valid'     => ['bool', 'callable'],
+            'doc'       => 'Set to false to disable SDK to populate parameters that enabled \'idempotencyToken\' trait with a random UUID v4 value on your behalf. Using default value \'true\' still allows parameter value to be overwritten when provided. Note: auto-fill only works when cryptographically secure random bytes generator functions(random_bytes, openssl_random_pseudo_bytes or mcrypt_create_iv) can be found. You may also provide a callable source of random bytes.',
+            'default'   => true,
+            'fn'        => [__CLASS__, '_apply_idempotency_auto_fill']
+        ],
+        'use_aws_shared_config_files' => [
+            'type'      => 'value',
+            'valid'     => ['bool'],
+            'doc'       => 'Set to false to disable checking for shared aws config files usually located in \'~/.aws/config\' and \'~/.aws/credentials\'.  This will be ignored if you set the \'profile\' setting.',
+            'default'   => true,
+        ],
+    ];
+
+    /**
+     * Gets an array of default client arguments, each argument containing a
+     * hash of the following:
+     *
+     * - type: (string, required) option type described as follows:
+     *   - value: The default option type.
+     *   - config: The provided value is made available in the client's
+     *     getConfig() method.
+     * - valid: (array, required) Valid PHP types or class names. Note: null
+     *   is not an allowed type.
+     * - required: (bool, callable) Whether or not the argument is required.
+     *   Provide a function that accepts an array of arguments and returns a
+     *   string to provide a custom error message.
+     * - default: (mixed) The default value of the argument if not provided. If
+     *   a function is provided, then it will be invoked to provide a default
+     *   value. The function is provided the array of options and is expected
+     *   to return the default value of the option. The default value can be a
+     *   closure and can not be a callable string that is not  part of the
+     *   defaultArgs array.
+     * - doc: (string) The argument documentation string.
+     * - fn: (callable) Function used to apply the argument. The function
+     *   accepts the provided value, array of arguments by reference, and an
+     *   event emitter.
+     *
+     * Note: Order is honored and important when applying arguments.
+     *
+     * @return array
+     */
+    public static function getDefaultArguments()
+    {
+        return self::$defaultArgs;
+    }
+
+    /**
+     * @param array $argDefinitions Client arguments.
+     */
+    public function __construct(array $argDefinitions)
+    {
+        $this->argDefinitions = $argDefinitions;
+    }
+
+    /**
+     * Resolves client configuration options and attached event listeners.
+     * Check for missing keys in passed arguments
+     *
+     * @param array       $args Provided constructor arguments.
+     * @param HandlerList $list Handler list to augment.
+     *
+     * @return array Returns the array of provided options.
+     * @throws \InvalidArgumentException
+     * @see Aws\AwsClient::__construct for a list of available options.
+     */
+    public function resolve(array $args, HandlerList $list)
+    {
+        $args['config'] = [];
+        foreach ($this->argDefinitions as $key => $a) {
+            // Add defaults, validate required values, and skip if not set.
+            if (!isset($args[$key])) {
+                if (isset($a['default'])) {
+                    // Merge defaults in when not present.
+                    if (is_callable($a['default'])
+                        && (
+                            is_array($a['default'])
+                            || $a['default'] instanceof \Closure
+                        )
+                    ) {
+                        $args[$key] = $a['default']($args);
+                    } else {
+                        $args[$key] = $a['default'];
+                    }
+                } elseif (empty($a['required'])) {
+                    continue;
+                } else {
+                    $this->throwRequired($args);
+                }
+            }
+
+            // Validate the types against the provided value.
+            foreach ($a['valid'] as $check) {
+                if (isset(self::$typeMap[$check])) {
+                    $fn = self::$typeMap[$check];
+                    if ($fn($args[$key])) {
+                        goto is_valid;
+                    }
+                } elseif ($args[$key] instanceof $check) {
+                    goto is_valid;
+                }
+            }
+
+            $this->invalidType($key, $args[$key]);
+
+            // Apply the value
+            is_valid:
+            if (isset($a['fn'])) {
+                $a['fn']($args[$key], $args, $list);
+            }
+
+            if ($a['type'] === 'config') {
+                $args['config'][$key] = $args[$key];
+            }
+        }
+
+        return $args;
+    }
+
+    /**
+     * Creates a verbose error message for an invalid argument.
+     *
+     * @param string $name        Name of the argument that is missing.
+     * @param array  $args        Provided arguments
+     * @param bool   $useRequired Set to true to show the required fn text if
+     *                            available instead of the documentation.
+     * @return string
+     */
+    private function getArgMessage($name, $args = [], $useRequired = false)
+    {
+        $arg = $this->argDefinitions[$name];
+        $msg = '';
+        $modifiers = [];
+        if (isset($arg['valid'])) {
+            $modifiers[] = implode('|', $arg['valid']);
+        }
+        if (isset($arg['choice'])) {
+            $modifiers[] = 'One of ' . implode(', ', $arg['choice']);
+        }
+        if ($modifiers) {
+            $msg .= '(' . implode('; ', $modifiers) . ')';
+        }
+        $msg = wordwrap("{$name}: {$msg}", 75, "\n  ");
+
+        if ($useRequired && is_callable($arg['required'])) {
+            $msg .= "\n\n  ";
+            $msg .= str_replace("\n", "\n  ", call_user_func($arg['required'], $args));
+        } elseif (isset($arg['doc'])) {
+            $msg .= wordwrap("\n\n  {$arg['doc']}", 75, "\n  ");
+        }
+
+        return $msg;
+    }
+
+    /**
+     * Throw when an invalid type is encountered.
+     *
+     * @param string $name     Name of the value being validated.
+     * @param mixed  $provided The provided value.
+     * @throws \InvalidArgumentException
+     */
+    private function invalidType($name, $provided)
+    {
+        $expected = implode('|', $this->argDefinitions[$name]['valid']);
+        $msg = "Invalid configuration value "
+            . "provided for \"{$name}\". Expected {$expected}, but got "
+            . describe_type($provided) . "\n\n"
+            . $this->getArgMessage($name);
+        throw new IAE($msg);
+    }
+
+    /**
+     * Throws an exception for missing required arguments.
+     *
+     * @param array $args Passed in arguments.
+     * @throws \InvalidArgumentException
+     */
+    private function throwRequired(array $args)
+    {
+        $missing = [];
+        foreach ($this->argDefinitions as $k => $a) {
+            if (empty($a['required'])
+                || isset($a['default'])
+                || isset($args[$k])
+            ) {
+                continue;
+            }
+            $missing[] = $this->getArgMessage($k, $args, true);
+        }
+        $msg = "Missing required client configuration options: \n\n";
+        $msg .= implode("\n\n", $missing);
+        throw new IAE($msg);
+    }
+
+    public static function _apply_retries($value, array &$args, HandlerList $list)
+    {
+        // A value of 0 for the config option disables retries
+        if ($value) {
+            $config = RetryConfigProvider::unwrap($value);
+
+            if ($config->getMode() === 'legacy') {
+                // # of retries is 1 less than # of attempts
+                $decider = RetryMiddleware::createDefaultDecider(
+                    $config->getMaxAttempts() - 1
+                );
+                $list->appendSign(
+                    Middleware::retry($decider, null, $args['stats']['retries']),
+                    'retry'
+                );
+            } else {
+                $list->appendSign(
+                    RetryMiddlewareV2::wrap(
+                        $config,
+                        ['collect_stats' => $args['stats']['retries']]
+                    ),
+                    'retry'
+                );
+            }
+        }
+    }
+
+    public static function _apply_credentials($value, array &$args)
+    {
+        if (is_callable($value)) {
+            return;
+        }
+
+        if ($value instanceof CredentialsInterface) {
+            $args['credentials'] = CredentialProvider::fromCredentials($value);
+        } elseif (is_array($value)
+            && isset($value['key'])
+            && isset($value['secret'])
+        ) {
+            $args['credentials'] = CredentialProvider::fromCredentials(
+                new Credentials(
+                    $value['key'],
+                    $value['secret'],
+                    isset($value['token']) ? $value['token'] : null,
+                    isset($value['expires']) ? $value['expires'] : null
+                )
+            );
+        } elseif ($value === false) {
+            $args['credentials'] = CredentialProvider::fromCredentials(
+                new Credentials('', '')
+            );
+            $args['config']['signature_version'] = 'anonymous';
+        } elseif ($value instanceof CacheInterface) {
+            $args['credentials'] = CredentialProvider::defaultProvider($args);
+        } else {
+            throw new IAE('Credentials must be an instance of '
+                . 'Aws\Credentials\CredentialsInterface, an associative '
+                . 'array that contains "key", "secret", and an optional "token" '
+                . 'key-value pairs, a credentials provider function, or false.');
+        }
+    }
+
+    public static function _default_credential_provider(array $args)
+    {
+        return CredentialProvider::defaultProvider($args);
+    }
+
+    public static function _apply_csm($value, array &$args, HandlerList $list)
+    {
+        if ($value === false) {
+            $value = new Configuration(
+                false,
+                \Aws\ClientSideMonitoring\ConfigurationProvider::DEFAULT_HOST,
+                \Aws\ClientSideMonitoring\ConfigurationProvider::DEFAULT_PORT,
+                \Aws\ClientSideMonitoring\ConfigurationProvider::DEFAULT_CLIENT_ID
+            );
+            $args['csm'] = $value;
+        }
+
+        $list->appendBuild(
+            ApiCallMonitoringMiddleware::wrap(
+                $args['credentials'],
+                $value,
+                $args['region'],
+                $args['api']->getServiceId()
+            ),
+            'ApiCallMonitoringMiddleware'
+        );
+
+        $list->appendAttempt(
+            ApiCallAttemptMonitoringMiddleware::wrap(
+                $args['credentials'],
+                $value,
+                $args['region'],
+                $args['api']->getServiceId()
+            ),
+            'ApiCallAttemptMonitoringMiddleware'
+        );
+    }
+
+    public static function _apply_api_provider(callable $value, array &$args)
+    {
+        $api = new Service(
+            ApiProvider::resolve(
+                $value,
+                'api',
+                $args['service'],
+                $args['version']
+            ),
+            $value
+        );
+
+        if (
+            empty($args['config']['signing_name'])
+            && isset($api['metadata']['signingName'])
+        ) {
+            $args['config']['signing_name'] = $api['metadata']['signingName'];
+        }
+
+        $args['api'] = $api;
+        $args['parser'] = Service::createParser($api);
+        $args['error_parser'] = Service::createErrorParser($api->getProtocol(), $api);
+    }
+
+    public static function _apply_endpoint_provider(callable $value, array &$args)
+    {
+        if (!isset($args['endpoint'])) {
+            $endpointPrefix = isset($args['api']['metadata']['endpointPrefix'])
+                ? $args['api']['metadata']['endpointPrefix']
+                : $args['service'];
+
+            // Check region is a valid host label when it is being used to
+            // generate an endpoint
+            if (!self::isValidRegion($args['region'])) {
+                throw new InvalidRegionException('Region must be a valid RFC'
+                    . ' host label.');
+            }
+            $serviceEndpoints =
+                is_array($value) && isset($value['services'][$args['service']]['endpoints'])
+                    ? $value['services'][$args['service']]['endpoints']
+                    : null;
+            if (isset($serviceEndpoints[$args['region']]['deprecated'])) {
+                trigger_error("The service " . $args['service'] . "has "
+                    . " deprecated the region " . $args['region'] . ".",
+                    E_USER_WARNING
+                );
+            }
+
+            $args['region'] = \Aws\strip_fips_pseudo_regions($args['region']);
+
+            // Invoke the endpoint provider and throw if it does not resolve.
+            $result = EndpointProvider::resolve($value, [
+                'service' => $endpointPrefix,
+                'region'  => $args['region'],
+                'scheme'  => $args['scheme'],
+                'options' => self::getEndpointProviderOptions($args),
+            ]);
+
+            $args['endpoint'] = $result['endpoint'];
+
+            if (
+                empty($args['config']['signature_version'])
+                && isset($result['signatureVersion'])
+            ) {
+                $args['config']['signature_version']
+                    = $result['signatureVersion'];
+            }
+
+            if (
+                empty($args['config']['signing_region'])
+                && isset($result['signingRegion'])
+            ) {
+                $args['config']['signing_region'] = $result['signingRegion'];
+            }
+
+            if (
+                empty($args['config']['signing_name'])
+                && isset($result['signingName'])
+            ) {
+                $args['config']['signing_name'] = $result['signingName'];
+            }
+        }
+    }
+
+    public static function _apply_endpoint_discovery($value, array &$args) {
+        $args['endpoint_discovery'] = $value;
+    }
+
+    public static function _default_endpoint_discovery_provider(array $args)
+    {
+        return ConfigurationProvider::defaultProvider($args);
+    }
+
+    public static function _apply_use_fips_endpoint($value, array &$args) {
+        if ($value instanceof CacheInterface) {
+            $value = UseFipsConfigProvider::defaultProvider($args);
+        }
+        if (is_callable($value)) {
+            $value = $value();
+        }
+        if ($value instanceof PromiseInterface) {
+            $value = $value->wait();
+        }
+        if ($value instanceof UseFipsEndpointConfigurationInterface) {
+            $args['config']['use_fips_endpoint'] = $value;
+        } else {
+            // The Configuration class itself will validate other inputs
+            $args['config']['use_fips_endpoint'] = new UseFipsEndpointConfiguration($value);
+        }
+    }
+
+    public static function _default_use_fips_endpoint(array &$args) {
+        return UseFipsConfigProvider::defaultProvider($args);
+    }
+
+    public static function _apply_use_dual_stack_endpoint($value, array &$args) {
+        if ($value instanceof CacheInterface) {
+            $value = UseDualStackConfigProvider::defaultProvider($args);
+        }
+        if (is_callable($value)) {
+            $value = $value();
+        }
+        if ($value instanceof PromiseInterface) {
+            $value = $value->wait();
+        }
+        if ($value instanceof UseDualStackEndpointConfigurationInterface) {
+            $args['config']['use_dual_stack_endpoint'] = $value;
+        } else {
+            // The Configuration class itself will validate other inputs
+            $args['config']['use_dual_stack_endpoint'] =
+                new UseDualStackEndpointConfiguration($value, $args['region']);
+        }
+    }
+
+    public static function _default_use_dual_stack_endpoint(array &$args) {
+        return UseDualStackConfigProvider::defaultProvider($args);
+    }
+
+    public static function _apply_serializer($value, array &$args, HandlerList $list)
+    {
+        $list->prependBuild(Middleware::requestBuilder($value), 'builder');
+    }
+
+    public static function _apply_debug($value, array &$args, HandlerList $list)
+    {
+        if ($value !== false) {
+            $list->interpose(
+                new TraceMiddleware(
+                    $value === true ? [] : $value,
+                    $args['api'])
+            );
+        }
+    }
+
+    public static function _apply_stats($value, array &$args, HandlerList $list)
+    {
+        // Create an array of stat collectors that are disabled (set to false)
+        // by default. If the user has passed in true, enable all stat
+        // collectors.
+        $defaults = array_fill_keys(
+            ['http', 'retries', 'timer'],
+            $value === true
+        );
+        $args['stats'] = is_array($value)
+            ? array_replace($defaults, $value)
+            : $defaults;
+
+        if ($args['stats']['timer']) {
+            $list->prependInit(Middleware::timer(), 'timer');
+        }
+    }
+
+    public static function _apply_profile($_, array &$args)
+    {
+        $args['credentials'] = CredentialProvider::ini($args['profile']);
+    }
+
+    public static function _apply_validate($value, array &$args, HandlerList $list)
+    {
+        if ($value === false) {
+            return;
+        }
+
+        $validator = $value === true
+            ? new Validator()
+            : new Validator($value);
+        $list->appendValidate(
+            Middleware::validation($args['api'], $validator),
+            'validation'
+        );
+    }
+
+    public static function _apply_handler($value, array &$args, HandlerList $list)
+    {
+        $list->setHandler($value);
+    }
+
+    public static function _default_handler(array &$args)
+    {
+        return new WrappedHttpHandler(
+            default_http_handler(),
+            $args['parser'],
+            $args['error_parser'],
+            $args['exception_class'],
+            $args['stats']['http']
+        );
+    }
+
+    public static function _apply_http_handler($value, array &$args, HandlerList $list)
+    {
+        $args['handler'] = new WrappedHttpHandler(
+            $value,
+            $args['parser'],
+            $args['error_parser'],
+            $args['exception_class'],
+            $args['stats']['http']
+        );
+    }
+
+    public static function _apply_user_agent($inputUserAgent, array &$args, HandlerList $list)
+    {
+        //Add SDK version
+        $xAmzUserAgent = ['aws-sdk-php/' . Sdk::VERSION];
+
+        //If on HHVM add the HHVM version
+        if (defined('HHVM_VERSION')) {
+            $xAmzUserAgent []= 'HHVM/' . HHVM_VERSION;
+        }
+
+        //Set up the updated user agent
+        $legacyUserAgent = $xAmzUserAgent;
+
+        //Add OS version
+        $disabledFunctions = explode(',', ini_get('disable_functions'));
+        if (function_exists('php_uname')
+            && !in_array('php_uname', $disabledFunctions, true)
+        ) {
+            $osName = "OS/" . php_uname('s') . '/' . php_uname('r');
+            if (!empty($osName)) {
+                $legacyUserAgent []= $osName;
+            }
+        }
+
+        //Add the language version
+        $legacyUserAgent []= 'lang/php/' . phpversion();
+
+        //Add exec environment if present
+        if ($executionEnvironment = getenv('AWS_EXECUTION_ENV')) {
+            $legacyUserAgent []= $executionEnvironment;
+        }
+
+        //Add the input to the end
+        if ($inputUserAgent){
+            if (!is_array($inputUserAgent)) {
+                $inputUserAgent = [$inputUserAgent];
+            }
+            $inputUserAgent = array_map('strval', $inputUserAgent);
+            $legacyUserAgent = array_merge($legacyUserAgent, $inputUserAgent);
+            $xAmzUserAgent = array_merge($xAmzUserAgent, $inputUserAgent);
+        }
+
+        $args['ua_append'] = $legacyUserAgent;
+
+        $list->appendBuild(static function (callable $handler) use (
+            $xAmzUserAgent,
+            $legacyUserAgent
+        ) {
+            return function (
+                CommandInterface $command,
+                RequestInterface $request
+            ) use ($handler, $legacyUserAgent, $xAmzUserAgent) {
+                return $handler(
+                    $command,
+                    $request->withHeader(
+                        'X-Amz-User-Agent',
+                        implode(' ', array_merge(
+                            $xAmzUserAgent,
+                            $request->getHeader('X-Amz-User-Agent')
+                        ))
+                    )->withHeader(
+                        'User-Agent',
+                        implode(' ', array_merge(
+                            $legacyUserAgent,
+                            $request->getHeader('User-Agent')
+                        ))
+                    )
+                );
+            };
+        });
+    }
+
+    public static function _apply_endpoint($value, array &$args, HandlerList $list)
+    {
+        $args['endpoint'] = $value;
+    }
+
+    public static function _apply_idempotency_auto_fill(
+        $value,
+        array &$args,
+        HandlerList $list
+    ) {
+        $enabled = false;
+        $generator = null;
+
+
+        if (is_bool($value)) {
+            $enabled = $value;
+        } elseif (is_callable($value)) {
+            $enabled = true;
+            $generator = $value;
+        }
+
+        if ($enabled) {
+            $list->prependInit(
+                IdempotencyTokenMiddleware::wrap($args['api'], $generator),
+                'idempotency_auto_fill'
+            );
+        }
+    }
+
+    public static function _default_endpoint_provider(array $args)
+    {
+        $options = self::getEndpointProviderOptions($args);
+        return PartitionEndpointProvider::defaultProvider($options)
+            ->getPartition($args['region'], $args['service']);
+    }
+
+    public static function _default_serializer(array $args)
+    {
+        return Service::createSerializer(
+            $args['api'],
+            $args['endpoint']
+        );
+    }
+
+    public static function _default_signature_provider()
+    {
+        return SignatureProvider::defaultProvider();
+    }
+
+    public static function _default_signature_version(array &$args)
+    {
+        if (isset($args['config']['signature_version'])) {
+            return $args['config']['signature_version'];
+        }
+
+        $args['__partition_result'] = isset($args['__partition_result'])
+            ? isset($args['__partition_result'])
+            : call_user_func(PartitionEndpointProvider::defaultProvider(), [
+                'service' => $args['service'],
+                'region' => $args['region'],
+            ]);
+
+        return isset($args['__partition_result']['signatureVersion'])
+            ? $args['__partition_result']['signatureVersion']
+            : $args['api']->getSignatureVersion();
+    }
+
+    public static function _default_signing_name(array &$args)
+    {
+        if (isset($args['config']['signing_name'])) {
+            return $args['config']['signing_name'];
+        }
+
+        $args['__partition_result'] = isset($args['__partition_result'])
+            ? isset($args['__partition_result'])
+            : call_user_func(PartitionEndpointProvider::defaultProvider(), [
+                'service' => $args['service'],
+                'region' => $args['region'],
+            ]);
+
+        if (isset($args['__partition_result']['signingName'])) {
+            return $args['__partition_result']['signingName'];
+        }
+
+        if ($signingName = $args['api']->getSigningName()) {
+            return $signingName;
+        }
+
+        return $args['service'];
+    }
+
+    public static function _default_signing_region(array &$args)
+    {
+        if (isset($args['config']['signing_region'])) {
+            return $args['config']['signing_region'];
+        }
+
+        $args['__partition_result'] = isset($args['__partition_result'])
+            ? isset($args['__partition_result'])
+            : call_user_func(PartitionEndpointProvider::defaultProvider(), [
+                'service' => $args['service'],
+                'region' => $args['region'],
+            ]);
+
+        return isset($args['__partition_result']['signingRegion'])
+            ? $args['__partition_result']['signingRegion']
+            : $args['region'];
+    }
+
+    public static function _missing_version(array $args)
+    {
+        $service = isset($args['service']) ? $args['service'] : '';
+        $versions = ApiProvider::defaultProvider()->getVersions($service);
+        $versions = implode("\n", array_map(function ($v) {
+            return "* \"$v\"";
+        }, $versions)) ?: '* (none found)';
+
+        return <<<EOT
+A "version" configuration value is required. Specifying a version constraint
+ensures that your code will not be affected by a breaking change made to the
+service. For example, when using Amazon S3, you can lock your API version to
+"2006-03-01".
+
+Your build of the SDK has the following version(s) of "{$service}": {$versions}
+
+You may provide "latest" to the "version" configuration value to utilize the
+most recent available API version that your client's API provider can find.
+Note: Using 'latest' in a production application is not recommended.
+
+A list of available API versions can be found on each client's API documentation
+page: http://docs.aws.amazon.com/aws-sdk-php/v3/api/index.html. If you are
+unable to load a specific API version, then you may need to update your copy of
+the SDK.
+EOT;
+    }
+
+    public static function _missing_region(array $args)
+    {
+        $service = isset($args['service']) ? $args['service'] : '';
+
+        return <<<EOT
+A "region" configuration value is required for the "{$service}" service
+(e.g., "us-west-2"). A list of available public regions and endpoints can be
+found at http://docs.aws.amazon.com/general/latest/gr/rande.html.
+EOT;
+    }
+
+    /**
+     * Extracts client options for the endpoint provider to its own array
+     *
+     * @param array $args
+     * @return array
+     */
+    private static function getEndpointProviderOptions(array $args)
+    {
+        $options = [];
+        $optionKeys = [
+            'sts_regional_endpoints',
+            's3_us_east_1_regional_endpoint',
+            ];
+        $configKeys = [
+            'use_dual_stack_endpoint',
+            'use_fips_endpoint',
+        ];
+        foreach ($optionKeys as $key) {
+            if (isset($args[$key])) {
+                $options[$key] = $args[$key];
+            }
+        }
+        foreach ($configKeys as $key) {
+            if (isset($args['config'][$key])) {
+                $options[$key] = $args['config'][$key];
+            }
+        }
+        return $options;
+    }
+
+    /**
+     * Validates a region to be used for endpoint construction
+     *
+     * @param $region
+     * @return bool
+     */
+    private static function isValidRegion($region)
+    {
+        return is_valid_hostlabel($region);
+    }
+}

--- server/vendor/aws/aws-sdk-php/src/ClientSideMonitoring/AbstractMonitoringMiddleware.php ---
@@ -0,0 +1,289 @@
+<?php
+
+namespace Aws\ClientSideMonitoring;
+
+use Aws\CommandInterface;
+use Aws\Exception\AwsException;
+use Aws\MonitoringEventsInterface;
+use Aws\ResponseContainerInterface;
+use Aws\ResultInterface;
+use GuzzleHttp\Promise;
+use Psr\Http\Message\RequestInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * @internal
+ */
+abstract class AbstractMonitoringMiddleware
+    implements MonitoringMiddlewareInterface
+{
+    private static $socket;
+
+    private $nextHandler;
+    private $options;
+    protected $credentialProvider;
+    protected $region;
+    protected $service;
+
+    protected static function getAwsExceptionHeader(AwsException $e, $headerName)
+    {
+        $response = $e->getResponse();
+        if ($response !== null) {
+            $header = $response->getHeader($headerName);
+            if (!empty($header[0])) {
+                return $header[0];
+            }
+        }
+        return null;
+    }
+
+    protected static function getResultHeader(ResultInterface $result, $headerName)
+    {
+        if (isset($result['@metadata']['headers'][$headerName])) {
+            return $result['@metadata']['headers'][$headerName];
+        }
+        return null;
+    }
+
+    protected static function getExceptionHeader(\Exception $e, $headerName)
+    {
+        if ($e instanceof ResponseContainerInterface) {
+            $response = $e->getResponse();
+            if ($response instanceof ResponseInterface) {
+                $header = $response->getHeader($headerName);
+                if (!empty($header[0])) {
+                    return $header[0];
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Constructor stores the passed in handler and options.
+     *
+     * @param callable $handler
+     * @param callable $credentialProvider
+     * @param $options
+     * @param $region
+     * @param $service
+     */
+    public function __construct(
+        callable $handler,
+        callable $credentialProvider,
+        $options,
+        $region,
+        $service
+    ) {
+        $this->nextHandler = $handler;
+        $this->credentialProvider = $credentialProvider;
+        $this->options = $options;
+        $this->region = $region;
+        $this->service = $service;
+    }
+
+    /**
+     * Standard invoke pattern for middleware execution to be implemented by
+     * child classes.
+     *
+     * @param  CommandInterface $cmd
+     * @param  RequestInterface $request
+     * @return Promise\PromiseInterface
+     */
+    public function __invoke(CommandInterface $cmd, RequestInterface $request)
+    {
+        $handler = $this->nextHandler;
+        $eventData = null;
+        $enabled = $this->isEnabled();
+
+        if ($enabled) {
+            $cmd['@http']['collect_stats'] = true;
+            $eventData = $this->populateRequestEventData(
+                $cmd,
+                $request,
+                $this->getNewEvent($cmd, $request)
+            );
+        }
+
+        $g = function ($value) use ($eventData, $enabled) {
+            if ($enabled) {
+                $eventData = $this->populateResultEventData(
+                    $value,
+                    $eventData
+                );
+                $this->sendEventData($eventData);
+
+                if ($value instanceof MonitoringEventsInterface) {
+                    $value->appendMonitoringEvent($eventData);
+                }
+            }
+            if ($value instanceof \Exception || $value instanceof \Throwable) {
+                return Promise\Create::rejectionFor($value);
+            }
+            return $value;
+        };
+
+        return Promise\Create::promiseFor($handler($cmd, $request))->then($g, $g);
+    }
+
+    private function getClientId()
+    {
+        return $this->unwrappedOptions()->getClientId();
+    }
+
+    private function getNewEvent(
+        CommandInterface $cmd,
+        RequestInterface $request
+    ) {
+        $event = [
+            'Api' => $cmd->getName(),
+            'ClientId' => $this->getClientId(),
+            'Region' => $this->getRegion(),
+            'Service' => $this->getService(),
+            'Timestamp' => (int) floor(microtime(true) * 1000),
+            'UserAgent' => substr(
+                $request->getHeaderLine('User-Agent') . ' ' . \Aws\default_user_agent(),
+                0,
+                256
+            ),
+            'Version' => 1
+        ];
+        return $event;
+    }
+
+    private function getHost()
+    {
+        return $this->unwrappedOptions()->getHost();
+    }
+
+    private function getPort()
+    {
+        return $this->unwrappedOptions()->getPort();
+    }
+
+    private function getRegion()
+    {
+        return $this->region;
+    }
+
+    private function getService()
+    {
+        return $this->service;
+    }
+
+    /**
+     * Returns enabled flag from options, unwrapping options if necessary.
+     *
+     * @return bool
+     */
+    private function isEnabled()
+    {
+        return $this->unwrappedOptions()->isEnabled();
+    }
+
+    /**
+     * Returns $eventData array with information from the request and command.
+     *
+     * @param CommandInterface $cmd
+     * @param RequestInterface $request
+     * @param array $event
+     * @return array
+     */
+    protected function populateRequestEventData(
+        CommandInterface $cmd,
+        RequestInterface $request,
+        array $event
+    ) {
+        $dataFormat = static::getRequestData($request);
+        foreach ($dataFormat as $eventKey => $value) {
+            if ($value !== null) {
+                $event[$eventKey] = $value;
+            }
+        }
+        return $event;
+    }
+
+    /**
+     * Returns $eventData array with information from the response, including
+     * the calculation for attempt latency.
+     *
+     * @param ResultInterface|\Exception $result
+     * @param array $event
+     * @return array
+     */
+    protected function populateResultEventData(
+        $result,
+        array $event
+    ) {
+        $dataFormat = static::getResponseData($result);
+        foreach ($dataFormat as $eventKey => $value) {
+            if ($value !== null) {
+                $event[$eventKey] = $value;
+            }
+        }
+        return $event;
+    }
+
+    /**
+     * Creates a UDP socket resource and stores it with the class, or retrieves
+     * it if already instantiated and connected. Handles error-checking and
+     * re-connecting if necessary. If $forceNewConnection is set to true, a new
+     * socket will be created.
+     *
+     * @param bool $forceNewConnection
+     * @return Resource
+     */
+    private function prepareSocket($forceNewConnection = false)
+    {
+        if (!is_resource(self::$socket)
+            || $forceNewConnection
+            || socket_last_error(self::$socket)
+        ) {
+            self::$socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);
+            socket_clear_error(self::$socket);
+            socket_connect(self::$socket, $this->getHost(), $this->getPort());
+        }
+
+        return self::$socket;
+    }
+
+    /**
+     * Sends formatted monitoring event data via the UDP socket connection to
+     * the CSM agent endpoint.
+     *
+     * @param array $eventData
+     * @return int
+     */
+    private function sendEventData(array $eventData)
+    {
+        $socket = $this->prepareSocket();
+        $datagram = json_encode($eventData);
+        $result = socket_write($socket, $datagram, strlen($datagram));
+        if ($result === false) {
+            $this->prepareSocket(true);
+        }
+        return $result;
+    }
+
+    /**
+     * Unwraps options, if needed, and returns them.
+     *
+     * @return ConfigurationInterface
+     */
+    private function unwrappedOptions()
+    {
+        if (!($this->options instanceof ConfigurationInterface)) {
+            try {
+                $this->options = ConfigurationProvider::unwrap($this->options);
+            } catch (\Exception $e) {
+                // Errors unwrapping CSM config defaults to disabling it
+                $this->options = new Configuration(
+                    false,
+                    ConfigurationProvider::DEFAULT_HOST,
+                    ConfigurationProvider::DEFAULT_PORT
+                );
+            }
+        }
+        return $this->options;
+    }
+}
\ No newline at end of file

--- server/vendor/aws/aws-sdk-php/src/ClientSideMonitoring/ApiCallAttemptMonitoringMiddleware.php ---
@@ -0,0 +1,262 @@
+<?php
+
+namespace Aws\ClientSideMonitoring;
+
+use Aws\CommandInterface;
+use Aws\Credentials\CredentialsInterface;
+use Aws\Exception\AwsException;
+use Aws\ResponseContainerInterface;
+use Aws\ResultInterface;
+use Psr\Http\Message\RequestInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * @internal
+ */
+class ApiCallAttemptMonitoringMiddleware extends AbstractMonitoringMiddleware
+{
+
+    /**
+     * Standard middleware wrapper function with CSM options passed in.
+     *
+     * @param callable $credentialProvider
+     * @param mixed  $options
+     * @param string $region
+     * @param string $service
+     * @return callable
+     */
+    public static function wrap(
+        callable $credentialProvider,
+        $options,
+        $region,
+        $service
+    ) {
+        return function (callable $handler) use (
+            $credentialProvider,
+            $options,
+            $region,
+            $service
+        ) {
+            return new static(
+                $handler,
+                $credentialProvider,
+                $options,
+                $region,
+                $service
+            );
+        };
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public static function getRequestData(RequestInterface $request)
+    {
+        return [
+            'Fqdn' => $request->getUri()->getHost(),
+        ];
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    public static function getResponseData($klass)
+    {
+        if ($klass instanceof ResultInterface) {
+            return [
+                'AttemptLatency' => self::getResultAttemptLatency($klass),
+                'DestinationIp' => self::getResultDestinationIp($klass),
+                'DnsLatency' => self::getResultDnsLatency($klass),
+                'HttpStatusCode' => self::getResultHttpStatusCode($klass),
+                'XAmzId2' => self::getResultHeader($klass, 'x-amz-id-2'),
+                'XAmzRequestId' => self::getResultHeader($klass, 'x-amz-request-id'),
+                'XAmznRequestId' => self::getResultHeader($klass, 'x-amzn-RequestId'),
+            ];
+        }
+        if ($klass instanceof AwsException) {
+            return [
+                'AttemptLatency' => self::getAwsExceptionAttemptLatency($klass),
+                'AwsException' => substr(
+                    self::getAwsExceptionErrorCode($klass),
+                    0,
+                    128
+                ),
+                'AwsExceptionMessage' => substr(
+                    self::getAwsExceptionMessage($klass),
+                    0,
+                    512
+                ),
+                'DestinationIp' => self::getAwsExceptionDestinationIp($klass),
+                'DnsLatency' => self::getAwsExceptionDnsLatency($klass),
+                'HttpStatusCode' => self::getAwsExceptionHttpStatusCode($klass),
+                'XAmzId2' => self::getAwsExceptionHeader($klass, 'x-amz-id-2'),
+                'XAmzRequestId' => self::getAwsExceptionHeader(
+                    $klass,
+                    'x-amz-request-id'
+                ),
+                'XAmznRequestId' => self::getAwsExceptionHeader(
+                    $klass,
+                    'x-amzn-RequestId'
+                ),
+            ];
+        }
+        if ($klass instanceof \Exception) {
+            return [
+                'HttpStatusCode' => self::getExceptionHttpStatusCode($klass),
+                'SdkException' => substr(
+                    self::getExceptionCode($klass),
+                    0,
+                    128
+                ),
+                'SdkExceptionMessage' => substr(
+                    self::getExceptionMessage($klass),
+                    0,
+                    512
+                ),
+                'XAmzId2' => self::getExceptionHeader($klass, 'x-amz-id-2'),
+                'XAmzRequestId' => self::getExceptionHeader($klass, 'x-amz-request-id'),
+                'XAmznRequestId' => self::getExceptionHeader($klass, 'x-amzn-RequestId'),
+            ];
+        }
+
+        throw new \InvalidArgumentException('Parameter must be an instance of ResultInterface, AwsException or Exception.');
+    }
+
+    private static function getResultAttemptLatency(ResultInterface $result)
+    {
+        if (isset($result['@metadata']['transferStats']['http'])) {
+            $attempt = end($result['@metadata']['transferStats']['http']);
+            if (isset($attempt['total_time'])) {
+                return (int) floor($attempt['total_time'] * 1000);
+            }
+        }
+        return null;
+    }
+
+    private static function getResultDestinationIp(ResultInterface $result)
+    {
+        if (isset($result['@metadata']['transferStats']['http'])) {
+            $attempt = end($result['@metadata']['transferStats']['http']);
+            if (isset($attempt['primary_ip'])) {
+                return $attempt['primary_ip'];
+            }
+        }
+        return null;
+    }
+
+    private static function getResultDnsLatency(ResultInterface $result)
+    {
+        if (isset($result['@metadata']['transferStats']['http'])) {
+            $attempt = end($result['@metadata']['transferStats']['http']);
+            if (isset($attempt['namelookup_time'])) {
+                return (int) floor($attempt['namelookup_time'] * 1000);
+            }
+        }
+        return null;
+    }
+
+    private static function getResultHttpStatusCode(ResultInterface $result)
+    {
+        return $result['@metadata']['statusCode'];
+    }
+
+    private static function getAwsExceptionAttemptLatency(AwsException $e) {
+        $attempt = $e->getTransferInfo();
+        if (isset($attempt['total_time'])) {
+            return (int) floor($attempt['total_time'] * 1000);
+        }
+        return null;
+    }
+
+    private static function getAwsExceptionErrorCode(AwsException $e) {
+        return $e->getAwsErrorCode();
+    }
+
+    private static function getAwsExceptionMessage(AwsException $e) {
+        return $e->getAwsErrorMessage();
+    }
+
+    private static function getAwsExceptionDestinationIp(AwsException $e) {
+        $attempt = $e->getTransferInfo();
+        if (isset($attempt['primary_ip'])) {
+            return $attempt['primary_ip'];
+        }
+        return null;
+    }
+
+    private static function getAwsExceptionDnsLatency(AwsException $e) {
+        $attempt = $e->getTransferInfo();
+        if (isset($attempt['namelookup_time'])) {
+            return (int) floor($attempt['namelookup_time'] * 1000);
+        }
+        return null;
+    }
+
+    private static function getAwsExceptionHttpStatusCode(AwsException $e) {
+        $response = $e->getResponse();
+        if ($response !== null) {
+            return $response->getStatusCode();
+        }
+        return null;
+    }
+
+    private static function getExceptionHttpStatusCode(\Exception $e) {
+        if ($e instanceof ResponseContainerInterface) {
+            $response = $e->getResponse();
+            if ($response instanceof ResponseInterface) {
+                return $response->getStatusCode();
+            }
+        }
+        return null;
+    }
+
+    private static function getExceptionCode(\Exception $e) {
+        if (!($e instanceof AwsException)) {
+            return get_class($e);
+        }
+        return null;
+    }
+
+    private static function getExceptionMessage(\Exception $e) {
+        if (!($e instanceof AwsException)) {
+            return $e->getMessage();
+        }
+        return null;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    protected function populateRequestEventData(
+        CommandInterface $cmd,
+        RequestInterface $request,
+        array $event
+    ) {
+        $event = parent::populateRequestEventData($cmd, $request, $event);
+        $event['Type'] = 'ApiCallAttempt';
+        return $event;
+    }
+
+    /**
+     * {@inheritdoc}
+     */
+    protected function populateResultEventData(
+        $result,
+        array $event
+    ) {
+        $event = parent::populateResultEventData($result, $event);
+
+        $provider = $this->credentialProvider;
+        /** @var CredentialsInterface $credentials */
+        $credentials = $provider()->wait();
+        $event['AccessKey'] = $credentials->getAccessKeyId();
+        $sessionToken = $credentials->getSecurityToken();
+        if ($sessionToken !== null) {
+            $event['SessionToken'] = $sessionToken;
+        }
+        if (empty($event['AttemptLatency'])) {
+            $event['AttemptLatency'] = (int) (floor(microtime(true) * 1000) - $event['Timestamp']);
+        }
+        return $event;
+    }
+}

