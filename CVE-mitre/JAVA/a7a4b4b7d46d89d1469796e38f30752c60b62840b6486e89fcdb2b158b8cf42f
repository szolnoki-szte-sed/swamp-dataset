--- src/integrationTest/java/uk/gov/hmcts/probate/service/NotificationServiceIT.java ---
@@ -64,6 +64,7 @@
 
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
@@ -136,6 +137,8 @@ class NotificationServiceIT {
     private static final String PERSONALISATION_NOC_SUBMITTED_DATE = "noc_date";
     private static final String PERSONALISATION_OLD_SOLICITOR_NAME = "old_solicitor_name";
     private static final DateTimeFormatter NOC_DATE = DateTimeFormatter.ofPattern("dd/MM/yyyy");
+    private static final String MARKDOWN_ERROR_MESSAGE
+            = "Markdown Link detected in case data, stop sending notification email.";
 
     @Autowired
     private NotificationService notificationService;
@@ -222,6 +225,8 @@ class NotificationServiceIT {
     private CaveatData caveatData;
     private CallbackRequest callbackRequest;
     private CaveatDetails caveatStoppedCtscCaseData;
+    private CaseDetails  markdownLinkCaseData;
+    private CaveatDetails markdownLinkCaveatData;
 
     @Mock
     private RegistriesProperties registriesPropertiesMock;
@@ -597,6 +602,23 @@ public void setUp() throws NotificationClientException, IOException {
             .deceasedDateOfDeath(LocalDate.of(2000, 12, 12))
             .build(), LAST_MODIFIED, ID);
 
+        markdownLinkCaseData = new CaseDetails(CaseData.builder()
+                .applicationType(PERSONAL)
+                .registryLocation("Oxford")
+                .solsSOTName("SOTName")
+                .deceasedForenames("Some text [example](http://example.com)")
+                .primaryApplicantEmailAddress("primary@probate-test.com")
+                .deceasedDateOfDeath(LocalDate.of(2000, 12, 12))
+                .build(), LAST_MODIFIED, ID);
+
+        markdownLinkCaveatData = new CaveatDetails(CaveatData.builder()
+                .applicationType(PERSONAL)
+                .registryLocation("Oxford")
+                .caveatorEmailAddress("caveator@probate-test.com")
+                .messageContent("Some text [example](http://example.com)")
+                .deceasedDateOfDeath(LocalDate.of(2000, 12, 12))
+                .build(), LAST_MODIFIED, ID);
+
         CollectionMember<CaseMatch> caseMatchMember = new CollectionMember<>(CaseMatch.builder().build());
         List<CollectionMember<CaseMatch>> caseMatch = new ArrayList<>();
         caseMatch.add(caseMatchMember);
@@ -2136,4 +2158,55 @@ void verifySendCaveatNocEmail()
 
         verify(pdfManagementService).generateAndUpload(any(SentEmail.class), eq(SENT_EMAIL));
     }
+
+    @Test
+    void throwExceptionSendEmailWhenInvalidPersonalisationExists() {
+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,
+                () -> notificationService.sendEmail(CASE_STOPPED, markdownLinkCaseData));
+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());
+    }
+
+    @Test
+    void throwExceptionSendExecutorEmailWhenInvalidPersonalisationExists() {
+        ExecutorsApplyingNotification executorsApplyingNotification = ExecutorsApplyingNotification.builder()
+                .name(personalCaseDataCtscRequestInformation.getData().getPrimaryApplicantFullName())
+                .address(SolsAddress.builder()
+                        .addressLine1("Addressline1")
+                        .postCode("postcode")
+                        .postTown("posttown")
+                        .build())
+                .email("primary@probate-test.com")
+                .notification("Yes").build();
+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,
+                () -> notificationService.sendEmail(CASE_STOPPED_REQUEST_INFORMATION,
+                        markdownLinkCaseData, executorsApplyingNotification));
+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());
+    }
+
+    @Test
+    void throwExceptionSendCaveatEmailWhenInvalidPersonalisationExists() {
+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,
+                () -> notificationService.sendCaveatEmail(GENERAL_CAVEAT_MESSAGE, markdownLinkCaveatData));
+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());
+    }
+
+    @Test
+    void throwExceptionSendEmailWithDocumentAttachedWhenInvalidPersonalisationExists() {
+        CollectionMember<Document> doc = new CollectionMember<>(Document.builder().build());
+
+        markdownLinkCaseData.getData().getProbateSotDocumentsGenerated().add(doc);
+        ExecutorsApplyingNotification executorsApplyingNotification = ExecutorsApplyingNotification.builder()
+                .name(markdownLinkCaseData.getData().getSolsSOTName())
+                .address(SolsAddress.builder()
+                        .addressLine1("Addressline1")
+                        .postCode("postcode")
+                        .postTown("posttown")
+                        .build())
+                .email("primary@probate-test.com")
+                .notification("Yes").build();
+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,
+                () -> notificationService.sendEmailWithDocumentAttached(markdownLinkCaseData,
+                        executorsApplyingNotification, REDECLARATION_SOT));
+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());
+    }
 }

--- src/main/java/uk/gov/hmcts/probate/service/NotificationService.java ---
@@ -37,6 +37,7 @@
 import uk.gov.hmcts.probate.service.notification.TemplateService;
 import uk.gov.hmcts.probate.service.template.pdf.PDFManagementService;
 import uk.gov.hmcts.probate.validator.EmailAddressNotifyValidationRule;
+import uk.gov.hmcts.probate.validator.PersonalisationValidationRule;
 import uk.gov.hmcts.reform.authorisation.generators.AuthTokenGenerator;
 import uk.gov.hmcts.reform.probate.model.cases.RegistryLocation;
 import uk.gov.service.notify.NotificationClient;
@@ -68,6 +69,9 @@ public class NotificationService {
     private static final String PERSONALISATION_APPLICANT_NAME = "applicant_name";
     private static final String PERSONALISATION_SOT_LINK = "sot_link";
     private static final DateTimeFormatter RELEASE_DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
+    private static final String INVALID_PERSONALISATION_ERROR_MESSAGE =
+            "Markdown Link detected in case data, stop sending notification email.";
+
     @Autowired
     private final EmailAddresses emailAddresses;
     private final NotificationTemplates notificationTemplates;
@@ -85,6 +89,7 @@ public class NotificationService {
     private final AuthTokenGenerator serviceAuthTokenGenerator;
     private final NotificationClientService notificationClientService;
     private final DocumentManagementService documentManagementService;
+    private final PersonalisationValidationRule personalisationValidationRule;
     @Autowired
     private BusinessValidationMessageService businessValidationMessageService;
     @Value("${notifications.grantDelayedNotificationPeriodDays}")
@@ -122,7 +127,12 @@ public Document sendEmail(State state, CaseDetails caseDetails, Optional<CaseOri
         if (state == state.CASE_STOPPED_CAVEAT) {
             personalisation = caveatPersonalisationService.getCaveatStopPersonalisation(personalisation, caseData);
         }
-
+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);
+        if (!invalidPersonalisation.isEmpty()) {
+            log.error("Personalisation validation failed for case: {} fields: {}",
+                    caseDetails.getId(), invalidPersonalisation);
+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);
+        }
         if (caseData.getApplicationType().equals(ApplicationType.SOLICITOR)) {
             if (!StringUtils.isEmpty(caseData.getSolsSOTName())) {
                 personalisation.replace(PERSONALISATION_APPLICANT_NAME, caseData.getSolsSOTName());
@@ -159,7 +169,12 @@ public Document sendEmail(State state, CaseDetails caseDetails, ExecutorsApplyin
         String emailReplyToId = registry.getEmailReplyToId();
 
         personalisation.replace(PERSONALISATION_APPLICANT_NAME, executor.getName());
-
+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);
+        if (!invalidPersonalisation.isEmpty()) {
+            log.error("Personalisation validation failed for case: {} fields: {}",
+                    caseDetails.getId(), invalidPersonalisation);
+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);
+        }
         SendEmailResponse response =
             getSendEmailResponse(state, templateId, emailReplyToId, emailAddress, personalisation, reference,
                 caseDetails.getId());
@@ -233,7 +248,12 @@ public Document sendCaveatEmail(State state, CaveatDetails caveatDetails)
         }
 
         String reference = caveatDetails.getId().toString();
-
+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);
+        if (!invalidPersonalisation.isEmpty()) {
+            log.error("Personalisation validation failed for case: {} fields: {}",
+                    caveatDetails.getId(), invalidPersonalisation);
+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);
+        }
         SendEmailResponse response;
         response = notificationClientService.sendEmail(caveatDetails.getId(), templateId, emailAddress,
             personalisation, reference);
@@ -300,18 +320,22 @@ public Document sendEmailWithDocumentAttached(CaseDetails caseDetails, Executors
         Registry registry =
             registriesProperties.getRegistries().get(caseDetails.getData().getRegistryLocation().toLowerCase());
 
-        String templateId = templateService.getTemplateId(state, caseDetails.getData().getApplicationType(),
-            caseDetails.getData().getRegistryLocation(),
-            caseDetails.getData().getLanguagePreference());
-        String emailReplyToId = registry.getEmailReplyToId();
-
         Map<String, Object> personalisation =
             grantOfRepresentationPersonalisationService.getPersonalisation(caseDetails, registry);
         grantOfRepresentationPersonalisationService.addSingleAddressee(personalisation, executor.getName());
 
         personalisation.put(PERSONALISATION_SOT_LINK, prepareUpload(sotDocument));
-
+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);
+        if (!invalidPersonalisation.isEmpty()) {
+            log.error("Personalisation validation failed for case: {} fields: {}",
+                    caseDetails.getId(), invalidPersonalisation);
+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);
+        }
         String reference = caseDetails.getData().getSolsSolicitorAppReference();
+        String templateId = templateService.getTemplateId(state, caseDetails.getData().getApplicationType(),
+                caseDetails.getData().getRegistryLocation(),
+                caseDetails.getData().getLanguagePreference());
+        String emailReplyToId = registry.getEmailReplyToId();
 
         SendEmailResponse response =
             getSendEmailResponse(state, templateId, emailReplyToId, executor.getEmail(), personalisation, reference,
@@ -365,6 +389,12 @@ private Document sendGrantNotificationEmail(ReturnedCaseDetails caseDetails, Str
             registriesProperties.getRegistries().get(caseDetails.getData().getRegistryLocation().toLowerCase());
         Map<String, Object> personalisation =
             grantOfRepresentationPersonalisationService.getPersonalisation(caseDetails, registry);
+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);
+        if (!invalidPersonalisation.isEmpty()) {
+            log.error("Personalisation validation failed for case: {} fields: {}",
+                    caseDetails.getId(), invalidPersonalisation);
+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);
+        }
         String reference = caseDetails.getData().getSolsSolicitorAppReference();
         String emailAddress = caseDetails.getData().getApplicationType().equals(ApplicationType.PERSONAL)
             ? caseDetails.getData().getPrimaryApplicantEmailAddress() : caseDetails.getData().getSolsSolicitorEmail();

--- src/main/java/uk/gov/hmcts/probate/validator/PersonalisationValidationRule.java ---
@@ -0,0 +1,35 @@
+package uk.gov.hmcts.probate.validator;
+
+import lombok.RequiredArgsConstructor;
+import org.springframework.stereotype.Component;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+@Component
+@RequiredArgsConstructor
+public class PersonalisationValidationRule {
+
+    private final Pattern markdownLinkPattern =
+            Pattern.compile("^\\[(.*?)]\\((https?:\\/\\/.*?)\\)$", Pattern.CASE_INSENSITIVE);
+
+    public <T> List<String> validatePersonalisation(Map<String, T> personalisation) {
+        List<String> invalidFields = new ArrayList<>();
+        for (var entry : personalisation.entrySet()) {
+            if (entry.getValue() != null) {
+                String entryValue = entry.getValue().toString();
+                int firstIndex = entryValue.indexOf('[');
+                int secondIndex = entryValue.indexOf(')');
+                if (firstIndex != -1 && secondIndex != -1 && firstIndex < secondIndex) {
+                    String valueToValidate = entryValue.substring(firstIndex, secondIndex + 1);
+                    if (!valueToValidate.isEmpty() && markdownLinkPattern.matcher(valueToValidate).find()) {
+                        invalidFields.add(entry.getKey());
+                    }
+                }
+            }
+        }
+        return invalidFields;
+    }
+}

--- src/test/java/uk/gov/hmcts/probate/validator/PersonalisationValidationRuleTest.java ---
@@ -0,0 +1,57 @@
+package uk.gov.hmcts.probate.validator;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.InjectMocks;
+import org.mockito.MockitoAnnotations;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class PersonalisationValidationRuleTest {
+
+    @InjectMocks
+    private PersonalisationValidationRule personalisationValidationRule;
+
+    @BeforeEach
+    void setUp() {
+        MockitoAnnotations.openMocks(this);
+    }
+
+    @Test
+    void shouldReturnFielNameWithHyperLinkWhereValidatePersonilization() {
+        Map<String, Object> personalisation = new HashMap<>();
+        personalisation.put("field1", "Some text [example](http://example.com)");
+        personalisation.put("field2", "Valid text");
+
+        List<String> result = personalisationValidationRule.validatePersonalisation(personalisation);
+
+        assertEquals(1, result.size());
+        assertTrue(result.contains("field1"));
+    }
+
+    @Test
+    void shouldRetunEmptyListWhereNoMarkDownLink() {
+        Map<String, Object> personalisation = new HashMap<>();
+        personalisation.put("field1", "Some text");
+        personalisation.put("field2", "Another  text");
+
+        List<String> result = personalisationValidationRule.validatePersonalisation(personalisation);
+
+        assertTrue(result.isEmpty());
+    }
+
+    @Test
+    void shouldRetunEmptyListForNullValid() {
+        Map<String, Object> personalisation = new HashMap<>();
+        personalisation.put("field1", null);
+
+        List<String> result = personalisationValidationRule.validatePersonalisation(personalisation);
+
+        assertTrue(result.isEmpty());
+    }
+}
\ No newline at end of file

