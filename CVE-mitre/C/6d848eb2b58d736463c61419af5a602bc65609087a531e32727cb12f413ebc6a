--- CMakeLists.txt ---
@@ -8,7 +8,7 @@ else()
 endif()
 
 project(picoquic
-        VERSION 1.1.30.2
+        VERSION 1.1.31.0
         DESCRIPTION "picoquic library"
         LANGUAGES C CXX)
 
@@ -105,6 +105,7 @@ set(PICOQUIC_LIBRARY_FILES
     picoquic/sacks.c
     picoquic/sender.c
     picoquic/sim_link.c
+    picoquic/siphash.c
     picoquic/sockloop.c
     picoquic/spinbit.c
     picoquic/ticket_store.c
@@ -124,7 +125,8 @@ set(PICOQUIC_CORE_HEADERS
      picoquic/picoquic_logger.h
      picoquic/picoquic_binlog.h
      picoquic/picoquic_config.h
-     picoquic/picoquic_lb.h)
+     picoquic/picoquic_lb.h
+     picoquic/siphash.h)
 
 set(LOGLIB_LIBRARY_FILES
     loglib/autoqlog.c

--- UnitTest1/unittest1.cpp ---
@@ -48,6 +48,20 @@ namespace UnitTest1
             Assert::AreEqual(ret, 0);
         }
 
+        TEST_METHOD(picohash_bytes)
+        {
+            int ret = picohash_bytes_test();
+
+            Assert::AreEqual(ret, 0);
+        }
+
+        TEST_METHOD(siphash)
+        {
+            int ret = siphash_test();
+
+            Assert::AreEqual(ret, 0);
+        }
+
         TEST_METHOD(picolog_basic)
         {
             int ret = picolog_basic_test();

--- loglib/cidset.c ---
@@ -24,10 +24,10 @@
 #include "picoquic_utils.h"
 
 /* Hash and compare for CNX hash tables */
-static uint64_t picoquic_cid_hash(const void* key)
+static uint64_t picoquic_cid_hash(const void* key, const uint8_t * hash_seed)
 {
     const picoquic_connection_id_t* cid = (const picoquic_connection_id_t*)key;
-    return picoquic_connection_id_hash(cid);
+    return picoquic_connection_id_hash(cid, hash_seed);
 }
 
 static int picoquic_cid_compare(const void* key0, const void* key1)

--- picoquic/picohash.c ---
@@ -23,14 +23,17 @@
  * Basic hash implementation, like we have seen tons off already.
  */
 #include "picohash.h"
+#include "siphash.h"
 #include <stdlib.h>
 #include <string.h>
 
 picohash_table* picohash_create_ex(size_t nb_bin,
-    uint64_t (*picohash_hash)(const void*),
+    uint64_t (*picohash_hash)(const void*, const uint8_t *),
     int (*picohash_compare)(const void*, const void*),
-    picohash_item * (*picohash_key_to_item)(const void*))
+    picohash_item * (*picohash_key_to_item)(const void*),
+    const uint8_t* hash_seed)
 {
+    static const uint8_t null_seed[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
     picohash_table* t = (picohash_table*)malloc(sizeof(picohash_table));
     size_t items_length = sizeof(picohash_item*) * nb_bin;
     t->hash_bin = NULL;
@@ -48,21 +51,22 @@ picohash_table* picohash_create_ex(size_t nb_bin,
         t->picohash_hash = picohash_hash;
         t->picohash_compare = picohash_compare;
         t->picohash_key_to_item = picohash_key_to_item;
+        t->hash_seed = (hash_seed == NULL)? null_seed: hash_seed;
     }
 
     return t;
 }
 
 picohash_table* picohash_create(size_t nb_bin,
-    uint64_t(*picohash_hash)(const void*),
+    uint64_t(*picohash_hash)(const void*, const uint8_t*),
     int (*picohash_compare)(const void*, const void*))
 {
-    return picohash_create_ex(nb_bin, picohash_hash, picohash_compare, NULL);
+    return picohash_create_ex(nb_bin, picohash_hash, picohash_compare, NULL, NULL);
 }
 
 picohash_item* picohash_retrieve(picohash_table* hash_table, const void* key)
 {
-    uint64_t hash = hash_table->picohash_hash(key);
+    uint64_t hash = hash_table->picohash_hash(key, hash_table->hash_seed);
     uint32_t bin = (uint32_t)(hash % hash_table->nb_bin);
     picohash_item* item = hash_table->hash_bin[bin];
 
@@ -79,7 +83,7 @@ picohash_item* picohash_retrieve(picohash_table* hash_table, const void* key)
 
 int picohash_insert(picohash_table* hash_table, const void* key)
 {
-    uint64_t hash = hash_table->picohash_hash(key);
+    uint64_t hash = hash_table->picohash_hash(key, hash_table->hash_seed);
     uint32_t bin = (uint32_t)(hash % hash_table->nb_bin);
     int ret = 0;
     picohash_item* item;
@@ -150,19 +154,21 @@ void picohash_delete_key(picohash_table* hash_table, void* key, int delete_key_t
 
 void picohash_delete(picohash_table* hash_table, int delete_key_too)
 {
-    for (uint32_t i = 0; i < hash_table->nb_bin; i++) {
-        picohash_item* item = hash_table->hash_bin[i];
-        while (item != NULL) {
-            picohash_item* tmp = item;
-            const void* key_to_delete = tmp->key;
-
-            item = item->next_in_bin;
-
-            if (hash_table->picohash_key_to_item == NULL) {
-                free(tmp);
-            }
-            if (delete_key_too) {
-                free((void*)key_to_delete);
+    if (hash_table->count > 0) {
+        for (uint32_t i = 0; i < hash_table->nb_bin; i++) {
+            picohash_item* item = hash_table->hash_bin[i];
+            while (item != NULL) {
+                picohash_item* tmp = item;
+                const void* key_to_delete = tmp->key;
+
+                item = item->next_in_bin;
+
+                if (hash_table->picohash_key_to_item == NULL) {
+                    free(tmp);
+                }
+                if (delete_key_too) {
+                    free((void*)key_to_delete);
+                }
             }
         }
     }
@@ -171,23 +177,43 @@ void picohash_delete(picohash_table* hash_table, int delete_key_too)
     free(hash_table);
 }
 
-uint64_t picohash_hash_mix(uint64_t hash, uint64_t h2)
-{
-    h2 ^= (hash << 17) ^ (hash >> 37);
-    hash ^= ((h2 << 31) ^ (h2 >> 17));
-
-    return hash;
-}
-
-uint64_t picohash_bytes(const uint8_t* key, uint32_t length)
+uint64_t picohash_bytes(const uint8_t* bytes, size_t length, const uint8_t* hash_seed)
 {
-    uint64_t hash = 0xDEADBEEF;
+    uint64_t hash =
+        ((uint64_t)hash_seed[8]) +
+        (((uint64_t)hash_seed[9]) << 8) +
+        (((uint64_t)hash_seed[10]) << 16) +
+        (((uint64_t)hash_seed[11]) << 24) +
+        (((uint64_t)hash_seed[12]) << 32) +
+        (((uint64_t)hash_seed[13]) << 40) +
+        (((uint64_t)hash_seed[14]) << 48) +
+        (((uint64_t)hash_seed[15]) << 56);
+    int rotate = 11;
 
     for (uint32_t i = 0; i < length; i++) {
-        hash ^= key[i];
-        hash ^= ((hash << 31) ^ (hash >> 17));
+        hash ^= bytes[i];
+        hash ^= hash_seed[i & 15];
+        hash ^= (hash << 8);
+        hash += (hash >> rotate);
+        rotate = (int)(hash & 31) + 11;
     }
-
+    hash ^= (hash >> rotate);
     return hash;
 }
 
+uint64_t picohash_siphash(const uint8_t* bytes, size_t length, const uint8_t* hash_seed)
+{
+    uint8_t sip_out[8];
+    uint64_t hash;
+    (void)siphash(bytes, length, hash_seed, sip_out, 8);
+    hash =
+        (uint64_t)sip_out[0] +
+        (((uint64_t)sip_out[1]) << 8) +
+        (((uint64_t)sip_out[2]) << 16) +
+        (((uint64_t)sip_out[3]) << 24) +
+        (((uint64_t)sip_out[4]) << 32) +
+        (((uint64_t)sip_out[5]) << 40) +
+        (((uint64_t)sip_out[6]) << 48) +
+        (((uint64_t)sip_out[7]) << 56);
+    return hash;
+}
\ No newline at end of file

--- picoquic/picohash.h ---
@@ -44,19 +44,21 @@ typedef struct picohash_table {
     picohash_item** hash_bin;
     size_t nb_bin;
     size_t count;
-    uint64_t (*picohash_hash)(const void*);
+    const uint8_t* hash_seed;
+    uint64_t (*picohash_hash)(const void*, const uint8_t*);
     int (*picohash_compare)(const void*, const void*);
     picohash_item* (*picohash_key_to_item)(const void*);
 } picohash_table;
 
 picohash_table* picohash_create(size_t nb_bin,
-    uint64_t (*picohash_hash)(const void*),
+    uint64_t (*picohash_hash)(const void*, const uint8_t*),
     int (*picohash_compute)(const void*, const void*));
 
 picohash_table* picohash_create_ex(size_t nb_bin,
-    uint64_t(*picohash_hash)(const void*),
+    uint64_t(*picohash_hash)(const void*, const uint8_t*),
     int (*picohash_compare)(const void*, const void*),
-    picohash_item* (*picohash_key_to_item)(const void*));
+    picohash_item* (*picohash_key_to_item)(const void*),
+    const uint8_t* hash_seed);
 
 picohash_item* picohash_retrieve(picohash_table* hash_table, const void* key);
 
@@ -68,9 +70,9 @@ void picohash_delete_key(picohash_table* hash_table, void* key, int delete_key_t
 
 void picohash_delete(picohash_table* hash_table, int delete_key_too);
 
-uint64_t picohash_hash_mix(uint64_t hash, uint64_t h2);
+uint64_t picohash_bytes(const uint8_t* key, size_t length, const uint8_t* hash_seed);
 
-uint64_t picohash_bytes(const uint8_t* key, uint32_t length);
+uint64_t picohash_siphash(const uint8_t* bytes, size_t length, const uint8_t* hash_seed);
 
 #ifdef __cplusplus
 }

--- picoquic/picoquic.h ---
@@ -40,7 +40,7 @@
 extern "C" {
 #endif
 
-#define PICOQUIC_VERSION "1.1.30.2"
+#define PICOQUIC_VERSION "1.1.31.0"
 #define PICOQUIC_ERROR_CLASS 0x400
 #define PICOQUIC_ERROR_DUPLICATE (PICOQUIC_ERROR_CLASS + 1)
 #define PICOQUIC_ERROR_AEAD_CHECK (PICOQUIC_ERROR_CLASS + 3)

--- picoquic/picoquic.vcxproj ---
@@ -175,6 +175,7 @@
     <ClCompile Include="sender.c" />
     <ClCompile Include="bbr.c" />
     <ClCompile Include="sim_link.c" />
+    <ClCompile Include="siphash.c" />
     <ClCompile Include="sockloop.c" />
     <ClCompile Include="spinbit.c" />
     <ClCompile Include="ticket_store.c" />

--- picoquic/picoquic.vcxproj.filters ---
@@ -138,6 +138,9 @@
     <ClCompile Include="pacing.c">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="siphash.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="picoquic.h">

--- picoquic/picoquic_internal.h ---
@@ -613,7 +613,7 @@ typedef struct st_picoquic_quic_t {
     uint8_t reset_seed[PICOQUIC_RESET_SECRET_SIZE];
     uint8_t retry_seed[PICOQUIC_RETRY_SECRET_SIZE];
     uint64_t* p_simulated_time;
-    uint8_t hash_seed[8];
+    uint8_t hash_seed[16];
     char const* ticket_file_name;
     char const* token_file_name;
     picoquic_stored_ticket_t * p_first_ticket;

--- picoquic/picoquic_utils.h ---
@@ -90,9 +90,10 @@ uint8_t picoquic_format_connection_id(uint8_t* bytes, size_t bytes_max, picoquic
 uint8_t picoquic_parse_connection_id(const uint8_t* bytes, uint8_t len, picoquic_connection_id_t *cnx_id);
 int picoquic_is_connection_id_null(const picoquic_connection_id_t * cnx_id);
 int picoquic_compare_connection_id(const picoquic_connection_id_t * cnx_id1, const picoquic_connection_id_t * cnx_id2);
-uint64_t picoquic_connection_id_hash(const picoquic_connection_id_t * cid);
+uint64_t picoquic_connection_id_hash(const picoquic_connection_id_t * cid, const uint8_t * hash_seed);
 uint64_t picoquic_val64_connection_id(picoquic_connection_id_t cnx_id);
-uint64_t picoquic_hash_addr(const struct sockaddr* addr);
+size_t picoquic_hash_addr_bytes(const struct sockaddr* addr, uint8_t* bytes);
+uint64_t picoquic_hash_addr(const struct sockaddr* addr, const uint8_t* hash_seed);
 size_t picoquic_parse_hexa(char const* hex_input, size_t input_length, uint8_t* bin_output, size_t output_max);
 uint8_t picoquic_parse_connection_id_hexa(char const * hex_input, size_t input_length, picoquic_connection_id_t * cnx_id);
 int picoquic_print_connection_id_hexa(char* buf, size_t buf_len, const picoquic_connection_id_t* cnxid);

--- picoquic/quicctx.c ---
@@ -258,10 +258,10 @@ typedef struct st_picoquic_net_secret_key_t {
 } picoquic_net_secret_key_t;
 
 /* Hash and compare for CNX hash tables */
-static uint64_t picoquic_local_cnxid_hash(const void* key)
+static uint64_t picoquic_local_cnxid_hash(const void* key, const uint8_t * hash_seed)
 {
     const picoquic_local_cnxid_t* l_cid = (const picoquic_local_cnxid_t*)key;
-    return picoquic_connection_id_hash(&l_cid->cnx_id);
+    return picoquic_connection_id_hash(&l_cid->cnx_id, hash_seed);
 }
 
 static int picoquic_local_cnxid_compare(const void* key1, const void* key2)
@@ -279,12 +279,12 @@ static picohash_item * picoquic_local_cnxid_to_item(const void* key)
     return &l_cid->hash_item;
 }
 
-static uint64_t picoquic_net_id_hash(const void* key)
+static uint64_t picoquic_net_id_hash(const void* key, const uint8_t* hash_seed)
 {
     const picoquic_path_t* path_x = (const picoquic_path_t*)key;
-
-    // return picohash_bytes((uint8_t*)&net->saddr, sizeof(net->saddr));
-    return picoquic_hash_addr((struct sockaddr*) & path_x->registered_peer_addr);
+    
+    /* Using siphash, because secret and IP address are chosen by third parties*/
+    return picoquic_hash_addr((struct sockaddr*) & path_x->registered_peer_addr, hash_seed);
 }
 
 static picohash_item * picoquic_local_netid_to_item(const void* key)
@@ -303,21 +303,17 @@ static int picoquic_net_id_compare(const void* key1, const void* key2)
     return picoquic_compare_addr((struct sockaddr*) & path_x1->registered_peer_addr, (struct sockaddr*) & path_x2->registered_peer_addr);
 }
 
-
-
-static uint64_t picoquic_net_icid_hash(const void* key)
+static uint64_t picoquic_net_icid_hash(const void* key, const uint8_t* hash_seed)
 {
-    /* The ICID is controlled by the peer. We mix a random seed in the
-     * hash to avoid possible shenanigans. */
+    uint64_t h;
+    uint8_t bytes[18 + PICOQUIC_CONNECTION_ID_MAX_SIZE];
     const picoquic_cnx_t* cnx = (const picoquic_cnx_t*)key;
-    picoquic_connection_id_t cid = cnx->initial_cnxid;
-
-    for (int i = 0; i < 8; i++) {
-        cid.id[i] ^= cnx->quic->hash_seed[i];
-    }
-
-    return picohash_hash_mix(picoquic_hash_addr((struct sockaddr*) & cnx->registered_icid_addr), 
-        picoquic_connection_id_hash(&cid));
+    size_t l = picoquic_hash_addr_bytes((struct sockaddr*)&cnx->registered_icid_addr, bytes);
+    memcpy(bytes + l, cnx->initial_cnxid.id, cnx->initial_cnxid.id_len);
+    l += cnx->initial_cnxid.id_len;
+    /* Using siphash, because CNX ID and IP address are chosen by third parties*/
+    h = picohash_siphash(bytes, (uint32_t)l, hash_seed);
+    return h;
 }
 
 static int picoquic_net_icid_compare(const void* key1, const void* key2)
@@ -339,12 +335,17 @@ static picohash_item * picoquic_net_icid_to_item(const void* key)
     return &cnx->registered_icid_item;
 }
 
-static uint64_t picoquic_net_secret_hash(const void* key)
+static uint64_t picoquic_net_secret_hash(const void* key, const uint8_t* hash_seed)
 {
+    uint64_t h;
+    uint8_t bytes[18 + PICOQUIC_RESET_SECRET_SIZE];
     const picoquic_cnx_t* cnx = (const picoquic_cnx_t*)key;
-
-    return picohash_hash_mix(picoquic_hash_addr((struct sockaddr*) & cnx->registered_secret_addr), 
-        picohash_bytes(cnx->registered_reset_secret, PICOQUIC_RESET_SECRET_SIZE));
+    size_t l = picoquic_hash_addr_bytes((struct sockaddr*)&cnx->registered_secret_addr, bytes);
+    memcpy(bytes + l, cnx->registered_reset_secret, PICOQUIC_RESET_SECRET_SIZE);
+    l += PICOQUIC_RESET_SECRET_SIZE;
+    /* Using siphash, because secret and IP address are chosen by third parties*/
+    h = picohash_siphash(bytes, (uint32_t)l, hash_seed);
+    return h;
 }
 
 static int picoquic_net_secret_compare(const void* key1, const void* key2)
@@ -391,7 +392,7 @@ picoquic_packet_context_enum picoquic_context_from_epoch(int epoch)
  * to the number of connections.
  */
 
-static uint64_t picoquic_issued_ticket_hash(const void* key)
+static uint64_t picoquic_issued_ticket_hash(const void* key, const uint8_t* hash_seed)
 {
     const picoquic_issued_ticket_t* ticket_key = (const picoquic_issued_ticket_t*)key;
 
@@ -691,15 +692,15 @@ picoquic_quic_t* picoquic_create(uint32_t max_nb_connections,
 
             if (max_cnx4 < (size_t)max_nb_connections ||
                 (quic->table_cnx_by_id = picohash_create_ex((size_t)max_nb_connections * 4,
-                picoquic_local_cnxid_hash, picoquic_local_cnxid_compare, picoquic_local_cnxid_to_item)) == NULL ||
+                picoquic_local_cnxid_hash, picoquic_local_cnxid_compare, picoquic_local_cnxid_to_item, quic->hash_seed)) == NULL ||
                 (quic->table_cnx_by_net = picohash_create_ex((size_t)max_nb_connections * 4,
-                    picoquic_net_id_hash, picoquic_net_id_compare, picoquic_local_netid_to_item)) == NULL ||
+                    picoquic_net_id_hash, picoquic_net_id_compare, picoquic_local_netid_to_item, quic->hash_seed)) == NULL ||
                 (quic->table_cnx_by_icid = picohash_create_ex((size_t)max_nb_connections,
-                    picoquic_net_icid_hash, picoquic_net_icid_compare, picoquic_net_icid_to_item)) == NULL ||
+                    picoquic_net_icid_hash, picoquic_net_icid_compare, picoquic_net_icid_to_item, quic->hash_seed)) == NULL ||
                 (quic->table_cnx_by_secret = picohash_create_ex((size_t)max_nb_connections * 4,
-                    picoquic_net_secret_hash, picoquic_net_secret_compare, picoquic_net_secret_to_item)) == NULL ||
+                    picoquic_net_secret_hash, picoquic_net_secret_compare, picoquic_net_secret_to_item, quic->hash_seed)) == NULL ||
                 (quic->table_issued_tickets = picohash_create_ex((size_t)max_nb_connections,
-                    picoquic_issued_ticket_hash, picoquic_issued_ticket_compare, picoquic_issued_ticket_key_to_item)) == NULL) {
+                    picoquic_issued_ticket_hash, picoquic_issued_ticket_compare, picoquic_issued_ticket_key_to_item, quic->hash_seed)) == NULL) {
                 ret = -1;
                 DBG_PRINTF("%s", "Cannot initialize hash tables\n");
             }
@@ -1024,7 +1025,7 @@ void picoquic_free(picoquic_quic_t* quic)
         }
 
         if (quic->table_cnx_by_secret != NULL) {
-            picohash_delete(quic->table_cnx_by_secret, 1);
+            picohash_delete(quic->table_cnx_by_secret, 0);
         }
 
         if (quic->verify_certificate_callback != NULL) {
@@ -1163,6 +1164,7 @@ void picoquic_unregister_net_id(picoquic_cnx_t* cnx, picoquic_path_t* path_x)
             picohash_delete_item(cnx->quic->table_cnx_by_net, item, 0);
         }
         memset(&path_x->registered_peer_addr, 0, sizeof(struct sockaddr_storage));
+        memset(&path_x->net_id_hash_item, 0, sizeof(path_x->net_id_hash_item));
     }
 }
 
@@ -4786,6 +4788,7 @@ void picoquic_delete_cnx(picoquic_cnx_t* cnx)
         picoquic_delete_remote_cnxid_stashes(cnx);
 
         picoquic_unregister_net_icid(cnx);
+        picoquic_unregister_net_secret(cnx);
 
         free(cnx);
     }

--- picoquic/siphash.c ---
@@ -0,0 +1,189 @@
+
+/*
+   This is a copy of the SipHash reference C implementation
+
+   Copyright (c) 2012-2022 Jean-Philippe Aumasson
+   <jeanphilippe.aumasson@gmail.com>
+   Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>
+
+   To the extent possible under law, the author(s) have dedicated all copyright
+   and related and neighboring rights to this software to the public domain
+   worldwide. This software is distributed without any warranty.
+
+   You should have received a copy of the CC0 Public Domain Dedication along
+   with
+   this software. If not, see
+   <http://creativecommons.org/publicdomain/zero/1.0/>.
+
+   The scatter-gather API was added to support scenarios where the
+   hash combines several distinct memory areas.
+ */
+
+#include <assert.h>
+#include <stddef.h>
+#include <stdint.h>
+#include "picohash.h"
+
+/* default: SipHash-2-4 */
+#ifndef cROUNDS
+#define cROUNDS 2
+#endif
+#ifndef dROUNDS
+#define dROUNDS 4
+#endif
+
+#define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))
+
+#define U32TO8_LE(p, v)                                                        \
+    (p)[0] = (uint8_t)((v));                                                   \
+    (p)[1] = (uint8_t)((v) >> 8);                                              \
+    (p)[2] = (uint8_t)((v) >> 16);                                             \
+    (p)[3] = (uint8_t)((v) >> 24);
+
+#define U64TO8_LE(p, v)                                                        \
+    U32TO8_LE((p), (uint32_t)((v)));                                           \
+    U32TO8_LE((p) + 4, (uint32_t)((v) >> 32));
+
+#define U8TO64_LE(p)                                                           \
+    (((uint64_t)((p)[0])) | ((uint64_t)((p)[1]) << 8) |                        \
+     ((uint64_t)((p)[2]) << 16) | ((uint64_t)((p)[3]) << 24) |                 \
+     ((uint64_t)((p)[4]) << 32) | ((uint64_t)((p)[5]) << 40) |                 \
+     ((uint64_t)((p)[6]) << 48) | ((uint64_t)((p)[7]) << 56))
+
+#define SIPROUND                                                               \
+    do {                                                                       \
+        v0 += v1;                                                              \
+        v1 = ROTL(v1, 13);                                                     \
+        v1 ^= v0;                                                              \
+        v0 = ROTL(v0, 32);                                                     \
+        v2 += v3;                                                              \
+        v3 = ROTL(v3, 16);                                                     \
+        v3 ^= v2;                                                              \
+        v0 += v3;                                                              \
+        v3 = ROTL(v3, 21);                                                     \
+        v3 ^= v0;                                                              \
+        v2 += v1;                                                              \
+        v1 = ROTL(v1, 17);                                                     \
+        v1 ^= v2;                                                              \
+        v2 = ROTL(v2, 32);                                                     \
+    } while (0)
+
+#ifdef DEBUG_SIPHASH
+#include <stdio.h>
+
+#define TRACE                                                                  \
+    do {                                                                       \
+        printf("(%3zu) v0 %016" PRIx64 "\n", inlen, v0);                       \
+        printf("(%3zu) v1 %016" PRIx64 "\n", inlen, v1);                       \
+        printf("(%3zu) v2 %016" PRIx64 "\n", inlen, v2);                       \
+        printf("(%3zu) v3 %016" PRIx64 "\n", inlen, v3);                       \
+    } while (0)
+#else
+#define TRACE
+#endif
+
+/*
+    Computes a SipHash value
+    *in: pointer to input data (read-only)
+    inlen: input data length in bytes (any size_t value)
+    *k: pointer to the key data (read-only), must be 16 bytes 
+    *out: pointer to output data (write-only), outlen bytes must be allocated
+    outlen: length of the output in bytes, must be 8 or 16
+*/
+int siphash(const void *in, const size_t inlen, const void *k, uint8_t *out,
+            const size_t outlen) {
+
+    const unsigned char *ni = (const unsigned char *)in;
+    const unsigned char *kk = (const unsigned char *)k;
+
+    assert((outlen == 8) || (outlen == 16));
+    uint64_t v0 = UINT64_C(0x736f6d6570736575);
+    uint64_t v1 = UINT64_C(0x646f72616e646f6d);
+    uint64_t v2 = UINT64_C(0x6c7967656e657261);
+    uint64_t v3 = UINT64_C(0x7465646279746573);
+    uint64_t k0 = U8TO64_LE(kk);
+    uint64_t k1 = U8TO64_LE(kk + 8);
+    uint64_t m;
+    int i;
+    const unsigned char *end = ni + inlen - (inlen % sizeof(uint64_t));
+    const int left = inlen & 7;
+    uint64_t b = ((uint64_t)inlen) << 56;
+    v3 ^= k1;
+    v2 ^= k0;
+    v1 ^= k1;
+    v0 ^= k0;
+
+    if (outlen == 16)
+        v1 ^= 0xee;
+
+    for (; ni != end; ni += 8) {
+        m = U8TO64_LE(ni);
+        v3 ^= m;
+
+        TRACE;
+        for (i = 0; i < cROUNDS; ++i)
+            SIPROUND;
+
+        v0 ^= m;
+    }
+
+    switch (left) {
+    case 7:
+        b |= ((uint64_t)ni[6]) << 48;
+        /* FALLTHRU */
+    case 6:
+        b |= ((uint64_t)ni[5]) << 40;
+        /* FALLTHRU */
+    case 5:
+        b |= ((uint64_t)ni[4]) << 32;
+        /* FALLTHRU */
+    case 4:
+        b |= ((uint64_t)ni[3]) << 24;
+        /* FALLTHRU */
+    case 3:
+        b |= ((uint64_t)ni[2]) << 16;
+        /* FALLTHRU */
+    case 2:
+        b |= ((uint64_t)ni[1]) << 8;
+        /* FALLTHRU */
+    case 1:
+        b |= ((uint64_t)ni[0]);
+        break;
+    case 0:
+        break;
+    }
+
+    v3 ^= b;
+
+    TRACE;
+    for (i = 0; i < cROUNDS; ++i)
+        SIPROUND;
+
+    v0 ^= b;
+
+    if (outlen == 16)
+        v2 ^= 0xee;
+    else
+        v2 ^= 0xff;
+
+    TRACE;
+    for (i = 0; i < dROUNDS; ++i)
+        SIPROUND;
+
+    b = v0 ^ v1 ^ v2 ^ v3;
+    U64TO8_LE(out, b);
+
+    if (outlen == 8)
+        return 0;
+
+    v1 ^= 0xdd;
+
+    TRACE;
+    for (i = 0; i < dROUNDS; ++i)
+        SIPROUND;
+
+    b = v0 ^ v1 ^ v2 ^ v3;
+    U64TO8_LE(out + 8, b);
+
+    return 0;
+}

--- picoquic/siphash.h ---
@@ -0,0 +1,34 @@
+/*
+   SipHash reference C implementation
+
+   Copyright (c) 2012-2021 Jean-Philippe Aumasson
+   <jeanphilippe.aumasson@gmail.com>
+   Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>
+
+   To the extent possible under law, the author(s) have dedicated all copyright
+   and related and neighboring rights to this software to the public domain
+   worldwide. This software is distributed without any warranty.
+
+   You should have received a copy of the CC0 Public Domain Dedication along
+   with
+   this software. If not, see
+   <http://creativecommons.org/publicdomain/zero/1.0/>.
+ */
+
+#ifndef SIPHASH_H
+#define SIPHASH_H
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int siphash(const void *in, const size_t inlen, const void *k, uint8_t *out,
+            const size_t outlen);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* SIPHASH_H */
\ No newline at end of file

--- picoquic/util.c ---
@@ -365,7 +365,7 @@ int picoquic_compare_connection_id(const picoquic_connection_id_t * cnx_id1, con
 }
 
 /* Hash connection ids for picohash_table's */
-uint64_t picoquic_connection_id_hash(const picoquic_connection_id_t * cid)
+uint64_t picoquic_connection_id_hash(const picoquic_connection_id_t * cid, const uint8_t * hash_seed)
 {
     uint64_t val64 = 0;
     size_t i = 0;
@@ -408,21 +408,33 @@ uint64_t picoquic_val64_connection_id(picoquic_connection_id_t cnx_id)
     return val64;
 }
 
-uint64_t picoquic_hash_addr(const struct sockaddr* addr)
-{
-    uint64_t h;
+/* Hash function for addresses. */
 
+size_t picoquic_hash_addr_bytes(const struct sockaddr* addr, uint8_t* bytes)
+{
+    size_t l = 0;
     if (addr->sa_family == AF_INET) {
-        struct sockaddr_in* a4 = (struct sockaddr_in*)addr;
-        h = picohash_bytes((uint8_t*)&a4->sin_addr , 4);
-        h += 128ull * a4->sin_port;
+        memcpy(bytes, &((struct sockaddr_in*)addr)->sin_addr, 4);
+        l += 4;
+        memcpy(bytes + l, &((struct sockaddr_in*)addr)->sin_port, 2);
+        l += 2;
     }
-    else {
-        struct sockaddr_in6* a6 = (struct sockaddr_in6*)addr;
-        h = picohash_bytes((uint8_t*)& a6->sin6_addr, 16);
-        h += 128ull * a6->sin6_port;
+    else if (addr->sa_family == AF_INET6) {
+        memcpy(bytes, &((struct sockaddr_in6*)addr)->sin6_addr, 16);
+        l += 16;
+        memcpy(bytes + l, &((struct sockaddr_in6*)addr)->sin6_port, 2);
+        l += 2;
     }
+    return l;
+}
+
+uint64_t picoquic_hash_addr(const struct sockaddr* addr, const uint8_t* hash_seed)
+{
+    uint8_t bytes[18];
+    size_t l = picoquic_hash_addr_bytes(addr, bytes);
 
+    /* Using siphash, because secret and IP address are chosen by third parties*/
+    uint64_t h = picohash_siphash(bytes, (uint32_t)l, hash_seed);
     return h;
 }
 #if 0

--- picoquic_t/picoquic_t.c ---
@@ -52,6 +52,8 @@ static const picoquic_test_def_t test_table[] = {
     { "threading", util_threading_test },
     { "picohash", picohash_test },
     { "picohash_embedded", picohash_embedded_test },
+    { "picohash_bytes", picohash_bytes_test },
+    { "siphash", siphash_test },
     { "picolog_basic", picolog_basic_test },
     { "bytestream", bytestream_test },
     { "sockloop_basic", sockloop_basic_test },

--- picoquictest/hashtest.c ---
@@ -21,19 +21,21 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <stdio.h>
 #ifdef _WINDOWS
 #include <malloc.h>
 #endif
 
 #include "picoquic_internal.h"
+#include "picoquic_utils.h"
 #include "picohash.h"
 
 struct hashtestkey {
     uint64_t x;
     picohash_item item;
 };
 
-static uint64_t hashtest_hash(const void* v)
+static uint64_t hashtest_hash(const void* v, const uint8_t* hash_seed)
 {
     const struct hashtestkey* k = (const struct hashtestkey*)v;
     uint64_t hash = (k->x + 0xDEADBEEFull);
@@ -72,12 +74,13 @@ int picohash_test_one(int embedded_item)
     /* Create a hash table */
     int ret = 0;
     picohash_table* t = NULL;
+    uint8_t hash_seed[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
     
     if (!embedded_item) {
         t = picohash_create(32, hashtest_hash, hashtest_compare);
     }
     else {
-        t = picohash_create_ex(32, hashtest_hash, hashtest_compare, hashtest_key_to_item);
+        t = picohash_create_ex(32, hashtest_hash, hashtest_compare, hashtest_key_to_item, hash_seed);
     }
 
     if (t == NULL) {
@@ -200,3 +203,133 @@ int picohash_embedded_test()
 {
     return(picohash_test_one(1));
 }
+
+/* Test the behavior of the basic hash
+ */
+void hash_test_init(uint8_t* test, size_t length, uint8_t * k, size_t k_length)
+{
+    /* Create a test string */
+    for (size_t i = 0; i < length; i++) {
+        test[i] = (uint8_t)(i + (i >> 8));
+    }
+
+    for (size_t i = 0; i < k_length; i++)
+    {
+        k[i] = (uint8_t)(k_length - i);
+    }
+}
+
+int picohash_bytes_test()
+{
+    uint8_t test[1024];
+    uint8_t k[16];
+    int ret = 0;
+    size_t test_lengths[12] = { 1, 3, 7, 8, 12, 16, 17, 31, 127, 257, 515, 1024 };
+    uint64_t href[12] = {
+        0x03016721e32d7aa7,
+        0x64208401ad85bed5,
+        0x44587b0209479519,
+        0x14a481748ee6d77e,
+        0x9a44370fd1b8c1ee,
+        0x27081725c4164c1a,
+        0x2f1f325da756df85,
+        0x2aa4fda796f9ffff,
+        0x8ded0692d7038037,
+        0x7893f9399f507284,
+        0x47a065dbeea77343,
+        0xb543a5b3c675127d
+    };
+
+    hash_test_init(test, sizeof(test), k, sizeof(k));
+
+    /* Compute or check the reference siphash value */
+    for (size_t i = 0; i < sizeof(test_lengths) / sizeof(size_t); i++) {
+        uint64_t h = picohash_bytes(test, (uint32_t)test_lengths[i], k);
+        if (h != href[i]) {
+            DBG_PRINTF("H[%zu] = %" PRIx64 " instead of %"PRIx64, i, h, href[i]);
+#if 1//def COMPUTING_REFERENCE_BASIC_VALUE
+            href[i] = h;
+#else
+            ret = -1;
+            break;
+#endif
+        }
+    }
+    return ret;
+}
+
+/* Test of the siphash function
+ */
+
+int siphash_test()
+{
+    uint8_t test[1024];
+    uint8_t k[16];
+    size_t test_lengths[12] = { 1, 3, 7, 8, 12, 16, 17, 31, 127, 257, 515, 1024 };
+    uint64_t href[12] = {
+        0xa9b786935f98d6b8,
+        0x3fb64f2d81ebf107,
+        0xcd34491a7b437e1b,
+        0x5fbe917709286bc4,
+        0xb2cc76e0f81d6e2f,
+        0x09e69c0f70753651,
+        0xc615b5349acc0cc2,
+        0x965379fb0e26e150,
+        0x85a286cfc4a62574,
+        0x5f774367aeea9f83,
+        0xd04ee1d420e9bc22,
+        0x0a7ad6655680779e
+    };
+    int ret = 0;
+
+    hash_test_init(test, sizeof(test), k, sizeof(k));
+    /* Compute or check the reference siphash value */
+    for (size_t i = 0; i < sizeof(test_lengths) / sizeof(size_t); i++) {
+        uint64_t h = picohash_siphash(test, test_lengths[i], k);
+        if (h != href[i]) {
+            DBG_PRINTF("H[%zu] = %" PRIu64 "instead of %"PRIu64, i, h, href[i]);
+#ifdef COMPUTING_REFERENCE_SIPASH_VALUE
+            href[i] = h;
+#else
+            ret = -1;
+            break;
+#endif
+        }
+    }
+#ifdef COMPARING_TIMES
+    /* Compare execution time */
+    uint64_t h;
+    double sip_t[48];
+    double basic_t[48];
+    for (size_t lt=1; lt <= 48; lt++) {
+        uint64_t start_siphash = picoquic_current_time();
+        uint64_t siphash_sum = 0;
+        uint64_t basic_sum = 0;
+        size_t n = 0;
+
+        for (size_t i = 0; i + lt < sizeof(test); i++) {
+            h = picohash_siphash(test, lt, k);
+            siphash_sum += h;
+            n++;
+        }
+        uint64_t start_basic = picoquic_current_time();
+        for (size_t i = 0; i + lt < sizeof(test); i++) {
+            h = picohash_bytes(test, (uint32_t)lt, k);
+            basic_sum += h;
+        }
+        uint64_t end_basic = picoquic_current_time();
+        uint64_t siphash_time = start_basic - start_siphash;
+        uint64_t basic_time = end_basic - start_basic;
+        double siphash_one = ((double)siphash_time) / n;
+        double basic_one = ((double)basic_time) / n;
+        sip_t[lt - 1] = siphash_one;
+        basic_t[lt - 1] = basic_one;
+        printf("Sip hash time, %zu: %" PRIu64 ", sum: %" PRIu64", n = % zu, us=%f\n", lt, siphash_time, siphash_sum, n, siphash_one);
+        printf("Basic hash time, %zu: %" PRIu64 ", sum: %" PRIu64", n = % zu, us=%f\n", lt, basic_time, basic_sum, n, basic_one);
+    }
+    for (int i = 0; i < 48; i++) {
+        printf("%d, %f, %f\n", i + 1, basic_t[i], sip_t[i]);
+    }
+#endif /* COMPARING TIMES */
+    return ret;
+}

--- picoquictest/picoquictest.h ---
@@ -43,6 +43,8 @@ int util_uint8_to_str_test();
 int util_memcmp_test();
 int util_threading_test();
 int picohash_test();
+int picohash_bytes_test();
+int siphash_test();
 int picohash_embedded_test();
 int picolog_basic_test();
 int bytestream_test();

