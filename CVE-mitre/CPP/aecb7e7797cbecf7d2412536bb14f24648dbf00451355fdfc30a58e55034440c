--- reverb/cc/BUILD ---
@@ -67,6 +67,7 @@ reverb_cc_test(
     deps = [
         ":tensor_compression",
         "//reverb/cc/testing:tensor_testutil",
+        "//third_party/absl/status",
     ] + reverb_tf_deps(),
 )
 

--- reverb/cc/tensor_compression.cc ---
@@ -18,6 +18,7 @@
 
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
+#include "absl/strings/str_cat.h"
 #include "reverb/cc/platform/logging.h"
 #include "reverb/cc/platform/snappy.h"
 #include "tensorflow/core/framework/register_types.h"
@@ -55,6 +56,40 @@ tensorflow::Tensor DeltaEncode(const tensorflow::Tensor& tensor, bool encode) {
   return output;
 }
 
+bool IsSupported(const tensorflow::DataType data_type) {
+  switch (data_type) {
+    case tensorflow::DT_FLOAT:
+    case tensorflow::DT_DOUBLE:
+    case tensorflow::DT_INT32:
+    case tensorflow::DT_UINT8:
+    case tensorflow::DT_INT16:
+    case tensorflow::DT_INT8:
+    case tensorflow::DT_STRING:
+    case tensorflow::DT_COMPLEX64:
+    case tensorflow::DT_INT64:
+    case tensorflow::DT_BOOL:
+    case tensorflow::DT_QINT8:
+    case tensorflow::DT_QUINT8:
+    case tensorflow::DT_QINT32:
+    case tensorflow::DT_BFLOAT16:
+    case tensorflow::DT_QINT16:
+    case tensorflow::DT_QUINT16:
+    case tensorflow::DT_UINT16:
+    case tensorflow::DT_COMPLEX128:
+    case tensorflow::DT_HALF:
+    // DT_RESOURCE and DT_VARIANT are not supported.
+    case tensorflow::DT_UINT32:
+    case tensorflow::DT_UINT64:
+    case tensorflow::DT_FLOAT8_E5M2:
+    case tensorflow::DT_FLOAT8_E4M3FN:
+    case tensorflow::DT_INT4:
+    case tensorflow::DT_UINT4:
+      return true;
+    default:
+      return false;
+  }
+}
+
 }  // namespace
 
 tensorflow::Tensor DeltaEncode(const tensorflow::Tensor& tensor, bool encode) {
@@ -83,6 +118,12 @@ std::vector<tensorflow::Tensor> DeltaEncodeList(
 
 absl::Status CompressTensorAsProto(const tensorflow::Tensor& tensor,
                                    tensorflow::TensorProto* proto) {
+  if (!IsSupported(tensor.dtype())) {
+    return absl::InvalidArgumentError(absl::StrCat(
+        "Tensor of dtype ", tensorflow::DataTypeString(tensor.dtype()),
+        " is not supported for compression."));
+  }
+
   if (tensor.dtype() == tensorflow::DT_STRING) {
     tensor.AsProtoTensorContent(proto);
     return absl::OkStatus();
@@ -97,6 +138,12 @@ absl::Status CompressTensorAsProto(const tensorflow::Tensor& tensor,
 
 absl::StatusOr<tensorflow::Tensor> DecompressTensorFromProto(
     const tensorflow::TensorProto& proto) {
+  if (!IsSupported(proto.dtype())) {
+    return absl::InvalidArgumentError(absl::StrCat(
+        "Tensor of dtype ", tensorflow::DataTypeString(proto.dtype()),
+        " is not supported for decompression."));
+  }
+
   if (proto.dtype() == tensorflow::DT_STRING) {
     tensorflow::Tensor tensor;
     REVERB_CHECK(tensor.FromProto(proto));

--- reverb/cc/tensor_compression_test.cc ---
@@ -18,19 +18,24 @@
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
+#include "absl/status/status.h"
 #include "reverb/cc/testing/tensor_testutil.h"
 #include "tensorflow/core/framework/register_types.h"
 #include "tensorflow/core/framework/tensor.h"
 #include "tensorflow/core/framework/tensor.pb.h"
 #include "tensorflow/core/framework/tensor_shape.h"
 #include "tensorflow/core/framework/types.h"
 #include "tensorflow/core/framework/types.pb.h"
+#include "tensorflow/core/framework/variant.h"
 #include "tensorflow/core/platform/tstring.h"
 
 namespace deepmind {
 namespace reverb {
 namespace {
 
+using ::testing::HasSubstr;
+using ::testing::status::StatusIs;
+
 template <typename T>
 void EncodeMatchesDecodeT() {
   tensorflow::Tensor tensor(tensorflow::DataTypeToEnum<T>::v(),
@@ -103,6 +108,30 @@ TEST(TensorCompressionTest, NonStringTensorWithDeltaEncoding) {
   test::ExpectTensorEqual<int>(tensor, DeltaEncode(result, false));
 }
 
+TEST(TensorCompressionTest, CompressingVariantNotSupported) {
+  tensorflow::Tensor tensor(tensorflow::DT_VARIANT,
+                            tensorflow::TensorShape({}));
+
+  tensorflow::Tensor internal(tensorflow::DT_FLOAT,
+                              tensorflow::TensorShape({2, 2}));
+  internal.flat<float>().setRandom();
+  tensor.flat<tensorflow::Variant>()(0) = internal;
+
+  tensorflow::TensorProto proto;
+  EXPECT_THAT(CompressTensorAsProto(DeltaEncode(tensor, true), &proto),
+              StatusIs(absl::StatusCode::kInvalidArgument,
+                       HasSubstr("variant is not supported")));
+}
+
+TEST(TensorCompressionTest, DecompressingVariantNotSupported) {
+  tensorflow::TensorProto proto;
+  proto.set_dtype(tensorflow::DT_VARIANT);
+
+  EXPECT_THAT(DecompressTensorFromProto(proto),
+              StatusIs(absl::StatusCode::kInvalidArgument,
+                       HasSubstr("variant is not supported")));
+}
+
 }  // namespace
 }  // namespace reverb
 }  // namespace deepmind

