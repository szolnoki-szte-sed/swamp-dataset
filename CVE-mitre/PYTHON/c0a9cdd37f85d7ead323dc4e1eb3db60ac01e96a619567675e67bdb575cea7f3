--- nuitka/__main__.py ---
@@ -25,6 +25,7 @@
 # Note: This avoids imports at all costs, such that initial startup doesn't do more
 # than necessary, until re-execution has been decided.
 
+import ast
 import os
 import sys
 
@@ -41,8 +42,8 @@ def main():
 
     if "NUITKA_PYTHONPATH" in os.environ:
         # Restore the PYTHONPATH gained from the site module, that we chose not
-        # to have imported. pylint: disable=eval-used
-        sys.path = eval(os.environ["NUITKA_PYTHONPATH"])
+        # to have imported during compilation.
+        sys.path = ast.literal_eval(os.environ["NUITKA_PYTHONPATH"])
         del os.environ["NUITKA_PYTHONPATH"]
     else:
         # Remove path element added for being called via "__main__.py", this can
@@ -101,20 +102,17 @@ def main():
 
     if "NUITKA_NAMESPACES" in os.environ:
         # Restore the detected name space packages, that were force loaded in
-        # site.py, and will need a free pass later on. pylint: disable=eval-used
-
+        # site.py, and will need a free pass later on
         from nuitka.importing.PreloadedPackages import setPreloadedPackagePaths
 
-        setPreloadedPackagePaths(eval(os.environ["NUITKA_NAMESPACES"]))
+        setPreloadedPackagePaths(ast.literal_eval(os.environ["NUITKA_NAMESPACES"]))
         del os.environ["NUITKA_NAMESPACES"]
 
     if "NUITKA_PTH_IMPORTED" in os.environ:
         # Restore the packages that the ".pth" files asked to import.
-        # pylint: disable=eval-used
-
         from nuitka.importing.PreloadedPackages import setPthImportedPackages
 
-        setPthImportedPackages(eval(os.environ["NUITKA_PTH_IMPORTED"]))
+        setPthImportedPackages(ast.literal_eval(os.environ["NUITKA_PTH_IMPORTED"]))
         del os.environ["NUITKA_PTH_IMPORTED"]
 
     # Now the real main program of Nuitka can take over.

--- nuitka/build/SconsCaching.py ---
@@ -19,6 +19,7 @@
 
 """
 
+import ast
 import os
 import platform
 import re
@@ -382,9 +383,7 @@ def checkCachingSuccess(source_dir):
         if clcache_stats_filename is not None and os.path.exists(
             clcache_stats_filename
         ):
-            stats = eval(  # lazy, pylint: disable=eval-used
-                getFileContents(clcache_stats_filename)
-            )
+            stats = ast.literal_eval(getFileContents(clcache_stats_filename))
 
             clcache_hit = stats["CacheHits"]
             clcache_miss = stats["CacheMisses"]

--- nuitka/nodes/NodeBases.py ---
@@ -25,6 +25,7 @@
 
 # from abc import abstractmethod
 
+import ast
 from abc import abstractmethod
 
 from nuitka import Options, Tracing, TreeXML, Variables
@@ -1175,9 +1176,7 @@ def fromXML(provider, xml, source_ref=None):
     kind, node_class, args, source_ref = extractKindAndArgsFromXML(xml, source_ref)
 
     if "constant" in args:
-        # TODO: Try and reduce/avoid this, use marshal and/or pickle from a file
-        # global stream     instead. For now, this will do. pylint: disable=eval-used
-        args["constant"] = eval(args["constant"])
+        args["constant"] = ast.literal_eval(args["constant"])
 
     if kind in (
         "ExpressionFunctionBody",

--- nuitka/plugins/PluginBase.py ---
@@ -26,6 +26,7 @@
 it being used.
 """
 
+import ast
 import inspect
 import os
 import sys
@@ -845,9 +846,8 @@ def queryRuntimeInformationMultiple(self, info_name, setup_codes, values):
 
         NamedTupleResult = namedtuple(info_name, keys)
 
-        # We are being lazy here, the code is trusted, pylint: disable=eval-used
         self._runtime_information_cache[info_name] = NamedTupleResult(
-            *(eval(value) for value in feedback)
+            *(ast.literal_eval(value) for value in feedback)
         )
 
         return self._runtime_information_cache[info_name]

