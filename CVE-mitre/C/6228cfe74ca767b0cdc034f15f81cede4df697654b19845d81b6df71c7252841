--- include/belle-sip/provider.h ---
@@ -89,6 +89,17 @@ BELLESIP_EXPORT int belle_sip_provider_add_authorization(belle_sip_provider_t *p
  **/
 BELLESIP_EXPORT belle_sip_dialog_t* belle_sip_provider_find_dialog(const belle_sip_provider_t *prov, const char* call_id,const char* local_tag,const char* remote_tag);
 
+/**
+ * Provides access to a specific dialog
+ * @param prov object
+ * @param call_if of the dialog
+ * @param remote_tag of the dialog
+ * @returns dialog that  correspond to these parameters or NULL if not found
+ *
+ **/
+BELLESIP_EXPORT belle_sip_dialog_t* belle_sip_provider_find_dialog_with_remote_tag(const belle_sip_provider_t *prov, const char* call_id,const char* remote_tag);
+
+
 /**
  * Enable rport in via header. Enabled by default
  * @param prov

--- src/CMakeLists.txt ---
@@ -235,7 +235,7 @@ if(ENABLE_SHARED)
 		set_target_properties(bellesip PROPERTIES
 			FRAMEWORK TRUE
 			MACOSX_FRAMEWORK_IDENTIFIER org.linphone.belle-sip
-			MACOSX_FRAMEWORK_INFO_PLIST "${CMAKE_SOURCE_DIR}/build/osx/Info.plist.in"
+			MACOSX_FRAMEWORK_INFO_PLIST "${PROJECT_SOURCE_DIR}/build/osx/Info.plist.in"
 			RESOURCE "${BELLESIP_RESOURCES}"
 			PUBLIC_HEADER "${BELLE_SIP_HEADER_FILES}"
 		)

--- src/belle_sip_utils.c ---
@@ -514,12 +514,13 @@ char* belle_generic_uri_to_escaped_path(const char* buff) {
 }
 
 char* belle_sip_string_to_backslash_less_unescaped_string(const char* buff) {
-	char *output_buff=belle_sip_malloc(strlen(buff)+1);
+	size_t buff_len = strlen(buff);
+	char *output_buff=belle_sip_malloc(buff_len+1);
 	unsigned int i;
 	unsigned int out_buff_index=0;
 
 	for(i=0; buff[i] != '\0'; i++) {
-		if (buff[i] == '\\') {
+		if (buff[i] == '\\' && i + 1 < buff_len ) { /*make sure escaped caracter exist*/
 			i++;/*skip \*/
 		}
 		/*make sure to only remove one \ in case of \\*/

--- src/dialog.c ---
@@ -1115,7 +1115,7 @@ int _belle_sip_dialog_match(belle_sip_dialog_t *obj, const char *call_id, const
 	/*Dialog created by notify matching subscription are still in NULL state if (obj->state==BELLE_SIP_DIALOG_NULL) belle_sip_fatal("_belle_sip_dialog_match() must not be used for dialog in null state.");*/
 	dcid=belle_sip_header_call_id_get_call_id(obj->call_id);
 	return strcmp(dcid,call_id)==0
-		&& strcmp(obj->local_tag,local_tag)==0
+		&& (!local_tag || strcmp(obj->local_tag,local_tag)==0) //local tag is not checked if not provided
 		&& obj->remote_tag /* handle 180 without to tag */ && remote_tag && strcmp(obj->remote_tag,remote_tag)==0;
 }
 

--- src/grammars/belle_sip_message.g ---
@@ -321,7 +321,7 @@ scope { belle_generic_uri_t* current; }
 catch [ANTLR3_RECOGNITION_EXCEPTION]
 {
    belle_sip_message("[\%s]  reason [\%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
-   belle_sip_object_unref($generic_uri::current);
+   belle_sip_object_unref($ret);
    $ret=NULL;
 }
 

--- src/grammars/belle_sip_messageLexer.c ---
@@ -2,7 +2,7 @@
  *  This C source file was generated by $ANTLR version 3.4
  *
  *     -  From the grammar source file : ../grammars/belle_sip_message.g
- *     -                            On : 2021-05-13 15:53:11
+ *     -                            On : 2021-09-07 16:55:34
  *     -                 for the lexer : belle_sip_messageLexerLexer
  *
  * Editing it, at least manually, is not wise.

--- src/grammars/belle_sip_messageLexer.h ---
@@ -2,7 +2,7 @@
  *  This C header file was generated by $ANTLR version 3.4
  *
  *     -  From the grammar source file : ../grammars/belle_sip_message.g
- *     -                            On : 2021-05-13 15:53:11
+ *     -                            On : 2021-09-07 16:55:34
  *     -                 for the lexer : belle_sip_messageLexerLexer
  *
  * Editing it, at least manually, is not wise.

--- src/grammars/belle_sip_messageParser.h ---
@@ -2,7 +2,7 @@
  *  This C header file was generated by $ANTLR version 3.4
  *
  *     -  From the grammar source file : ../grammars/belle_sip_message.g
- *     -                            On : 2021-05-13 15:53:10
+ *     -                            On : 2021-09-07 16:55:33
  *     -                for the parser : belle_sip_messageParserParser
  *
  * Editing it, at least manually, is not wise.

--- src/provider.c ---
@@ -521,7 +521,10 @@ static void channel_on_sending(belle_sip_channel_listener_t *obj, belle_sip_chan
 	if (belle_sip_message_is_request(msg)){
 		const belle_sip_list_t *rroutes;
 		/*probably better to be in channel*/
-		fix_outgoing_via(prov, chan, msg);
+		if (strcmp("CANCEL",belle_sip_request_get_method(BELLE_SIP_REQUEST(msg))) != 0)
+			fix_outgoing_via(prov, chan, msg);
+			/*else
+			 in case of CANCEL, via header must excatly be equal to INVITE's via header*/
 
 		for (rroutes=belle_sip_message_get_headers(msg,"Record-Route");rroutes!=NULL;rroutes=rroutes->next){
 			belle_sip_header_record_route_t* rr=(belle_sip_header_record_route_t*)rroutes->data;
@@ -706,12 +709,11 @@ belle_sip_dialog_t * belle_sip_provider_create_dialog_internal(belle_sip_provide
 	return dialog;
 }
 
-/*find a dialog given the call id, local-tag and to-tag*/
-belle_sip_dialog_t* belle_sip_provider_find_dialog(const belle_sip_provider_t *prov, const char* call_id, const char* local_tag, const char* remote_tag) {
+static belle_sip_dialog_t* _belle_sip_provider_find_dialog(const belle_sip_provider_t *prov, const char* call_id, const char* local_tag, const char* remote_tag, bool_t local_tag_mandatory) {
 	belle_sip_list_t* iterator;
 	belle_sip_dialog_t*returned_dialog=NULL;
 
-	if (call_id == NULL || local_tag == NULL || remote_tag == NULL) {
+	if (call_id == NULL || (local_tag_mandatory && (local_tag == NULL)) || remote_tag == NULL) {
 		return NULL;
 	}
 
@@ -722,12 +724,21 @@ belle_sip_dialog_t* belle_sip_provider_find_dialog(const belle_sip_provider_t *p
 		if (belle_sip_dialog_get_state(dialog) != BELLE_SIP_DIALOG_NULL && _belle_sip_dialog_match(dialog,call_id,local_tag,remote_tag)) {
 			if (!returned_dialog)
 				returned_dialog=dialog;
-			else
+			else {
 				belle_sip_fatal("More than 1 dialog is matching, check your app");
+			}
 		}
 	}
 	return returned_dialog;
 }
+/*find a dialog given the call id, local-tag and to-tag*/
+belle_sip_dialog_t* belle_sip_provider_find_dialog(const belle_sip_provider_t *prov, const char* call_id, const char* local_tag, const char* remote_tag) {
+	return _belle_sip_provider_find_dialog(prov, call_id, local_tag, remote_tag, TRUE);
+}
+
+belle_sip_dialog_t* belle_sip_provider_find_dialog_with_remote_tag(const belle_sip_provider_t *prov, const char* call_id,const char* remote_tag) {
+	return _belle_sip_provider_find_dialog(prov, call_id, NULL, remote_tag, FALSE);
+}
 
 /*finds an existing dialog for an outgoing or incoming message */
 belle_sip_dialog_t *belle_sip_provider_find_dialog_from_message(belle_sip_provider_t *prov, belle_sip_message_t *msg, int as_uas){

--- tester/belle_sip_headers_tester.c ---
@@ -188,7 +188,9 @@ static void test_from_header_with_paramless_address_spec(void) {
 	BC_ASSERT_STRING_EQUAL(belle_generic_uri_get_scheme(L_absoluteUri), "tel");
 	BC_ASSERT_STRING_EQUAL(belle_sip_header_from_get_tag(L_from),"dlfjklcn6545614XX");
 	belle_sip_object_unref(L_from);
-
+	BC_ASSERT_PTR_NULL(belle_sip_header_from_parse("F: x:xx%"));
+	BC_ASSERT_PTR_NULL(belle_sip_header_from_parse("F\"\\"));
+	
 }
 
 static void test_to_header_with_paramless_address_spec(void) {

