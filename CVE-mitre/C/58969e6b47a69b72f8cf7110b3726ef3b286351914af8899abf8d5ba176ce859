--- peglib.h ---
@@ -1239,12 +1239,10 @@ class LiteralString : public Ope,
                       public std::enable_shared_from_this<LiteralString> {
 public:
   LiteralString(std::string &&s, bool ignore_case)
-      : lit_(s), ignore_case_(ignore_case),
-        is_word_(false) {}
+      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}
 
   LiteralString(const std::string &s, bool ignore_case)
-      : lit_(s), ignore_case_(ignore_case),
-        is_word_(false) {}
+      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}
 
   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
                     any &dt) const override;
@@ -3438,6 +3436,21 @@ class ParserGenerator {
       }
     }
 
+    // Check if the start rule has ignore operator
+    {
+      auto &rule = grammar[data.start];
+      if (rule.ignoreSemanticValue) {
+        if (log) {
+          auto line = line_info(s, rule.s_);
+          log(line.first, line.second,
+              "Ignore operator cannot be applied to '" + rule.name + "'.");
+        }
+        ret = false;
+      }
+    }
+
+    if (!ret) { return nullptr; }
+
     // Check missing definitions
     for (auto &x : grammar) {
       auto &rule = x.second;

--- test/test1.cc ---
@@ -34,6 +34,17 @@ TEST_CASE("Empty syntax test", "[general]")
     REQUIRE(ret == false);
 }
 
+TEST_CASE("Start rule with ignore operator test", "[general]")
+{
+    parser parser(R"(
+        ~ROOT <- _
+        _ <- ' '
+    )");
+
+    bool ret = parser;
+    REQUIRE(ret == false);
+}
+
 TEST_CASE("Backslash escape sequence test", "[general]")
 {
     parser parser(R"(

