--- README.md ---
@@ -79,6 +79,11 @@ server.register(fastifyPassport.secureSession())
 fastifyPassport.use('test', new SomePassportStrategy()) // you'd probably use some passport strategy from npm here
 ```
 
+## Session cleanup on logIn
+
+For security reasons the session is cleaned after login. You can manage this configuration at your own risk by using
+`clearSessionOnLogin (default: true)` and `clearSessionIgnoreFields (default: ['passport', 'session'])`
+
 ## Difference between `@fastify/secure-session` and `@fastify/session`
 `@fastify/secure-session` and `@fastify/session` are both session plugins for Fastify which are capable of encrypting/decrypting the session. The main difference is that `@fastify/secure-session` uses the stateless approach and stores the whole session in an encrypted cookie whereas `@fastify/session` uses the stateful approach for sessions and stores them in a session store.
 

--- package.json ---
@@ -42,8 +42,9 @@
   },
   "devDependencies": {
     "@fastify/cookie": "^8.0.0",
+    "@fastify/csrf-protection": "^6.2.0",
     "@fastify/secure-session": "^6.0.0",
-    "@fastify/session": "^10.0.0",
+    "@fastify/session": "^10.2.0",
     "@types/jest": "^27.0.0",
     "@types/node": "^18.0.0",
     "@types/passport": "^1.0.5",

--- src/Authenticator.ts ---
@@ -20,6 +20,8 @@ export type InfoTransformerFunction = (info: any) => Promise<any>
 export interface AuthenticatorOptions {
   key?: string
   userProperty?: string
+  clearSessionOnLogin?: boolean
+  clearSessionIgnoreFields?: string[]
 }
 
 export class Authenticator {
@@ -33,13 +35,23 @@ export class Authenticator {
   private serializers: SerializeFunction<any, any>[] = []
   private deserializers: DeserializeFunction<any, any>[] = []
   private infoTransformers: InfoTransformerFunction[] = []
+  private clearSessionOnLogin: boolean
+  private clearSessionIgnoreFields: string[]
 
   constructor(options: AuthenticatorOptions = {}) {
     this.key = options.key || 'passport'
     this.userProperty = options.userProperty || 'user'
-
     this.use(new SessionStrategy(this.deserializeUser.bind(this)))
-    this.sessionManager = new SecureSessionManager({ key: this.key }, this.serializeUser.bind(this))
+    this.clearSessionOnLogin = options.clearSessionOnLogin ?? true
+    this.clearSessionIgnoreFields = ['passport', 'session', ...(options.clearSessionIgnoreFields || [])]
+    this.sessionManager = new SecureSessionManager(
+      {
+        key: this.key,
+        clearSessionOnLogin: this.clearSessionOnLogin,
+        clearSessionIgnoreFields: this.clearSessionIgnoreFields,
+      },
+      this.serializeUser.bind(this)
+    )
   }
 
   use(strategy: AnyStrategy): this

--- src/session-managers/SecureSessionManager.ts ---
@@ -5,25 +5,55 @@ import { SerializeFunction } from '../Authenticator'
 /** Class for storing passport data in the session using `@fastify/secure-session` or `@fastify/session` */
 export class SecureSessionManager {
   key: string
+  clearSessionOnLogin: boolean
+  clearSessionIgnoreFields: string[] = ['session']
   serializeUser: SerializeFunction
 
   constructor(serializeUser: SerializeFunction)
-  constructor(options: { key?: string }, serializeUser: SerializeFunction)
-  constructor(options: SerializeFunction | { key?: string }, serializeUser?: SerializeFunction) {
+  constructor(
+    options: { key?: string; clearSessionOnLogin?: boolean; clearSessionIgnoreFields?: string[] },
+    serializeUser: SerializeFunction
+  )
+  constructor(
+    options: SerializeFunction | { key?: string; clearSessionOnLogin?: boolean; clearSessionIgnoreFields?: string[] },
+    serializeUser?: SerializeFunction
+  ) {
     if (typeof options === 'function') {
       this.serializeUser = options
       this.key = 'passport'
+      this.clearSessionOnLogin = true
     } else if (typeof serializeUser === 'function') {
       this.serializeUser = serializeUser
       this.key =
         (options && typeof options === 'object' && typeof options.key === 'string' && options.key) || 'passport'
+      this.clearSessionOnLogin = options.clearSessionOnLogin ?? true
+      this.clearSessionIgnoreFields = [...this.clearSessionIgnoreFields, ...(options.clearSessionIgnoreFields || [])]
     } else {
       throw new Error('SecureSessionManager#constructor must have a valid serializeUser-function passed as a parameter')
     }
   }
 
   async logIn(request: FastifyRequest, user: any) {
     const object = await this.serializeUser(user, request)
+
+    if (this.clearSessionOnLogin && object) {
+      // Handle @fastify/session to prevent token/CSRF fixation
+      if (request.session.regenerate) {
+        await request.session.regenerate(this.clearSessionIgnoreFields)
+      } else {
+        const currentFields = request.session.data() || {}
+        // Handle @fastify/secure-session against CSRF fixation
+        // TODO: This is quite hacky. The best option would be having a regenerate method
+        // on secure-session as well
+        for (const field of Object.keys(currentFields)) {
+          if (this.clearSessionIgnoreFields.includes(field)) {
+            continue
+          }
+          request.session.set(field, undefined)
+        }
+      }
+    }
+
     // Handle sessions using @fastify/session
     if (request.session.regenerate) {
       // regenerate session to guard against session fixation

--- test/csrf-fixation.test.ts ---
@@ -0,0 +1,62 @@
+/* eslint-disable @typescript-eslint/no-empty-function */
+import { getConfiguredTestServer, TestBrowserSession } from './helpers'
+import fastifyCsrfProtection from '@fastify/csrf-protection'
+
+function createServer(sessionPluginName: '@fastify/session' | '@fastify/secure-session') {
+  const { server, fastifyPassport } = getConfiguredTestServer()
+
+  void server.register(fastifyCsrfProtection, { sessionPlugin: sessionPluginName })
+
+  server.post(
+    '/login',
+    { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },
+    async () => 'success'
+  )
+
+  server.get('/csrf', async (_req, reply) => {
+    return reply.generateCsrf()
+  })
+  server.get('/session', async (req) => {
+    return req.session.get('_csrf')
+  })
+  return server
+}
+
+const suite = (sessionPluginName: '@fastify/session' | '@fastify/secure-session') => {
+  process.env.SESSION_PLUGIN = sessionPluginName
+  const server = createServer(sessionPluginName)
+  describe(`${sessionPluginName} tests`, () => {
+    describe('guard against fixation', () => {
+      let user: TestBrowserSession
+
+      beforeEach(() => {
+        user = new TestBrowserSession(server)
+      })
+
+      test(`should renegerate csrf token on login`, async () => {
+        {
+          const sess = await user.inject({ method: 'GET', url: '/session' })
+          expect(sess.body).toBe('')
+        }
+        await user.inject({ method: 'GET', url: '/csrf' })
+        {
+          const sess = await user.inject({ method: 'GET', url: '/session' })
+          expect(sess.body).not.toBe('')
+        }
+        await user.inject({
+          method: 'POST',
+          url: '/login',
+          payload: { login: 'test', password: 'test' },
+        })
+        {
+          const sess = await user.inject({ method: 'GET', url: '/session' })
+          expect(sess.body).toBe('')
+        }
+      })
+    })
+  })
+  delete process.env.SESSION_PLUGIN
+}
+
+suite('@fastify/session')
+suite('@fastify/secure-session')

--- test/helpers.ts ---
@@ -2,7 +2,7 @@ import * as fs from 'fs'
 import fastify, { FastifyInstance } from 'fastify'
 import fastifySecureSession, { SecureSessionPluginOptions } from '@fastify/secure-session'
 import fastifyCookie from '@fastify/cookie'
-import Authenticator from '../src/Authenticator'
+import Authenticator, { AuthenticatorOptions } from '../src/Authenticator'
 import { Strategy } from '../src/strategies'
 import { InjectOptions, Response as LightMyRequestResponse } from 'light-my-request'
 import * as parseCookies from 'set-cookie-parser'
@@ -97,17 +97,19 @@ export const getTestServer = (sessionOptions: SessionOptions = null) => {
   const server = fastify()
   loadSessionPlugins(server, sessionOptions)
 
-  server.setErrorHandler((error, request, reply) => {
-    console.error(error)
+  server.setErrorHandler((error, _request, reply) => {
     void reply.status(500)
     void reply.send(error)
   })
   return server
 }
 
 /** Create a fastify instance with fastify-passport plugin registered but with no strategies registered yet. */
-export const getRegisteredTestServer = (sessionOptions: SessionOptions = null) => {
-  const fastifyPassport = new Authenticator()
+export const getRegisteredTestServer = (
+  sessionOptions: SessionOptions = null,
+  passportOptions: AuthenticatorOptions = {}
+) => {
+  const fastifyPassport = new Authenticator(passportOptions)
   fastifyPassport.registerUserSerializer(async (user) => JSON.stringify(user))
   fastifyPassport.registerUserDeserializer(async (serialized: string) => JSON.parse(serialized))
 
@@ -122,9 +124,10 @@ export const getRegisteredTestServer = (sessionOptions: SessionOptions = null) =
 export const getConfiguredTestServer = (
   name = 'test',
   strategy = new TestStrategy('test'),
-  sessionOptions: SessionOptions = null
+  sessionOptions: SessionOptions = null,
+  passportOptions: AuthenticatorOptions = {}
 ) => {
-  const { fastifyPassport, server } = getRegisteredTestServer(sessionOptions)
+  const { fastifyPassport, server } = getRegisteredTestServer(sessionOptions, passportOptions)
   fastifyPassport.use(name, strategy)
   return { fastifyPassport, server }
 }

--- test/independent-strategy-instances.test.ts ---
@@ -18,7 +18,7 @@ class WelcomeStrategy extends Strategy {
 const suite = (sessionPluginName) => {
   describe(`${sessionPluginName} tests`, () => {
     test(`should allow passing a specific Strategy instance to an authenticate call`, async () => {
-      const { server, fastifyPassport } = getRegisteredTestServer()
+      const { server, fastifyPassport } = getRegisteredTestServer(null, { clearSessionIgnoreFields: ['messages'] })
       server.get(
         '/',
         {

--- test/multi-instance.test.ts ---
@@ -3,89 +3,96 @@ import { Authenticator } from '../src/Authenticator'
 import { Strategy } from '../src/strategies'
 import { getTestServer, TestBrowserSession } from './helpers'
 
+let counter: number
+let authenticators: Record<string, Authenticator>
+
+async function TestStrategyModule(instance: FastifyInstance, { namespace, clearSessionOnLogin }) {
+  class TestStrategy extends Strategy {
+    authenticate(request: any, _options?: { pauseStream?: boolean }) {
+      if (request.isAuthenticated()) {
+        return this.pass()
+      }
+      if (request.body && request.body.login === 'test' && request.body.password === 'test') {
+        return this.success({ namespace, id: String(counter++) })
+      }
+
+      this.fail()
+    }
+  }
+
+  const strategyName = `test-${namespace}`
+  const authenticator = new Authenticator({
+    key: `passport${namespace}`,
+    userProperty: `user${namespace}`,
+    clearSessionOnLogin,
+  })
+  authenticator.use(strategyName, new TestStrategy(strategyName))
+  authenticator.registerUserSerializer<any, string>(async (user) => {
+    if (user.namespace == namespace) {
+      return namespace + '-' + JSON.stringify(user)
+    }
+    throw 'pass'
+  })
+  authenticator.registerUserDeserializer<string, any>(async (serialized: string) => {
+    if (serialized.startsWith(`${namespace}-`)) {
+      return JSON.parse(serialized.slice(`${namespace}-`.length))
+    }
+    throw 'pass'
+  })
+
+  await instance.register(authenticator.initialize())
+  await instance.register(authenticator.secureSession())
+  authenticators[namespace] = authenticator
+
+  instance.get(
+    `/${namespace}`,
+    { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },
+    async () => `hello ${namespace}!`
+  )
+
+  instance.get(
+    `/user/${namespace}`,
+    { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },
+    async (request) => JSON.stringify(request[`user${namespace}`])
+  )
+
+  instance.post(
+    `/login-${namespace}`,
+    {
+      preValidation: authenticator.authenticate(strategyName, {
+        successRedirect: `/${namespace}`,
+        authInfo: false,
+      }),
+    },
+    () => {
+      return
+    }
+  )
+
+  instance.post(
+    `/logout-${namespace}`,
+    { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },
+    async (request, reply) => {
+      await request.logout()
+      void reply.send('logged out')
+    }
+  )
+}
+
 const suite = (sessionPluginName) => {
   describe(`${sessionPluginName} tests`, () => {
-    describe('multiple registered instances', () => {
+    describe('multiple registered instances (clearSessionOnLogin: false)', () => {
       let server: FastifyInstance
-      let authenticators: Record<string, Authenticator>
       let session: TestBrowserSession
-      let counter: number
 
       beforeEach(async () => {
         counter = 0
-        server = getTestServer()
         authenticators = {}
+        server = getTestServer()
         session = new TestBrowserSession(server)
 
         for (const namespace of ['a', 'b']) {
-          await server.register(async (instance) => {
-            class TestStrategy extends Strategy {
-              authenticate(request: any, _options?: { pauseStream?: boolean }) {
-                if (request.isAuthenticated()) {
-                  return this.pass()
-                }
-                if (request.body && request.body.login === 'test' && request.body.password === 'test') {
-                  return this.success({ namespace, id: String(counter++) })
-                }
-
-                this.fail()
-              }
-            }
-
-            const strategyName = `test-${namespace}`
-            const authenticator = new Authenticator({ key: `passport${namespace}`, userProperty: `user${namespace}` })
-            authenticator.use(strategyName, new TestStrategy(strategyName))
-            authenticator.registerUserSerializer<any, string>(async (user) => {
-              if (user.namespace == namespace) {
-                return namespace + '-' + JSON.stringify(user)
-              }
-              throw 'pass'
-            })
-            authenticator.registerUserDeserializer<string, any>(async (serialized: string) => {
-              if (serialized.startsWith(`${namespace}-`)) {
-                return JSON.parse(serialized.slice(`${namespace}-`.length))
-              }
-              throw 'pass'
-            })
-
-            await instance.register(authenticator.initialize())
-            await instance.register(authenticator.secureSession())
-            authenticators[namespace] = authenticator
-
-            instance.get(
-              `/${namespace}`,
-              { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },
-              async () => `hello ${namespace}!`
-            )
-
-            instance.get(
-              `/user/${namespace}`,
-              { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },
-              async (request) => JSON.stringify(request[`user${namespace}`])
-            )
-
-            instance.post(
-              `/login-${namespace}`,
-              {
-                preValidation: authenticator.authenticate(strategyName, {
-                  successRedirect: `/${namespace}`,
-                  authInfo: false,
-                }),
-              },
-              () => {
-                return
-              }
-            )
-
-            instance.post(
-              `/logout-${namespace}`,
-              { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },
-              async (request, reply) => {
-                await request.logout()
-                void reply.send('logged out')
-              }
-            )
-          })
+          await server.register(TestStrategyModule, { namespace, clearSessionOnLogin: false })
         }
       })
 
@@ -251,6 +258,183 @@ const suite = (sessionPluginName) => {
         expect(userA.id).not.toEqual(userB.id)
       })
     })
+
+    describe('multiple registered instances (clearSessionOnLogin: true)', () => {
+      let server: FastifyInstance
+      let session: TestBrowserSession
+
+      beforeEach(async () => {
+        server = getTestServer()
+        session = new TestBrowserSession(server)
+        authenticators = {}
+        counter = 0
+
+        for (const namespace of ['a', 'b']) {
+          await server.register(TestStrategyModule, { namespace, clearSessionOnLogin: true })
+        }
+      })
+
+      test('logging in with one instance should not log in the other instance', async () => {
+        let response = await session.inject({ method: 'GET', url: '/a' })
+        expect(response.body).toEqual('Unauthorized')
+        expect(response.statusCode).toEqual(401)
+
+        response = await session.inject({ method: 'GET', url: '/b' })
+        expect(response.body).toEqual('Unauthorized')
+        expect(response.statusCode).toEqual(401)
+
+        // login a
+        const loginResponse = await session.inject({
+          method: 'POST',
+          url: '/login-a',
+          payload: { login: 'test', password: 'test' },
+        })
+
+        expect(loginResponse.statusCode).toEqual(302)
+        expect(loginResponse.headers.location).toEqual('/a')
+
+        // access protected route
+        response = await session.inject({
+          method: 'GET',
+          url: '/a',
+        })
+        expect(response.statusCode).toEqual(200)
+        expect(response.body).toEqual('hello a!')
+
+        // access user data
+        response = await session.inject({
+          method: 'GET',
+          url: '/user/a',
+        })
+        expect(response.statusCode).toEqual(200)
+
+        // try to access route protected by other instance
+        response = await session.inject({
+          method: 'GET',
+          url: '/b',
+        })
+        expect(response.statusCode).toEqual(401)
+      })
+
+      test('simultaneous login should NOT be possible', async () => {
+        // login a
+        let response = await session.inject({
+          method: 'POST',
+          url: '/login-a',
+          payload: { login: 'test', password: 'test' },
+        })
+
+        expect(response.statusCode).toEqual(302)
+        expect(response.headers.location).toEqual('/a')
+
+        // login b
+        response = await session.inject({
+          method: 'POST',
+          url: '/login-b',
+          payload: { login: 'test', password: 'test' },
+        })
+
+        expect(response.statusCode).toEqual(302)
+        expect(response.headers.location).toEqual('/b')
+
+        // access a protected route (/a) was invalidated after login /b
+        response = await session.inject({
+          method: 'GET',
+          url: '/a',
+        })
+        expect(response.statusCode).toEqual(401)
+        expect(response.body).toEqual('Unauthorized')
+
+        // access b protected route
+        response = await session.inject({
+          method: 'GET',
+          url: '/b',
+        })
+        expect(response.statusCode).toEqual(200)
+        expect(response.body).toEqual('hello b!')
+      })
+
+      test('logging out with one instance should log out the other instance', async () => {
+        // login a
+        let response = await session.inject({
+          method: 'POST',
+          url: '/login-a',
+          payload: { login: 'test', password: 'test' },
+        })
+
+        expect(response.statusCode).toEqual(302)
+        expect(response.headers.location).toEqual('/a')
+
+        // login b
+        response = await session.inject({
+          method: 'POST',
+          url: '/login-b',
+          payload: { login: 'test', password: 'test' },
+        })
+
+        expect(response.statusCode).toEqual(302)
+        expect(response.headers.location).toEqual('/b')
+
+        // logout a
+        response = await session.inject({
+          method: 'POST',
+          url: '/logout-a',
+        })
+        expect(response.statusCode).toEqual(401)
+
+        // try to access route protected by now logged out instance
+        response = await session.inject({
+          method: 'GET',
+          url: '/a',
+        })
+        expect(response.statusCode).toEqual(401)
+
+        // access b protected route which should still be logged in
+        response = await session.inject({
+          method: 'GET',
+          url: '/b',
+        })
+        expect(response.statusCode).toEqual(200)
+        expect(response.body).toEqual('hello b!')
+      })
+
+      test('user objects from different instances should be different', async () => {
+        // login a
+        let response = await session.inject({
+          method: 'POST',
+          url: '/login-a',
+          payload: { login: 'test', password: 'test' },
+        })
+        expect(response.statusCode).toEqual(302)
+        expect(response.headers.location).toEqual('/a')
+
+        response = await session.inject({
+          method: 'GET',
+          url: '/user/a',
+        })
+        expect(response.statusCode).toEqual(200)
+        const userA = JSON.parse(response.body)
+
+        // login b
+        response = await session.inject({
+          method: 'POST',
+          url: '/login-b',
+          payload: { login: 'test', password: 'test' },
+        })
+
+        expect(response.statusCode).toEqual(302)
+        expect(response.headers.location).toEqual('/b')
+
+        response = await session.inject({
+          method: 'GET',
+          url: '/user/b',
+        })
+        expect(response.statusCode).toEqual(200)
+        const userB = JSON.parse(response.body)
+
+        expect(userA.id).not.toEqual(userB.id)
+      })
+    })
   })
 }
 

--- test/passport.test.ts ---
@@ -24,7 +24,9 @@ const suite = (sessionPluginName) => {
     })
 
     test(`should allow login, and add successMessage to session upon logged in`, async () => {
-      const { server, fastifyPassport } = getConfiguredTestServer()
+      const { server, fastifyPassport } = getConfiguredTestServer('test', new TestStrategy('test'), null, {
+        clearSessionIgnoreFields: ['messages'],
+      })
 
       server.get(
         '/',
@@ -79,7 +81,9 @@ const suite = (sessionPluginName) => {
         }
       }
 
-      const { server, fastifyPassport } = getConfiguredTestServer('test', new WelcomeStrategy('test'))
+      const { server, fastifyPassport } = getConfiguredTestServer('test', new WelcomeStrategy('test'), null, {
+        clearSessionIgnoreFields: ['messages'],
+      })
       server.get(
         '/',
         {
@@ -121,7 +125,7 @@ const suite = (sessionPluginName) => {
 
     test(`should throw error if pauseStream is being used`, async () => {
       jest.spyOn(console, 'error').mockImplementation(jest.fn())
-      const fastifyPassport = new Authenticator()
+      const fastifyPassport = new Authenticator({ clearSessionIgnoreFields: ['messages'] })
       fastifyPassport.use('test', new TestStrategy('test'))
       fastifyPassport.registerUserSerializer(async (user) => JSON.stringify(user))
       fastifyPassport.registerUserDeserializer(async (serialized: string) => JSON.parse(serialized))
@@ -164,7 +168,9 @@ const suite = (sessionPluginName) => {
     })
 
     test(`should execute successFlash if logged in`, async () => {
-      const { server, fastifyPassport } = getConfiguredTestServer()
+      const { server, fastifyPassport } = getConfiguredTestServer('test', new TestStrategy('test'), null, {
+        clearSessionIgnoreFields: ['flash'],
+      })
       server.get(
         '/',
         { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },
@@ -299,7 +305,9 @@ const suite = (sessionPluginName) => {
     })
 
     test(`should redirect to the returnTo set in the session upon login`, async () => {
-      const { server, fastifyPassport } = getConfiguredTestServer()
+      const { server, fastifyPassport } = getConfiguredTestServer('test', new TestStrategy('test'), null, {
+        clearSessionIgnoreFields: ['returnTo'],
+      })
       server.addHook('preValidation', async (request, _reply) => {
         request.session.set('returnTo', '/success')
       })
@@ -602,7 +610,7 @@ const suite = (sessionPluginName) => {
     })
 
     test(`should allow registering strategies after creating routes referring to those strategies by name`, async () => {
-      const { server, fastifyPassport } = getRegisteredTestServer()
+      const { server, fastifyPassport } = getRegisteredTestServer(null, { clearSessionIgnoreFields: ['messages'] })
 
       server.get(
         '/',

