--- docs/configuration/config_yaml.rst ---
@@ -917,18 +917,18 @@ Use the following settings to configure the server:
        # (X-Forwarded-Host by default, see above) with forwarded requests.
        hostFallback:
 
-       # List of trusted downstream servers for which to ignore the IP address when trying to determine
-       # the connecting client's IP address. If you have OctoPrint behind more than one reverse proxy
-       # you should add their IPs here so that they won't be interpreted as the client's IP. One reverse
-       # proxy will be handled correctly by default.
+       # List of trusted proxy servers for which to ignore the IP address when trying to determine
+       # the connecting client's IP address. A reverse proxy on the same machine as OctoPrint (e.g. as
+       # found on OctoPi) will be handled correctly by the default setting of 127.0.0.1 and ::1, further
+       # proxies in front of that you'll have to add yourself.
        trustedDownstream:
-       - 192.168.1.254
-       - 192.168.23.42
+       - 127.0.0.1
+       - "::1"
 
      # Whether to allow OctoPrint to be embedded in a frame or not. Note that depending on your setup you might
      # have to set SameSite to None, Secure to true and serve OctoPrint through a reverse proxy that enables https
      # for cookies and thus logging in to work
-     allowFraming: true
+     allowFraming: false
 
      # Settings for further configuration of the cookies that OctoPrint sets (login, remember me, ...)
      cookies:

--- src/octoprint/plugins/appkeys/__init__.py ---
@@ -356,12 +356,8 @@ def on_api_command(self, command, data):
                 # deprecated key based revoke?
                 from flask import request
 
-                from octoprint.server.util import get_remote_address
-
                 self._logger.warning(
-                    "Deprecated key based revoke command sent to /api/plugin/appkeys by {}, should be migrated to use app id/user tuple".format(
-                        get_remote_address(request)
-                    )
+                    f"Deprecated key based revoke command sent to /api/plugin/appkeys by {request.remote_addr}, should be migrated to use app id/user tuple"
                 )
 
             else:

--- src/octoprint/schema/config/access_control.py ---
@@ -36,6 +36,9 @@ class AccessControlConfig(BaseModel):
     autologinAs: Optional[str] = None
     """The name of the user to automatically log on clients originating from `localNetworks` as. Must be the name of one of your configured users."""
 
+    autologinHeadsupAcknowledged: bool = False
+    """Whether the user has acknowledged the heads-up about the importance of a correct reverse proxy configuration in the presence of autologin."""
+
     trustBasicAuthentication: bool = False
     """Whether to trust Basic Authentication headers. If you have setup Basic Authentication in front of OctoPrint and the user names you use there match OctoPrint accounts, by setting this to true users will be logged into OctoPrint as the user during Basic Authentication. **ONLY ENABLE THIS** if your OctoPrint instance is only accessible through a connection locked down through Basic Authentication!"""
 

--- src/octoprint/schema/config/server.py ---
@@ -42,8 +42,8 @@ class ReverseProxyConfig(BaseModel):
 
     portFallback: Optional[str] = None
 
-    trustedDownstream: List[str] = []
-    """List of trusted downstream servers for which to ignore the IP address when trying to determine the connecting client's IP address. If you have OctoPrint behind more than one reverse proxy you should add their IPs here so that they won't be interpreted as the client's IP. One reverse proxy will be handled correctly by default."""
+    trustedDownstream: List[str] = ["127.0.0.1", "::1"]
+    """List of trusted downstream servers for which to ignore the IP address when trying to determine the connecting client's IP address. A reverse proxy on the same machine as OctoPrint (e.g. as found on OctoPi) will be handled correctly by default, further proxies in front of that you'll have to add yourself."""
 
 
 @with_attrs_docs

--- src/octoprint/server/__init__.py ---
@@ -381,6 +381,7 @@ def run(self):
         util.tornado.fix_json_encode()
         util.tornado.fix_websocket_check_origin()
         util.tornado.enable_per_message_deflate_extension()
+        util.tornado.fix_tornado_xheader_handling()
 
         self._setup_mimetypes()
 

--- src/octoprint/server/api/__init__.py ---
@@ -38,7 +38,6 @@
 )
 from octoprint.server.util.flask import (
     get_json_command_from_request,
-    get_remote_address,
     limit,
     no_firstrun_access,
     passive_login,
@@ -302,7 +301,7 @@ def login():
     if "user" in data and "pass" in data:
         username = data["user"]
         password = data["pass"]
-        remote_addr = get_remote_address(request)
+        remote_addr = request.remote_addr
 
         if "remember" in data and data["remember"] in valid_boolean_trues:
             remember = True
@@ -398,7 +397,7 @@ def logout():
 
     if username:
         eventManager().fire(Events.USER_LOGGED_OUT, payload={"username": username})
-        auth_log(f"Logging out user {username} from {get_remote_address(request)}")
+        auth_log(f"Logging out user {username} from {request.remote_addr}")
 
     return r
 
@@ -774,7 +773,7 @@ def _test_address(data):
 
     remote_addr = data.get("address")
     if not remote_addr:
-        remote_addr = get_remote_address(request)
+        remote_addr = request.remote_addr
 
     remote_addr = sanitize_address(remote_addr)
     ip = netaddr.IPAddress(remote_addr)

--- src/octoprint/server/api/settings.py ---
@@ -125,9 +125,11 @@ def getSettings():
 
     data = {
         "api": {
-            "key": s.get(["api", "key"])
-            if Permissions.ADMIN.can() and credentials_checked_recently()
-            else None,
+            "key": (
+                s.get(["api", "key"])
+                if Permissions.ADMIN.can() and credentials_checked_recently()
+                else None
+            ),
             "allowCrossOrigin": s.get(["api", "allowCrossOrigin"]),
         },
         "appearance": {
@@ -410,6 +412,14 @@ def getSettings():
     else:
         data["webcam"] = {}
 
+    if Permissions.ADMIN.can():
+        data["accessControl"] = {
+            "autologinLocal": s.getBoolean(["accessControl", "autologinLocal"]),
+            "autologinHeadsupAcknowledged": s.getBoolean(
+                ["accessControl", "autologinHeadsupAcknowledged"]
+            ),
+        }
+
     return jsonify(data)
 
 
@@ -557,6 +567,13 @@ def _saveSettings(data):
         if "allowCrossOrigin" in data["api"]:
             s.setBoolean(["api", "allowCrossOrigin"], data["api"]["allowCrossOrigin"])
 
+    if "accessControl" in data:
+        if "autologinHeadsupAcknowledged" in data["accessControl"]:
+            s.setBoolean(
+                ["accessControl", "autologinHeadsupAcknowledged"],
+                data["accessControl"]["autologinHeadsupAcknowledged"],
+            )
+
     if "appearance" in data:
         if "name" in data["appearance"]:
             s.set(["appearance", "name"], data["appearance"]["name"])

--- src/octoprint/server/api/system.py ---
@@ -15,7 +15,7 @@
 from octoprint.plugin import plugin_manager
 from octoprint.server import NO_CONTENT
 from octoprint.server.api import api
-from octoprint.server.util.flask import get_remote_address, no_firstrun_access
+from octoprint.server.util.flask import no_firstrun_access
 from octoprint.settings import settings as s
 from octoprint.systemcommands import system_command_manager
 from octoprint.util.commandline import CommandlineCaller
@@ -96,9 +96,7 @@ def _usageForFolders():
 @Permissions.SYSTEM.require(403)
 def performSystemAction():
     logging.getLogger(__name__).warning(
-        "Deprecated API call to /api/system made by {}, should be migrated to use /system/commands/custom/<action>".format(
-            get_remote_address(request)
-        )
+        f"Deprecated API call to /api/system made by {request.remote_addr}, should be migrated to use /system/commands/custom/<action>"
     )
 
     data = request.get_json(silent=True)

--- src/octoprint/server/util/flask.py ---
@@ -12,7 +12,7 @@
 import threading
 import time
 from datetime import datetime, timedelta, timezone
-from typing import Any, Union
+from typing import Any, Dict, List, Union
 
 import flask
 import flask.json
@@ -29,6 +29,7 @@
 from flask import current_app
 from flask_login import COOKIE_NAME as REMEMBER_COOKIE_NAME
 from flask_login.utils import decode_cookie, encode_cookie
+from pydantic import BaseModel
 from werkzeug.local import LocalProxy
 from werkzeug.utils import cached_property
 
@@ -666,7 +667,7 @@ def passive_login():
 
     user = flask_login.current_user
 
-    remote_address = get_remote_address(flask.request)
+    remote_address = flask.request.remote_addr
     ip_check_enabled = settings().getBoolean(["server", "ipCheck", "enabled"])
     ip_check_trusted = settings().get(["server", "ipCheck", "trustedSubnets"])
 
@@ -1713,10 +1714,11 @@ def decorated_view(*args, **kwargs):
     return decorated_view
 
 
+@deprecated(
+    "get_remote_address is no longer required and deprecated, you can just use flask.request.remote_addr instead",
+    since="1.10.0",
+)
 def get_remote_address(request):
-    forwardedFor = request.headers.get("X-Forwarded-For", None)
-    if forwardedFor is not None:
-        return forwardedFor.split(",")[0]
     return request.remote_addr
 
 
@@ -2012,3 +2014,50 @@ def session_signature(user, session):
 def validate_session_signature(sig, user, session):
     user_sig = session_signature(user, session)
     return len(user_sig) == len(sig) and hmac.compare_digest(sig, user_sig)
+
+
+##~~ Reverse proxy info
+
+
+class ReverseProxyInfo(BaseModel):
+    client_ip: str
+    server_protocol: str
+    server_name: str
+    server_port: int
+    server_path: str
+    cookie_suffix: str
+    trusted_proxies: List[str] = []
+    headers: Dict[str, str] = {}
+
+
+def get_reverse_proxy_info():
+    headers = {}
+    for header in sorted(
+        (
+            "X-Forwarded-For",
+            "X-Forwarded-Protocol",
+            "X-Scheme",
+            "X-Forwarded-Host",
+            "X-Forwarded-Port",
+            "X-Forwarded-Server",
+            "Host",
+            "X-Script-Name",
+        )
+    ):
+        if header in flask.request.headers:
+            headers[header] = flask.request.headers[header]
+
+    trusted_downstreams = settings().get(["server", "reverseProxy", "trustedDownstream"])
+    if not trusted_downstreams:
+        trusted_downstreams = []
+
+    return ReverseProxyInfo(
+        client_ip=flask.request.remote_addr,
+        server_protocol=flask.request.environ.get("wsgi.url_scheme"),
+        server_name=flask.request.environ.get("SERVER_NAME"),
+        server_port=int(flask.request.environ.get("SERVER_PORT")),
+        server_path=flask.request.script_root if flask.request.script_root else "/",
+        cookie_suffix=get_cookie_suffix(flask.request),
+        trusted_proxies=trusted_downstreams,
+        headers=headers,
+    )

--- src/octoprint/server/util/sockjs.py ---
@@ -85,14 +85,14 @@ class PrinterStateConnection(
 
     _event_payload_processors = {
         Events.CLIENT_OPENED: [
-            lambda user, payload: payload
-            if user.has_permission(Permissions.ADMIN)
-            else {}
+            lambda user, payload: (
+                payload if user.has_permission(Permissions.ADMIN) else {}
+            )
         ],
         Events.CLIENT_AUTHED: [
-            lambda user, payload: payload
-            if user.has_permission(Permissions.ADMIN)
-            else {}
+            lambda user, payload: (
+                payload if user.has_permission(Permissions.ADMIN) else {}
+            )
         ],
         "*": [],
     }
@@ -101,10 +101,12 @@ class PrinterStateConnection(
     _emit_permissions = {
         "connected": [],
         "reauthRequired": [],
-        "plugin": lambda payload: []
-        if payload.get("plugin") in ("backup", "softwareupdate")
-        and settings().getBoolean(["server", "firstRun"])
-        else [Permissions.STATUS],
+        "plugin": lambda payload: (
+            []
+            if payload.get("plugin") in ("backup", "softwareupdate")
+            and settings().getBoolean(["server", "firstRun"])
+            else [Permissions.STATUS]
+        ),
         "*": [Permissions.STATUS],
     }
 
@@ -179,10 +181,15 @@ def __init__(
 
     @staticmethod
     def _get_remote_address(info):
-        forwarded_for = info.headers.get("X-Forwarded-For")
-        if forwarded_for is not None:
-            return forwarded_for.split(",")[0]
-        return info.ip
+        from octoprint.util.net import get_http_client_ip
+
+        trusted_proxies = settings().get(["server", "reverseProxy", "trustedUpstream"])
+        if not isinstance(trusted_proxies, list):
+            trusted_proxies = ["127.0.0.1"]
+
+        return get_http_client_ip(
+            info.ip, info.headers.get("X-Forwarded-For"), trusted_proxies
+        )
 
     def _keep_alive_callback(self):
         if not self._authed:

--- src/octoprint/server/util/tornado.py ---
@@ -18,6 +18,7 @@
 import tornado.httpserver
 import tornado.httputil
 import tornado.iostream
+import tornado.netutil
 import tornado.tcpserver
 import tornado.util
 import tornado.web
@@ -26,6 +27,7 @@
 from zipstream.ng import ZIP_DEFLATED, ZipStream
 
 import octoprint.util
+import octoprint.util.net
 
 
 def fix_json_encode():
@@ -93,6 +95,36 @@ def get_check_tuple(urlstring):
     tornado.websocket.WebSocketHandler.check_origin = patched_check_origin
 
 
+def fix_tornado_xheader_handling():
+    """
+    This fixes tornado.httpserver._HTTPRequestContext._apply_xheaders to only use "X-Forwarded-For" header
+    for rewriting the ``remote_ip`` field, utilizing the set of trusted downstreams, instead of blindly
+    trusting ``X-Real-Ip``, and to also fetch the scheme from "X-Forwarded-Proto" if available.
+    """
+
+    def patched_apply_xheaders(self, headers: "tornado.httputil.HTTPHeaders") -> None:
+        """Rewrite the ``remote_ip`` and ``protocol`` fields."""
+
+        # other than the default implementation, we only use "X-Forwarded-For" here, not "X-Real-Ip"
+        ip = octoprint.util.net.get_http_client_ip(
+            self.remote_ip, headers.get("X-Forwarded-For"), self.trusted_downstream
+        )
+        if tornado.netutil.is_valid_ip(ip):
+            self.remote_ip = ip
+
+        # also fetch scheme from "X-Forwarded-Proto" if available
+        proto_header = headers.get("X-Scheme", headers.get("X-Forwarded-Proto"))
+        if proto_header:
+            # use only the last proto entry if there is more than one
+            proto_header = proto_header.split(",")[-1].strip()
+        if proto_header in ("http", "https"):
+            self.protocol = proto_header
+
+    import tornado.httpserver
+
+    tornado.httpserver._HTTPRequestContext._apply_xheaders = patched_apply_xheaders
+
+
 # ~~ More sensible logging
 
 

--- src/octoprint/server/views.py ---
@@ -198,6 +198,7 @@ def login():
     allowed_paths = [
         url_for("index"),
         url_for("recovery"),
+        url_for("reverse_proxy_test"),
     ]
     try:
         allowed_paths += [
@@ -369,21 +370,26 @@ def in_cache():
 @app.route("/reverse_proxy_test")
 @app.route("/reverse_proxy_test/")
 def reverse_proxy_test():
-    from octoprint.server.util.flask import get_cookie_suffix, get_remote_address
-
-    remote_address = get_remote_address(request)
-    cookie_suffix = get_cookie_suffix(request)
-
-    return render_template(
-        "reverse_proxy_test.jinja2",
-        theming=[],
-        client_ip=remote_address,
-        server_protocol=request.environ.get("wsgi.url_scheme"),
-        server_name=request.environ.get("SERVER_NAME"),
-        server_port=request.environ.get("SERVER_PORT"),
-        server_path=request.script_root if request.script_root else "/",
-        cookie_suffix=cookie_suffix,
-    )
+    from octoprint.server.util.flask import get_reverse_proxy_info
+
+    authenticated = request.args.get("authenticated", False) is not False
+    if authenticated:
+        response = require_fresh_login_with(permissions=[Permissions.ADMIN])
+        if response:
+            return response
+
+    kwargs = get_reverse_proxy_info().dict()
+
+    try:
+        return render_template(
+            "reverse_proxy_test.jinja2",
+            authenticated=authenticated,
+            theming=[],
+            **kwargs,
+        )
+    except Exception:
+        _logger.exception("Error rendering reverse proxy test page")
+        return abort(500)
 
 
 @app.route("/")

--- src/octoprint/static/js/app/viewmodels/settings.js ---
@@ -1292,6 +1292,44 @@ $(function () {
                         self.requestData();
                     }, self.reauthenticationTimeout);
             }
+
+            // if autologinLocal is enabled and the heads-up not yet acknowledged, show it now
+            if (
+                self.settings.accessControl &&
+                self.settings.accessControl.autologinLocal() &&
+                !self.settings.accessControl.autologinHeadsupAcknowledged()
+            ) {
+                const text = gettext(
+                    "<p>You have Autologin enabled. This means that you will be automatically logged in when accessing OctoPrint from a local IP.</p>" +
+                        "<p>By default, OctoPrint is configured in such a way this should not pose a security risk. However, <strong>if you yourself have " +
+                        "any additional reverse proxies configured</strong> in front of OctoPrint, make sure those are configured correctly.</p>" +
+                        "<p><a href='%(url)s' target='_blank' rel='noopener noreferer'>Read more in the FAQ</a>.</p>"
+                );
+
+                new PNotify.singleButtonNotify({
+                    title: gettext("Autologin Heads-up"),
+                    text: _.sprintf(text, {
+                        url: "https://faq.octoprint.org/reverse-proxy"
+                    }),
+                    hide: false,
+                    confirm: {
+                        confirm: true,
+                        buttons: [
+                            {
+                                text: gettext("Got it!"),
+                                addClass: "btn-primary",
+                                click: function (notice) {
+                                    notice.remove();
+                                    self.settings.accessControl.autologinHeadsupAcknowledged(
+                                        true
+                                    );
+                                    self.saveData();
+                                }
+                            }
+                        ]
+                    }
+                });
+            }
         };
 
         self.cancelData = function () {

--- src/octoprint/static/less/octoprint.less ---
@@ -1034,7 +1034,8 @@ ul.dropdown-menu li a {
 
 #settings_dialog {
   .aboutlink,
-  .systeminfolink {
+  .systeminfolink,
+  .reverseproxylink {
     float: left;
   }
 }

--- src/octoprint/templates/dialogs/settings.jinja2 ---
@@ -50,6 +50,7 @@
     <div class="modal-footer">
         <button class="btn aboutlink" data-bind="click: function() { about.show('about_about') }"><i class="fas fa-info-circle"></i> {{ _('About OctoPrint') }}</button>
         <button class="btn systeminfolink" data-bind="visible: $root.loginState.hasPermissionKo($root.access.permissions.SYSTEM), click: function() { about.show('about_systeminfo') }"><i class="fas fa-flag-checkered"></i> {{ _('System info') }}</button>
+        <a href="{{ url_for('reverse_proxy_test', authenticated='') }}" class="btn reverseproxylink" target="_blank" rel="noopener noreferer"><i class="fas fa-check-double"></i> {{ _('Reverse Proxy Test') }}</a>
         <button class="btn" data-test-id="settings-close-button" data-bind="click: function() { cancelData() }" aria-hidden="true">{{ _('Close') }}</button>
         <button class="btn btn-primary" data-test-id="settings-save" data-bind="click: function() { saveData(undefined, $root.hide) }, enable: !exchanging(), css: {disabled: exchanging()}"><i class="fas fa-spinner fa-spin" data-bind="visible: sending"></i> {{ _('Save') }}</button>
     </div>

--- src/octoprint/templates/reverse_proxy_test.jinja2 ---
@@ -53,8 +53,8 @@
     </div>
     <div id="reverse_proxy_test" class="container" style="padding-top: 1em">
         <div class="alert alert-error" data-bind="visible: !cookieSuffixMatch">
-            <strong>Warning!</strong> The used cookie suffix doesn't match between client and server. That means that OctoPrint's
-            UI won't work properly. Please check your configuration and fix it.
+            <strong>Warning!</strong> The used cookie suffix doesn't match between client and server. That means that logging
+            into OctoPrint's UI won't work properly. Please check your configuration and fix it.
         </div>
 
         <p>
@@ -119,6 +119,37 @@
             </tr>
         </table>
 
+        {% if authenticated %}
+            <p>
+                OctoPrint received the following <strong>request headers</strong> from your client that were used to determine the above values:
+            </p>
+
+            <ul>
+                {% for key, value in headers.items() %}
+                    <li><code>{{ key }}</code>: <code>{{ value }}</code></li>
+                {% endfor %}
+            </ul>
+
+            <p>
+                Your server side Client IP was determined to be {{ client_ip }}. Your <code>X-Forwarded-For</code> header
+                {% if headers["X-Forwarded-For"] %} (<code>{{ headers["X-Forwarded-For"] }}</code>){% endif %} might
+                have influenced that. Make sure that this is the IP that OctoPrint should be seeing. It will be the right most
+                IP in the <code>X-Forwarded-For</code> header that is not among your <strong>configured trusted downstreams</strong>:
+            </p>
+
+            <ul>
+                {% for host in trusted_proxies %}
+                    <li><code>{{ host }}</code></li>
+                {% endfor %}
+            </ul>
+        {% else %}
+            <p>
+                To receive more information about the request headers that OctoPrint received, please
+                <a href="{{ url_for("reverse_proxy_test", authenticated="") }}">request the authenticated version of this page</a>.
+                Note that this will only work if the above settings are reporting green across the board.
+            </p>
+        {% endif %}
+
         <p>
             Please refer to <a href="https://faq.octoprint.org/reverse-proxy" target="_blank" rel="noopener noreferrer">the Reverse Proxy FAQ entry</a>
             for information on correct configuration and examples.

--- src/octoprint/util/net.py ---
@@ -297,3 +297,26 @@ def download_file(url, folder, max_length=None, connect_timeout=3.05, read_timeo
             for chunk in r.iter_content(chunk_size=8192):
                 f.write(chunk)
     return path
+
+
+def get_http_client_ip(remote_addr, forwarded_for, trusted_proxies):
+    try:
+        trusted_ip_set = netaddr.IPSet(trusted_proxies)
+    except netaddr.AddrFormatError:
+        # something's wrong with one of these addresses, let's add them one by one
+        trusted_ip_set = netaddr.IPSet()
+        for trusted_proxy in trusted_proxies:
+            try:
+                trusted_ip_set.add(trusted_proxy)
+            except netaddr.AddrFormatError:
+                logging.getLogger(__name__).error(
+                    f"Trusted proxy {trusted_proxy} is not a correctly formatted IP address or subnet"
+                )
+
+    if forwarded_for is not None and sanitize_address(remote_addr) in trusted_ip_set:
+        for addr in (
+            sanitize_address(addr.strip()) for addr in reversed(forwarded_for.split(","))
+        ):
+            if addr not in trusted_ip_set:
+                return addr
+    return sanitize_address(remote_addr)

--- tests/util/test_net.py ---
@@ -2,10 +2,9 @@
 __copyright__ = "Copyright (C) 2017 The OctoPrint Project - Released under terms of the AGPLv3 License"
 
 import socket
-import unittest
 from unittest import mock
 
-import ddt
+import pytest
 
 import octoprint.util.net
 
@@ -37,9 +36,9 @@ def patched_ifaddresses_netmask(addr):
     return patched_ifaddresses(addr, "netmask")
 
 
-@ddt.ddt
-class UtilNetTest(unittest.TestCase):
-    @ddt.data(
+@pytest.mark.parametrize(
+    "input_address,input_additional,expected",
+    [
         ("127.0.0.1", [], True),
         ("192.168.123.234", [], True),
         ("172.24.0.1", [], True),
@@ -54,51 +53,160 @@ class UtilNetTest(unittest.TestCase):
         ("2a01:4f8:1c0c:6958::1:23", [], True),
         ("fe80::89f3:31bb:ced0:2093%wlan0", [], True),
         (None, [], True),
-    )
-    @ddt.unpack
-    @mock.patch("netifaces.interfaces", side_effect=patched_interfaces)
-    @mock.patch.object(octoprint.util.net, "HAS_V6", True)
-    def test_is_lan_address(self, input_address, input_additional, expected, nifs):
+    ],
+)
+def test_is_lan_address(input_address, input_additional, expected):
+    with mock.patch(
+        "netifaces.interfaces", side_effect=patched_interfaces
+    ), mock.patch.object(octoprint.util.net, "HAS_V6", True):
         for side_effect in (patched_ifaddresses_mask, patched_ifaddresses_netmask):
             with mock.patch("netifaces.ifaddresses", side_effect=side_effect):
-                actual = octoprint.util.net.is_lan_address(
-                    input_address, additional_private=input_additional
+                assert (
+                    octoprint.util.net.is_lan_address(
+                        input_address, additional_private=input_additional
+                    )
+                    == expected
                 )
-                self.assertEqual(expected, actual)
 
-    @ddt.data(
+
+@pytest.mark.parametrize(
+    "address,expected",
+    [
         ("fe80::89f3:31bb:ced0:2093%wlan0", "fe80::89f3:31bb:ced0:2093"),
         ("2a01:4f8:1c0c:6958::1:23", "2a01:4f8:1c0c:6958::1:23"),
         ("10.1.2.3", "10.1.2.3"),
-    )
-    @ddt.unpack
-    def test_strip_interface_tag(self, address, expected):
-        actual = octoprint.util.net.strip_interface_tag(address)
-        self.assertEqual(expected, actual)
+    ],
+)
+def test_strip_interface_tag(address, expected):
+    assert octoprint.util.net.strip_interface_tag(address) == expected
 
-    @ddt.data(
+
+@pytest.mark.parametrize(
+    "address,expected",
+    [
         ("::ffff:192.168.1.1", "192.168.1.1"),
         ("::ffff:2a01:4f8", "::ffff:2a01:4f8"),
         ("2a01:4f8:1c0c:6958::1:23", "2a01:4f8:1c0c:6958::1:23"),
         ("11.1.2.3", "11.1.2.3"),
-    )
-    @ddt.unpack
-    def test_unmap_v4_in_v6(self, address, expected):
-        actual = octoprint.util.net.unmap_v4_as_v6(address)
-        self.assertEqual(expected, actual)
+    ],
+)
+def test_unmap_v4_in_v6(address, expected):
+    assert octoprint.util.net.unmap_v4_as_v6(address) == expected
+
 
-    @ddt.data(
+@pytest.mark.parametrize(
+    "address,expected",
+    [
         ({"mask": "192.168.0.0/24"}, "192.168.0.0/24"),
         ({"netmask": "192.168.0.0/24"}, "192.168.0.0/24"),
+    ],
+)
+def test_get_netmask(address, expected):
+    assert octoprint.util.net.get_netmask(address) == expected
+
+
+def test_get_netmask_broken_address():
+    with pytest.raises(ValueError):
+        octoprint.util.net.get_netmask({"nm": "192.168.0.0/24"})
+
+
+@pytest.mark.parametrize(
+    "remote_addr,header,trusted_proxies,expected",
+    [
+        (
+            "127.0.0.1",
+            None,
+            ["127.0.0.1", "::1"],
+            "127.0.0.1",
+        ),  # direct access via ipv4 localhost
+        (
+            "::1",
+            None,
+            ["127.0.0.1", "::1"],
+            "::1",
+        ),  # direct access via ipv6 localhost
+        (
+            "192.168.1.10",
+            None,
+            ["127.0.0.1", "::1"],
+            "192.168.1.10",
+        ),  # direct access via lan
+        (
+            "127.0.0.1",
+            "192.168.1.10",
+            ["127.0.0.1", "::1"],
+            "192.168.1.10",
+        ),  # access through reverse proxy on 127.0.0.1
+        (
+            "127.0.0.1",
+            "10.1.2.3, 192.168.1.10",
+            ["127.0.0.1", "::1", "192.168.1.10"],
+            "10.1.2.3",
+        ),  # access through trusted reverse proxies on 127.0.0.1 and 192.168.1.10
+        (
+            "127.0.0.1",
+            "10.1.2.3, 192.168.1.10",
+            ["127.0.0.1", "::1", "192.168.1.0/24"],
+            "10.1.2.3",
+        ),  # access through trusted reverse proxies on 127.0.0.1 and something on 192.168.1.0/24
+        (
+            "127.0.0.1",
+            "10.1.2.3, 192.168.1.10",
+            ["127.0.0.1", "::1", "unknown", "192.168.1.0/24"],
+            "10.1.2.3",
+        ),  # access through trusted reverse proxies on 127.0.0.1 and something on 192.168.1.0/24, invalid proxy in between
+        (
+            "::1",
+            "fd12:3456:789a:2::1, fd12:3456:789a:1::1",
+            ["127.0.0.1", "::1", "fd12:3456:789a:1::/64"],
+            "fd12:3456:789a:2::1",
+        ),  # access through trusted reverse proxies on ::1 and something on fd12:3456:789a:1::/64
+        (
+            "127.100.100.1",
+            "10.1.2.3, 192.168.1.10",
+            ["0.0.0.0/0"],
+            "127.100.100.1",
+        ),  # everything is trusted (BAD IDEA!)
+        (
+            "192.168.1.10",
+            "127.0.0.1",
+            ["127.0.0.1", "::1"],
+            "192.168.1.10",
+        ),  # spoofing attempt #1: direct access via lan, spoofed to 127.0.0.1
+        (
+            "::ffff:192.168.1.10",
+            "::1",
+            ["127.0.0.1", "::1"],
+            "192.168.1.10",
+        ),  # spoofing attempt #2: direct access via lan, spoofed to ::1
+        (
+            "127.0.0.1",
+            "127.0.0.1, 192.168.1.10",
+            ["127.0.0.1", "::1"],
+            "192.168.1.10",
+        ),  # spoofing attempt #3: access through reverse proxy on 127.0.0.1, real ip 192.168.1.10, spoofed to 127.0.0.1
+        (
+            "::1",
+            "::1, ::ffff:192.168.1.10",
+            ["127.0.0.1", "::1"],
+            "192.168.1.10",
+        ),  # spoofing attempt #4: access through reverse proxy on ::1, real ip 192.168.1.10, spoofed to ::1
+        (
+            "127.0.0.1",
+            "127.0.0.1, 10.1.2.3, 192.168.1.10",
+            ["127.0.0.1", "::1", "192.168.1.10"],
+            "10.1.2.3",
+        ),  # spoofing attempt #5: access through trusted reverse proxies on 127.0.0.1 and 192.168.1.10, real ip 10.1.2.3, spoofed to 127.0.0.1
+        (
+            "::1",
+            "::1, fd12:3456:789a:2::1, fd12:3456:789a:1::1",
+            ["127.0.0.1", "::1", "fd12:3456:789a:1::/64"],
+            "fd12:3456:789a:2::1",
+        ),  # spoofing attempt #6: access through trusted reverse proxies on ::1 and something on fd12:3456:789a:1::/64, spoofed to ::1
+    ],
+)
+def test_get_http_client_ip(remote_addr, header, trusted_proxies, expected):
+    assert (
+        octoprint.util.net.get_http_client_ip(remote_addr, header, trusted_proxies)
+        == expected
     )
-    @ddt.unpack
-    def test_get_netmask(self, address, expected):
-        actual = octoprint.util.net.get_netmask(address)
-        self.assertEqual(expected, actual)
-
-    def test_get_netmask_broken_address(self):
-        try:
-            octoprint.util.net.get_netmask({"nm": "192.168.0.0/24"})
-            self.fail("Expected ValueError")
-        except Exception as e:
-            self.assertIsInstance(e, ValueError)

